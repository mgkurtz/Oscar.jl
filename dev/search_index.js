var documenterSearchIndex = {"docs":
[{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"using Oscar","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"Pages = [\"subgroups.md\"]","category":"page"},{"location":"Groups/subgroups/#subgroups","page":"Subgroups","title":"Subgroups","text":"","category":"section"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"The following functions are available in Oscar for subgroup properties:","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"sub(G::GAPGroup, gens::AbstractVector{<:GAPGroupElem})\nissubgroup\nembedding(G::T, H::T) where T <: GAPGroup\nindex(G::T, H::T) where T <: GAPGroup\nisnormal(G::T, H::T) where T <: GAPGroup\nischaracteristic(G::T, H::T) where T <: GAPGroup","category":"page"},{"location":"Groups/subgroups/#sub-Tuple{Oscar.GAPGroup, AbstractVector{var\"#s271\"} where var\"#s271\"<:GAPGroupElem}","page":"Subgroups","title":"sub","text":"sub(G::GAPGroup, gens::AbstractVector{<:GAPGroupElem})\nsub(gens::GAPGroupElem...)\n\nThis function returns two objects: a group H, that is the subgroup of G generated by the elements x,y,..., and the embedding homomorphism of H into G. The object H has the same type of G, and it has no memory of the \"parent\" group G: it is an independent group.\n\nExamples\n\njulia> G = symmetric_group(4); H, _ = sub(G,[cperm([1,2,3]),cperm([2,3,4])]);\n\njulia> H == alternating_group(4)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#issubgroup","page":"Subgroups","title":"issubgroup","text":"issubgroup(G::T, H::T) where T <: GAPGroup\n\nReturn (true,f) if H is a subgroup of G, where f is the embedding homomorphism of H into G, otherwise return (false,nothing).\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#embedding-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"embedding","text":"embedding(G::T, H::T) where T <: GAPGroup\n\nReturn the embedding morphism of H into G. An exception is thrown if H is not a subgroup of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#index-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"index","text":"index(::Type{I} = fmpz, G::T, H::T) where I <: IntegerUnion where T <: GAPGroup\n\nReturn the index of H in G, as an instance of I.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#isnormal-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"isnormal","text":"isnormal(G::T, H::T) where T <: GAPGroup\n\nReturn whether the group H is normalized by G, i.e., whether H is invariant under conjugation with elements of G.\n\nnote: Note\nTo test whether H is a normal subgroup, use isnormal(G, H) && issubset(H, G)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#ischaracteristic-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"ischaracteristic","text":"ischaracteristic(G::T, H::T) where T <: GAPGroup\n\nReturn whether the subgroup H is characteristic in G, i.e., H is invariant under all automorphisms of G.\n\nnote: Note\nTo test whether H is a characteristic subgroup, use ischaracteristic(G, H) && issubset(H, G)\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#Standard-subgroups","page":"Subgroups","title":"Standard subgroups","text":"","category":"section"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"The following functions are available in Oscar to obtain standard subgroups of a group G. Every such function returns a tuple (H,f), where H is a group of the same type of G and f is the embedding homomorphism of H into G.","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"trivial_subgroup\ncenter(G::GAPGroup)\nsylow_subgroup(G::GAPGroup, p::IntegerUnion)\nderived_subgroup\nfitting_subgroup\nfrattini_subgroup\nradical_subgroup\nsocle\npcore(G::GAPGroup, p::IntegerUnion)\nintersect(V::T...) where T<:GAPGroup","category":"page"},{"location":"Groups/subgroups/#trivial_subgroup","page":"Subgroups","title":"trivial_subgroup","text":"trivial_subgroup(G::GAPGroup)\n\nReturn the trivial subgroup of G, together with its embedding morphism into G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#center-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"center","text":"center(G::Group)\n\nReturn the center of G, i.e., the subgroup of all x in G such that x y equals y x for every y in G, together with its embedding morphism into G.\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#sylow_subgroup-Tuple{Oscar.GAPGroup, Union{Integer, fmpz}}","page":"Subgroups","title":"sylow_subgroup","text":"sylow_subgroup(G::Group, p::IntegerUnion)\n\nReturn a Sylow p-subgroup of the finite group G, for a prime p. This is a subgroup of p-power order in G whose index in G is coprime to p.\n\nExamples\n\njulia> g = symmetric_group(4); order(g)\n24\n\njulia> s = sylow_subgroup(g, 2); order(s[1])\n8\n\njulia> s = sylow_subgroup(g, 3); order(s[1])\n3\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#derived_subgroup","page":"Subgroups","title":"derived_subgroup","text":"derived_subgroup(G::GAPGroup)\n\nReturn the derived subgroup of G, i.e., the subgroup generated by all commutators of G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#fitting_subgroup","page":"Subgroups","title":"fitting_subgroup","text":"fitting_subgroup(G::GAPGroup)\n\nReturn the Fitting subgroup of G, i.e., the largest nilpotent normal subgroup of G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#frattini_subgroup","page":"Subgroups","title":"frattini_subgroup","text":"frattini_subgroup(G::GAPGroup)\n\nReturn the Frattini subgroup of G, i.e., the intersection of all maximal subgroups of G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#radical_subgroup","page":"Subgroups","title":"radical_subgroup","text":"radical_subgroup(G::GAPGroup)\n\nReturn the solvable radical of G, i.e., the largest solvable normal subgroup of G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#socle","page":"Subgroups","title":"socle","text":"socle(G::GAPGroup)\n\nReturn the socle of G, i.e., the subgroup generated by all minimal normal subgroups of G, see minimal_normal_subgroups.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#pcore-Tuple{Oscar.GAPGroup, Union{Integer, fmpz}}","page":"Subgroups","title":"pcore","text":"pcore(G::Group, p::IntegerUnion)\n\nReturn C, f, where C is the p-core (i.e. the largest normal p-subgroup) of G and f is the embedding morphism of C into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#intersect-Union{Tuple{Vararg{T, N} where N}, Tuple{T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"intersect","text":"intersect(V::T...) where T <: Group\nintersect(V::AbstractVector{T}) where T <: Group\n\nIf V is  G_1 G_2 ldots G_n , return the intersection K of the groups G_1 G_2 ldots G_n, together with the embeddings of K into G_i.\n\n\n\n","category":"method"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"The following functions return a vector of subgroups.","category":"page"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"subgroups(G::GAPGroup)\nnormal_subgroups\nmaximal_subgroups\nmaximal_normal_subgroups\nminimal_normal_subgroups\ncharacteristic_subgroups\nderived_series\nsylow_system\nhall_subgroups_representatives\nhall_system\ncomplement_system","category":"page"},{"location":"Groups/subgroups/#subgroups-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"subgroups","text":"subgroups(G::Group)\n\nReturn the vector of all subgroups of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#normal_subgroups","page":"Subgroups","title":"normal_subgroups","text":"normal_subgroups(G::Group)\n\nReturn the vector of normal subgroups of G (see isnormal).\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#maximal_subgroups","page":"Subgroups","title":"maximal_subgroups","text":"maximal_subgroups(G::Group)\n\nReturn the vector of maximal subgroups of G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#maximal_normal_subgroups","page":"Subgroups","title":"maximal_normal_subgroups","text":"maximal_normal_subgroups(G::Group)\n\nReturn the vector of maximal normal subgroups of G, i.e., of those proper normal subgroups of G that are maximal among the proper normal subgroups.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#minimal_normal_subgroups","page":"Subgroups","title":"minimal_normal_subgroups","text":"minimal_normal_subgroups(G::Group)\n\nReturn the vector of minimal normal subgroups of G, i.e., of those nontrivial normal subgroups of G that are minimal among the nontrivial normal subgroups.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#characteristic_subgroups","page":"Subgroups","title":"characteristic_subgroups","text":"characteristic_subgroups(G::Group)\n\nReturn the list of characteristic subgroups of G, i.e., those subgroups that are invariant under all automorphisms of G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#derived_series","page":"Subgroups","title":"derived_series","text":"derived_series(G::GAPGroup)\n\nReturn the vector  G_1 G_2 ldots , where G_1 = G and G_i+1 = derived_subgroup(G_i).\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#sylow_system","page":"Subgroups","title":"sylow_system","text":"sylow_system(G::Group)\n\nReturn a vector of Sylow p-subgroups of the finite group G, where p runs over the prime factors of the order of G, such that every two such subgroups commute with each other (as subgroups).\n\nSylow systems exist only for solvable groups, an exception is thrown if G is not solvable.\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#hall_subgroups_representatives","page":"Subgroups","title":"hall_subgroups_representatives","text":"hall_subgroups_representatives(G::Group, P::AbstractVector{<:IntegerUnion})\n\nReturn a vector that contains representatives of conjugacy classes of Hall P-subgroups of the finite group G, for a vector P of primes. A Hall P-subgroup of G is a subgroup the order of which is only divisible by primes in P and whose index in G is coprime to all primes in P.\n\nFor solvable G, Hall P-subgroups exist and are unique up to conjugacy. For nonsolvable G, Hall P-subgroups may not exist or may not be unique up to conjugacy.\n\nExamples\n\njulia> g = dihedral_group(30);\n\njulia> h = hall_subgroups_representatives(g, [2, 3]);\n\njulia> (length(h), order(h[1]))\n(1, 6)\n\njulia> g = GL(3, 2)\nGL(3,2)\n\njulia> h = hall_subgroups_representatives(g, [2, 3]);\n\njulia> (length(h), order(h[1]))\n(2, 24)\n\njulia> h = hall_subgroups_representatives(g, [2, 7]); length(h)\n0\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#hall_system","page":"Subgroups","title":"hall_system","text":"hall_system(G::Group)\n\nReturn a vector of P-Hall subgroups of the finite group G, where P runs over the subsets of prime factors of the order of G.\n\nHall systems exist only for solvable groups, an exception is thrown if G is not solvable.\n\n\n\n","category":"function"},{"location":"Groups/subgroups/#complement_system","page":"Subgroups","title":"complement_system","text":"complement_system(G::Group)\n\nReturn a vector of p-Hall subgroups of the finite group G, where p runs over the prime factors of the order of G.\n\nComplement systems exist only for solvable groups, an exception is thrown if G is not solvable.\n\n\n\n","category":"function"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"note: Note\nWhen a function returns a vector of subgroups, the output consists in the subgroups only; the embeddings are not returned as well. To get the embedding homomorphism of the subgroup H in G, one can type embedding(G,H).","category":"page"},{"location":"Groups/subgroups/#Conjugation-action-of-elements-and-subgroups","page":"Subgroups","title":"Conjugation action of elements and subgroups","text":"","category":"section"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"isconjugate(G::GAPGroup, x::GAPGroupElem, y::GAPGroupElem)\nisconjugate(G::GAPGroup, H::GAPGroup, K::GAPGroup)\nrepresentative_action(G::GAPGroup, x::GAPGroupElem, y::GAPGroupElem)\nrepresentative_action(G::GAPGroup, H::GAPGroup, K::GAPGroup)\ncentralizer(G::GAPGroup, x::GAPGroupElem)\ncentralizer(G::T, H::T) where T <: GAPGroup\nnormalizer(G::GAPGroup, x::GAPGroupElem)\nnormalizer(G::T, H::T) where T<:GAPGroup\ncore(G::T, H::T) where T<:GAPGroup\nnormal_closure(G::T, H::T) where T<:GAPGroup","category":"page"},{"location":"Groups/subgroups/#isconjugate-Tuple{Oscar.GAPGroup, GAPGroupElem, GAPGroupElem}","page":"Subgroups","title":"isconjugate","text":"isconjugate(G::GAPGroup, x::GAPGroupElem, y::GAPGroupElem)\n\nReturn whether x and y are conjugate elements in G, i.e., there is an element z in G such that x^z equals y.\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#isconjugate-Tuple{Oscar.GAPGroup, Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"isconjugate","text":"isconjugate(G::GAPGroup, H::GAPGroup, K::GAPGroup)\n\nReturn whether H and K are conjugate subgroups in G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#representative_action-Tuple{Oscar.GAPGroup, GAPGroupElem, GAPGroupElem}","page":"Subgroups","title":"representative_action","text":"representative_action(G::Group, x::GAPGroupElem, y::GAPGroupElem)\n\nIf x and y are conjugate in G, return (true, z), where x^z == y holds; otherwise, return (false, nothing).\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#representative_action-Tuple{Oscar.GAPGroup, Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"representative_action","text":"representative_action(G::Group, H::Group, K::Group)\n\nIf H and K are conjugate subgroups in G, return true, z where H^z = K; otherwise, return false, nothing. ```\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#centralizer-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"centralizer","text":"centralizer(G::Group, x::GroupElem)\n\nReturn the centralizer of x in G, i.e., the subgroup of all g in G such that g x equals x g, together with its embedding morphism into G.\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#centralizer-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"centralizer","text":"centralizer(G::Group, H::Group)\n\nReturn the centralizer of H in G, i.e., the subgroup of all g in G such that g h equals h g for every h in H, together with its embedding morphism into G.\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#normalizer-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"normalizer","text":"normalizer(G::Group, x::GAPGroupElem)\n\nReturn N, f, where N is the normalizer of the cyclic subgroup generated by x in G and f is the embedding morphism of N into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#normalizer-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"normalizer","text":"normalizer(G::Group, H::Group)\n\nReturn N, f, where N is the normalizer of H in G, i.e., the largest subgroup of G in which H is normal, and f is the embedding morphism of N into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#core-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"core","text":"core(G::Group, H::Group)\n\nReturn C, f, where C is the normal core of H in G, that is, the largest normal subgroup of G that is contained in H, and f is the embedding morphism of C into G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#normal_closure-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"normal_closure","text":"normal_closure(G::Group, H::Group)\n\nReturn N, f, where N is the normal closure of H in G, that is, the smallest normal subgroup of G that contains H, and f is the embedding morphism of N into G.\n\nNote that H must be a subgroup of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"GroupConjClass{T<:GAPGroup, S<:Union{GAPGroupElem,GAPGroup}}\nrepresentative(G::GroupConjClass)\nacting_group(G::GroupConjClass)\nnumber_conjugacy_classes(G::GAPGroup)\nconjugacy_class(G::GAPGroup, g::GAPGroupElem)\nconjugacy_class(G::T, g::T) where T<:GAPGroup\nconjugacy_classes(G::GAPGroup)\nconjugacy_classes_subgroups(G::GAPGroup)\nconjugacy_classes_maximal_subgroups(G::GAPGroup)","category":"page"},{"location":"Groups/subgroups/#GroupConjClass","page":"Subgroups","title":"GroupConjClass","text":"GroupConjClass\n\nIt could be either the conjugacy class of an element or of a subgroup in a group G. It is displayed as\n\n     cc = x ^ G\n\nwhere G is a group and x = representative(cc) is either an element or a subgroup of G.\n\n\n\n\n\n","category":"type"},{"location":"Groups/subgroups/#representative-Tuple{GroupConjClass}","page":"Subgroups","title":"representative","text":"representative(C::GroupConjClass)\n\nReturn a representative of the conjugacy class C.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#acting_group-Tuple{GroupConjClass}","page":"Subgroups","title":"acting_group","text":"acting_group(C::GroupConjClass)\n\nReturn the acting group of the conjugacy class C.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#number_conjugacy_classes-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"number_conjugacy_classes","text":"number_conjugacy_classes(G::GAPGroup)\n\nReturn the number of conjugacy classes of elements in G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#conjugacy_class-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"conjugacy_class","text":"conjugacy_class(G::Group, g::GAPGroupElem) -> GroupConjClass\n\nReturn the conjugacy class cc of g in G, where g = representative(cc).\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#conjugacy_class-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"conjugacy_class","text":"conjugacy_class(G::T, H::T) where T<:Group -> GroupConjClass\n\nReturn the subgroup conjugacy class cc of H in G, where H = representative(cc).\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#conjugacy_classes-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"conjugacy_classes","text":"conjugacy_classes(G::Group)\n\nReturn the vector of all conjugacy classes of elements in G. It is guaranteed that the class of the identity is in the first position.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#conjugacy_classes_subgroups-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"conjugacy_classes_subgroups","text":"conjugacy_classes_subgroups(G::Group)\n\nReturn the vector of all conjugacy classes of subgroups of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#conjugacy_classes_maximal_subgroups-Tuple{Oscar.GAPGroup}","page":"Subgroups","title":"conjugacy_classes_maximal_subgroups","text":"conjugacy_classes_maximal_subgroups(G::Group)\n\nReturn the vector of all conjugacy classes of maximal subgroups of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#Cosets-(left/right/double)","page":"Subgroups","title":"Cosets (left/right/double)","text":"","category":"section"},{"location":"Groups/subgroups/","page":"Subgroups","title":"Subgroups","text":"GroupCoset\nright_coset(H::GAPGroup, g::GAPGroupElem)\nleft_coset(H::GAPGroup, g::GAPGroupElem)\nisright(c::GroupCoset)\nisleft(c::GroupCoset)\nisbicoset(C::GroupCoset)\nacting_domain(C::GroupCoset)\nrepresentative(C::GroupCoset)\nright_cosets(G::GAPGroup, H::GAPGroup)\nleft_cosets(G::GAPGroup, H::GAPGroup)\nright_transversal(G::T, H::T) where T<: GAPGroup\nleft_transversal(G::T, H::T) where T<: GAPGroup\nGroupDoubleCoset{T <: GAPGroup, S <: GAPGroupElem}\ndouble_coset(G::T, g::GAPGroupElem{T}, H::T) where T<: GAPGroup\ndouble_cosets(G::T, H::T, K::T; NC=false) where T<: GAPGroup\nleft_acting_group(C::GroupDoubleCoset)\nright_acting_group(C::GroupDoubleCoset)\nrepresentative(C::GroupDoubleCoset)\norder(C::Union{GroupCoset,GroupDoubleCoset})\nBase.rand(C::Union{GroupCoset,GroupDoubleCoset})\nintersect(V::AbstractVector{Union{T, GroupCoset, GroupDoubleCoset}}) where T <: GAPGroup","category":"page"},{"location":"Groups/subgroups/#GroupCoset","page":"Subgroups","title":"GroupCoset","text":"GroupCoset{T<: Group, S <: GAPGroupElem}\n\nType of group cosets. It is displayed as H * x (right cosets) or x * H (left cosets), where H is a subgroup of a group G and x is an element of G. Two cosets are equal if, and only if, they are both left (resp. right) and they contain the same elements.\n\n\n\n\n\n","category":"type"},{"location":"Groups/subgroups/#right_coset-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"right_coset","text":"right_coset(H::Group, g::GAPGroupElem)\n*(H::Group, g::GAPGroupElem)\n\nReturn the coset Hg.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#left_coset-Tuple{Oscar.GAPGroup, GAPGroupElem}","page":"Subgroups","title":"left_coset","text":"left_coset(H::Group, g::GAPGroupElem)\n*(g::GAPGroupElem, H::Group)\n\nReturn the coset gH.\n\nnote: Note\nSince GAP supports right cosets only, the underlying GAP object of left_coset(H,g) is the right coset H^(g^-1) * g.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#isright-Tuple{GroupCoset}","page":"Subgroups","title":"isright","text":"isright(c::GroupCoset)\n\nReturn whether the coset c is a right coset of its acting domain.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#isleft-Tuple{GroupCoset}","page":"Subgroups","title":"isleft","text":"isleft(c::GroupCoset)\n\nReturn whether the coset c is a left coset of its acting domain.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#isbicoset-Tuple{GroupCoset}","page":"Subgroups","title":"isbicoset","text":"isbicoset(C::GroupCoset)\n\nReturn whether C is simultaneously a right coset and a left coset for the same subgroup H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#acting_domain-Tuple{GroupCoset}","page":"Subgroups","title":"acting_domain","text":"acting_domain(C::GroupCoset)\n\nIf C = Hx or xH, return H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#representative-Tuple{GroupCoset}","page":"Subgroups","title":"representative","text":"representative(C::GroupCoset)\n\nIf C = Hx or xH, return x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#right_cosets-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"right_cosets","text":"right_cosets(G::Group, H::Group)\n\nReturn the vector of the right cosets of H in G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#left_cosets-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Subgroups","title":"left_cosets","text":"left_cosets(G::Group, H::Group)\n\nReturn the vector of the left cosets of H in G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#right_transversal-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"right_transversal","text":"right_transversal(G::T, H::T) where T<: Group\n\nReturn a vector containing a complete set of representatives for right cosets for H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#left_transversal-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"left_transversal","text":"left_transversal(G::T, H::T) where T<: Group\n\nReturn a vector containing a complete set of representatives for left cosets for H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#GroupDoubleCoset","page":"Subgroups","title":"GroupDoubleCoset","text":"GroupDoubleCoset{T<: Group, S <: GAPGroupElem}\n\nGroup double coset. It is displayed as H * x * K, where H and K are subgroups of a group G and x is an element of G. Two double cosets are equal if, and only if, they contain the same elements.\n\n\n\n\n\n","category":"type"},{"location":"Groups/subgroups/#double_coset-Union{Tuple{T}, Tuple{T, GAPGroupElem{T}, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"double_coset","text":"double_coset(H::Group, x::GAPGroupElem, K::Group)\n*(H::Group, x::GAPGroupElem, K::Group)\n\nreturns the double coset HxK.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#double_cosets-Union{Tuple{T}, Tuple{T, T, T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"double_cosets","text":"double_cosets(G::T, H::T, K::T; NC=false) where T<: GAPGroup\n\nReturn the vector of all the double cosets HxK for x in G. If NC == true, do not check whether H and K are subgroups of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#left_acting_group-Tuple{GroupDoubleCoset}","page":"Subgroups","title":"left_acting_group","text":"left_acting_group(C::GroupDoubleCoset)\n\nif C = HxK, returns H\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#right_acting_group-Tuple{GroupDoubleCoset}","page":"Subgroups","title":"right_acting_group","text":"right_acting_group(C::GroupDoubleCoset)\n\nif C = HxK, returns K\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#representative-Tuple{GroupDoubleCoset}","page":"Subgroups","title":"representative","text":"representative(C::GroupDoubleCoset)\n\nif C = HxK, returns x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#order-Tuple{Union{GroupCoset, GroupDoubleCoset}}","page":"Subgroups","title":"order","text":"order(C::Union{GroupCoset,GroupDoubleCoset})\n\nReturn the cardinality of the (double) coset C.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#rand-Tuple{Union{GroupCoset, GroupDoubleCoset}}","page":"Subgroups","title":"rand","text":"rand(rng::Random.AbstractRNG = Random.GLOBAL_RNG, C::Union{GroupCoset,GroupDoubleCoset})\n\nReturn a random element of the (double) coset C, using the random number generator rng.\n\n\n\n\n\n","category":"method"},{"location":"Groups/subgroups/#intersect-Union{Tuple{AbstractArray{Union{GroupCoset, GroupDoubleCoset, T}, 1}}, Tuple{T}} where T<:Oscar.GAPGroup","page":"Subgroups","title":"intersect","text":"intersect(V::AbstractVector{Union{T, GroupCoset, GroupDoubleCoset}}) where T <: GAPGroup\n\nReturn a vector containing all elements belonging to all groups and cosets in V.\n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/new_developers/#Introduction-for-new-developers","page":"Introduction for new developers","title":"Introduction for new developers","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"This document is meant to get new developers started. It will not go into depth of programming in Julia or working with git, as there are far better resources on these things online.","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"note: Pay attention to your GitHub notifications!\nOnce you open a pull request on GitHub you will receive feedback, comments, and questions on GitHub. So please pay attention to your GitHub notifications.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Important-notes","page":"Introduction for new developers","title":"Important notes","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"If you encounter error messages after rebasing to the current master chances are that some dependencies need upgrading. Please first try whether executing ]up gets rid of your errors.\nPlease have a look at the Developer Style Guide. Adhering to the style guide makes reviewing code easier for us, and hence your new feature can be merged faster.\nLet us know what you are working on:\nYou can open a draft pull request on GitHub right at the beginning of your work.\nFeel free to contact us on Slack.\nHave a look at our community page.\nPlease also read our page on Documenting OSCAR code.\nLook at existing code that does similar things to your project to get an idea of what OSCAR code should look like. Try to look at multiple examples.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Overview","page":"Introduction for new developers","title":"Overview","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"In general you have to do the following six steps for submitting changes to the Oscar source:","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Fork the main Oscar.jl repository. For this go to the Oscar.jl GitHub page and click on \"Fork\" at the upper right.\nClone your forked repository to your local machine.\ngit clone git@github.com:your_github_username/Oscar.jl\nCreate a new branch, usually the naming convention is to use your initials (\"yi\") and then describe your change, for example:\ngit checkout -b yi/new_feature\ngit checkout -b yi/issue1234\ngit checkout -b yi/document_feature\nEdit your source and try out your changes locally (see below). To use your local copy of the sources, start Julia and\n]dev /path/to/local/clone/of/your/fork/of/Oscar.jl\nIf this succeeds, you can enter using Oscar in Julia and it will use your local copy.\nOnce you are done editing, push your branch and open a pull request. It is recommended that you open a draft pull request to the main Oscar repository as soon as you start working. That way Oscar developers are aware of work being done and can give feedback early in the process.\nOnce you have finished your work, mark your pull request as ready. It will then be reviewed and, probably after feedback and requests for changes, merged.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Alternative:-]dev-Oscar","page":"Introduction for new developers","title":"Alternative: ]dev Oscar","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Alternatively you can call","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"]dev Oscar","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"in Julia. This will create a directory ~/.julia/dev/Oscar. This directory is a git clone of the central Oscar repository. You can develope your code here, however you will still have to fork Oscar, as you have no rights to push to the central repository. You can then add your fork as another remote, have a look at the section on rebasing below for hints.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#The-edit-process","page":"Introduction for new developers","title":"The edit process","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/#Editing-the-source","page":"Introduction for new developers","title":"Editing the source","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"The sources can be found in the src folder. Please pay attention to the folder structure and choose sensibly where to place your code (when fixing a bug this is probably a minor question).","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Adding-tests","page":"Introduction for new developers","title":"Adding tests","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/#Adding-documentation","page":"Introduction for new developers","title":"Adding documentation","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"There are two places where documentation can be added:","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"In the docstrings above the functions in the src folder;\nIn the documentation files in the docs/src folder.\nThe overall structure is fixed in the file docs/doc.main. If you create a new file in docs/src, you will have to add an entry in docs/doc.main.","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"In general, 1 is preferred to 2, i.e. any explanation of the functions and objects should go there and the files in docs/src should remain relatively sparse. Please also pay attention to the documentation section of the Developer Style Guide.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Further-hints","page":"Introduction for new developers","title":"Further hints","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/#Ask-Oscar-related-questions-in-the-Oscar-slack","page":"Introduction for new developers","title":"Ask Oscar related questions in the Oscar slack","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/#Use-]up","page":"Introduction for new developers","title":"Use ]up","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Working with the development version also entails that the packages Oscar depends on need to be up to date. Julia can update these packages if you type ]up in the Julia prompt. Many error messages after updating the source can be resolved by simply updating.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Style-guide","page":"Introduction for new developers","title":"Style guide","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Please have a look at the Developer Style Guide to get an overview over naming conventions, code formatting, etc.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Building-the-documentation","page":"Introduction for new developers","title":"Building the documentation","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"To build and test the documentation, please have a look at Documenting OSCAR code.","category":"page"},{"location":"DeveloperDocumentation/new_developers/#Rebasing","page":"Introduction for new developers","title":"Rebasing","text":"","category":"section"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"One way to stay up to date with the current master is rebasing. In order to do this, add the main Oscar.jl repository as a remote, fetch, and then rebase.","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"git remote add oscar-system git@github.com:oscar-system/Oscar.jl\ngit fetch oscar-system\ngit rebase oscar-system/master","category":"page"},{"location":"DeveloperDocumentation/new_developers/","page":"Introduction for new developers","title":"Introduction for new developers","text":"Adding the remote only has to be executed once.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Multivariate-Polynomial-Ring-Interface","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Multivariate polynomial rings are supported in AbstractAlgebra.jl, and in addition to the standard Ring interface, numerous additional functions are provided.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Unlike other kinds of rings, even complex operations such as GCD depend heavily on the multivariate representation. Therefore AbstractAlgebra.jl cannot provide much in the way of additional functionality to external multivariate implementations.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"This means that external libraries must be able to implement their multivariate formats in whatever way they see fit. The required interface here should be implemented, even if it is not optimal. But it can be extended, either by implementing one of the optional interfaces, or by extending the required interface in some other way.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Naturally, any multivariate polynomial ring implementation provides the full Ring interface, in order to be treated as a ring for the sake of AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Considerations which make it impossible for AbstractAlgebra.jl to provide generic functionality on top of an arbitrary multivariate module include:","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"orderings (lexical, degree, weighted, block, arbitrary)\nsparse or dense representation\ndistributed or recursive representation\npacked or unpacked exponents\nexponent bounds (and whether adaptive or not)\nrandom access or iterators\nwhether monomials and polynomials have the same type\nwhether special cache aware data structures such as Geobuckets are used","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Types-and-parents","page":"Multivariate Polynomial Ring Interface","title":"Types and parents","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"AbstractAlgebra.jl provides two abstract types for multivariate polynomial rings and their elements:","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"MPolyRing{T} is the abstract type for multivariate polynomial ring parent types\nMPolyElem{T} is the abstract type for multivariate polynomial types","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"We have that MPolyRing{T} <: Ring and MPolyElem{T} <: RingElem.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Note that both abstract types are parameterised. The type T should usually be the type of elements of the coefficient ring of the polynomial ring. For example, in the case of mathbbZx y the type T would be the type of an integer, e.g. BigInt.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Multivariate polynomial rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Multivariate polynomial rings should at least be distinguished based on their base (coefficient) ring and number of variables. But if they have the same base ring, symbols (for their variables/generators) and ordering, they should certainly have the same parent object.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Required-functionality-for-multivariate-polynomials","page":"Multivariate Polynomial Ring Interface","title":"Required functionality for multivariate polynomials","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"In addition to the required functionality for the Ring interface, the Multivariate Polynomial interface has the following required functions.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"We suppose that R is a fictitious base ring (coefficient ring) and that S is a multivariate polynomial ring over R (i.e. S = Rx y ldots) with parent object S of type MyMPolyRing{T}. We also assume the polynomials in the ring have type MyMPoly{T}, where T is the type of elements of the base (coefficient) ring.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem or more generally the union type RingElement which includes the Julia integer, rational and floating point types.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Constructors","page":"Multivariate Polynomial Ring Interface","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"To construct a multivariate polynomial ring, there is the following constructor.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"PolynomialRing(R::Ring, s::Vector{AbstractString}; ordering=:lex, cached=true)","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a tuple, S, vars consisting of a polynomial ring S and an array of generators (variables) which print according to the strings in the supplied vector s. The ordering can at present be :lex, :deglex or :degrevlex. By default, the polynomial ring is cached, and creating a polynomial ring with the same data will return the same ring object S. If this caching is not desired, it can be switched off by setting cached=false.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Polynomials in a given ring can be constructed using the generators and basic polynomial arithmetic. However, this is inefficient and the following build context is provided for building polynomials term-by-term. It assumes the polynomial data type is random access, and so the constructor functions must be reimplemented for all other types of polynomials.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"MPolyBuildCtx(R::MPolyRing)","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a build context for creating polynomials in the given polynomial ring.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"push_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Add the term with coefficient c and exponent vector v to the polynomial under construction in the build context M.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"finish(M::MPolyBuildCtx)","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Finish construction of the polynomial, sort the terms, remove duplicate and zero terms and return the created polynomial.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Data-type-and-parent-object-methods","page":"Multivariate Polynomial Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"symbols(S::MyMPolyRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an array of Symbols representing the variables (generators) of the polynomial ring. Note that these are Symbols not Strings, though their string values will usually be used when printing polynomials.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"nvars(f::MyMPolyRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the number of variables of the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"gens(S::MyMPolyRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an array of all the generators (variables) of the given polynomial ring (as polynomials).","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The first entry in the array will be the variable with most significance with respect to the ordering.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"gen(S::MyMPolyRing{T}, i::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the i-th generator (variable) of the given polynomial ring (as a polynomial).","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"ordering(S::MyMPolyRing{T})","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the ordering of the given polynomial ring as a symbol. Supported values currently include :lex, :deglex and :degrevlex.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Basic-manipulation-of-rings-and-elements","page":"Multivariate Polynomial Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"length(f::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the number of nonzero terms of the given polynomial. The length of the zero polynomial is defined to be 0. The return value should be of type Int.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"degrees(f::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an array of the degrees of the polynomial f in each of the variables.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"total_degree(f::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the total degree of the polynomial f, i.e. the highest sum of exponents occuring in any term of f.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"isgen(x::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return true if x is a generator of the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"coefficients(p::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an iterator for the coefficients of the polynomial p, starting with the coefficient of the most significant term with respect to the ordering. Generic code will provide this function automatically for random access polynomials that implement the coeff function.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"monomials(p::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an iterator for the monomials of the polynomial p, starting with the monomial of the most significant term with respect to the ordering. Monomials in AbstractAlgebra are defined to have coefficient 1. See the function terms if you also require the coefficients, however note that only monomials can be compared. Generic code will provide this function automatically for random access polynomials that implement the monomial function.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"terms(p::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an iterator for the terms of the polynomial p, starting with the most significant term with respect to the ordering. Terms in AbstractAlgebra include the coefficient. Generic code will provide this function automatically for random access polynomials that implement the term function.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"exponent_vectors(a::MyMPoly{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return an iterator for the exponent vectors for each of the terms of the polynomial starting with the most significant term with respect to the ordering. Each exponent vector is an array of Ints, one for each variable, in the order given when the polynomial ring was created. Generic code will provide this function automatically for random access polynomials that implement the exponent_vector function.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Exact-division","page":"Multivariate Polynomial Ring Interface","title":"Exact division","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"For any ring that implements exact division, the following can be implemented.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divexact(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the exact quotient of f by g if it exists, otherwise throw an error.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divides(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a tuple (flag, q) where flag is true if g divides f, in which case q will be the exact quotient, or flag is false and q is set to zero.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"remove(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a tuple (v q) such that the highest power of g that divides f is g^v and the cofactor is q.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"valuation(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return v such that the highest power of g that divides f is g^v.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Ad-hoc-exact-division","page":"Multivariate Polynomial Ring Interface","title":"Ad hoc exact division","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"For any ring that implements exact division, the following can be implemented.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divexact(f::MyMPoly{T}, c::Integer) where T <: RingElem\ndivexact(f::MyMPoly{T}, c::Rational) where T <: RingElem\ndivexact(f::MyMPoly{T}, c::T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Divide the polynomial exactly by the constant c.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Euclidean-division","page":"Multivariate Polynomial Ring Interface","title":"Euclidean division","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Although multivariate polynomial rings are not in general Euclidean, it is possible to define a quotient with remainder function that depends on the polynomial ordering in the case that the quotient ring is a field or a Euclidean domain. In the case that a polynomial g divides a polynomial f, the result no longer depends on the ordering and the remainder is zero, with the quotient agreeing with the exact quotient.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divrem(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a tuple (q r) such that f = qg + r, where the coefficients of terms of r whose monomials are divisible by the leading monomial of g are reduced modulo the leading coefficient of g (according to the Euclidean function on the coefficients).","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Note that the result of this function depends on the ordering of the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"div(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"As per the divrem function, but returning the quotient only. Especially when the quotient happens to be exact, this function can be exceedingly fast.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#GCD","page":"Multivariate Polynomial Ring Interface","title":"GCD","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"In cases where there is a meaningful Euclidean structure on the coefficient ring, it is possible to compute the GCD of multivariate polynomials.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"gcd(f::MyMPoly{T}, g::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a greatest common divisor of f and g.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Square-root","page":"Multivariate Polynomial Ring Interface","title":"Square root","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Over rings for which an exact square root is available, it is possible to take the square root of a polynomial or test whether it is a square.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"sqrt(f::MyMPoly{T}, check::Bool=true) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the square root of the polynomial f and raise an exception if it is not a square. If check is set to false, the input is assumed to be a perfect square and this assumption is not fully checked. This can be significantly faster.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"issquare(::MyMPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return true if f is a square.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Interface-for-sparse-distributed,-random-access-multivariates","page":"Multivariate Polynomial Ring Interface","title":"Interface for sparse distributed, random access multivariates","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The following additional functions should be implemented by libraries that provide a sparse distributed polynomial format, stored in a representation for which terms can be accessed in constant time (e.g. where arrays are used to store coefficients and exponent vectors).","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Sparse-distributed,-random-access-constructors","page":"Multivariate Polynomial Ring Interface","title":"Sparse distributed, random access constructors","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"In addition to the standard constructors, the following constructor, taking arrays of coefficients and exponent vectors, should be provided.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"(S::MyMPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Create the polynomial in the given ring with nonzero coefficients specified by the elements of A and corresponding exponent vectors given by the elements of m.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"There is no assumption about coefficients being nonzero or terms being in order or unique. Zero terms are removed by the function, duplicate terms are combined (added) and the terms are sorted so that they are in the correct order.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Each exponent vector uses a separate integer for each exponent field, the first of which should be the exponent for the most significant variable with respect to the ordering. All exponents must be non-negative.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"A library may also optionally provide an interface that makes use of BigInt (or any other big integer type) for exponents instead of Int.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Sparse-distributed,-random-access-basic-manipulation","page":"Multivariate Polynomial Ring Interface","title":"Sparse distributed, random access basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"coeff(f::MyMPoly{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the coefficient of the n-th term of f. The first term should be the most significant term with respect to the ordering.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"coeff(a::MyMPoly{T}, exps::Vector{Int}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the coefficient of the term with the given exponent vector, or zero if there is no such term.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"monomial(f::MyMPoly{T}, n::Int) where T <: RingElem\nmonomial!(m::MyMPoly{T}, f::MyMPoly{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the n-th monomial of f or set m to the n-th monomial of f, respectively. The first monomial should be the most significant term with respect to the ordering. Monomials have coefficient 1 in AbstractAlgebra. See the function term if you also require the coefficient, however, note that only monomials can be compared.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"term(f::MyMPoly{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the n-th term of f. The first term should be the one whose monomial is most significant with respect to the ordering.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"exponent(f::MyMPoly{T}, i::Int, j::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return the exponent of the j-th variable in the i-th term of the polynomial f. The first term is the one with whose monomial is most significant with respect to the ordering.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"exponent_vector(a::MyMPoly{T}, i::Int) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Return a vector of exponents, corresponding to the exponent vector of the i-th term of the polynomial. Term numbering begins at 1 and the exponents are given in the order of the variables for the ring, as supplied when the ring was created.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"setcoeff!(a::MyMPoly, exps::Vector{Int}, c::S) where S <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Set the coefficient of the term with the given exponent vector to the given value c. If no such term exists (and c neq 0), one will be inserted. This function takes O(log n) operations if a term with the given exponent already exists and c neq 0, or if the term is inserted at the end of the polynomial. Otherwise it can take O(n) operations in the worst case. This function must return the modified polynomial.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Unsafe-functions","page":"Multivariate Polynomial Ring Interface","title":"Unsafe functions","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The following functions must be provided, but are considered unsafe, as they may leave the polynomials in an inconsistent state and they mutate their inputs. As usual, such functions should only be applied on polynomials that have no references elsewhere in the system and are mainly intended to be used in carefully written library code, rather than by users.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Users should instead build polynomials using the constructors described above.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"fit!(f::MyMPoly{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Ensure that the polynomial f internally has space for n nonzero terms. This function must mutate the function in-place if it is mutable. It does not return the mutated polynomial. Immutable types can still be supported by defining this function to do nothing.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"setcoeff!(a::MyMPoly{T}, i::Int, c::T) where T <: RingElement\nsetcoeff!(a::MyMPoly{T}, i::Int, c::U) where {T <: RingElement, U <: Integer}","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Set the i-th coefficient of the polynomial a to c. No check is performed on the index i or for c = 0. It may be necessary to call combine_like_terms after calls to this function, to remove zero terms. The function must return the modified polynomial.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"combine_like_terms!(a::MyMPoly{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Remove zero terms and combine any adjacent terms with the same exponent vector (by adding them). It is assumed that all the exponent vectors are already in the correct order with respect to the ordering. The function must return the resulting polynomial.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"set_exponent_vector!(a::MyMPoly{T}, i::Int, exps::Vector{Int}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Set the i-th exponent vector to the given exponent vector. No check is performed on the index i, which is assumed to be valid (or that the polynomial has enough space allocated). No sorting of exponents is performed by this function. To sort the terms after setting any number of exponents with this function, run the sort_terms! function. The function must return the modified polynomial.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"sort_terms!(a::MyMPoly{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Sort the terms of the given polynomial according to the polynomial ring ordering. Zero terms and duplicate exponents are ignored. To deal with those call combine_like_terms. The sorted polynomial must be returned by the function.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Optional-functionality-for-multivariate-polynomials","page":"Multivariate Polynomial Ring Interface","title":"Optional functionality for multivariate polynomials","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The following functions can optionally be implemented for multivariate polynomial types.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Reduction-by-an-ideal","page":"Multivariate Polynomial Ring Interface","title":"Reduction by an ideal","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"divrem(f::MyMPoly{T}, G::Vector{MyMPoly{T}}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"As per the divrem function above, except that each term of r starting with the most significant term, is reduced modulo the leading terms of each of the polynomials in the array G for which the leading monomial is a divisor.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"A tuple (Q r) is returned from the function, where Q is an array of polynomials of the same length as G, and such that f = r + sum QiGi.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The result is again dependent on the ordering in general, but if the polynomials in G are over a field and the reduced generators of a Groebner basis, then the result is unique.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Evaluation","page":"Multivariate Polynomial Ring Interface","title":"Evaluation","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"evaluate(a::MyMPoly{T}, A::Vector{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Evaluate the polynomial at the given values in the coefficient ring of the polynomial. The result should be an element of the coefficient ring.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"evaluate(f::MyMPoly{T}, A::Vector{U}) where {T <: RingElem, U <: Integer}","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Evaluate the polynomial f at the values specified by the entries of the array A.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"(a::MyMPoly{T})(vals::Union{NCRingElem, RingElement}...) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Evaluate the polynomial at the given arguments. This provides functional notation for polynomial evaluation, i.e. f(a b c). It must be defined for each supported polynomial type (Julia does not allow functional notation to be defined for an abstract type).","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The code for this function in MPoly.jl can be used when implementing this as it provides the most general possible evaluation, which is much more general than the case of evaluation at elements of the same ring.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The evaluation should succeed for any set of values for which a multiplication is defined with the product of a coefficient and all the values before it.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"note: Note\nThe values at which a polynomial is evaluated may be in non-commutative rings. Products are performed in the order of the variables in the polynomial ring that the polynomial belongs to, preceded by a multiplication by the coefficient on the left.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/#Derivations","page":"Multivariate Polynomial Ring Interface","title":"Derivations","text":"","category":"section"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"The following function allows to compute derivations of multivariate polynomials of type MPoly.","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"derivative(f::MyMPoly{T}, j::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpoly_interface/","page":"Multivariate Polynomial Ring Interface","title":"Multivariate Polynomial Ring Interface","text":"Compute the derivative of f with respect to the j-th variable of the polynomial ring.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"Pages = [\"polymake.md\"]","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/#Polyhedron-and-polymake's-Polytope","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"Many polyhedral computations are done through polymake. polymake (Ewgenij Gawrilow, Michael Joswig (2000), polymake.org) is open source software for research in polyhedral geometry and is attached to Julia via Polymake.jl (Marek Kaluba, Benjamin Lorenz, Sascha Timme (2020), Polymake.jl). This is visible in the structure Polyhedron via a pointer pm_polytope to the corresponding polymake object. Using Polymake.jl one can apply all functionality of polymake to the polymake object hidden behind this pointer.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"Sometimes it can be necessary to directly invoke some polymake functions on an Oscar Polyhedron object (e.g. because some functionality has not yet been made available via Oscar's interface). In that case, the following two functions allow extracting the underlying Polymake.jl object from a Polyhedron, respectively wrapping a Polymake.jl object representing a polyhedron into a high-level Polyhedron object.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"Polyhedron(::Polymake.BigObject)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/#Polyhedron-Tuple{Polymake.BigObject}","page":"Polyhedron and polymake's Polytope","title":"Polyhedron","text":"Polyhedron{T}(P::Polymake.BigObject) where T<:scalar_types\n\nConstruct a Polyhedron corresponding to a Polymake.BigObject of type Polytope.\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"The following shows all the data currently known for a Polyhedron.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"C = cube(3)\nC.pm_polytope","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"polymake allows for an interactive visualization of 3-dimensional polytopes in the browser: Polymake.visual(C.pm_polytope).","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"warning: Warning\nThere are several design differences between polymake and Oscar. Polyhedra in polymake and Polymake.jl use homogeneous coordinates. The polyhedra in Oscar use affine coordinates.  Indices in polymake are zero-based, whereas in Oscar they are one-based.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"The next example shows a purely combinatorial construction of a polytope (here: a square). In spite of being given no coordinates, polymake can check for us that this is a simple polytope; i.e., each vertex is contained in dimension many facets.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"Q = Polymake.polytope.Polytope(VERTICES_IN_FACETS=[[0,2],[1,3],[0,1],[2,3]]);\nQ.SIMPLE","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"However, without coordinates, some operations such as computing the volume cannot work:","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/polymake/","page":"Polyhedron and polymake's Polytope","title":"Polyhedron and polymake's Polytope","text":"Q.VOLUME","category":"page"},{"location":"Hecke/function_fields/degree_localization/#Degree-localization-of-a-rational-function-field","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"","category":"section"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"CurrentModule = Hecke\nDocTestSetup = quote\n  using Hecke\nend","category":"page"},{"location":"Hecke/function_fields/degree_localization/#Degree-localization","page":"Degree localization of a rational function field","title":"Degree localization","text":"","category":"section"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"Given k(x) a (univariate) rational function field, there are two rings of interest, both of which are Euclidean:","category":"page"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"kx\nk_\n\\infty(x) = {a/b | a, b \\in k[x] \\;\\;\\mbox{where}\\;\\; \\deg(a) \\leq \\deg(b)}","category":"page"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"The second of these rings is the localization of k1x at (1x) inside the rational function field k(x), i.e. the localization of the function field at the point at infinity, i.e. the valuation ring for valuation -degree(x).","category":"page"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"We refer to this ring as the degree localization of the rational function field k(x).","category":"page"},{"location":"Hecke/function_fields/degree_localization/#Construction-of-the-degree-localization","page":"Degree localization of a rational function field","title":"Construction of the degree localization","text":"","category":"section"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"The degree localization of a rational function field k(x) can be constructed using a Localization constructor, passing in the degree function as argument.","category":"page"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"Localization(K::Generic.RationalFunctionField{T}, ::typeof(degree)) where T <: FieldElement","category":"page"},{"location":"Hecke/function_fields/degree_localization/#Localization-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.RationalFunctionField{T}, typeof(degree)}} where T<:FieldElement","page":"Degree localization of a rational function field","title":"Localization","text":"Localization(K::RationalFunctionField{T}, ::typeof(degree)) where T <: FieldElement\n\nReturn the localization of k1x at (1x) inside the rational function field k(x), i.e. the localization of the function field at the point at infinity, i.e. the valuation ring for valuation -degree(x). This is the ring k_infty(x) =  fg  deg(f) leq deg(g).\n\n\n\n","category":"method"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"","category":"page"},{"location":"Hecke/function_fields/degree_localization/#Example","page":"Degree localization of a rational function field","title":"Example +","text":"","category":"section"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"using Hecke # hide\nK, x = RationalFunctionField(FlintQQ, \"x\");\nR = Localization(K, degree)","category":"page"},{"location":"Hecke/function_fields/degree_localization/#Elements-of-the-degree-localization","page":"Degree localization of a rational function field","title":"Elements of the degree localization","text":"","category":"section"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"Elements of the degree localization are created using the parent object R representing the degree localization","category":"page"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"","category":"page"},{"location":"Hecke/function_fields/degree_localization/#Example-2","page":"Degree localization of a rational function field","title":"Example +","text":"","category":"section"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"using Hecke # hide\nK, x = RationalFunctionField(FlintQQ, \"x\");\nR = Localization(K, degree)\n\na = R()\nb = R(1)\nc = R((x + 1)//x)","category":"page"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"Note that the degree of the denominator of the function field element passed to the constructor must be at least that of the numerator or an exception is raised.","category":"page"},{"location":"Hecke/function_fields/degree_localization/#Element-functionality","page":"Degree localization of a rational function field","title":"Element functionality","text":"","category":"section"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"degree(a::KInftyElem)\nvaluation(a::KInftyElem)","category":"page"},{"location":"Hecke/function_fields/degree_localization/#degree-Tuple{KInftyElem}","page":"Degree localization of a rational function field","title":"degree","text":" degree(a::KInftyElem)\n\nReturn the degree of the given element, i.e. degree(numerator) - degree(denominator).\n\n\n\n","category":"method"},{"location":"Hecke/function_fields/degree_localization/#valuation-Tuple{KInftyElem}","page":"Degree localization of a rational function field","title":"valuation","text":"valuation(a::KInftyElem)\n\nReturn the degree valuation of the given element, i.e. -degree(a).\n\n\n\n","category":"method"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"One can test whether a given element of a rational function field is in the degree localization.","category":"page"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"in(a::Generic.Rat{T}, R::KInftyRing{T}) where T <: FieldElement","category":"page"},{"location":"Hecke/function_fields/degree_localization/#in-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.Rat{T}, KInftyRing{T}}} where T<:FieldElement","page":"Degree localization of a rational function field","title":"in","text":"in(a::Generic.Rat{T}, R::KInftyRing{T}) where T <: FieldElement\n\nReturn true if the given element of the rational function field is an element of k_\\infty(x), i.e. if degree(numerator) <= degree(denominator).\n\n\n\n","category":"method"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"All basic arithmetic operations are provided for elements of the degree localization.","category":"page"},{"location":"Hecke/function_fields/degree_localization/","page":"Degree localization of a rational function field","title":"Degree localization of a rational function field","text":"As the degree localization is a Euclidean ring, all standard Euclidean functions, including div, divrem, mod, gcd, gcdx, are provided.","category":"page"},{"location":"Hecke/class_fields/intro/#Class-Field-Theory","page":"Class Field Theory","title":"Class Field Theory","text":"","category":"section"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/class_fields/intro/#Introduction","page":"Class Field Theory","title":"Introduction","text":"","category":"section"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"This chapter deals with abelian extensions of number fields and the rational numbers.","category":"page"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {\\Q}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {\\Q} is is not practical.","category":"page"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients.","category":"page"},{"location":"Hecke/class_fields/intro/#Ray-Class-Groups","page":"Class Field Theory","title":"Ray Class Groups","text":"","category":"section"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"Given an integral ideal m_0 le Z_K and a list of real places m_infty, the ray class group modulo (m_0 m_infty), C(m) is defined as the group of ideals coprime to m_0 modulo the elements ain K^* s.th. v_p(a-1) ge v_p(m_0) and for all vin m_infty, a^(v) 0. This is a finite abelian group. For m_0 = Z_K and m_infty =  we get C() is the class group, if m_infty contains all real places, we obtain the narrow class group, or strict class group.","category":"page"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"ray_class_group(m::Hecke.NfAbsOrdIdl{Nemo.AnticNumberField,Nemo.nf_elem}, inf_plc::Vector{Hecke.InfPlc}; p_part, n_quo)\nclass_group(K::Nemo.AnticNumberField)\nnorm_group(f::Nemo.PolyElem, mR::Hecke.MapRayClassGrp, isabelian::Bool)\nnorm_group(K::NfRel{nf_elem}, mR::Hecke.MapRayClassGrp, isabelian::Bool)","category":"page"},{"location":"Hecke/class_fields/intro/#ray_class_group-Tuple{NfOrdIdl, Vector{InfPlc}}","page":"Class Field Theory","title":"ray_class_group","text":"ray_class_group(m::NfOrdIdl, inf_plc::Vector{InfPlc}; n_quo::Int, lp::Dict{NfOrdIdl, Int}) -> GrpAbFinGen, MapRayClassGrp\n\nGiven an ideal m and a set of infinite places of K, this function returns the corresponding ray class group as an abstract group mathcal Cl_m and a map going from the group into the group of ideals of K that are coprime to m. If n_quo is set, it will return the group modulo n_quo. The factorization of m can be given with the keyword argument lp.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#class_group-Tuple{AnticNumberField}","page":"Class Field Theory","title":"class_group","text":"class_group(K::AnticNumberField) -> GrpAbFinGen, Map\n\nShortcut for class_group(maximal_order(K)): returns the class group as an abelian group and a map from this group to the set of ideals of the maximal order.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#norm_group-Tuple{PolyElem, MapRayClassGrp, Bool}","page":"Class Field Theory","title":"norm_group","text":"norm_group(f::Nemo.PolyElem, mR::Hecke.MapRayClassGrp, isabelian::Bool = true; of_closure::Bool = false) -> Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap\n\nnorm_group(f::Array{PolyElem{nf_elem}}, mR::Hecke.MapRayClassGrp, isabelian::Bool = true; of_closure::Bool = false) -> Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap\n\nComputes the subgroup of the Ray Class Group R given by the norm of the extension generated by a/the roots of f. If isabelian is set to true, then the code assumes the field to be abelian, hence the algorithm stops when the quotient by the norm group has the correct order. Even though the algorithm is probabilistic by nature, in this case the result is guaranteed. If of_closure is given, then the norm group of the splitting field of the polynomial(s) is computed. It is the callers responsibility to ensure that the ray class group passed in is large enough.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#norm_group-Tuple{Hecke.NfRel{nf_elem}, MapRayClassGrp, Bool}","page":"Class Field Theory","title":"norm_group","text":"norm_group(K::NfRel{nf_elem}, mR::Hecke.MapRayClassGrp) -> Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap\n\nnorm_group(K::NfRelNS{nf_elem}, mR::Hecke.MapRayClassGrp) -> Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap\n\nComputes the subgroup of the Ray Class Group R given by the norm of the extension.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#Ray-Class-Fields","page":"Class Field Theory","title":"Ray Class Fields","text":"","category":"section"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps.","category":"page"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"It should be noted that this is a {\\em lazy} construction: nothing is computed at this point.","category":"page"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"ray_class_field(m::Union{Hecke.MapClassGrp, Hecke.MapRayClassGrp})\nray_class_field(m::Union{Hecke.MapClassGrp, Hecke.MapRayClassGrp}, quomap::Hecke.GrpAbFinGenMap)\nray_class_field(I::Hecke.NfAbsOrdIdl; n_quo, p_part)\nray_class_field(I::Hecke.NfAbsOrdIdl, ::Vector{InfPlc}; n_quo, p_part)\nhilbert_class_field(k::AnticNumberField)\nring_class_field(::NfAbsOrd)","category":"page"},{"location":"Hecke/class_fields/intro/#ray_class_field-Tuple{Union{Hecke.MapClassGrp, MapRayClassGrp}}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(m::MapClassGrp) -> ClassField\nray_class_field(m::MapRayClassGrp) -> ClassField\n\nCreates the (formal) abelian extension defined by the map m A to I where I is the set of ideals coprime to the modulus defining m and A is a quotient of the ray class group (or class group). The map m must be the map returned from a call to {classgroup} or {rayclass_group}.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#ray_class_field-Tuple{Union{Hecke.MapClassGrp, MapRayClassGrp}, GrpAbFinGenMap}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(m::Union{MapClassGrp, MapRayClassGrp}, quomap::GrpAbFinGenMap) -> ClassField\n\nFor m a map computed by either {rayclassgroup} or {class_group} and q a canonical projection (quotient map) as returned by {quo} for q quotient of the domain of m and a subgroup of m, create the (formal) abelian extension where the (relative) automorphism group is canonically isomorphic to the codomain of q.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#ray_class_field-Tuple{NfAbsOrdIdl}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(I::NfAbsOrdIdl; n_quo = 0) -> ClassField\n\nThe ray class field modulo I. If n_quo is given, then the largest subfield of exponent n is computed.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#ray_class_field-Tuple{NfAbsOrdIdl, Vector{InfPlc}}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(I::NfAbsOrdIdl, inf::Vector{InfPlc}; n_quo = 0) -> ClassField\n\nThe ray class field modulo I and the infinite places given. If n_quo is given, then the largest subfield of exponent n is computed.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#hilbert_class_field-Tuple{AnticNumberField}","page":"Class Field Theory","title":"hilbert_class_field","text":"hilbert_class_field(k::AnticNumberField) -> ClassField\n\nThe Hilbert class field of k as a formal (ray-) class field.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#ring_class_field-Tuple{NfAbsOrd}","page":"Class Field Theory","title":"ring_class_field","text":"ring_class_field(O::NfAbsOrd) -> ClassField\n\nThe ring class field of O, i.e. the maximal abelian extension ramified only at primes dividing the conductor with the automorphism group isomorphic to the Picard group.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#Example","page":"Class Field Theory","title":"Example","text":"","category":"section"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"using Hecke # hide\nQx, x = PolynomialRing(FlintQQ, \"x\");\nK, a = NumberField(x^2 - 10, \"a\");\nc, mc = class_group(K)\nA = ray_class_field(mc)","category":"page"},{"location":"Hecke/class_fields/intro/#Conversions","page":"Class Field Theory","title":"Conversions","text":"","category":"section"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group.","category":"page"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{setverboselevel(:ClassField, n)}}} where 0le nle 3","category":"page"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"number_field(C::ClassField)","category":"page"},{"location":"Hecke/class_fields/intro/#number_field-Tuple{ClassField}","page":"Class Field Theory","title":"number_field","text":"NumberField(CF::ClassField) -> NfRelNS{nf_elem}\n\nGiven a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields.\n\nNote, the return type is always a non-simple extension.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"using Hecke; # hide\nQx, x = PolynomialRing(FlintQQ, \"x\");\nk, a = NumberField(x^2 - 10, \"a\");\nc, mc = class_group(k);\nA = ray_class_field(mc)\nK = number_field(A)\nZK = maximal_order(K)\nisone(discriminant(ZK))","category":"page"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"ray_class_field(K::NfRel{nf_elem})\ngenus_field(A::ClassField, k::AnticNumberField)\nmaximal_abelian_subfield(A::ClassField, k::AnticNumberField)\nmaximal_abelian_subfield(K::NfRel{nf_elem})","category":"page"},{"location":"Hecke/class_fields/intro/#ray_class_field-Tuple{Hecke.NfRel{nf_elem}}","page":"Class Field Theory","title":"ray_class_field","text":"ray_class_field(K::NfRel{nf_elem}) -> ClassField\n\nFor a (relative) abelian extension, compute an abstract representation as a class field.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#genus_field-Tuple{ClassField, AnticNumberField}","page":"Class Field Theory","title":"genus_field","text":"genus_field(A::ClassField, k::AnticNumberField) -> ClassField\n\nThe maximal extension contained in A that is the compositum of K with an abelian extension of k.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#maximal_abelian_subfield-Tuple{ClassField, AnticNumberField}","page":"Class Field Theory","title":"maximal_abelian_subfield","text":"maximal_abelian_subfield(A::ClassField, k::AnticNumberField) -> ClassField\n\nThe maximal abelian extension of k contained in A. k must be a subfield of the base field of A.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#maximal_abelian_subfield-Tuple{Hecke.NfRel{nf_elem}}","page":"Class Field Theory","title":"maximal_abelian_subfield","text":"maximal_abelian_subfield(K::NfRel{nf_elem}; of_closure::Bool = false) -> ClassField\n\nUsing a probabilistic algorithm for the norm group computation, determine the maximal abelian subfield in K over its base field. If of_closure is set to true, then the algorithm is applied to the normal closure of K (without computing it).\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#Invariants","page":"Class Field Theory","title":"Invariants","text":"","category":"section"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"degree(C::ClassField)\nbase_ring(A::Hecke.ClassField)\nbase_field(A::Hecke.ClassField)\ndiscriminant(C::Hecke.ClassField)\nconductor(C::Hecke.ClassField)\ndefining_modulus(C::ClassField)\niscyclic(C::ClassField)\nisconductor(C::Hecke.ClassField, m::NfOrdIdl, inf_plc::Vector{InfPlc})\nisnormal(C::ClassField)\niscentral(C::ClassField)","category":"page"},{"location":"Hecke/class_fields/intro/#degree-Tuple{ClassField}","page":"Class Field Theory","title":"degree","text":"degree(A::ClassField)\n\nThe degree of A over its base field, i.e. the size of the defining ideal group.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#base_ring-Tuple{ClassField}","page":"Class Field Theory","title":"base_ring","text":"base_ring(A::ClassField)\n\nThe maximal order of the field that A is defined over.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#base_field-Tuple{ClassField}","page":"Class Field Theory","title":"base_field","text":"base_field(A::ClassField)\n\nThe number field that A is defined over.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#discriminant-Tuple{ClassField}","page":"Class Field Theory","title":"discriminant","text":"discriminant(C::ClassField) -> NfOrdIdl\n\nUsing the conductor-discriminant formula, compute the (relative) discriminant of C. This does not use the defining equations.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#conductor-Tuple{ClassField}","page":"Class Field Theory","title":"conductor","text":"conductor(C::ClassField) -> NfOrdIdl, Vector{InfPlc}\n\nReturn the conductor of the abelian extension corresponding to C.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#defining_modulus-Tuple{ClassField}","page":"Class Field Theory","title":"defining_modulus","text":"defining_modulus(CF::ClassField)\n\nThe modulus, i.e. an ideal of the set of real places, used to create the class field.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#iscyclic-Tuple{ClassField}","page":"Class Field Theory","title":"iscyclic","text":"iscyclic(C::ClassField)\n\nTests if the (relative) automorphism group of C is cyclic (by checking the defining ideal group).\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#isconductor-Tuple{ClassField, NfOrdIdl, Vector{InfPlc}}","page":"Class Field Theory","title":"isconductor","text":"isconductor(C::Hecke.ClassField, m::NfOrdIdl, inf_plc::Vector{InfPlc}=InfPlc[]; check) -> NfOrdIdl, Vector{InfPlc}\n\nChecks if (m, inf_plc) is the conductor of the abelian extension corresponding to C. If check is false, it assumes that the given modulus is a multiple of the conductor. This is usually faster than computing the conductor.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#isnormal-Tuple{ClassField}","page":"Class Field Theory","title":"isnormal","text":"isnormal(C::ClassField) -> Bool\n\nFor a class field C defined over a normal base field k, decide if C is normal over Q.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#iscentral-Tuple{ClassField}","page":"Class Field Theory","title":"iscentral","text":"iscentral(C::ClassField) -> Bool\n\nFor a class field C defined over a normal base field k, decide if C is central over Q.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#Operations","page":"Class Field Theory","title":"Operations","text":"","category":"section"},{"location":"Hecke/class_fields/intro/","page":"Class Field Theory","title":"Class Field Theory","text":"*(a::Hecke.ClassField, b::Hecke.ClassField)\ncompositum(a::Hecke.ClassField, b::Hecke.ClassField)\n==(a::Hecke.ClassField, b::Hecke.ClassField)\nintersect(a::Hecke.ClassField, b::Hecke.ClassField)\nprime_decomposition_type(C::Hecke.ClassField, p::Hecke.NfAbsOrdIdl)\nHecke.issubfield(a::ClassField, b::ClassField)\nHecke.islocal_norm(r::Hecke.ClassField, a::Hecke.NfAbsOrdElem)\nHecke.islocal_norm(r::Hecke.ClassField, a::Hecke.NfAbsOrdElem, p::Hecke.NfAbsOrdIdl)\nHecke.normal_closure(r::Hecke.ClassField)\nsubfields(r::ClassField)\nsubfields(r::ClassField, d::Int)","category":"page"},{"location":"Hecke/class_fields/intro/#*-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"*","text":"*(A::ClassField, B::ClassField) -> ClassField\n\nThe compositum of a and b as a (formal) class field.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#compositum-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"compositum","text":"compositum(a::ClassField, b::ClassField) -> ClassField\n\nThe compositum of a and b as a (formal) class field.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#==-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"==","text":"==(a::ClassField, b::ClassField)\n\nTests if a and b are equal.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#intersect-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"intersect","text":"intersect(a::ClassField, b::ClassField) -> ClassField\n\nThe intersection of a and b as a class field.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#prime_decomposition_type-Tuple{ClassField, NfAbsOrdIdl}","page":"Class Field Theory","title":"prime_decomposition_type","text":"prime_decomposition_type(C::ClassField, p::NfAbsOrdIdl) -> (Int, Int, Int)\n\nFor a prime p in the base ring of r, determine the splitting type of p in r. ie. the tuple (e f g) giving the ramification degree, the inertia and the number of primes above p.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#issubfield-Tuple{ClassField, ClassField}","page":"Class Field Theory","title":"issubfield","text":"issubfield(a::ClassField, b::ClassField) -> Bool\n\nDetermines if a is a subfield of b.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#islocal_norm-Tuple{ClassField, NfAbsOrdElem}","page":"Class Field Theory","title":"islocal_norm","text":"islocal_norm(r::ClassField, a::NfAbsOrdElem) -> Bool\n\nTests if a is a local norm at all finite places in the extension implictly given by r.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#islocal_norm-Tuple{ClassField, NfAbsOrdElem, NfAbsOrdIdl}","page":"Class Field Theory","title":"islocal_norm","text":"islocal_norm(r::ClassField, a::NfAbsOrdElem, p::NfAbsOrdIdl) -> Bool\n\nTests if a is a local norm at p in the extension implictly given by r. Currently the conductor cannot have infinite places.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#normal_closure-Tuple{ClassField}","page":"Class Field Theory","title":"normal_closure","text":"normal_closure(C::ClassField) -> ClassField\n\nFor a ray class field C extending a normal base field k, compute the normal closure over Q.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#subfields-Tuple{ClassField}","page":"Class Field Theory","title":"subfields","text":"subfields(C::ClassField) -> Vector{ClassField}\n\nFind all subfields of C as class fields. Note: this will not find all subfields over Q, but only the ones sharing the same base field.\n\n\n\n","category":"method"},{"location":"Hecke/class_fields/intro/#subfields-Tuple{ClassField, Int64}","page":"Class Field Theory","title":"subfields","text":"subfields(C::ClassField, d::Int) -> Vector{ClassField}\n\nFind all subfields of C of degree d as class fields. Note: this will not find all subfields over Q, but only the ones sharing the same base field.\n\n\n\n","category":"method"},{"location":"Hecke/pmat/introduction/#PMatLink","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"This chapter deals with pseudo-matrices. We follow the common terminology and conventions introduced in Henri Cohen (2000), however, we operate on rows, not on columns.","category":"page"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"Let R be a Dedekind domain, typically, the maximal order of some number field K, further fix some finite dimensional K-vectorspace V (with some basis), frequently K^n or the K-structure of some extension of K. Since in general R is not a PID, the R-modules in V are usually not free, but still projective.","category":"page"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"Any finitely generated R-module Msubset V can be represented as a pseudo-matrix PMat as follows: The structure theory of R-modules gives the existence of (fractional) R-ideals mathfrak A_i and elements omega_iin V such that M = sum mathfrak A_i omega_i and the sum is direct.","category":"page"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"Following Cohen we call modules of the form mathfrak Aomega for some ideal mathfrak A and omega in V a pseudo element. A system (mathfrak A_i omega_i) is called a pseudo-generating system for M if langle mathfrak A_iomega_iilangle = M. A pseudo-generating system is called a pseudo-basis if the omega_i are K-linear independent.","category":"page"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"A pseudo-matrix X is a tuple containing a vector of ideals mathfrak A_i (1le ile r) and a matrix Uin K^rtimes n. The i-th row together with the i-th ideal defines a pseudo-element, thus an R-module, all of them together generate a module M.","category":"page"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"A pseudo-matrix X=((mathfrak A_i)_i U) is said to be in pseudo-hnf if U is essentially upper triangular. Similar to the classical hnf, there is an algorithm that transforms any pseudo-matrix into one in pseudo-hnf while maintaining the module.","category":"page"},{"location":"Hecke/pmat/introduction/#Creation","page":"Introduction","title":"Creation","text":"","category":"section"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"In general to create a PMat one has to specify a matrix and a vector of ideals:","category":"page"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"PseudoMatrix(m::AbstractAlgebra.MatElem{nf_elem}, c::Vector{NfOrdIdl})\nPseudoMatrix(m::Generic.Mat{NfOrdElem}, c::Vector{NfOrdIdl})\nPseudoMatrix(m::Generic.Mat{nf_elem})","category":"page"},{"location":"Hecke/pmat/introduction/#PseudoMatrix-Tuple{MatElem{nf_elem}, Vector{NfOrdIdl}}","page":"Introduction","title":"PseudoMatrix","text":"PseudoMatrix(m::Generic.Mat{nf_elem}, c::Vector{NfOrdIdl}) -> PMat{nf_elem, NfOrdFracIdl}\n\nReturns the (row) pseudo matrix representing the Z_k-module  sum c_i m_i  where c_i are the ideals in c and m_i the rows of M.\n\n\n\n","category":"method"},{"location":"Hecke/pmat/introduction/#PseudoMatrix-Tuple{AbstractAlgebra.Generic.Mat{NfOrdElem}, Vector{NfOrdIdl}}","page":"Introduction","title":"PseudoMatrix","text":"PseudoMatrix(m::Generic.Mat{NfOrdElem}, c::Vector{NfOrdIdl}) -> PMat{nf_elem, NfOrdFracIdl}\n\nReturns the (row) pseudo matrix representing the Z_k-module  sum c_i m_i  where c_i are the ideals in c and m_i the rows of M.\n\n\n\n","category":"method"},{"location":"Hecke/pmat/introduction/#PseudoMatrix-Tuple{AbstractAlgebra.Generic.Mat{nf_elem}}","page":"Introduction","title":"PseudoMatrix","text":"PseudoMatrix(m::Generic.Mat{NfOrdElem}) -> PMat{nf_elem, NfOrdFracIdl}\n\nReturns the free (row) pseudo matrix representing the Z_k-module  sum Z_k m_i  where m_i are the rows of M.\n\n\n\n","category":"method"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"(Those functions are also available as pseudo_matrix)","category":"page"},{"location":"Hecke/pmat/introduction/#Operations","page":"Introduction","title":"Operations","text":"","category":"section"},{"location":"Hecke/pmat/introduction/","page":"Introduction","title":"Introduction","text":"coefficient_ideals(M::PMat)\nmatrix(M::PMat)\nbase_ring(M::PMat)\npseudo_hnf(P::PMat{nf_elem, NfOrdFracIdl})\npseudo_hnf_with_transform(P::PMat{nf_elem, NfOrdFracIdl})","category":"page"},{"location":"Hecke/pmat/introduction/#coefficient_ideals-Tuple{Hecke.PMat}","page":"Introduction","title":"coefficient_ideals","text":"coefficient_ideals(M::PMat)\n\nReturns the vector of coefficient ideals.\n\n\n\n","category":"method"},{"location":"Hecke/pmat/introduction/#matrix-Tuple{Hecke.PMat}","page":"Introduction","title":"matrix","text":"matrix(M::PMat)\n\nReturns the matrix part of the PMat.\n\n\n\n","category":"method"},{"location":"Hecke/pmat/introduction/#base_ring-Tuple{Hecke.PMat}","page":"Introduction","title":"base_ring","text":"base_ring(M::PMat)\n\nThe PMat M defines an R-module for some maximal order R. This function returns the R that was used to defined M.\n\n\n\nbase_ring(I::MPolyIdeal)\n\nReturn the ambient ring of I.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R, [x, y])^2\nideal(x^2, x*y, y^2)\n\njulia> base_ring(I)\nMultivariate Polynomial Ring in x, y over Rational Field\n\n\n\n","category":"method"},{"location":"Hecke/pmat/introduction/#pseudo_hnf-Tuple{Hecke.PMat{nf_elem, Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}}","page":"Introduction","title":"pseudo_hnf","text":"pseudo_hnf(P::PMat)\n\nTransforms P into pseudo-Hermite form as defined by Cohen. Essentially the matrix part of P will be upper triangular with some technical normalisation for the off-diagonal elements. This operation preserves the module.\n\nA optional second argument can be specified as a symbols, indicating the desired shape of the echelon form. Possible are :upperright (the default) and :lowerleft\n\n\n\n","category":"method"},{"location":"Hecke/pmat/introduction/#pseudo_hnf_with_transform-Tuple{Hecke.PMat{nf_elem, Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}}","page":"Introduction","title":"pseudo_hnf_with_transform","text":"pseudo_hnf_with_transform(P::PMat)\n\nTransforms P into pseudo-Hermite form as defined by Cohen. Essentially the matrix part of P will be upper triangular with some technical normalisation for the off-diagonal elements. This operation preserves the module. The used transformation is returned as a second return value.\n\nA optional second argument can be specified as a symbols, indicating the desired shape of the echelon form. Possible are :upperright (the default) and :lowerleft\n\n\n\n","category":"method"},{"location":"Hecke/pmat/introduction/#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"Nemo/constructors/#Constructing-mathematical-objects-in-Nemo","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"","category":"section"},{"location":"Nemo/constructors/#Constructing-objects-in-Julia","page":"Constructing mathematical objects in Nemo","title":"Constructing objects in Julia","text":"","category":"section"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"In Julia, one constructs objects of a given type by calling a type constructor. This is simply a function with the same name as the type itself. For example, to construct a BigInt object in Julia, we simply call the BigInt constructor:","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"n = BigInt(\"1234567898765434567898765434567876543456787654567890\")","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Julia also uses constructors to convert between types. For example, to convert an Int to a BigInt:","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"m = BigInt(123)","category":"page"},{"location":"Nemo/constructors/#How-we-construct-objects-in-Nemo","page":"Constructing mathematical objects in Nemo","title":"How we construct objects in Nemo","text":"","category":"section"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Julia types don't contain enough information to properly model groups, rings and fields, especially if they are parameterised by values. For example, the ring of integers modulo n for a multiprecision modulus n cannot be modeled using types alone.","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Instead of using types to construct objects in Nemo, we use special objects that we refer to as parent objects. They behave a lot like Julia types.","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Consider the following simple example, to create a Flint multiprecision integer:","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"n = ZZ(\"12345678765456787654567890987654567898765678909876567890\")","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Here ZZ is not a Julia type, but a callable object. However, for most purposes one can think of such a parent object ZZ as though it were a type.","category":"page"},{"location":"Nemo/constructors/#Constructing-parent-objects","page":"Constructing mathematical objects in Nemo","title":"Constructing parent objects","text":"","category":"section"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"For more complicated groups, rings, fields, etc., one first needs to construct the parent object before one can use it to construct element objects.","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Nemo provides a set of functions for constructing such parent objects. For example, to create a parent object for polynomials over the integers, we use the PolynomialRing parent object constructor.","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"R, x = PolynomialRing(ZZ, \"x\")\nf = x^3 + 3x + 1\ng = R(12)","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"In this example, R is the parent object and we use it to convert the Int value 12 to an element of the polynomial ring mathbbZx.","category":"page"},{"location":"Nemo/constructors/#List-of-parent-object-constructors","page":"Constructing mathematical objects in Nemo","title":"List of parent object constructors","text":"","category":"section"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"For convenience, we provide a list of all the parent object constructors in Nemo and explain what domains they represent.","category":"page"},{"location":"Nemo/constructors/","page":"Constructing mathematical objects in Nemo","title":"Constructing mathematical objects in Nemo","text":"Mathematics Nemo constructor\nR = mathbbZ R = ZZ\nR = mathbbQ R = QQ\nR = mathbbF_p^n R, a = FiniteField(p, n, \"a\")\nR = mathbbZnmathbbZ R = ResidueRing(ZZ, n)\nS = Rx S, x = PolynomialRing(R, \"x\")\nS = Rx y S, (x, y) = PolynomialRing(R, [\"x\", \"y\"])\nS = Rx (to precision n) S, x = PowerSeriesRing(R, n, \"x\")\nS = R((x)) (to precision n) S, x = LaurentSeriesRing(R, n, \"x\")\nS = mathrmFrac_R S = FractionField(R)\nS = R(f) S = ResidueRing(R, f)\nS = mathrmMat_mtimes n(R) S = MatrixSpace(R, m, n)\nS = mathbbQx(f) S, a = NumberField(f, \"a\")\nS = mathbbQ_p (to precision N) S = PadicField(p, n)\nS = mathbbR (to precision n) S = RealField(n)\nS = mathbbC (to precision n) S = ComplexField(n)","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"Pages = [\"polyhedral_complexes.md\"]","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/#Polyhedral-Complexes","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"","category":"section"},{"location":"PolyhedralGeometry/polyhedral_complexes/#Introduction","page":"Polyhedral Complexes","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers and other fields are not yet supported everywhere in the implementation.","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"A nonempty finite collection mathcalP of polyhedra in mathbbF^n, for n fixed, is a polyhedral complex if","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"the set mathcalF is closed with respect to taking faces and\nif CDinmathcalF then Ccap D is a face of both C and D.","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/#Construction","page":"Polyhedral Complexes","title":"Construction","text":"","category":"section"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"To construct a polyhedral complex, you must pass points of each polyhedron in the polyhedral complex, such that the polyhedron is the convex hull thereof, along with an IncidenceMatrix encoding which points generate which polyhedron.","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"PolyhedralComplex","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/#PolyhedralComplex","page":"Polyhedral Complexes","title":"PolyhedralComplex","text":"PolyhedralComplex{T}(polyhedra, vr, far_vertices, L) where T<:scalar_types\n\nArguments\n\npolyhedra::IncidenceMatrix: An incidence matrix; there is a 1 at position (i,j) if the ith polytope contains point j and 0 otherwise.\nvr::Matrix: The points whose convex hulls make up the polyhedral complex. This matrix also contains the far vertices.\nfar_vertices::Vector{Int}: Vector containing the indices of the rows corresponding to the far vertices in vr.\nL::Matrix: Generators of the lineality space of the polyhedral complex.\n\nA polyhedral complex formed from points, rays, and lineality combined into polyhedra indicated by an incidence matrix, where the columns represent the points and the rows represent the polyhedra.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2,3],[1,3,4]])\n2×4 IncidenceMatrix\n[1, 2, 3]\n[1, 3, 4]\n\n\njulia> vr = [0 0; 1 0; 1 1; 0 1]\n4×2 Matrix{Int64}:\n 0  0\n 1  0\n 1  1\n 0  1\n\njulia> PC = PolyhedralComplex(IM, vr)\nA polyhedral complex in ambient dimension 2\n\n\n\n","category":"type"},{"location":"PolyhedralGeometry/polyhedral_complexes/#Auxiliary-functions","page":"Polyhedral Complexes","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/polyhedral_complexes/","page":"Polyhedral Complexes","title":"Polyhedral Complexes","text":"ambient_dim(PC::PolyhedralComplex)\ncodim(PC::PolyhedralComplex)\ndim(PC::PolyhedralComplex)\nf_vector(PC::PolyhedralComplex)\nisembedded(PC::PolyhedralComplex)\nmaximal_polyhedra(PC::PolyhedralComplex{T}) where T<:scalar_types\nn_maximal_polyhedra(PC::PolyhedralComplex)\nnpolyhedra(PC::PolyhedralComplex)\nnrays(PC::PolyhedralComplex)\nnvertices(PC::PolyhedralComplex)\npolyhedra_of_dim\nrays(PC::PolyhedralComplex)\nvertices(PC::PolyhedralComplex)","category":"page"},{"location":"PolyhedralGeometry/polyhedral_complexes/#ambient_dim-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"ambient_dim","text":"ambient_dim(PC::PolyhedralComplex)\n\nReturn the ambient dimension of PC.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2,3],[1,3,4]])\n2×4 IncidenceMatrix\n[1, 2, 3]\n[1, 3, 4]\n\n\njulia> V = [0 0; 1 0; 1 1; 0 1]\n4×2 Matrix{Int64}:\n 0  0\n 1  0\n 1  1\n 0  1\n\njulia> PC = PolyhedralComplex(IM, V)\nA polyhedral complex in ambient dimension 2\n\njulia> ambient_dim(PC)\n2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#codim-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"codim","text":"codim(PC::PolyhedralComplex)\n\nCompute the codimension of a polyhedral complex.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = PolyhedralComplex(IM, VR, far_vertices)\nA polyhedral complex in ambient dimension 2\n\njulia> codim(PC)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#dim-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"dim","text":"dim(PC::PolyhedralComplex)\n\nCompute the dimension of the polyhedral complex.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0; 1 0; 1 1; 0 1];\n\njulia> PC = PolyhedralComplex(IM, VR)\nA polyhedral complex in ambient dimension 2\n\njulia> dim(PC)\n2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#f_vector-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"f_vector","text":"f_vector(PC::PolyhedralComplex)\n\nCompute the vector (f₀f₁f₂f_dim(PC))` where f_i is the number of faces of PC of dimension i.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = IncidenceMatrix([[1,2,4],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = PolyhedralComplex(IM, VR, far_vertices);\n\njulia> f_vector(PC)\n3-element Vector{Int64}:\n 1\n 3\n 2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#isembedded-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"isembedded","text":"isembedded(PC::PolyhedralComplex)\n\nReturn true if PC is embedded, i.e. if its vertices can be computed as a subset of some mathbbR^n.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4]]);\n\njulia> PC = PolyhedralComplex(IM, VR)\nA polyhedral complex in ambient dimension 2\n\njulia> isembedded(PC)\ntrue\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#maximal_polyhedra-Union{Tuple{PolyhedralComplex{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Polyhedral Complexes","title":"maximal_polyhedra","text":"maximal_polyhedra(PC::PolyhedralComplex)\n\nReturn the maximal polyhedra of PC\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2,3],[1,3,4]])\n2×4 IncidenceMatrix\n[1, 2, 3]\n[1, 3, 4]\n\n\njulia> VR = [0 0; 1 0; 1 1; 0 1]\n4×2 Matrix{Int64}:\n 0  0\n 1  0\n 1  1\n 0  1\n\njulia> PC = PolyhedralComplex(IM, VR, [2])\nA polyhedral complex in ambient dimension 2\n\njulia> maximal_polyhedra(PC)\n2-element SubObjectIterator{Polyhedron{fmpq}}:\n A polyhedron in ambient dimension 2\n A polyhedron in ambient dimension 2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#n_maximal_polyhedra-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"n_maximal_polyhedra","text":"n_maximal_polyhedra(PC::PolyhedralComplex)\n\nReturn the number of maximal polyhedra of PC\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2,3],[1,3,4]])\n2×4 IncidenceMatrix\n[1, 2, 3]\n[1, 3, 4]\n\n\njulia> VR = [0 0; 1 0; 1 1; 0 1]\n4×2 Matrix{Int64}:\n 0  0\n 1  0\n 1  1\n 0  1\n\njulia> PC = PolyhedralComplex(IM, VR, [2])\nA polyhedral complex in ambient dimension 2\n\njulia> n_maximal_polyhedra(PC)\n2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#npolyhedra-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"npolyhedra","text":"npolyhedra(PC::PolyhedralComplex)\n\nReturn the total number of polyhedra in the polyhedral complex PC.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = IncidenceMatrix([[1,2,4],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = PolyhedralComplex(IM, VR, far_vertices);\n\njulia> npolyhedra(PC)\n6\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#nrays-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"nrays","text":"nrays(PC::PolyhedralComplex)\n\nReturn the number of rays of PC.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = IncidenceMatrix([[1,2,4],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = PolyhedralComplex(IM, VR, far_vertices);\n\njulia> nrays(PC)\n3\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#nvertices-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"nvertices","text":"nvertices(PC::PolyhedralComplex)\n\nReturn the number of vertices of PC.\n\nExamples\n\njulia> VR = [0 0; 1 0; -1 0; 0 1];\n\njulia> IM = IncidenceMatrix([[1,2,4],[1,3,4]]);\n\njulia> far_vertices = [2,3,4];\n\njulia> PC = PolyhedralComplex(IM, VR, far_vertices);\n\njulia> nvertices(PC)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#polyhedra_of_dim","page":"Polyhedral Complexes","title":"polyhedra_of_dim","text":"polyhedra_of_dim(PC::PolyhedralComplex, polyhedron_dim::Int)\n\nReturn the polyhedra of a given dimension in the polyhedral complex PC.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0; 1 0; 1 1; 0 1];\n\njulia> PC = PolyhedralComplex(IM, VR);\n\njulia> P1s = polyhedra_of_dim(PC,1)\n5-element SubObjectIterator{Polyhedron{fmpq}}:\n A polyhedron in ambient dimension 2\n A polyhedron in ambient dimension 2\n A polyhedron in ambient dimension 2\n A polyhedron in ambient dimension 2\n A polyhedron in ambient dimension 2\n\njulia> for p in P1s\n       println(dim(p))\n       end\n1\n1\n1\n1\n1\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/polyhedral_complexes/#rays-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"rays","text":"rays(PC::PolyhedralComplex)\n\nReturn the rays of PC\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2,3],[1,3,4]]);\n\njulia> VR = [0 0; 1 0; 1 1; 0 1];\n\njulia> PC = PolyhedralComplex(IM, VR, [2])\nA polyhedral complex in ambient dimension 2\n\njulia> rays(PC);\n\njulia> rays(PC)\n1-element SubObjectIterator{RayVector{fmpq}}:\n [1, 0]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/polyhedral_complexes/#vertices-Tuple{PolyhedralComplex}","page":"Polyhedral Complexes","title":"vertices","text":"vertices(as, P)\n\nReturn an iterator over the vertices of P in the format defined by as.\n\nOptional arguments for as include\n\nPointVector.\n\nExamples\n\nThe following code computes the vertices of the Minkowski sum of a triangle and a square:\n\njulia> P = simplex(2) + cube(2);\n\njulia> vertices(PointVector, P)\n5-element SubObjectIterator{PointVector{fmpq}}:\n [-1, -1]\n [2, -1]\n [2, 1]\n [-1, 2]\n [1, 2]\n\n\n\nvertices(T::TropicalVariety{M, EMB})\nvertices(T::TropicalCurve{M, EMB})\nvertices(T::TropicalHypersurface{M, EMB})\nvertices(T::TropicalLinearSpace{M, EMB})\n\nReturn the vertices of T, which are points in euclidean space if T is embedded or elements in an ordered set otherwise.\n\nExamples\n\nThe vertices of a plane tropical line, plane tropical honeycomb quadric, and plane tropical honeycomb cubic\n\njulia> RR = TropicalSemiring(min);\n\njulia> S,(x,y) = RR[\"x\",\"y\"];\n\njulia> f1 = x+y+1;\n\njulia> tropicalLine = TropicalHypersurface(f1);\n\njulia> vertices(tropicalLine)\n1-element SubObjectIterator{PointVector{fmpq}}:\n [1, 1]\n\njulia> f2 = 1*x^2+x*y+1*y^2+x+y+1;\n\njulia> tropicalQuadric = TropicalHypersurface(f1);\n\njulia> vertices(tropicalQuadric)\n1-element SubObjectIterator{PointVector{fmpq}}:\n [1, 1]\n\njulia> f3 = x^3+x*y^2+x^2*y+y^3+x^2+x*y+y^2+x+y+1;\n\njulia> tropicalCubic = TropicalHypersurface(f3);\n\njulia> vertices(tropicalCubic)\n2-element SubObjectIterator{PointVector{fmpq}}:\n [0, 0]\n [1, 1]\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"using Oscar","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"Pages = [\"affine_algebras.md\"]","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Affine-Algebras","page":"Affine Algebras","title":"Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"With regard to notation, we use affine algebra as a synonym for quotient ring of a multivariate polynomial ring modulo an ideal. More specifically, if R is a multivariate polynomial ring with coefficient ring C, and A=RI is the quotient ring of R modulo an ideal I of R, we refer to A as an affine algebra over C, or an affine C-algebra. In this section, we discuss functionality for handling such algebras in OSCAR.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"note: Note\nAs for the entire chapter on commutative algebra, most of the functions discussed here rely on Gröbner basis techniques. They are implemented for affine algebras over fields (exact fields supported by OSCAR) and, if not indicated otherwise, for affine algebras over the integers.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"note: Note\nIn Oscar, elements of quotient rings are not necessarily reduced with regard to the modulus of the quotient ring. Operations involving Gröbner basis computations may lead to partial reductions. Full reductions, depending on the choice of a monomial ordering, are achieved by explicitly computing normal forms. The functions simplify and simplify! discussed in this section implements this.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"note: Note\nIf A=RI is an affine algebra such that R is (multi)graded by a finitely generated  Abelian group G, and such that I is homogeneous with respect to this grading, then the grading descends to a G-grading on A. Our notation and OSCAR functionality for dealing with such gradings carry over from the case of multivariate polynomial rings to the case of affine algebras, wherever this is appropriate. First examples are the functions ìs_graded, ìs_standard_graded,  ìs_z_graded, ìs_zm_graded, and ìs_positively_graded. Further examples will be discussed in what follows.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Types","page":"Affine Algebras","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"The OSCAR type for quotient rings of  multivariate polynomial rings is of parametrized form MPolyQuo{T}, with elements of type MPolyQuoElem{T}. Here, T is the element type of the polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Constructors","page":"Affine Algebras","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"quo(R::MPolyRing, I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#quo-Tuple{MPolyRing, MPolyIdeal}","page":"Affine Algebras","title":"quo","text":"quo(R::MPolyRing, I::MPolyIdeal) -> MPolyQuoRing, Map\n\nCreate the quotient ring RI and return the new ring as well as the projection map Rrightarrow RI.\n\nquo(R::MPolyRing, V::Vector{MPolyElem}) -> MPolyQuoRing, Map\n\nAs above, where Isubset R is the ideal generated by the polynomials in V.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\n\njulia> A, _ = quo(R, ideal(R, [x^2-y^3, x-y]))\n(Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal(x^2 - y^3, x - y), Map from\nMultivariate Polynomial Ring in x, y over Rational Field to Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal(x^2 - y^3, x - y) defined by a julia-function with inverse)\n\njulia> typeof(A)\nMPolyQuo{fmpq_mpoly}\n\njulia> typeof(x)\nfmpq_mpoly\n\njulia> A, p = quo(R, ideal(R, [x^2-y^3, x-y]));\n\njulia> p\nMap from\nMultivariate Polynomial Ring in x, y over Rational Field to Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal(x^2 - y^3, x - y) defined by a julia-function with inverse\n\njulia> p(x)\nx\n\njulia> typeof(p(x))\nMPolyQuoElem{fmpq_mpoly}\n\njulia> S, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> B, _ = quo(S, ideal(S, [x^2*z-y^3, x-y]))\n(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1] by ideal(x^2*z - y^3, x - y), Map from\nMultivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1] to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1] by ideal(x^2*z - y^3, x - y) defined by a julia-function with inverse)\n\njulia> typeof(B)\nMPolyQuo{MPolyElem_dec{fmpq, fmpq_mpoly}}\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Data-Associated-to-Affine-Algebras","page":"Affine Algebras","title":"Data Associated to Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Basic-Data","page":"Affine Algebras","title":"Basic Data","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"If A=R/I is the quotient ring of a multivariate polynomial ring R modulo an ideal I of R, then","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"base_ring(A) refers to R,\nmodulus(A) to I,\ngens(A) to the generators of A,\nngens(A) to the number of these generators, and\ngen(A, i) as well as A[i] to the i-th such generator.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Examples","page":"Affine Algebras","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\nA, _ = quo(R, ideal(R, [y-x^2, z-x^3]))\nbase_ring(A)\nmodulus(A)\ngens(A)\nngens(A)\ngen(A, 2)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"grading_group(q::MPolyQuo{<:MPolyElem_dec})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#grading_group-Tuple{MPolyQuo{var\"#s271\"} where var\"#s271\"<:MPolyElem_dec}","page":"Affine Algebras","title":"grading_group","text":"grading_group(A::MPolyQuo{<:MPolyElem_dec})\n\nIf A is, say, G-graded, return G.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> A, _ = quo(R, ideal(R, [x^2*z-y^3, x-y]));\n\njulia> grading_group(A)\nGrpAb: Z\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Dimension","page":"Affine Algebras","title":"Dimension","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"dim(A::MPolyQuo)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#dim-Tuple{MPolyQuo}","page":"Affine Algebras","title":"dim","text":"dim(A::MPolyQuo)\n\nReturn the Krull dimension of A.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> A, _ = quo(R, ideal(R, [y-x^2, z-x^3]))\n(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x^2 + y, -x^3 + z), Map from\nMultivariate Polynomial Ring in x, y, z over Rational Field to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x^2 + y, -x^3 + z) defined by a julia-function with inverse)\n\njulia> dim(A)\n1\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Elements-of-Affine-Algebras","page":"Affine Algebras","title":"Elements of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Types-2","page":"Affine Algebras","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"The OSCAR type for elements of quotient rings of  multivariate polynomial rings is of parametrized form MPolyQuo{T}, where T is the element type of the polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Creating-Elements-of-Affine-Algebras","page":"Affine Algebras","title":"Creating Elements of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"Elements of an affine algebra RI are created as images of elements of R under the projection map.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-2","page":"Affine Algebras","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\nA, p = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]))\nf = p(x^3*y^2-y^3*x^2+x*y)\ntypeof(f)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Reducing-Elements-of-Affine-Algebras","page":"Affine Algebras","title":"Reducing Elements of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"simplify(f::MPolyQuoElem)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#simplify-Tuple{MPolyQuoElem}","page":"Affine Algebras","title":"simplify","text":"simplify(f::MPolyQuoElem)\n\nReduce f with regard to the modulus of the quotient ring.\n\nsimplify!(f::MPolyQuoElem)\n\nReduce f with regard to the modulus of the quotient ring, and replace f by the reduction.\n\nExamples\n\njulia> R, (x,) = PolynomialRing(QQ, [\"x\"]);\n\njulia> A, p = quo(R, ideal(R, [x^4]));\n\njulia> f = p(x-x^6)\n-x^6 + x\n\njulia> simplify(f)\nx\n\njulia> f\n-x^6 + x\n\njulia> simplify!(f)\nx\n\njulia> f\nx\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Tests-on-Elements-of-Affine-Algebras","page":"Affine Algebras","title":"Tests on Elements of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"==(f::MPolyQuoElem{T}, g::MPolyQuoElem{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#==-Union{Tuple{T}, Tuple{MPolyQuoElem{T}, MPolyQuoElem{T}}} where T","page":"Affine Algebras","title":"==","text":"==(f::MPolyQuoElem{T}, g::MPolyQuoElem{T}) where T\n\nReturn true if f is equal to g, false otherwise.\n\nExamples\n\njulia> R, (x,) = PolynomialRing(QQ, [\"x\"]);\n\njulia> A, p = quo(R, ideal(R, [x^4]));\n\njulia> f = p(x-x^6)\n-x^6 + x\n\njulia> g = p(x)\nx\n\njulia> f == g\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"ishomogeneous(f::MPolyQuoElem{<:MPolyElem_dec})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#ishomogeneous-Tuple{MPolyQuoElem{var\"#s271\"} where var\"#s271\"<:MPolyElem_dec}","page":"Affine Algebras","title":"ishomogeneous","text":"ishomogeneous(f::MPolyQuoElem{<:MPolyElem_dec})\n\nReturn true if f is homogeneous, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> A, p = quo(R, ideal(R, [y-x, z^3-x^3]));\n\njulia> f = p(y^2-x^2+z^4)\n-x^2 + y^2 + z^4\n\njulia> ishomogeneous(f)\ntrue\n\njulia> f\nz^4\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Data-associated-to-Elements-of-Affine-Algebras","page":"Affine Algebras","title":"Data associated to Elements of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"Given an element f of an affine algebra A, ","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"parent(f) refers to A.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"In the graded case,  we also have:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":" homogeneous_components(f::MPolyQuoElem{<:MPolyElem_dec})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#homogeneous_components-Tuple{MPolyQuoElem{var\"#s271\"} where var\"#s271\"<:MPolyElem_dec}","page":"Affine Algebras","title":"homogeneous_components","text":"homogeneous_components(f::MPolyQuoElem{<:MPolyElem_dec})\n\nReturn the homogeneous components of f.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> A, p = quo(R, ideal(R, [y-x, z^3-x^3]));\n\njulia> f = p(y^2-x^2+x*y*z+z^4)\n-x^2 + x*y*z + y^2 + z^4\n\njulia> homogeneous_components(f)\nDict{GrpAbFinGenElem, MPolyQuoElem{MPolyElem_dec{fmpq, fmpq_mpoly}}} with 2 entries:\n  [4] => z^4\n  [3] => y^2*z\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"homogeneous_component(f::MPolyQuoElem{<:MPolyElem_dec}, g::GrpAbFinGenElem)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#homogeneous_component-Tuple{MPolyQuoElem{var\"#s271\"} where var\"#s271\"<:MPolyElem_dec, GrpAbFinGenElem}","page":"Affine Algebras","title":"homogeneous_component","text":"homogeneous_component(f::MPolyQuoElem{<:MPolyElem_dec}, g::GrpAbFinGenElem)\n\nGiven an element f of an affine algebra which is graded by a finitely generated Abelian group, and given an element g of that group, return the homogeneous component of f of degree g.\n\nhomogeneous_component(f::MPolyQuoElem{<:MPolyElem_dec}, g::Vector{<:IntegerUnion})\n\nGiven an element f of a mathbb  Z^m-graded affine algebra, and given a vector g of m integers, convert g into an element of the group  mathbb  Z^m, and return the homogeneous component of f whose degree  is that element.\n\nhomogeneous_component(f::MPolyQuoElem{<:MPolyElem_dec}, g::IntegerUnion)\n\nGiven an element f of a mathbb  Z-graded affine algebra, and given an integer g, convert g into an element of the group mathbb  Z,  and return the homogeneous component of f whose degree is that element.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> A, p = quo(R, ideal(R, [y-x, z^3-x^3]));\n\njulia> f = p(y^2-x^2+x*y*z+z^4)\n-x^2 + x*y*z + y^2 + z^4\n\njulia> homogeneous_component(f, 4)\nz^4\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"degree(f::MPolyQuoElem{<:MPolyElem_dec})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#degree-Tuple{MPolyQuoElem{var\"#s271\"} where var\"#s271\"<:MPolyElem_dec}","page":"Affine Algebras","title":"degree","text":"degree(f::MPolyQuoElem{<:MPolyElem_dec})\n\nGiven a homogeneous element f of a graded affine algebra, return the degree of f.\n\ndegree(::Type{Vector{Int}}, f::MPolyQuoElem{<:MPolyElem_dec})\n\nGiven a homogeneous element f of a mathbb Z^m-graded affine algebra, return the degree of f, converted to a vector of integer numbers.\n\ndegree(::Type{Int}, f::MPolyQuoElem{<:MPolyElem_dec})\n\nGiven a homogeneous element f of a mathbb Z-graded affine algebra, return the degree of f, converted to an integer number.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"] );\n\njulia> A, p = quo(R, ideal(R, [y-x, z^3-x^3]))\n(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1] by ideal(-x + y, -x^3 + z^3), Map from\nMultivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1] to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1] by ideal(-x + y, -x^3 + z^3) defined by a julia-function with inverse)\n\njulia> f = p(y^2-x^2+z^4)\n-x^2 + y^2 + z^4\n\njulia> degree(f)\ngraded by [4]\n\njulia> typeof(degree(f))\nGrpAbFinGenElem\n\njulia> degree(Int, f)\n4\n\njulia> typeof(degree(Int, f))\nInt64\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Ideals-in-Affine-Algebras","page":"Affine Algebras","title":"Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Constructors-2","page":"Affine Algebras","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"ideal(Q::MPolyQuo{T}, V::Vector{T}) where T <: MPolyElem","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#ideal-Union{Tuple{T}, Tuple{MPolyQuo{T}, Vector{T}}} where T<:MPolyElem","page":"Affine Algebras","title":"ideal","text":"ideal(A::MPolyQuo{T}, V::Vector{T}) where T <: MPolyElem\n\nGiven a (graded) quotient ring A=R/I and a vector V of (homogeneous) polynomials in R,  create the ideal of A which is generated by the images of the entries of V.\n\nideal(A::MPolyQuo{T}, V::Vector{MPolyQuoElem{T}}) where T <: MPolyElem\n\nGiven a (graded) quotient ring A and a vector V of (homogeneous) elements of A,  create the ideal of A which is generated by the entries of V.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\n\njulia> A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));\n\njulia> I = ideal(A, [x^2-y])\nideal(x^2 - y)\n\njulia> S, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> B, _ = quo(S, ideal(S, [x^2*z-y^3, x-y]));\n\njulia> J = ideal(B, [x^2-y^2])\nideal(x^2 - y^2)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Reducing-Ideals-in-Affine-Algebras","page":"Affine Algebras","title":"Reducing Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"simplify(a::MPolyQuoIdeal)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#simplify-Tuple{MPolyQuoIdeal}","page":"Affine Algebras","title":"simplify","text":"simplify(a::MPolyQuoIdeal)\n\nReduce a with regard to the modulus of the quotient ring.\n\nsimplify!(a::MPolyQuoIdeal)\n\nReduce a with regard to the modulus of the quotient ring, and replace a by the reduction.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\n\njulia> A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));\n\njulia> a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])\nideal(x^3*y^4 - x + y, x*y^2 + x*y)\n\njulia> simplify(a)\nideal(x^2*y^3 - x + y, x*y^2 + x*y)\n\njulia> a\nideal(x^3*y^4 - x + y, x*y^2 + x*y)\n\njulia> simplify!(a);\n\njulia> a\nideal(x^2*y^3 - x + y, x*y^2 + x*y)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Data-Associated-to-Ideals-in-Affine-Algebras","page":"Affine Algebras","title":"Data Associated to Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Basic-Data-2","page":"Affine Algebras","title":"Basic Data","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"If a is an ideal of the affine algebra A, then","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"base_ring(a) refers to A,\ngens(a) to the generators of a,\nngens(a) to the number of these generators,  and\ngen(a, i) as well as a[i] to the i-th such generator.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-3","page":"Affine Algebras","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\nA, _ = quo(R, ideal(R, [y-x^2, z-x^3]));\na = ideal(A, [x-y, z^4])\nbase_ring(a)\ngens(a)\nngens(a)\ngen(a, 2)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Dimension-of-Ideals-in-Affine-Algebras","page":"Affine Algebras","title":"Dimension of Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"dim(a::MPolyQuoIdeal)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#dim-Tuple{MPolyQuoIdeal}","page":"Affine Algebras","title":"dim","text":"dim(a::MPolyQuoIdeal)\n\nReturn the Krull dimension of a.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));\n\njulia> a = ideal(A, [x-y])\nideal(x - y)\n\njulia> dim(a)\n0\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Minimal-Sets-of-Generators","page":"Affine Algebras","title":"Minimal Sets of Generators","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"In the graded case, we have:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"minimal_generating_set(I::MPolyQuoIdeal{<:MPolyElem_dec})","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#minimal_generating_set-Tuple{MPolyQuoIdeal{var\"#s271\"} where var\"#s271\"<:MPolyElem_dec}","page":"Affine Algebras","title":"minimal_generating_set","text":"minimal_generating_set(I::MPolyQuoIdeal{<:MPolyElem_dec})\n\nGiven a homogeneous ideal I in a graded affine algebra over a field, return an array containing a minimal set of generators of I.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> V = [x, z^2, x^3+y^3, y^4, y*z^5];\n\njulia> I = ideal(R, V)\nideal(x, z^2, x^3 + y^3, y^4, y*z^5)\n\njulia> A, p = quo(R, ideal(R, [x-y]));\n\njulia> J = ideal(A, [p(x) for x in V]);\n\njulia> minimal_generating_set(J)\n2-element Vector{MPolyQuoElem{MPolyElem_dec{fmpq, fmpq_mpoly}}}:\n x\n z^2\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Operations-on-Ideals-in-Affine-Algebras","page":"Affine Algebras","title":"Operations on Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Simple-Ideal-Operations-in-Affine-Algebras","page":"Affine Algebras","title":"Simple Ideal Operations in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Powers-of-Ideal","page":"Affine Algebras","title":"Powers of Ideal","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":":^(a::MPolyQuoIdeal, m::Int)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#^-Tuple{MPolyQuoIdeal, Int64}","page":"Affine Algebras","title":"^","text":":^(a::MPolyQuoIdeal, m::Int)\n\nReturn the m-th power of a.  \n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Sum-of-Ideals","page":"Affine Algebras","title":"Sum of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":":+(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#+-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras","title":"+","text":":+(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn the sum of a and b.  \n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Product-of-Ideals","page":"Affine Algebras","title":"Product of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":":*(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#*-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras","title":"*","text":":*(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn the product of a and b.  \n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Intersection-of-Ideals","page":"Affine Algebras","title":"Intersection of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"intersect(a::MPolyQuoIdeal{T}, bs::MPolyQuoIdeal{T}...) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#intersect-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, Vararg{MPolyQuoIdeal{T}, N} where N}} where T","page":"Affine Algebras","title":"intersect","text":"intersect(a::MPolyQuoIdeal{T}, bs::MPolyQuoIdeal{T}...) where T\n\nReturn the intersection of two or more ideals.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\n\njulia> A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));\n\njulia> a = ideal(A, [y^2])\nideal(y^2)\n\njulia> b = ideal(A, [x])\nideal(x)\n\njulia> intersect(a,b)\nideal(x*y)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Ideal-Quotients","page":"Affine Algebras","title":"Ideal Quotients","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"quotient(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#quotient-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras","title":"quotient","text":"quotient(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn the ideal quotient of a by b. Alternatively, use a:b. \n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\n\njulia> A, _ = quo(R, ideal(R, [x^2-y^3, x-y]));\n\njulia> a = ideal(A, [y^2])\nideal(y^2)\n\njulia> b = ideal(A, [x])\nideal(x)\n\njulia> a:b\nideal(y)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Tests-on-Ideals-in-Affine-Algebras","page":"Affine Algebras","title":"Tests on Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Basic-Tests","page":"Affine Algebras","title":"Basic Tests","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"iszero(a::MPolyQuoIdeal)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#iszero-Tuple{MPolyQuoIdeal}","page":"Affine Algebras","title":"iszero","text":"iszero(a::MPolyQuoIdeal)\n\nReturn true if a is the zero ideal, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Equality-of-Ideals-in-Affine-Algebras","page":"Affine Algebras","title":"Equality of Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"==(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#==-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras","title":"==","text":"==(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn true if a is equal to b, false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\n\njulia> A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));\n\njulia> a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])\nideal(x^3*y^4 - x + y, x*y^2 + x*y)\n\njulia> b = ideal(A, [x^3*y^3-x+y, x^2*y+y^2*x])\nideal(x^3*y^3 - x + y, x^2*y + x*y^2)\n\njulia> a == b\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Containment-of-Ideals-in-Affine-Algebras","page":"Affine Algebras","title":"Containment of Ideals in Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"issubset(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#issubset-Union{Tuple{T}, Tuple{MPolyQuoIdeal{T}, MPolyQuoIdeal{T}}} where T","page":"Affine Algebras","title":"issubset","text":"issubset(a::MPolyQuoIdeal{T}, b::MPolyQuoIdeal{T}) where T\n\nReturn true if a is contained in b, false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\n\njulia> A, _ = quo(R, ideal(R, [x^3*y^2-y^3*x^2, x*y^4-x*y^2]));\n\njulia> a = ideal(A, [x^3*y^4-x+y, x*y+y^2*x])\nideal(x^3*y^4 - x + y, x*y^2 + x*y)\n\njulia> b = ideal(A, [x^3*y^3-x+y, x^2*y+y^2*x])\nideal(x^3*y^3 - x + y, x^2*y + x*y^2)\n\njulia> issubset(a,b)\nfalse\n\njulia> issubset(b,a)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Homomorphisms-From-Affine-Algebras","page":"Affine Algebras","title":"Homomorphisms From Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"If A=RI is an affine C-algebra, and S is any ring, then defining a ring homomorphism overlinephi A rightarrow S means to define a ring homomorphism phi R rightarrow S such that Isubset ker(phi). Thus, overlinephi  is determined by specifying its restriction to C, and by assigning an image to each generator of A. In OSCAR, such homomorphisms are created by using the following constructor:","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"hom(A::MPolyQuo, S::NCRing, coeff_map, images::Vector; check::Bool = true)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#hom-Tuple{MPolyQuo, AbstractAlgebra.NCRing, Any, Vector{T} where T}","page":"Affine Algebras","title":"hom","text":"hom(A::MPolyQuo, S::NCRing, coeff_map, images::Vector; check::Bool = true)\n\nhom(A::MPolyQuo, S::NCRing, images::Vector; check::Bool = true)\n\nGiven a homomorphism coeff_map from C to S, where C is the  coefficient ring of the base ring of A, and given a vector images of ngens(A)  elements of S, return the homomorphism A to S whose restriction  to C is coeff_map, and which sends the i-th generator of A to the  i-th entry of images.\n\nIf no coefficient map is entered, invoke a canonical homomorphism of C to S, if such a homomorphism exists, and throw an error, otherwise.\n\nnote: Note\nThe function returns a well-defined homomorphism A to S iff the given data defines a homomorphism from the base ring of A to S whose kernel contains the modulus of A. This condition is checked by the  function in case check = true (default).\n\nnote: Note\nIn case check = true (default), the function also checks the conditions below:If S is graded, the assigned images must be homogeneous with respect to the given grading.\nIf S is noncommutative, the assigned images must pairwise commute. \n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"] );\n\njulia> A, _ = quo(R, ideal(R, [y-x^2, z-x^3]));\n\njulia> S, (s, t) = PolynomialRing(QQ, [\"s\", \"t\"]);\n\njulia> F = hom(A, S, [s, s^2, s^3])\nMap with following data\nDomain:\n=======\nQuotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x^2 + y, -x^3 + z)\nCodomain:\n=========\nMultivariate Polynomial Ring in s, t over Rational Field\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"Given a ring homomorphism F from R to S as above, domain(F) and codomain(F) refer to R and S, respectively. Given ring homomorphisms F from R to S and G from S to T as above, compose(F, G) refers to their composition.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Homomorphisms-of-Affine-Algebras","page":"Affine Algebras","title":"Homomorphisms of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"The OSCAR homomorphism type AffAlgHom models ring homomorphisms R to S such that the type of both R and S  is a subtype of Union{MPolyRing{T}, MPolyQuo{U}}, where T <: FieldElem and U <: MPolyElem{T}. Functionality for these homomorphism is discussed in what follows.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Data-Associated-to-Homomorphisms-of-Affine-Algebras","page":"Affine Algebras","title":"Data Associated to Homomorphisms of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"preimage(F::AffAlgHom, I::MPolyIdeal)\nkernel(F::AffAlgHom)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#preimage-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T<:FieldElem, U<:MPolyElem{T}, DT<:Union{MPolyRing{T}, MPolyQuo{U}}, CT<:Union{MPolyRing{T}, MPolyQuo{U}}, V}, MPolyIdeal}","page":"Affine Algebras","title":"preimage","text":"preimage(F::AffAlgHom, I::U) where U <: Union{MPolyIdeal, MPolyQuoIdeal}\n\nReturn the preimage of the ideal I under F.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#kernel-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T<:FieldElem, U<:MPolyElem{T}, DT<:Union{MPolyRing{T}, MPolyQuo{U}}, CT<:Union{MPolyRing{T}, MPolyQuo{U}}, V}}","page":"Affine Algebras","title":"kernel","text":"kernel(F::AffAlgHom)\n\nReturn the kernel of F.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-4","page":"Affine Algebras","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"D1, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"]);\nC1, (s,t) = GradedPolynomialRing(QQ, [\"s\", \"t\"]);\nV1 = [s^3, s^2*t, s*t^2, t^3];\npara = hom(D1, C1, V1)\ntwistedCubic = kernel(para)\nC2, p2 = quo(D1, twistedCubic);\nD2, (a, b, c) = GradedPolynomialRing(QQ, [\"a\", \"b\", \"c\"]);\nV2 = [p2(w-y), p2(x), p2(z)];\nproj = hom(D2, C2, V2)\nnodalCubic = kernel(proj)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"D3,y = PolynomialRing(QQ, \"y\" => 1:3);\nC3, x = PolynomialRing(QQ, \"x\" => 1:3);\nV3 = [x[1]*x[2], x[1]*x[3], x[2]*x[3]];\nF3 = hom(D3, C3, V3)\nsphere = ideal(C3, [x[1]^3 + x[2]^3  + x[3]^3 - 1])\nsteinerRomanSurface = preimage(F3, sphere)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Tests-on-Homomorphisms-of-Affine-Algebras","page":"Affine Algebras","title":"Tests on Homomorphisms of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"isinjective(F::AffAlgHom)\nissurjective(F::AffAlgHom)\nisbijective(F::AffAlgHom)\nisfinite(F::AffAlgHom)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#isinjective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T<:FieldElem, U<:MPolyElem{T}, DT<:Union{MPolyRing{T}, MPolyQuo{U}}, CT<:Union{MPolyRing{T}, MPolyQuo{U}}, V}}","page":"Affine Algebras","title":"isinjective","text":"isinjective(F::AffAlgHom)\n\nReturn true if F is injective, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#issurjective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T<:FieldElem, U<:MPolyElem{T}, DT<:Union{MPolyRing{T}, MPolyQuo{U}}, CT<:Union{MPolyRing{T}, MPolyQuo{U}}, V}}","page":"Affine Algebras","title":"issurjective","text":"issurjective(F::AffAlgHom)\n\nReturn true if F is issurjective, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#isbijective-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T<:FieldElem, U<:MPolyElem{T}, DT<:Union{MPolyRing{T}, MPolyQuo{U}}, CT<:Union{MPolyRing{T}, MPolyQuo{U}}, V}}","page":"Affine Algebras","title":"isbijective","text":"isbijective(F::AffAlgHom)\n\nReturn true if F is bijective, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#isfinite-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T<:FieldElem, U<:MPolyElem{T}, DT<:Union{MPolyRing{T}, MPolyQuo{U}}, CT<:Union{MPolyRing{T}, MPolyQuo{U}}, V}}","page":"Affine Algebras","title":"isfinite","text":"isfinite(F::AffAlgHom)\n\nReturn true if F is finite, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-5","page":"Affine Algebras","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"D, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\nS, (a, b, c) = PolynomialRing(QQ, [\"a\", \"b\", \"c\"]);\nC, p = quo(S, ideal(S, [c-b^3]));\nV = [p(2*a + b^6), p(7*b - a^2), p(c^2)];\nF = hom(D, C, V)\nissurjective(F)\nD1, _ = quo(D, kernel(F));\nF1 = hom(D1, C, V);\nisbijective(F1)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"R, (x, y, z) = PolynomialRing(QQ, [ \"x\", \"y\", \"z\"]);\nC, (s, t) = PolynomialRing(QQ, [\"s\", \"t\"]);\nV = [s*t, t, s^2];\nparaWhitneyUmbrella = hom(R, C, V)\nD, _ = quo(R, kernel(paraWhitneyUmbrella));\nisfinite(hom(D, C, V))","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Inverting-Homomorphisms-of-Affine-Algebras","page":"Affine Algebras","title":"Inverting Homomorphisms of Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"inverse(F::AffAlgHom)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#inverse-Tuple{Oscar.MPolyAnyMap{DT, CT, Nothing, V} where {T<:FieldElem, U<:MPolyElem{T}, DT<:Union{MPolyRing{T}, MPolyQuo{U}}, CT<:Union{MPolyRing{T}, MPolyQuo{U}}, V}}","page":"Affine Algebras","title":"inverse","text":"inverse(F::AffAlgHom)\n\nIf F is bijective, return its inverse.\n\nExamples\n\njulia> D1, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> D, _ = quo(D1, [y-x^2, z-x^3])\n(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x^2 + y, -x^3 + z), Map from\nMultivariate Polynomial Ring in x, y, z over Rational Field to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x^2 + y, -x^3 + z) defined by a julia-function with inverse)\n\njulia> C, (t,) = PolynomialRing(QQ, [\"t\"]);\n\njulia> F = hom(D, C, [t, t^2, t^3]);\n\njulia> isbijective(F)\ntrue\n\njulia> G = inverse(F)\nMap with following data\nDomain:\n=======\nMultivariate Polynomial Ring in t over Rational Field\nCodomain:\n=========\nQuotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x^2 + y, -x^3 + z)\n\njulia> G(t)\nx\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"D1, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\nD, _ = quo(D1, [y-x^2, z-x^3])\nC, (t,) = PolynomialRing(QQ, [\"t\"]);\npara = hom(D, C, [t, t^2, t^3]);\nisbijective(para)\ninverse(para)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Subalgebras","page":"Affine Algebras","title":"Subalgebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Subalgebra-Membership","page":"Affine Algebras","title":"Subalgebra Membership","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"subalgebra_membership(f::T, V::Vector{T}) where T <: Union{MPolyElem, MPolyQuoElem}","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#subalgebra_membership-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:Union{MPolyElem, MPolyQuoElem}","page":"Affine Algebras","title":"subalgebra_membership","text":"subalgebra_membership(f::T, V::Vector{T}) where T <: Union{MPolyElem, MPolyQuoElem}\n\nGiven an element f of a graded multivariate polynomial ring over a field, or of a quotient ring of such a ring, and given a vector V of elements in the same ring, consider the subalgebra generated by the entries of V in that ring. If f is contained in the subalgebra, return (true, h), where h is giving the polynomial relation. Return, (false, 0), otherwise.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:3)\n(Multivariate Polynomial Ring in x[1], x[2], x[3] over Rational Field, fmpq_mpoly[x[1], x[2], x[3]])\n\njulia> f = x[1]^6*x[2]^6-x[1]^6*x[3]^6;\n\njulia> V = [x[1]^3*x[2]^3-x[1]^3*x[3]^3, x[1]^3*x[2]^3+x[1]^3*x[3]^3]\n2-element Vector{fmpq_mpoly}:\n x[1]^3*x[2]^3 - x[1]^3*x[3]^3\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3\n\njulia> subalgebra_membership(f, V)\n(true, t_1*t_2)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Minimal-Subalgebra-Generators","page":"Affine Algebras","title":"Minimal Subalgebra Generators","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"minimal_subalgebra_generators(V::Vector{T}) where T <: Union{MPolyElem, MPolyQuoElem}","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#minimal_subalgebra_generators-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{MPolyElem, MPolyQuoElem}","page":"Affine Algebras","title":"minimal_subalgebra_generators","text":"minimal_subalgebra_generators(V::Vector{T}) where T <: Union{MPolyElem, MPolyQuoElem}\n\nGiven a vector V of homogeneous elements of a positively graded multivariate  polynomial ring over a field, or of a quotient ring of such a ring, return a minimal subset of the elements in V which, in the given ring, generate the same subalgebra as all elements in V.\n\nnote: Note\nThe conditions on V and the given ring are automatically checked.\n\nExamples\n\njulia> R, (x, y) = GradedPolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field graded by \n  x -> [1]\n  y -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y])\n\njulia> V = [x, y, x^2+y^2]\n3-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n x\n y\n x^2 + y^2\n\njulia> minimal_subalgebra_generators(V)\n2-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n x\n y\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Noether-Normalization","page":"Affine Algebras","title":"Noether Normalization","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"noether_normalization(A::MPolyQuo)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#noether_normalization-Tuple{MPolyQuo}","page":"Affine Algebras","title":"noether_normalization","text":"noether_normalization(A::MPolyQuo)\n\nGiven an affine algebra A=RI over a field K, return a triple (VFG) such that: V is a vector of d=dim A elements of A, represented by linear forms l_iin R, and such that KVhookrightarrow A is a Noether normalization for A; F A=RI rightarrow B = Rphi(I)  is an isomorphism, induced by a linear change $ \\phi $ of coordinates of R which maps the l_i to the the last d variables of R; and G = F^-1.\n\nwarning: Warning\nThe algorithm may not terminate over a small finite field. If it terminates, the result is correct.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-6","page":"Affine Algebras","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\nA, _ = quo(R, ideal(R, [x*y, x*z]));\nL = noether_normalization(A);\nL[1]\nL[2]\nL[3]","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Normalization","page":"Affine Algebras","title":"Normalization","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"normalization(A::MPolyQuo)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#normalization-Tuple{MPolyQuo}","page":"Affine Algebras","title":"normalization","text":"normalization(A::MPolyQuo; alg = :equidimDec)\n\nFind the normalization of a reduced affine algebra over a perfect field K. That is, given the quotient A=RI of a multivariate polynomial ring R over K modulo a radical ideal I, compute the integral closure overlineA  of A in its total ring of fractions Q(A), together with the embedding  f A rightarrow overlineA. \n\nImplemented Algorithms and how to Read the Output\n\nThe function relies on the algorithm  of Greuel, Laplagne, and Seelisch which proceeds by finding a suitable decomposition  I=I_1capdotscap I_r into radical ideals I_k, together with maps A = RI rightarrow A_k=overlineRI_k which give rise to the normalization map of A:\n\nAhookrightarrow A_1times dotstimes A_r=overlineA\n\nFor each k, the function specifies two representations of A_k: It returns an array of triples (A_k f_k mathfrak a_k), where A_k is represented as an affine K-algebra, and f_k as a map of affine K-algebras. The third entry mathfrak a_k is a tuple (d_k J_k), consisting of an element d_kin A and an ideal J_ksubset A, such that frac1d_kJ_k = A_k  as A-submodules of the total ring of fractions of A.\n\nBy default (alg = :equidimDec), as a first step on its way to find the decomposition I=I_1capdotscap I_r,  the algorithm computes an equidimensional decomposition of the radical ideal I. Alternatively, if specified by alg = :primeDec, the algorithm computes I=I_1capdotscap I_r as the prime decomposition of the radical ideal I.\n\nSee Gert-Martin Greuel, Santiago Laplagne, Frank Seelisch (2010).\n\nwarning: Warning\nThe function does not check whether A is reduced. Use isreduced(A) in case you are unsure (this may take some time).\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\n\njulia> A, _ = quo(R, ideal(R, [(x^2-y^3)*(x^2+y^2)*x]));\n\njulia> L = normalization(A);\n\njulia> size(L)\n(2,)\n\njulia> LL = normalization(A, alg = :primeDec);\n\njulia> size(LL)\n(3,)\n\njulia> LL[1][1]\nQuotient of Multivariate Polynomial Ring in T(1), x, y over Rational Field by ideal(-T(1)*y + x, -T(1)*x + y^2, T(1)^2 - y, -x^2 + y^3)\n\njulia> LL[1][2]\nMap with following data\nDomain:\n=======\nQuotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal(x^5 - x^3*y^3 + x^3*y^2 - x*y^5)\nCodomain:\n=========\nQuotient of Multivariate Polynomial Ring in T(1), x, y over Rational Field by ideal(-T(1)*y + x, -T(1)*x + y^2, T(1)^2 - y, -x^2 + y^3)\n\njulia> LL[1][3]\n(y, ideal(x, y))\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"normalization_with_delta(A::MPolyQuo)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#normalization_with_delta-Tuple{MPolyQuo}","page":"Affine Algebras","title":"normalization_with_delta","text":"normalization_with_delta(A::MPolyQuo; alg = :equidimDec)\n\nCompute the normalization\n\nAhookrightarrow A_1times dotstimes A_r=overlineA\n\nof A as does normalize(A), but return additionally the delta invariant of A, that is, the dimension \n\ndim_K(overlineAA)\n\n. \n\nHow to Read the Output\n\nThe return value is a tuple whose first element is normalize(A), whose second element is an array containing the delta invariants of the A_k, and whose third element is the (total) delta invariant of A. The return value -1 in the third element indicates that the delta invariant is infinite.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]);\n\njulia> A, _ = quo(R, ideal(R, [(x^2-y^3)*(x^2+y^2)*x]));\n\njulia> L = normalization_with_delta(A);\n\njulia> L[2]\n3-element Vector{Int64}:\n 1\n 1\n 0\n\njulia> L[3]\n13\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> A, _ = quo(R, ideal(R, [z^3-x*y^4]))\n(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x*y^4 + z^3), Map from\nMultivariate Polynomial Ring in x, y, z over Rational Field to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x*y^4 + z^3) defined by a julia-function with inverse)\n\njulia> L = normalization_with_delta(A)\n(Tuple{MPolyQuo{fmpq_mpoly}, Oscar.MPolyAnyMap{MPolyQuo{fmpq_mpoly}, MPolyQuo{fmpq_mpoly}, Nothing, MPolyQuoElem{fmpq_mpoly}}, Tuple{MPolyQuoElem{fmpq_mpoly}, MPolyQuoIdeal{fmpq_mpoly}}}[(Quotient of Multivariate Polynomial Ring in T(1), T(2), x, y, z over Rational Field by ideal(T(1)*y - T(2)*z, T(2)*y - z, -T(1)*z + x*y^2, T(1)^2 - x*z, T(1)*T(2) - x*y, -T(1) + T(2)^2, x*y^4 - z^3), Map with following data\nDomain:\n=======\nQuotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x*y^4 + z^3)\nCodomain:\n=========\nQuotient of Multivariate Polynomial Ring in T(1), T(2), x, y, z over Rational Field by ideal(T(1)*y - T(2)*z, T(2)*y - z, -T(1)*z + x*y^2, T(1)^2 - x*z, T(1)*T(2) - x*y, -T(1) + T(2)^2, x*y^4 - z^3), (z^2, ideal(x*y^2*z, x*y^3, z^2)))], [-1], -1)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Integral-Bases","page":"Affine Algebras","title":"Integral Bases","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"integral_basis(f::MPolyElem, i::Int)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#integral_basis-Tuple{MPolyElem, Int64}","page":"Affine Algebras","title":"integral_basis","text":"integral_basis(f::MPolyElem, i::Int)\n\nGiven a polynomial f in two variables with rational coefficients and an integer iin12 specifying one of the variables, f must be irreducible and monic in the specified variable: Say, finmathbb Qxy is monic in y. Then the normalization of A = Qxylangle f rangle, that is, the integral closure overlineA of A in its quotient field, is a free module over Kx of finite rank, and any set of free generators for overlineA over Kx is called an integral basis for overlineA over Kx. Relying on the algorithm by Janko Böhm, Wolfram Decker, Santiago Laplagne, Gerhard Pfister (2019), the function returns a pair (d V), where d is an element of A, and V is a vector of elements in A, such that the fractions vd vin V, form an integral basis for overlineA over Kx. \n\nnote: Note\nThe conditions on f are automatically checked.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> f = (y^2-2)^2 + x^5\nx^5 + y^4 - 4*y^2 + 4\n\njulia> integral_basis(f, 2)\n(x^2, MPolyQuoElem{fmpq_mpoly}[x^2, x^2*y, y^2 - 2, y^3 - 2*y])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Tests-on-Affine-Algebras","page":"Affine Algebras","title":"Tests on Affine Algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Reducedness-Test","page":"Affine Algebras","title":"Reducedness Test","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"isreduced(Q::MPolyQuo)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#isreduced-Tuple{MPolyQuo}","page":"Affine Algebras","title":"isreduced","text":"isreduced(A::MPolyQuo)\n\nGiven an affine algebra A, return true if A is reduced, false otherwise.\n\nwarning: Warning\nThe function computes the radical of the modulus of A. This may take some time.\n\nExamples\n\njulia> R, (x,) = PolynomialRing(QQ, [\"x\"])\n(Multivariate Polynomial Ring in x over Rational Field, fmpq_mpoly[x])\n\njulia> A, _ = quo(R, ideal(R, [x^4]))\n(Quotient of Multivariate Polynomial Ring in x over Rational Field by ideal(x^4), Map from\nMultivariate Polynomial Ring in x over Rational Field to Quotient of Multivariate Polynomial Ring in x over Rational Field by ideal(x^4) defined by a julia-function with inverse)\n\njulia> isreduced(A)\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Normality-Test","page":"Affine Algebras","title":"Normality Test","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"isnormal(A::MPolyQuo)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#isnormal-Tuple{MPolyQuo}","page":"Affine Algebras","title":"isnormal","text":"isnormal(A::MPolyQuo)\n\nGiven an affine algebra A over a perfect field, return true if A is normal, false otherwise.\n\nnote: Note\nThis function performs the first step of the normalization algorithm of Greuel, Laplagne, and Seelisch Gert-Martin Greuel, Santiago Laplagne, Frank Seelisch (2010) and may, thus, be more efficient than computing the full normalization of A.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> A, _ = quo(R, ideal(R, [z^2-x*y]))\n(Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x*y + z^2), Map from\nMultivariate Polynomial Ring in x, y, z over Rational Field to Quotient of Multivariate Polynomial Ring in x, y, z over Rational Field by ideal(-x*y + z^2) defined by a julia-function with inverse)\n\njulia> isnormal(A)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Cohen-Macaulayness-Test","page":"Affine Algebras","title":"Cohen-Macaulayness Test","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"iscohenmacaulay(R)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#Examples-7","page":"Affine Algebras","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/#Hilbert-Series-and-Hilbert-Polynomial","page":"Affine Algebras","title":"Hilbert Series and Hilbert Polynomial","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"Given a multivariate polynomial ring R over a field K together with a (multi)grading on R by a finitely generated abelian group G, let I be an ideal of R which is homogeneous with respect to this grading. Then the affine K-algebra A=RI inherits the grading: A = bigoplus_gin G A_g. Suppose now that R is positively graded by G. That is, G is torsion-free and each graded piece R_g has finite dimension. Then also A_g is a finite dimensional K-vector space for each g, and we have the well-defined Hilbert function of A,","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"H(A underlinephantomd) G to N  gmapsto dim_K(A_g)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"The Hilbert series of A is the generating function ","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"H_A(mathbb t)=sum_gin G H(A g) mathbb t^g","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"(see  Section 8.2 in Ezra Miller, Bernd Sturmfels (2005) for a formal discussion extending the classical case of mathbb Z-gradings with positive weights to the more general case considered here). As in the classical case, the infinitely many values of the Hilbert function can be expressed in finite terms by representing the Hilbert series as a rational function (see Theorem 8.20 in Ezra Miller, Bernd Sturmfels (2005) for a precise statement).","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"By a result of Macaulay, if A = RI is an affine algebra, and L_(I) is the leading ideal of I with respect to a global monomial ordering , then the Hilbert function of A equals that of RL_(I) (see Theorem 15.26 in David Eisenbud (1995)). Thus, using Gröbner bases, the computation of Hilbert series can be reduced to the case where the modulus of an affine algebra is a monomial ideal. In the latter case, we face a problem  of combinatorial nature, and there are various strategies of how to proceed (see Martin Kreuzer, Lorenzo Robbiano (2005)). The functions hilbert_series, hilbert_series_reduced, hilbert_series_expanded, hilbert_function, hilbert_polynomial, and degree address the case of mathbb Z-gradings with positive weights, relying on corresponding Singular functionality. The functions multi_hilbert_series, multi_hilbert_series_reduced, and multi_hilbert_function use different strategies and allow one to handle positive gradings in full generality.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#\\mathbb-Z-Gradings-With-Positive-Weights","page":"Affine Algebras","title":"mathbb Z-Gradings With Positive Weights","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"Let R=Kx_1 dots x_n be a polynomial ring in n variables over a field K. Assign positive integer weights w_i to the variables x_i, and grade R=bigoplus_din mathbb Z R_d=bigoplus_dgeq 0 R_d according to the corresponding weighted degree. Let I be an ideal of R which is homogeneous with respect to this grading. Then the affine K-algebra A=RI inherits the grading: A = bigoplus_dgeq 0 A_d, where each graded piece A_d is a finite dimensional K-vector space. In this situation, the Hilbert function of A is of type","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"H(A underlinephantomd) N to N d mapsto dim_K(d)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"and the Hilbert series of A is the formal power series","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"H_A(t)=sum_dgeq 0 H(A d) t^dinmathbb Zt","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"The Hilbert series can be written as a rational function p(t)q(t), with denominator","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"q(t) = (1-t^w_1)cdots (1-t^w_n)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"In the standard mathbb Z-graded case, where the weights on the variables are all 1, the Hilbert function is of polynomial nature: There exists  a unique polynomial P_A(t)inmathbbQt, the Hilbert polynomial, which satisfies H(Md)=P_M(d) for all d gg 0. Furthermore, the degree of A is defined as the dimension of A over K if this dimension is finite, and as the integer d such that the leading term of the Hilbert polynomial has the form d t^ee, otherwise.","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"hilbert_series(A::MPolyQuo)\nhilbert_series_reduced(A::MPolyQuo)\nhilbert_series_expanded(A::MPolyQuo, d::Int)\nhilbert_function(A::MPolyQuo, d::Int)\nhilbert_polynomial(A::MPolyQuo)\ndegree(A::MPolyQuo)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_series-Tuple{MPolyQuo}","page":"Affine Algebras","title":"hilbert_series","text":"hilbert_series(A::MPolyQuo)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading  is inherited from a mathbb Z-grading on the polynomial ring R defined by assigning  positive integer weights to the variables, and where I is a homogeneous ideal of R  with respect to this grading, return a pair (pq), say, of univariate polynomials  p qinmathbb Zt such that pq represents the Hilbert series of A as  a rational function with denominator \n\nq = (1-t^w_1)cdots (1-t^w_n)\n\nwhere n is the number of variables of R, and w_1 dots w_n are the assigned weights.\n\nSee also hilbert_series_reduced.\n\nExamples\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_series(A)\n(2*t^3 - 3*t^2 + 1, t^4 - 4*t^3 + 6*t^2 - 4*t + 1)\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3]);\n\njulia> A, _ = quo(R, ideal(R, [x*y*z]));\n\njulia> hilbert_series(A)\n(-t^6 + 1, -t^6 + t^5 + t^4 - t^2 - t + 1)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_series_reduced-Tuple{MPolyQuo}","page":"Affine Algebras","title":"hilbert_series_reduced","text":"hilbert_series_reduced(A::MPolyQuo)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading  is inherited from a mathbb Z-grading on the polynomial ring R defined by assigning  positive integer weights to the variables, and where I is a homogeneous ideal of R  with respect to this grading, return a pair (pq), say, of univariate polynomials  p qinmathbb Zt such that pq represents the Hilbert series of A as  a rational function written in lowest terms. \n\nSee also hilbert_series.\n\nExamples\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_series_reduced(A)\n(2*t + 1, t^2 - 2*t + 1)\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3]);\n\njulia> A, _ = quo(R, ideal(R, [x*y*z]));\n\njulia> hilbert_series(A)\n(-t^6 + 1, -t^6 + t^5 + t^4 - t^2 - t + 1)\n\njulia> hilbert_series_reduced(A)\n(t^2 - t + 1, t^2 - 2*t + 1)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_series_expanded-Tuple{MPolyQuo, Int64}","page":"Affine Algebras","title":"hilbert_series_expanded","text":"hilbert_series_expanded(A::MPolyQuo, d::Int)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading  is inherited from a mathbb Z-grading on the polynomial ring R defined by assigning  positive integer weights to the variables, and where I is a homogeneous ideal of R  with respect to this grading, return the Hilbert series of A to precision d. \n\nExamples\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_series_expanded(A, 7)\n1 + 4*t + 7*t^2 + 10*t^3 + 13*t^4 + 16*t^5 + 19*t^6 + 22*t^7 + O(t^8)\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3]);\n\njulia> A, _ = quo(R, ideal(R, [x*y*z]));\n\njulia> hilbert_series_expanded(A, 5)\n1 + t + 2*t^2 + 3*t^3 + 4*t^4 + 5*t^5 + O(t^6)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_function-Tuple{MPolyQuo, Int64}","page":"Affine Algebras","title":"hilbert_function","text":"hilbert_function(A::MPolyQuo, d::Int)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading  is inherited from a mathbb Z-grading on the polynomial ring R defined by assigning  positive integer weights to the variables, and where I is a homogeneous ideal of R  with respect to this grading, return the value H(A d), where \n\nH(A underlinephantomd) N rightarrow N  d  mapsto dim_K A_d\n\nis the Hilbert function of A.\n\nExamples\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_function(A,7)\n22\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3]);\n\njulia> A, _ = quo(R, ideal(R, [x*y*z]));\n\njulia> hilbert_function(A, 5)\n5\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#hilbert_polynomial-Tuple{MPolyQuo}","page":"Affine Algebras","title":"hilbert_polynomial","text":" hilbert_polynomial(A::MPolyQuo)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading  is inherited from the standard mathbb Z-grading on the polynomial ring R, return the Hilbert polynomial of A.\n\nExamples\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> hilbert_polynomial(A)\n3*t + 1\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#degree-Tuple{MPolyQuo}","page":"Affine Algebras","title":"degree","text":"degree(A::MPolyQuo)\n\nGiven a mathbb Z-graded affine algebra A = RI over a field K, where the grading  is inherited from the standard mathbb Z-grading on the polynomial ring R, return the degree of A.\n\nExamples\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> degree(A)\n3\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#Positive-Gradings-in-Full-Generality","page":"Affine Algebras","title":"Positive Gradings in Full Generality","text":"","category":"section"},{"location":"CommutativeAlgebra/affine_algebras/","page":"Affine Algebras","title":"Affine Algebras","text":"multi_hilbert_series(A::MPolyQuo)\nmulti_hilbert_series_reduced(A::MPolyQuo)\nmulti_hilbert_function(A::MPolyQuo, g::GrpAbFinGenElem)","category":"page"},{"location":"CommutativeAlgebra/affine_algebras/#multi_hilbert_series-Tuple{MPolyQuo}","page":"Affine Algebras","title":"multi_hilbert_series","text":"multi_hilbert_series(A::MPolyQuo)\n\nReturn the Hilbert series of the positively graded affine algebra A.\n\nExamples\n\njulia> W = [1 1 1; 0 0 -1];\n\njulia> R, x = GradedPolynomialRing(QQ, [\"x[1]\", \"x[2]\", \"x[3]\"], W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3] over Rational Field graded by\n  x[1] -> [1 0]\n  x[2] -> [1 0]\n  x[3] -> [1 -1], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3]])\n\njulia> I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);\n\njulia> A, _ = quo(R, I);\n\njulia> H = multi_hilbert_series(A);\n\njulia> H[1][1]\n-t[1]^5*t[2]^2 + t[1]^5*t[2] + t[1]^4*t[2]^2 - t[1]^4 + t[1]^2*t[2]^2 - t[1]^2*t[2] + t[1]*t[2]^4 - t[1]*t[2]^2 - t[2]^4 + 1\n\njulia> H[1][2]\n-t[1]^2*t[2] + t[1]^2 + 2*t[1]*t[2] - 2*t[1] - t[2] + 1\n\njulia> H[2]\n[1    0]\n[1   -1]\n\njulia> G = abelian_group(fmpz_mat([1 -1]));\n\njulia> g = gen(G, 1)\nElement of\n(General) abelian group with relation matrix\n[1 -1]\nwith components [0 1]\n\njulia> W = [g, g, g, g];\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"], W);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> multi_hilbert_series(A)\n((2*t^3 - 3*t^2 + 1, t^4 - 4*t^3 + 6*t^2 - 4*t + 1), [1])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#multi_hilbert_series_reduced-Tuple{MPolyQuo}","page":"Affine Algebras","title":"multi_hilbert_series_reduced","text":"multi_hilbert_series_reduced(A::MPolyQuo)\n\nReturn the reduced Hilbert series of the positively graded affine algebra A.\n\nExamples\n\njulia> W = [1 1 1; 0 0 -1];\n\njulia> R, x = GradedPolynomialRing(QQ, [\"x[1]\", \"x[2]\", \"x[3]\"], W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3] over Rational Field graded by\n  x[1] -> [1 0]\n  x[2] -> [1 0]\n  x[3] -> [1 -1], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3]])\n\njulia> I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);\n\njulia> A, _ = quo(R, I);\n\njulia> H = multi_hilbert_series_reduced(A);\n\njulia> H[1][1]\n-t[1]^4*t[2] + t[1]^3 + t[1]^2 + t[1]*t[2] + t[1] + t[2]^3 + t[2]^2 + t[2] + 1\n\njulia> H[1][2]\n-t[1] + 1\n\njulia> H[2]\n[1    0]\n[1   -1]\n\njulia> G = abelian_group(fmpz_mat([1 -1]));\n\njulia> g = gen(G, 1);\n\njulia> W = [g, g, g, g];\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"], W);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> multi_hilbert_series_reduced(A)\n((2*t + 1, t^2 - 2*t + 1), [1])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/affine_algebras/#multi_hilbert_function-Tuple{MPolyQuo, GrpAbFinGenElem}","page":"Affine Algebras","title":"multi_hilbert_function","text":"multi_hilbert_function(A::MPolyQuo, g::GrpAbFinGenElem)\n\nGiven an element g of a finitely generated Abelian group G, and given an affine algebra A = RI over a field K, where R is positively graded by G, and where I is homogeneous with respect to this grading, consider  the induced grading on A, and return the value H(A g) of  the Hilbert function\n\nH(A underlinephantomd) G to N  gmapsto dim_K(A_g)\n\nmulti_hilbert_function(A::MPolyQuo, g::Vector{<:IntegerUnion})\n\nGiven an affine algebra A = RI as above, where G =mathbb  Z^m,  and given a vector g of m integers, convert g into an element  of the group mathbb  Z^m, and return the value H(A g) as above.\n\nmulti_hilbert_function(A::MPolyQuo, g::IntegerUnion)\n\nGiven an affine algebra A = RI as above, where G =mathbb  Z, and given an integer g, convert g into an element of the group  mathbb  Z, and return the value H(A g) as above.\n\nExamples\n\njulia> W = [1 1 1; 0 0 -1];\n\njulia> R, x = GradedPolynomialRing(QQ, [\"x[1]\", \"x[2]\", \"x[3]\"], W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3] over Rational Field graded by \n  x[1] -> [1 0]\n  x[2] -> [1 0]\n  x[3] -> [1 -1], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3]])\n\njulia> I = ideal(R, [x[1]^3*x[2], x[2]*x[3]^2, x[2]^2*x[3], x[3]^4]);\n\njulia> A, _ = quo(R, I);\n\njulia> multi_hilbert_function(A::MPolyQuo, [1, 0])\n2\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"], [-1, -1, -1, -1]);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> multi_hilbert_function(A, -7)\n22\n\njulia> G = abelian_group(fmpz_mat([1 -1]));\n\njulia> g = gen(G, 1);\n\njulia> W = [g, g, g, g];\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"], W);\n\njulia> A, _ = quo(R, ideal(R, [w*y-x^2, w*z-x*y, x*z-y^2]));\n\njulia> multi_hilbert_function(A, 7*g)\n22\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/field_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"AbstractAlgebra/field_introduction/","page":"Introduction","title":"Introduction","text":"A number of basic fields are provided, such as the rationals, finite fields, the real field, etc.","category":"page"},{"location":"AbstractAlgebra/field_introduction/","page":"Introduction","title":"Introduction","text":"Various generic field constructions can then be made recursively on top of these basic fields. For example, fraction fields, residue fields, function fields, etc.","category":"page"},{"location":"AbstractAlgebra/field_introduction/","page":"Introduction","title":"Introduction","text":"From the point of view of the system, all fields are rings and whether an object is a ring/field or an element thereof can be determined at the type level. There are abstract types for all field and for all field element types.","category":"page"},{"location":"AbstractAlgebra/field_introduction/","page":"Introduction","title":"Introduction","text":"The field hierarchy can be extended by implementing new fields to follow one or more field interfaces, including the interface that all fields must follow. Once an interface is satisfied, all the corresponding generic functionality will work over the new field.","category":"page"},{"location":"AbstractAlgebra/field_introduction/","page":"Introduction","title":"Introduction","text":"Implementations of new fields can either be generic or can be specialised implementations provided by, for example, a C library.","category":"page"},{"location":"Hecke/quad_forms/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"This chapter deals with quadratic and Hermitian spaces and lattices there of.","category":"page"},{"location":"Hecke/quad_forms/introduction/#Definitions-and-vocabulary","page":"Introduction","title":"Definitions and vocabulary","text":"","category":"section"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"We begin by collecting the necessary definitions and vocabulary. The terminology follows mainly [Kir16]","category":"page"},{"location":"Hecke/quad_forms/introduction/#Quadratic-and-Hermitian-spaces","page":"Introduction","title":"Quadratic and Hermitian spaces","text":"","category":"section"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"Let E be a number field. A quadratic space is a finite-dimensional vector space V over E together with a bilinear morphism Phi colon V times V to E. We will always work with an implicit canonical basis e_1dotsce_n of V. In view of this, quadratic spaces are in bijection with symmetric matrices over E. If V is a quadratic space, we call the matrix G = (Phi(e_i e_j))_1 leq i j leq n in E^n times n the Gram matrix of V.","category":"page"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"Let EK be an extension of number fields of degree two with non-trivial automorphism overlinephantomx E to E. A Hermitian space is a finite-dimensional vector space V over E together with a sesquilinear (with respect to the involution overlinephantomx) morphism Phi colon V times V to K. We will always work with an implicit canonical basis e_1dotsce_n of V. In view of this, Hermitian spaces are in bijection with Hermitian matrices over E. If V is a Hermitian space, we call the matrix G = (Phi(e_i e_j))_1 leq i j leq n in E^n times n the Gram matrix of V. We call overlinephantomx the involution of V.","category":"page"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"In both cases we refer to the field E as the base ring V. In this chapter we will refer to quadratic and Hermitian spaces also just as spaces. For Hermitian lattices, the field K will be refered to as the fixed field of V.","category":"page"},{"location":"Hecke/quad_forms/introduction/#Quadratic-and-Hermitian-lattices","page":"Introduction","title":"Quadratic and Hermitian lattices","text":"","category":"section"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"Let V be a space (either quadratic or Hermitian) with base field E. A finitely generated mathcal O_E-submodule L of V is called a quadratic lattice or Hermitian lattice respectively. We call V the ambient space of L and Lotimes_mathcal O_E E the rational span of L. The ring mathcal O_E will be referred to as the base ring of L.","category":"page"},{"location":"Hecke/quad_forms/introduction/#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"Many of the implemented algorithms for computing with quadratic and hermitian lattices over number fields are based on the Magma implementation of Markus Kirschmer, which can be found here.","category":"page"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"[Kir16] : Definite quadratic and hermitian forms with small class number. Habilitationsschrift. RWTH Aachen University, 2016, pdf","category":"page"},{"location":"Hecke/quad_forms/introduction/","page":"Introduction","title":"Introduction","text":"[Kir19] : Determinant groups of hermitian lattices over local fields, Archiv der Mathematik, 113 (2019), no. 4, 337–347. pdf","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/residue/#Generic-residue-rings","page":"Generic residue rings","title":"Generic residue rings","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"AbstractAlgebra.jl provides modules, implemented in src/Residue.jl and src/ResidueField for residue rings and fields, respectively, over any Euclidean domain (in practice most of the functionality is provided for GCD domains that provide a meaningful GCD function) belonging to the AbstractAlgebra.jl abstract type hierarchy.","category":"page"},{"location":"AbstractAlgebra/residue/#Generic-residue-types","page":"Generic residue rings","title":"Generic residue types","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"AbstractAlgebra.jl implements generic residue rings with type Generic.Res{T} or in the case of residue rings that are known to be fields, Generic.ResF{T}, where T is the type of elements of the base ring. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Parent objects of generic residue ring elements have type Generic.ResRing{T} and those of residue fields have type GenericResField{T}.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"The defining modulus of the residue ring is stored in the parent object.","category":"page"},{"location":"AbstractAlgebra/residue/#Abstract-types","page":"Generic residue rings","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"All residue element types belong to the abstract type ResElem{T} or ResFieldElem{T} in the case of residue fields, and the residue ring types belong to the abstract type ResRing{T} or ResField{T} respectively. This enables one to write generic functions that can accept any AbstractAlgebra residue type.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"note: Note\nNote that both the generic residue ring type Generic.ResRing{T} and the abstract type it belongs to, ResRing{T} are both called ResRing, and similarly for the residue field types. In each case, the  former is a (parameterised) concrete type for a residue ring over a given base ring whose elements have type T. The latter is an abstract type representing all residue ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"AbstractAlgebra/residue/#Residue-ring-constructors","page":"Generic residue rings","title":"Residue ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"In order to construct residues in AbstractAlgebra.jl, one must first construct the residue ring itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"ResidueRing(R::Ring, m::RingElem; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"ResidueField(R::Ring, m::RingElem; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Given a base ring R and residue m contained in this ring, return the parent object of the residue ring R(m). By default the parent object S will depend only on R and m and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"The ResidueField constructor does the same thing as the ResidueRing constructor, but the resulting object has type belonging to Field rather than Ring, so it can be used anywhere a field is expected in AbstractAlgebra.jl. No check is made for maximality of the ideal generated by m.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"There are also the following for constructing residue rings and fields.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"quo(R::Ring, m::RingElem; cached::Bool = true)\nquo(::Type{Field}, R::Ring, m::RingElem; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/residue/#quo-Tuple{AbstractAlgebra.Ring, RingElem}","page":"Generic residue rings","title":"quo","text":"quo(R::Ring, a::RingElement; cached::Bool = true)\n\nReturns S, f where S = ResidueRing(R, a) and f is the  projection map from R to S. This map is supplied as a map with section where the section is the lift of an element of the residue field back to the ring R.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/residue/#quo-Tuple{Type{AbstractAlgebra.Field}, AbstractAlgebra.Ring, RingElem}","page":"Generic residue rings","title":"quo","text":"quo(::Type{Field}, R::Ring, a::RingElement; cached::Bool = true)\n\nReturns S, f where S = ResidueField(R, a) and f is the  projection map from R to S. This map is supplied as a map with section where the section is the lift of an element of the residue field back to the ring R.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Here are some examples of creating residue rings and making use of the resulting parent objects to coerce various elements into the residue ring.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1\n\njulia> U, f = quo(R, x^3 + 3x + 1)\n(Residue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, Map with section with the following data\n\nDomain:\n=======\nUnivariate Polynomial Ring in x over Rationals\n\nCodomain:\n========\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1)\n\njulia> U === S\ntrue","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"All of the examples here are generic residue rings, but specialised implementations of residue rings provided by external modules will also usually provide a ResidueRing constructor to allow creation of their residue rings.","category":"page"},{"location":"AbstractAlgebra/residue/#Residue-constructors","page":"Generic residue rings","title":"Residue constructors","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"One can use the parent objects of a residue ring to construct residues, as per any ring.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"(R::ResRing)() # constructs zero\n(R::ResRing)(c::Integer)\n(R::ResRing)(c::elem_type(R))\n(R::ResRing{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/residue/#Functions-for-types-and-parents-of-residue-rings","page":"Generic residue rings","title":"Functions for types and parents of residue rings","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"base_ring(R::ResRing)\nbase_ring(a::ResElem)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Return the base ring over which the ring was constructed.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"parent(a::ResElem)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Return the parent of the given residue.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"characteristic(R::ResRing)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Return the characteristic of the given residue ring. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/residue/#Residue-ring-functions","page":"Generic residue rings","title":"Residue ring functions","text":"","category":"section"},{"location":"AbstractAlgebra/residue/#Basic-functionality","page":"Generic residue rings","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Residue rings implement the Ring interface.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"zero(R::NCRing)\none(R::NCRing)\niszero(a::NCRingElement)\nisone(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"divexact(a::T, b::T) where T <: RingElement\ninv(a::T)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"The Residue Ring interface is also implemented.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"modulus(S::ResRing)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"data(f::ResElem)\nlift(f::ResElem)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Return a lift of the residue to the base ring.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"The following functions are also provided for residues.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"modulus(::ResElem)","category":"page"},{"location":"AbstractAlgebra/residue/#modulus-Tuple{ResElem}","page":"Generic residue rings","title":"modulus","text":"modulus(R::ResElem)\n\nReturn the modulus a of the residue ring S = R(a) that the supplied residue r belongs to.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f = S(x + 1)\nx + 1\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> isunit(f)\ntrue\n\njulia> m = modulus(S)\nx^3 + 3*x + 1\n\njulia> d = data(f)\nx + 1\n\njulia> U = base_ring(S)\nUnivariate Polynomial Ring in x over Rationals\n\njulia> V = base_ring(f)\nUnivariate Polynomial Ring in x over Rationals\n\njulia> T = parent(f)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f == deepcopy(f)\ntrue\n\njulia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)","category":"page"},{"location":"AbstractAlgebra/residue/#Inversion","page":"Generic residue rings","title":"Inversion","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Base.inv(::ResElem)","category":"page"},{"location":"AbstractAlgebra/residue/#inv-Tuple{ResElem}","page":"Generic residue rings","title":"inv","text":"Base.inv(a::ResElem)\n\nReturn the inverse of the element a in the residue ring. If an impossible inverse is encountered, an exception is raised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = inv(f)\n1//3*x^2 - 1//3*x + 4//3\n","category":"page"},{"location":"AbstractAlgebra/residue/#Greatest-common-divisor","page":"Generic residue rings","title":"Greatest common divisor","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"gcd{T <: RingElem}(::ResElem{T}, ::ResElem{T})","category":"page"},{"location":"AbstractAlgebra/residue/#gcd-Union{Tuple{T}, Tuple{ResElem{T}, ResElem{T}}} where T<:RingElem","page":"Generic residue rings","title":"gcd","text":"gcd(a::ResElem{T}, b::ResElem{T}) where {T <: RingElement}\n\nReturn a greatest common divisor of a and b if one exists. This is done by taking the greatest common divisor of the data associated with the supplied residues and taking its greatest common divisor with the modulus.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = S(x^2 + 2x + 1)\nx^2 + 2*x + 1\n\njulia> h = gcd(f, g)\n1\n","category":"page"},{"location":"AbstractAlgebra/residue/#Square-Root","page":"Generic residue rings","title":"Square Root","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"issquare{T <: Integer}(::ResFieldElem{T})","category":"page"},{"location":"AbstractAlgebra/residue/#issquare-Union{Tuple{AbstractAlgebra.ResFieldElem{T}}, Tuple{T}} where T<:Integer","page":"Generic residue rings","title":"issquare","text":"issquare(a::ResFieldElem{T}) where T <: Integer\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Base.sqrt{T <: Integer}(::ResFieldElem{T})","category":"page"},{"location":"AbstractAlgebra/residue/#sqrt-Union{Tuple{AbstractAlgebra.ResFieldElem{T}}, Tuple{T}} where T<:Integer","page":"Generic residue rings","title":"sqrt","text":"sqrt(a::ResFieldElem{T}; check::Bool=true) where T <: Integer\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"julia> R = ResidueField(ZZ, 733)\nResidue field of Integers modulo 733\n\njulia> a = R(86)\n86\n\njulia> issquare(a)\ntrue\n\njulia> sqrt(a)\n532","category":"page"},{"location":"AbstractAlgebra/residue/#Random-generation","page":"Generic residue rings","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Random residues can be generated using rand. The parameters after the residue ring are used to generate elements of the base ring.","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"rand(R::ResRing, v...)","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"Examples","category":"page"},{"location":"AbstractAlgebra/residue/","page":"Generic residue rings","title":"Generic residue rings","text":"using AbstractAlgebra # hide\nR = ResidueRing(ZZ, 7)\nf = rand(R, 0:6)\n\nS, x = PolynomialRing(QQ, \"x\")\nU = ResidueField(S, x^3 + 3x + 1)\ng = rand(S, 2:2, -10:10)","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Generic-matrix-algebras","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"AbstractAlgebra.jl allows the creation of an algebra (ring) of mtimes m matrices over a computable, commutative ring.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Functions specific to generic matrix algebras of mtimes m matrices are implemented in src/generic/MatrixAlgebra.jl. The remaining functionality is in the file src/generic/Matrix.jl.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"As well as implementing the entire Matrix interface, including the optional functionality, there are many additional generic algorithms implemented for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Almost all of the functionality specified for generic matrices is available for matrix algebras. The exceptions are functions such as solve and nullspace which may return non-square matrices, or which don't accept square matrices.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"All of the generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default, so it is not necessary to qualify names of functions.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Types-and-parent-objects","page":"Generic matrix algebras","title":"Types and parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Generic matrices in AbstractAlgebra.jl have type Generic.MatAlgElem{T} for matrices in a matrix algebra, where T is the type of elements of the matrix. Internally, generic matrices are implemented using an object wrapping a Julia two dimensional array, though they are not themselves Julia arrays. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Parents of generic matrices in a matrix algebra have type Generic.MatAlgebra{T}.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Note that matrix algebras are noncommutative rings. Thus their types belong to NCRing and NCRingElem. They cannot be used in constructions which require a commutative ring (Ring and RingElem respectively).","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"The generic matrix algebra matrix types belong to the abstract type MatAlgElem{T} and the parent types belong to  MatAlgebra{T} Note that both of these require disambiguation from the concrete types in Generic of the same name.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"The degree and base ring R of a generic matrix are stored in its parent object, however to allow creation of matrices without first creating the matrix space parent, generic matrices in Julia do not contain a reference to their parent. They contain the row and column numbers (or degree, in the case of matrix algebras) and the base ring on a per matrix basis. The parent object can then be reconstructed from this data on demand.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Matrix-algebra-constructors","page":"Generic matrix algebras","title":"Matrix algebra constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"A matrix algebra in AbstractAlgebra.jl represents a collection of all matrices with given degree and base ring.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"In order to construct matrices in AbstractAlgebra.jl, one must construct the matrix algebra itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"MatrixAlgebra(R::Ring, degree::Int; cache::Bool=true)","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Construct the algebra of matrices with the given degree over the given base ring. By default such matrix spaces are cached based on the base ring and degree. If the optional named parameter cached is set to false, no caching occurs.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Here are some examples of creating matrix algebras and making use of the resulting parent objects to coerce various elements into the matrix algebra.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixAlgebra(R, 3)\nMatrix Algebra of degree 3 over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S()\n[0   0   0]\n[0   0   0]\n[0   0   0]\n\njulia> B = S(12)\n[12    0    0]\n[ 0   12    0]\n[ 0    0   12]\n\njulia> C = S(R(11))\n[11    0    0]\n[ 0   11    0]\n[ 0    0   11]\n","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Matrix-algebra-element-constructors","page":"Generic matrix algebras","title":"Matrix algebra element constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"The following additional constructors are provided for constructing various kinds of matrices in a matrix algebra.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"identity_matrix(::Generic.MatAlgElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#identity_matrix-Union{Tuple{AbstractAlgebra.Generic.MatAlgElem{T}}, Tuple{T}} where T<:RingElement","page":"Generic matrix algebras","title":"identity_matrix","text":"identity_matrix(M::MatAlgElem{T}) where T <: RingElement\n\nReturn the identity matrix over the same base ring as M and with the same dimensions.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"S = MatrixAlgebra(ZZ, 2)\nM = zero(S)\n\nP = identity_matrix(M)","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Matrix-algebra-functionality-provided-by-AbstractAlgebra.jl","page":"Generic matrix algebras","title":"Matrix algebra functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Most of the generic matrix functionality described in the generic matrix section of the documentation is available for both matrix spaces and matrix algebras. Exceptions include functions that do not return or accept square matrices or which cannot specify a parent. Such functions include solve and nullspace which can't be provided for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"In addition to the functionality described for matrix spaces, matrix algebras support all noncommutative ring operations, and matrix algebras can be used as a base ring for other generic constructs that accept a noncommutative base ring (NCRing).","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"In this section we describe functionality provided for matrix algebras only.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#Basic-matrix-functionality","page":"Generic matrix algebras","title":"Basic matrix functionality","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"As well as the Ring and Matrix interfaces, the following functions are provided to manipulate matrices.","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"degree(::Generic.MatAlgElem)","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/#degree-Tuple{AbstractAlgebra.Generic.MatAlgElem}","page":"Generic matrix algebras","title":"degree","text":"degree(a::MatAlgElem)\n\nReturn the degree n of the given matrix algebra.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix_algebras/","page":"Generic matrix algebras","title":"Generic matrix algebras","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixAlgebra(R, 3)\nMatrix Algebra of degree 3 over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> n = degree(A)\n3\n","category":"page"},{"location":"Hecke/examples/#Examples-and-sample-code","page":"Examples and sample code","title":"Examples and sample code","text":"","category":"section"},{"location":"Hecke/examples/","page":"Examples and sample code","title":"Examples and sample code","text":"Pages = [\n    \"examples/reduction.md\",\n]\nDepth = 2","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/qadic/#Qadics","page":"Qadics","title":"Qadics","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Q-adic fields, that is, unramified extensions of p-adic fields, are provided in Nemo by Flint. This allows construction of q-adic fields for any prime power q.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Q-adic fields are constructed using the FlintQadicField function. However, for convenience we define","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"QadicField = FlintQadicField","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"so that q-adic fields can be constructed using QadicField rather than FlintQadicField. Note that this is the name of the constructor, but not of qadic field type.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"The types of q-adic fields in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Library Field Element type Parent type\nFlint mathbbQ_q qadic QadicField","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"All the q-adic field types belong to the Field abstract type and the q-adic field element types belong to the FieldElem abstract type.","category":"page"},{"location":"Nemo/qadic/#P-adic-functionality","page":"Qadics","title":"P-adic functionality","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Q-adic fields in Nemo provide all the functionality described in AbstractAlgebra for fields:.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Below, we document all the additional function that is provide by Nemo for q-adic fields.","category":"page"},{"location":"Nemo/qadic/#Constructors","page":"Qadics","title":"Constructors","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"In order to construct q-adic field elements in Nemo, one must first construct the q-adic field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"FlintQadicField(::Integer, ::Int, ::Int)","category":"page"},{"location":"Nemo/qadic/#FlintQadicField-Tuple{Integer, Int64, Int64}","page":"Qadics","title":"FlintQadicField","text":"FlintQadicField(p::Integer, d::Int, prec::Int, var::String = \"a\")\n\nReturns the parent object for the q-adic field for given prime p and degree d, where the default absolute precision of elements of the field is given by prec and the generator is printed as var.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"It is also possible to call the inner constructor directly. It has the following form.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"FlintQadicField(p::fmpz, d::Int, prec::Int)","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Returns the parent object for the q-adic field for given prime p and degree d, where the default absolute precision of elements of the field is given by prec. It also return the uniformizer p with the default precision.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Here are some examples of creating q-adic fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"R, p = QadicField(7, 1, 30)\nS, _ = QadicField(ZZ(65537), 1, 30)\n\na = R()\nb = S(1)\nc = S(ZZ(123))\nd = R(ZZ(1)//7^2)","category":"page"},{"location":"Nemo/qadic/#Big-oh-notation","page":"Qadics","title":"Big-oh notation","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Elements of p-adic fields can  be constructed using the big-oh notation. For this purpose we define the following functions.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"O(::FlintQadicField, ::Integer)\nO(::FlintQadicField, ::fmpz)\nO(::FlintQadicField, ::fmpq)","category":"page"},{"location":"Nemo/qadic/#O-Tuple{FlintQadicField, Integer}","page":"Qadics","title":"O","text":"O(R::FlintQadicField, m::Integer)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"Nemo/qadic/#O-Tuple{FlintQadicField, fmpz}","page":"Qadics","title":"O","text":"O(R::FlintQadicField, m::fmpz)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"Nemo/qadic/#O-Tuple{FlintQadicField, fmpq}","page":"Qadics","title":"O","text":"O(R::FlintQadicField, m::fmpq)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"The O(p^n) construction can be used to construct q-adic values of precision n by adding it to integer values representing the q-adic value modulo p^n as in the examples.","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"R, _ = QadicField(7, 30)\nS, _ = QadicField(ZZ(65537), 30)\n\nc = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nd = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)\nf = ZZ(1)//7^2 + ZZ(2)//7 + 3 + 4*7 + O(R, 7^2)","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Beware that the expression 1 + 2*p + 3*p^2 + O(R, p^n) is actually computed as a normal Julia expression. Therefore if {Int} values are used instead of Flint integers or Julia bignums, overflow may result in evaluating the value.","category":"page"},{"location":"Nemo/qadic/#Basic-manipulation","page":"Qadics","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"prime(::FlintQadicField)","category":"page"},{"location":"Nemo/qadic/#prime-Tuple{FlintQadicField}","page":"Qadics","title":"prime","text":"prime(R::FlintQadicField)\n\nReturn the prime p for the given q-adic field.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"precision(::qadic)","category":"page"},{"location":"Nemo/qadic/#precision-Tuple{qadic}","page":"Qadics","title":"precision","text":"precision(a::qadic)\n\nReturn the precision of the given q-adic field element, i.e. if the element is known to O(p^n) this function will return n.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"valuation(::qadic)","category":"page"},{"location":"Nemo/qadic/#valuation-Tuple{qadic}","page":"Qadics","title":"valuation","text":"valuation(a::qadic)\n\nReturn the valuation of the given q-adic field element, i.e. if the given element is divisible by p^n but not a higher power of q then the function will return n.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"lift(::FmpqPolyRing, ::qadic)\nlift(::FmpzPolyRing, ::qadic)","category":"page"},{"location":"Nemo/qadic/#lift-Tuple{FmpqPolyRing, qadic}","page":"Qadics","title":"lift","text":"lift(R::FmpqPolyRing, a::qadic)\n\nReturn a lift of the given q-adic field element to mathbbQx.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/#lift-Tuple{FmpzPolyRing, qadic}","page":"Qadics","title":"lift","text":"lift(R::FmpzPolyRing, a::qadic)\n\nReturn a lift of the given q-adic field element to mathbbZx if possible.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"R, _ = QadicField(7, 1, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 7^2 + 3*7^3 + O(R, 7^5)\nc = R(2)\n\nk = precision(a)\nm = prime(R)\nn = valuation(b)\nQx, x = FlintQQ[\"x\"]\np = lift(Qx, a)\nZy, y = FlintZZ[\"y\"]\nq = lift(Zy, divexact(a, b))","category":"page"},{"location":"Nemo/qadic/#Square-root","page":"Qadics","title":"Square root","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Base.sqrt(::qadic)","category":"page"},{"location":"Nemo/qadic/#sqrt-Tuple{qadic}","page":"Qadics","title":"sqrt","text":"Base.sqrt(f::PolyElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\nsqrt(a::FieldElem)\n\nReturn the square root of the element a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"R, _ = QadicField(7, 1, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\nc = 7^2 + 2*7^3 + O(R, 7^4)\n\nd = sqrt(a)\nf = sqrt(b)\nf = sqrt(c)\ng = sqrt(R(121))","category":"page"},{"location":"Nemo/qadic/#Special-functions","page":"Qadics","title":"Special functions","text":"","category":"section"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Base.exp(::qadic)","category":"page"},{"location":"Nemo/qadic/#exp-Tuple{qadic}","page":"Qadics","title":"exp","text":"exp(a::AbsSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::RelSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"log(::qadic)","category":"page"},{"location":"Nemo/qadic/#log-Tuple{qadic}","page":"Qadics","title":"log","text":"log(a::SeriesElem{T}) where T <: FieldElement\n\nReturn the logarithm of the power series a.\n\n\n\nlog(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the logarithm of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"teichmuller(::qadic)","category":"page"},{"location":"Nemo/qadic/#teichmuller-Tuple{qadic}","page":"Qadics","title":"teichmuller","text":"teichmuller(a::qadic)\n\nReturn the Teichmuller lift of the q-adic value a. We require the valuation of a to be nonnegative. The precision of the output will be the same as the precision of the input. For convenience, if a is congruent to zero modulo q we return zero. If the input is not valid an exception is thrown.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"frobenius(::qadic, ::Int)","category":"page"},{"location":"Nemo/qadic/#frobenius-Tuple{qadic, Int64}","page":"Qadics","title":"frobenius","text":"frobenius(a::qadic, e::Int = 1)\n\nReturn the image of the e-th power of Frobenius on the q-adic value a. The precision of the output will be the same as the precision of the input.\n\n\n\n","category":"method"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"Examples","category":"page"},{"location":"Nemo/qadic/","page":"Qadics","title":"Qadics","text":"R, _ = QadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 5*7 + 3*7^2 + O(R, 7^3)\nc = 3*7 + 2*7^2 + O(R, 7^5)\n\nc = exp(c)\nd = log(a)\nc = exp(R(0))\nd = log(R(1))\nf = teichmuller(b)\ng = frobenius(a, 2)","category":"page"},{"location":"Nemo/misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"Nemo/misc/#Global-variables-and-precompilation","page":"Miscellaneous","title":"Global variables and precompilation","text":"","category":"section"},{"location":"Nemo/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Due to limitations of the precompilation of modules in julia, global variables referring to certain Nemo types require special attention when used inside modules. As a simple example, the following code for a module called A will not work as expected:","category":"page"},{"location":"Nemo/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"module A\n\nusing Nemo\nQx, x = QQ[\"x\"]\nf(n) = x^n\nend","category":"page"},{"location":"Nemo/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"When running julia and loading the module via using/import A, calling f will lead to segmentation faults. The preferred workaround is to put the definitions of the global variables into the __init__() function of the module as follows:","category":"page"},{"location":"Nemo/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"module A\n\nusing Nemo\n\nfunction __init__()\n  global (Qx, x) = QQ[\"x\"]\nend\n\nf(n) = x^n\nend","category":"page"},{"location":"Nemo/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Alternatively, one can disable precompilation by adding __precompile__(false) inside A. Note that this might have other unwanted side effects.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/real/#Real-field","page":"Real field","title":"Real field","text":"","category":"section"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/Float.jl for making Julia BigFloats conform to the AbstractAlgebra.jl Field interface.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"In addition to providing a parent object RealField for Julia BigFloats, we implement any additional functionality required by AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"Because BigFloat cannot be directly included in the AbstractAlgebra.jl abstract type hierarchy, we achieve integration of Julia BigFloats by introducing a type union, called FieldElement, which is a union of FieldElem and a number of Julia types, including BigFloat. Everywhere that FieldElem is notionally used in AbstractAlgebra.jl, we are in fact using FieldElement, with additional care being taken to avoid ambiguities.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"The details of how this is done are technical, and we refer the reader to the implementation for details. For most intents and purposes, one can think of the Julia BigFloat type as belonging to FieldElem.","category":"page"},{"location":"AbstractAlgebra/real/#Types-and-parent-objects","page":"Real field","title":"Types and parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"Reals have type BigFloat, as in Julia itself. We simply supplement the functionality for this type as required for computer algebra.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"The parent objects of such integers has type Floats{BigFloat}.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"For convenience, we also make Float64 a part of the AbstractAlgebra.jl type hierarchy and its parent object (accessible as RDF) has type Floats{Float64}.","category":"page"},{"location":"AbstractAlgebra/real/#Rational-constructors","page":"Real field","title":"Rational constructors","text":"","category":"section"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"In order to construct reals in AbstractAlgebra.jl, one can first construct the real field itself. This is accomplished using the following constructor.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"Floats{BigFloat}()","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"This gives the unique object of type Floats{BigFloat} representing the field of reals in AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"In practice, one simply uses RealField which is assigned to be the return value of the above constructor. There is no need to call the constructor in practice.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"Here are some examples of creating the real field and making use of the resulting parent object to coerce various elements into the field.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"Examples","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"julia> RR = RealField\nFloats\n\njulia> f = RR()\n0.0\n\njulia> g = RR(123)\n123.0\n\njulia> h = RR(BigInt(1234))\n1234.0\n\njulia> k = RR(12//7)\n1.714285714285714285714285714285714285714285714285714285714285714285714285714291\n\njulia> m = RR(2.3)\n2.29999999999999982236431605997495353221893310546875\n","category":"page"},{"location":"AbstractAlgebra/real/#Basic-field-functionality","page":"Real field","title":"Basic field functionality","text":"","category":"section"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"The real field in AbstractAlgebra.jl implements the full Field interface.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"We give some examples of such functionality.","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"Examples","category":"page"},{"location":"AbstractAlgebra/real/","page":"Real field","title":"Real field","text":"julia> RR = RealField\nFloats\n\njulia> f = RR(12//7)\n1.714285714285714285714285714285714285714285714285714285714285714285714285714291\n\njulia> h = zero(RR)\n0.0\n\njulia> k = one(RR)\n1.0\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> U = base_ring(RR)\nUnion{}\n\njulia> T = parent(f)\nFloats\n\njulia> f == deepcopy(f)\ntrue\n\njulia> g = f + 12\n13.71428571428571428571428571428571428571428571428571428571428571428571428571433\n\njulia> m = inv(g)\n0.07291666666666666666666666666666666666666666666666666666666666666666666666666631\n","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/#Extending-the-interface-of-AbstractAlgebra.jl","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"In this section we will discuss on how to extend the interface of AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/#Elements-and-parents","page":"Extending the interface of AbstractAlgebra.jl","title":"Elements and parents","text":"","category":"section"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"Any implementation with elements and parents should implement the following interface:","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"parent\nelem_type\nparent_type","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/#parent","page":"Extending the interface of AbstractAlgebra.jl","title":"parent","text":"parent(a)\n\nReturn parent object of given element a.\n\nExamples\n\njulia> G = SymmetricGroup(5); g = Perm([3,4,5,2,1])\n(1,3,5)(2,4)\n\njulia> parent(g) == G\ntrue\n\njulia> S, x = LaurentSeriesRing(ZZ, 3, \"x\")\n(Laurent series ring in x over Integers, x + O(x^4))\n\njulia> parent(x) == S\ntrue\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/extending_abstractalgebra/#elem_type","page":"Extending the interface of AbstractAlgebra.jl","title":"elem_type","text":"elem_type(parent)\nelem_type(parent_type)\n\nGiven a parent object (or its type), return the type of its elements.\n\nExample\n\njulia> S, x = PowerSeriesRing(QQ, 2, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^3))\n\njulia> elem_type(S) == typeof(x)\ntrue\n\n\n\nelem_type(::Type{T}) where T <: GAPGroup\nelem_type(::T) where T <: GAPGroup\n\nelem_type maps (the type of) a group to the type of its elements. For now, a group of type T has elements of type BasicGAPGroupElem{T}. So we provide it mostly for consistency with other parts of OSCAR. In the future, a more elaborate setup for group element types might also be needed.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/extending_abstractalgebra/#parent_type","page":"Extending the interface of AbstractAlgebra.jl","title":"parent_type","text":"parent_type(element)\nparent_type(element_type)\n\nGiven an element (or its type), return the type of its parent object.\n\nExample\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = MatrixSpace(R, 2, 2)\nMatrix Space of 2 rows and 2 columns over Univariate Polynomial Ring in x over Integers\n\njulia> a = rand(S, 0:1, 0:1);\n\njulia> parent_type(a) == typeof(S)\ntrue\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/extending_abstractalgebra/#Aquiring-associated-elements-and-parents","page":"Extending the interface of AbstractAlgebra.jl","title":"Aquiring associated elements and parents","text":"","category":"section"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"Further, if one has a base ring, like polynomials over the integers mathbbZx, then one should implement","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"base_ring","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/#base_ring","page":"Extending the interface of AbstractAlgebra.jl","title":"base_ring","text":"base_ring(a)\n\nReturn base ring R of given element or parent a.\n\nExamples\n\njulia> S, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> base_ring(S) == QQ\ntrue\n\njulia> R = GF(7)\nFinite field F_7\n\njulia> base_ring(R)\nUnion{}\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/extending_abstractalgebra/#Special-elements","page":"Extending the interface of AbstractAlgebra.jl","title":"Special elements","text":"","category":"section"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"For rings, one has to extend the following methods:","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"one\nzero","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/#one","page":"Extending the interface of AbstractAlgebra.jl","title":"one","text":"one(a)\n\nReturn the multiplicative identity in the algebraic structure of a, which can be either an element or parent.\n\nExamples\n\njulia> S = MatrixSpace(ZZ, 2, 2)\nMatrix Space of 2 rows and 2 columns over Integers\n\njulia> one(S)\n[1   0]\n[0   1]\n\njulia> R, x = PuiseuxSeriesField(QQ, 4, \"x\")\n(Puiseux series field in x over Rationals, x + O(x^5))\n\njulia> one(x)\n1 + O(x^4)\n\njulia> G = GF(5)\nFinite field F_5\n\njulia> one(G)\n1\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/extending_abstractalgebra/#zero","page":"Extending the interface of AbstractAlgebra.jl","title":"zero","text":"zero(a)\n\nReturn the additive identity in the algebraic structure of a, which can be either an element or parent.\n\nExamples\n\njulia> S = MatrixAlgebra(QQ, 2)\nMatrix Algebra of degree 2 over Rationals\n\njulia> zero(S)\n[0//1   0//1]\n[0//1   0//1]\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> zero(x^3 + 2)\n0\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"Groups should only extend at least one of these. The one that is required depends on if the group is additive (commutative) or multiplicative.","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/#Basic-manipulation","page":"Extending the interface of AbstractAlgebra.jl","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"If one would like to implement a ring, these are the basic manipulation methods that all rings should extend:","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"isone\niszero\nisunit","category":"page"},{"location":"AbstractAlgebra/extending_abstractalgebra/#isone","page":"Extending the interface of AbstractAlgebra.jl","title":"isone","text":"isone(a)\n\nReturn true if a is the multiplicative identity, else return false.\n\nExamples\n\njulia> S = MatrixSpace(ZZ, 2, 2); T = MatrixSpace(ZZ, 2, 3); U = MatrixSpace(ZZ, 3, 2);\n\njulia> isone(S([1 0; 0 1]))\ntrue\n\njulia> isone(T([1 0 0; 0 1 0]))\nfalse\n\njulia> isone(U([1 0; 0 1; 0 0]))\nfalse\n\njulia> T, x = PuiseuxSeriesField(QQ, 10, \"x\")\n(Puiseux series field in x over Rationals, x + O(x^11))\n\njulia> isone(x), isone(T(1))\n(false, true)\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/extending_abstractalgebra/#iszero","page":"Extending the interface of AbstractAlgebra.jl","title":"iszero","text":"iszero(a)\n\nReturn true if a is the additative identity, else return false.\n\nExamples\n\njulia> T, x = PuiseuxSeriesField(QQ, 10, \"x\")\n(Puiseux series field in x over Rationals, x + O(x^11))\n\njulia> a = T(0)\nO(x^10)\n\njulia> iszero(a)\ntrue\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/extending_abstractalgebra/#isunit","page":"Extending the interface of AbstractAlgebra.jl","title":"isunit","text":"isunit(a::T) where {T <: NCRingElem}\n\nReturn true if a is invertible, else return false.\n\nExamples\n\njulia> S, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> isunit(x), isunit(S(1)), isunit(S(4))\n(false, true, true)\n\njulia> isunit(ZZ(-1)), isunit(ZZ(4))\n(true, false)\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/extending_abstractalgebra/","page":"Extending the interface of AbstractAlgebra.jl","title":"Extending the interface of AbstractAlgebra.jl","text":"With the same logic as earlier, groups only need to extend one of the methods isone and iszero.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"InvariantTheory/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The invariant theory part of OSCAR provides functionality for computing polynomial invariants of group actions, focusing on finite and linearly reductive groups, respectively.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The basic setting in this context consists of a group G, a field K, a vector space V over K of finite dimension n and  a representation rho G to textGL(V) of G on V. The induced action on the dual vector space V^ast,","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"V^ast  times G rightarrow V^ast (f pi)mapsto f      pi  = fcirc rho(pi)","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"extends to an action of G on the graded symmetric algebra","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"KV=S(V^*)=bigoplus_dgeq 0 S^d V^*","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"which preserves the grading.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The invariants of G are the fixed points of this action, its invariant ring is the graded subalgebra","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"KV^G=fin KV mid f      pi =f text  for any  piin G subset KV","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Explicitly, the choice of a basis of V and its dual basis, say, x_1 dots x_n of V^* gives rise to isomorphisms textGL(V) cong textGL_n(K) and KVcong  Kx_1 dots x_n. After identifying textGL(V) with textGL_n(K) and KV with Kx_1 dots x_n by means of these isomorphisms, the action of G on KV is given as follows:","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"(f      pi)  (x_1 dots x_n)  = f((x_1 dots x_n) cdot rho(pi))","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Accordingly, KV^G may be regarded as a graded subalgebra of Kx_1 dots x_n:","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"KV^G cong Kx_1 dots x_n^G =fin Kx_1 dots x_n mid f      pi =f text  for any  piin G","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The main objective of invariant theory in OSCAR is the computation of K-algebra generators for invariant rings.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nIf KV^G is finitely generated as a K-algebra, then any minimal system of homogeneous generators is called a fundamental system of invariants for KV^G. By Nakayama's lemma, the number of elements in such a system is uniquely determined as the embedding dimension of KV^G. Similarly, the degrees of these elements are uniquely determined.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nIf KV^G is finitely generated as a K-algebra, then KV^G admits a graded Noether normalization, that is, a Noether normalization Kp_1 dots p_m subset KV^G with p_1 dots p_m homogeneous. Given any such Noether normalization, p_1 dots p_m is called a homogeneous system of parameters or a system of primary invariants for KV^G, and  any minimal system s_0=1 s_1dots s_l of homogeneous generators of KV^G as a Kp_1 dots p_m-module is called a system of secondary invariants for KV^G with respect to p_1 dots p_m. A secondary invariant s_ineq 1 is called irreducible if it cannot be written as a polynomial expression in the primary invariants and the other secondary invariants. The  irreducible secondary invariants form a minimal system of homogeneous generators for KV^G as a Kp_1 dots p_m-algebra. Somewhat abusing notation, we call every minimal system of homogeneous generators for KV^G as a Kp_1 dots p_m-algebra a system of irreducible secondary invariants.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nFor the invariant rings handled by OSCAR, the assumption that KV^G is finitely generated as a K-algebra will be guaranteed by theoretical results. In addition, where not mentioned otherwise, the following will hold:There exists a Reynolds operator mathcal R KV to KV. That is, mathcal R is a K-linear graded map which projects KV onto KV^G, and which is a KV^G-module homomorphism.\nThe ring KV^G is Cohen-Macaulay. Equivalently, KV^G is a free module (of finite rank) over any of its graded Noether normalizations.","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"The textbook","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Harm Derksen, Gregor Kemper (2015)","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"and the survey article","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"Wolfram Decker, Theo de Jong (1998)","category":"page"},{"location":"InvariantTheory/intro/","page":"Introduction","title":"Introduction","text":"provide details on theory and algorithms as well as references.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/puiseux/#Puiseux-series","page":"Puiseux series","title":"Puiseux series","text":"","category":"section"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Nemo allows the creation of Puiseux series over any computable ring R. Puiseux series are series of the form a_jx^jm + a_j+1x^(j+1)m + cdots + a_k-1x^(k-1)m + O(x^km) where m is a positive integer, a_i in R and the relative precision k - j is at most equal to some specified precision n.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of Puiseux series over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"The following table shows each of the Puiseux series types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl `Generic.PuiseuxSeriesRingElem{T} Generic.PuiseuxSeriesRing{T}\nGeneric field K AbstractAlgebra.jl `Generic.PuiseuxSeriesFieldElem{T} Generic.PuiseuxSeriesField{T}\nmathbbZ Flint FlintPuiseuxSeriesRingElem{fmpz_laurent_series} FlintPuiseuxSeriesRing{fmpz_laurent_series}","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"For convenience, FlintPuiseuxSeriesRingElem and FlintPuiseuxSeriesFieldElem both belong to a union type called FlintPuiseuxSeriesElem.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"The maximum relative precision, the string representation of the variable and the base ring R of a generic power series are stored in the parent object. ","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Note that unlike most other Nemo types, Puiseux series are parameterised by the type of the underlying Laurent series type (which must exist before Nemo can make use of it), instead of the type of the coefficients.","category":"page"},{"location":"Nemo/puiseux/#Puiseux-power-series","page":"Puiseux series","title":"Puiseux power series","text":"","category":"section"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Puiseux series have their maximum relative precision capped at some value prec_max. This refers to the maximum precision of the underlying Laurent series. See the description of the generic Puiseux series in AbstractAlgebra.jl for details.","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"There are numerous important things to be aware of when working with Puiseux series, or series in general. Please refer to the documentation of generic Puiseux series and  series in general in AbstractAlgebra.jl for details.","category":"page"},{"location":"Nemo/puiseux/#Puiseux-series-functionality","page":"Puiseux series","title":"Puiseux series functionality","text":"","category":"section"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Puiseux series rings in Nemo implement all the same functionality that is available for AbstractAlgebra series rings, with the exception of the pol_length and polcoeff functions:","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/series","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"In addition, generic Puiseux series are provided by AbstractAlgebra.jl","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"We list below only the functionality that differs from that described in AbstractAlgebra, for specific rings provided by Nemo.","category":"page"},{"location":"Nemo/puiseux/#Special-functions","page":"Puiseux series","title":"Special functions","text":"","category":"section"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Base.sqrt(a::FlintPuiseuxSeriesElem{fmpz_laurent_series})","category":"page"},{"location":"Nemo/puiseux/#sqrt-Tuple{FlintPuiseuxSeriesElem{fmpz_laurent_series}}","page":"Puiseux series","title":"sqrt","text":"Base.sqrt(f::PolyElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Base.exp(a::FlintPuiseuxSeriesElem{fmpz_laurent_series})","category":"page"},{"location":"Nemo/puiseux/#exp-Tuple{FlintPuiseuxSeriesElem{fmpz_laurent_series}}","page":"Puiseux series","title":"exp","text":"exp(a::AbsSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::RelSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"eta_qexp(x::FlintPuiseuxSeriesElem{fmpz_laurent_series})","category":"page"},{"location":"Nemo/puiseux/#eta_qexp-Tuple{FlintPuiseuxSeriesElem{fmpz_laurent_series}}","page":"Puiseux series","title":"eta_qexp","text":"eta_qexp(x::FlintPuiseuxSeriesElem{fmpz_laurent_series})\n\nReturn the q-series for eta evaluated at x, which must currently be a rational power of the generator of the Puiseux series ring.\n\n\n\n","category":"method"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"Examples","category":"page"},{"location":"Nemo/puiseux/","page":"Puiseux series","title":"Puiseux series","text":"S, x = PuiseuxSeriesRing(ZZ, 30, \"x\")\n\na = 1 + z + 3z^2 + O(z^5)\n\nh = sqrt(a^2)\nk = eta_qexp(S)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"CurrentModule = Oscar","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Pages = [\"NormalToricVarieties.md\"]","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#Normal-Toric-Varieties","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/#Introduction","page":"Normal Toric Varieties","title":"Introduction","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"We introduce two main types of normal toric varieties, distinguishing between the affine and non-affine case:","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"AffineNormalToricVariety is the toric variety associated to a cone sigma, denoted by U_sigma in David A. Cox, John B. Little, Henry K. Schenck (2011)\nNormalToricVariety is the toric variety associated to a polyhedral fan Sigma, denoted by X_Sigma in David A. Cox, John B. Little, Henry K. Schenck (2011)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"warning: Warning\nThe lattice is always assumed to be the standard lattice mathbbZ^n. Transformations for non-standard lattices will have to be done by the user.","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#Constructors","page":"Normal Toric Varieties","title":"Constructors","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/#Affine-Toric-Varieties","page":"Normal Toric Varieties","title":"Affine Toric Varieties","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"AffineNormalToricVariety(C::Cone)\nNormalToricVariety(C::Cone)\nAffineNormalToricVariety(v::NormalToricVariety)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#AffineNormalToricVariety-Tuple{Cone}","page":"Normal Toric Varieties","title":"AffineNormalToricVariety","text":"AffineNormalToricVariety(C::Cone)\n\nConstruct the affine normal toric variety U_C corresponding to a polyhedral cone C.\n\nExamples\n\nSet C to be the positive orthant in two dimensions.\n\njulia> C = positive_hull([1 0; 0 1])\nA polyhedral cone in ambient dimension 2\n\njulia> antv = AffineNormalToricVariety(C)\nA normal, affine toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#NormalToricVariety-Tuple{Cone}","page":"Normal Toric Varieties","title":"NormalToricVariety","text":"NormalToricVariety(C::Cone)\n\nConstruct the (affine) normal toric variety X_Sigma corresponding to a polyhedral fan Sigma = C consisting only of the cone C.\n\nExamples\n\nSet C to be the positive orthant in two dimensions.\n\njulia> C = positive_hull([1 0; 0 1])\nA polyhedral cone in ambient dimension 2\n\njulia> ntv = NormalToricVariety(C)\nA normal, affine toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#AffineNormalToricVariety-Tuple{NormalToricVariety}","page":"Normal Toric Varieties","title":"AffineNormalToricVariety","text":"AffineNormalToricVariety(v::NormalToricVariety)\n\nFor internal design, we make a strict distinction between normal toric varieties and affine toric varieties. Given an affine, normal toric variety v, this method turns it into an affine toric variety.\n\nExamples\n\njulia> v = NormalToricVariety(positive_hull([1 0; 0 1]))\nA normal, affine toric variety\n\njulia> affineVariety = AffineNormalToricVariety(v)\nA normal, affine toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Normal-Toric-Varieties-2","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"NormalToricVariety(rays::Vector{Vector{Int64}}, max_cones::Vector{Vector{Int64}})\nNormalToricVariety(PF::PolyhedralFan)\nNormalToricVariety(P::Polyhedron)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#NormalToricVariety-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}}","page":"Normal Toric Varieties","title":"NormalToricVariety","text":"NormalToricVariety(rays::Vector{Vector{Int64}}, max_cones::Vector{Vector{Int64}})\n\nConstruct a normal toric variety X by providing the rays and maximal cones as vector of vectors.\n\nExamples\n\njulia> ray_generators = [[1,0],[0,1],[-1,5],[0,-1]]\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [-1, 5]\n [0, -1]\n\njulia> max_cones = [[1,2],[2,3],[3,4],[4,1]]\n4-element Vector{Vector{Int64}}:\n [1, 2]\n [2, 3]\n [3, 4]\n [4, 1]\n\njulia> NormalToricVariety(ray_generators, max_cones)\nA normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#NormalToricVariety-Tuple{PolyhedralFan}","page":"Normal Toric Varieties","title":"NormalToricVariety","text":"NormalToricVariety(PF::PolyhedralFan)\n\nConstruct the normal toric variety X_PF corresponding to a polyhedral fan PF.\n\nExamples\n\nTake PF to be the normal fan of the square.\n\njulia> square = cube(2)\nA polyhedron in ambient dimension 2\n\njulia> nf = normal_fan(square)\nA polyhedral fan in ambient dimension 2\n\njulia> ntv = NormalToricVariety(nf)\nA normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#NormalToricVariety-Tuple{Polyhedron}","page":"Normal Toric Varieties","title":"NormalToricVariety","text":"NormalToricVariety(P::Polyhedron)\n\nConstruct the normal toric variety X_Sigma_P corresponding to the normal fan Sigma_P of the given polyhedron P.\n\nNote that this only coincides with the projective variety associated to P from the affine relations of the lattice points in P, if P is very ample.\n\nExamples\n\nSet P to be a square.\n\njulia> square = cube(2)\nA polyhedron in ambient dimension 2\n\njulia> ntv = NormalToricVariety(square)\nA normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Famous-Toric-Vareties","page":"Normal Toric Varieties","title":"Famous Toric Vareties","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"affine_space(::Type{NormalToricVariety}, d::Int)\ndel_pezzo(b::Int)\nhirzebruch_surface(r::Int)\nprojective_space(::Type{NormalToricVariety}, d::Int)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#affine_space-Tuple{Type{NormalToricVariety}, Int64}","page":"Normal Toric Varieties","title":"affine_space","text":"affine_space(::Type{NormalToricVariety}, d::Int)\n\nConstructs the (toric) affine space of dimension d.\n\nExamples\n\njulia> affine_space(NormalToricVariety, 2)\nA normal, affine, 2-dimensional toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#del_pezzo-Tuple{Int64}","page":"Normal Toric Varieties","title":"del_pezzo","text":"del_pezzo(b::Int)\n\nConstructs the delPezzo surface with b blowups for b at most 3.\n\nExamples\n\njulia> del_pezzo(3)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#hirzebruch_surface-Tuple{Int64}","page":"Normal Toric Varieties","title":"hirzebruch_surface","text":"hirzebruch_surface(r::Int)\n\nConstructs the r-th Hirzebruch surface.\n\nExamples\n\njulia> hirzebruch_surface(5)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#projective_space-Tuple{Type{NormalToricVariety}, Int64}","page":"Normal Toric Varieties","title":"projective_space","text":"projective_space(::Type{NormalToricVariety}, d::Int)\n\nConstruct the projective space of dimension d.\n\nExamples\n\njulia> projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Further-Constructions","page":"Normal Toric Varieties","title":"Further Constructions","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"blowup_on_ith_minimal_torus_orbit(v::AbstractNormalToricVariety, n::Int, coordinate_name::String)\nBase.:*(v::AbstractNormalToricVariety, w::AbstractNormalToricVariety)\nNormalToricVarietiesFromStarTriangulations(P::Polyhedron)\nNormalToricVarietyFromGLSM(charges::fmpz_mat)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#blowup_on_ith_minimal_torus_orbit-Tuple{Oscar.AbstractNormalToricVariety, Int64, String}","page":"Normal Toric Varieties","title":"blowup_on_ith_minimal_torus_orbit","text":"blowup_on_ith_minimal_torus_orbit(v::AbstractNormalToricVariety, n::Int, coordinate_name::String)\n\nReturn the blowup of the normal toric variety v on its i-th minimal torus orbit.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> bP2 = blowup_on_ith_minimal_torus_orbit(P2,1,\"e\")\nA normal toric variety over QQ\n\njulia> cox_ring(bP2)\nMultivariate Polynomial Ring in x2, x3, x1, e over Rational Field graded by\n  x2 -> [1 0]\n  x3 -> [0 1]\n  x1 -> [1 0]\n  e -> [-1 1]\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#*-Tuple{Oscar.AbstractNormalToricVariety, Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"*","text":"Base.:*(v::AbstractNormalToricVariety, w::AbstractNormalToricVariety)\n\nReturn the Cartesian/direct product of two normal toric varieties v and w.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> P2 * P2\nA normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#NormalToricVarietiesFromStarTriangulations-Tuple{Polyhedron}","page":"Normal Toric Varieties","title":"NormalToricVarietiesFromStarTriangulations","text":"NormalToricVarietiesFromStarTriangulations(P::Polyhedron)\n\nReturns the list of toric varieties obtained from fine regular star triangulations of the polyhedron P.\n\nExamples\n\njulia> P = convex_hull([0 0 0; 0 0 1; 1 0 1; 1 1 1; 0 1 1])\nA polyhedron in ambient dimension 3\n\njulia> NormalToricVarietiesFromStarTriangulations(P::Polyhedron)\n2-element Vector{NormalToricVariety}:\n A normal toric variety\n A normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#NormalToricVarietyFromGLSM-Tuple{fmpz_mat}","page":"Normal Toric Varieties","title":"NormalToricVarietyFromGLSM","text":"NormalToricVarietyFromGLSM(charges::fmpz_mat)\n\nWitten's Generalized-Sigma models (GLSM) Edward Witten (1988) originally sparked interest in the physics community in toric varieties. On a mathematical level, this establishes a construction of toric varieties for  which a Z^n grading of the Cox ring is provided. See for example Huijun Fan, Tyler Jarvis, Yongbin Ruan (2017), which describes this as GIT construction David A. Cox, John B. Little, Henry K. Schenck (2011).\n\nExplicitly, given the grading of the Cox ring, the map from the group of torus invariant Weil divisors to the class group is known. Under the assumption that the variety in question has no torus factor, we can then identify the map from the lattice to the group of torus invariant Weil divisors as the kernel of the map from the torus invariant Weil divisor to the class group. The latter is a map between free Abelian groups, i.e. is provided by an integer valued matrix. The rows of this matrix are nothing but the ray generators of the fan of the toric variety. It then remains to triangulate these rays, hence in general for a GLSM the toric variety is only unique up to fine regular star triangulations.\n\nExamples\n\njulia> charges = [[1,1,1]]\n1-element Vector{Vector{Int64}}:\n [1, 1, 1]\n\njulia> NormalToricVarietyFromGLSM(charges)\n1-element Vector{NormalToricVariety}:\n A normal toric variety\n\nFor convenience, we also support:\n\nNormalToricVarietyFromGLSM(charges::Vector{Vector{Int}})\nNormalToricVarietyFromGLSM(charges::Vector{Vector{fmpz}})\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Properties-of-Toric-Varieties","page":"Normal Toric Varieties","title":"Properties of Toric Varieties","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"hastorusfactor(v::AbstractNormalToricVariety)\nisaffine(v::AbstractNormalToricVariety)\niscomplete(v::AbstractNormalToricVariety)\nisfano(v::AbstractNormalToricVariety)\nisgorenstein(v::AbstractNormalToricVariety)\nissimplicial(v::AbstractNormalToricVariety)\nissmooth(v::AbstractNormalToricVariety)\nisnormal(v::AbstractNormalToricVariety)\nisorbifold(v::AbstractNormalToricVariety)\nisprojective(v::AbstractNormalToricVariety)\nis_projective_space(v::AbstractNormalToricVariety)\nis_q_gorenstein(v::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#hastorusfactor-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"hastorusfactor","text":"hastorusfactor(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v has a torus factor.\n\nExamples\n\njulia> hastorusfactor(projective_space(NormalToricVariety, 2))\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#isaffine-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"isaffine","text":"isaffine(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is affine.\n\nExamples\n\njulia> isaffine(projective_space(NormalToricVariety, 2))\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#iscomplete-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"iscomplete","text":"iscomplete(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is complete.\n\nExamples\n\njulia> iscomplete(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#isfano-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"isfano","text":"isfano(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is fano.\n\nExamples\n\njulia> isfano(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#isgorenstein-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"isgorenstein","text":"isgorenstein(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is Gorenstein.\n\nExamples\n\njulia> isgorenstein(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#issimplicial-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"issimplicial","text":"issimplicial(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is simplicial. Hence, this function works just as isorbifold. It is implemented for user convenience.\n\nExamples\n\njulia> issimplicial(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#issmooth-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"issmooth","text":"issmooth(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is smooth.\n\nExamples\n\njulia> issmooth(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#isnormal-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"isnormal","text":"isnormal(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is normal. (This function is somewhat tautological at this point.)\n\nExamples\n\njulia> isnormal(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#isorbifold-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"isorbifold","text":"isorbifold(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is an orbifold.\n\nExamples\n\njulia> isorbifold(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#isprojective-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"isprojective","text":"isprojective(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is projective, i.e. if the fan of v is the the normal fan of a polytope.\n\nExamples\n\njulia> isprojective(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#is_projective_space-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"is_projective_space","text":"is_projective_space(v::AbstractNormalToricVariety)\n\nDecides if the normal toric varieties v is a projective space.\n\nExamples\n\njulia> F5 = hirzebruch_surface(5)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> is_projective_space(F5)\nfalse\n\njulia> is_projective_space(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#is_q_gorenstein-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"is_q_gorenstein","text":"is_q_gorenstein(v::AbstractNormalToricVariety)\n\nChecks if the normal toric variety v is Q-Gorenstein.\n\nExamples\n\njulia> is_q_gorenstein(projective_space(NormalToricVariety, 2))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Operations-for-Toric-Varieties","page":"Normal Toric Varieties","title":"Operations for Toric Varieties","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/#Affine-Open-Covering","page":"Normal Toric Varieties","title":"Affine Open Covering","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"affine_open_covering( v::AbstractNormalToricVariety )","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#affine_open_covering-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"affine_open_covering","text":"affine_open_covering(v::AbstractNormalToricVariety)\n\nCompute an affine open cover of the normal toric variety v, i.e. returns a list of affine toric varieties.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> affine_open_covering(p2)\n3-element Vector{AffineNormalToricVariety}:\n A normal, affine toric variety\n A normal, affine toric variety\n A normal, affine toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Characters,-Weil-Divisors,-Cartier-Divisors,-Class-Group-and-Picard-Group","page":"Normal Toric Varieties","title":"Characters, Weil Divisors, Cartier Divisors, Class Group and Picard Group","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"torusinvariant_cartier_divisor_group(v::AbstractNormalToricVariety)\ncharacter_lattice(v::AbstractNormalToricVariety)\nclass_group(v::AbstractNormalToricVariety)\nmap_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group(v::AbstractNormalToricVariety)\nmap_from_torusinvariant_cartier_divisor_group_to_picard_group(v::AbstractNormalToricVariety)\nmap_from_character_lattice_to_torusinvariant_weil_divisor_group(v::AbstractNormalToricVariety)\nmap_from_torusinvariant_weil_divisor_group_to_class_group(v::AbstractNormalToricVariety)\npicard_group(v::AbstractNormalToricVariety)\ntorusinvariant_weil_divisor_group(v::AbstractNormalToricVariety)\ntorusinvariant_prime_divisors(v::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#torusinvariant_cartier_divisor_group-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"torusinvariant_cartier_divisor_group","text":"torusinvariant_cartier_divisor_group(v::AbstractNormalToricVariety)\n\nReturn the Cartier divisor group of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> torusinvariant_cartier_divisor_group(p2)\nGrpAb: Z^3\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#character_lattice-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"character_lattice","text":"character_lattice(v::AbstractNormalToricVariety)\n\nReturn the character lattice of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> character_lattice(p2)\nGrpAb: Z^2\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#class_group-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"class_group","text":"class_group(v::AbstractNormalToricVariety)\n\nReturn the class group of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> class_group(p2)\nGrpAb: Z\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#map_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"map_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group","text":"map_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group(v::AbstractNormalToricVariety)\n\nReturn the embedding of the group of Cartier divisors into the group of torus-invariant Weil divisors of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> map_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group(p2)\nIdentity map with\n\nDomain:\n=======\nGrpAb: Z^3\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#map_from_torusinvariant_cartier_divisor_group_to_picard_group-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"map_from_torusinvariant_cartier_divisor_group_to_picard_group","text":"map_from_torusinvariant_cartier_divisor_group_to_picard_group(v::AbstractNormalToricVariety)\n\nReturn the map from the Cartier divisors to the Picard group of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> map_from_torusinvariant_cartier_divisor_group_to_picard_group(p2)\nMap with following data\nDomain:\n=======\nAbelian group with structure: Z^3\nCodomain:\n=========\nAbelian group with structure: Z\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#map_from_character_lattice_to_torusinvariant_weil_divisor_group-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"map_from_character_lattice_to_torusinvariant_weil_divisor_group","text":"map_from_character_lattice_to_torusinvariant_weil_divisor_group(v::AbstractNormalToricVariety)\n\nReturn the map from the character lattice to the group of principal divisors of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> map_from_character_lattice_to_torusinvariant_weil_divisor_group(p2)\nMap with following data\nDomain:\n=======\nAbelian group with structure: Z^2\nCodomain:\n=========\nAbelian group with structure: Z^3\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#map_from_torusinvariant_weil_divisor_group_to_class_group-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"map_from_torusinvariant_weil_divisor_group_to_class_group","text":"map_from_torusinvariant_weil_divisor_group_to_class_group(v::AbstractNormalToricVariety)\n\nReturn the map from the group of Weil divisors to the class of group of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> map_from_torusinvariant_weil_divisor_group_to_class_group(p2)\nMap with following data\nDomain:\n=======\nAbelian group with structure: Z^3\nCodomain:\n=========\nAbelian group with structure: Z\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#picard_group-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"picard_group","text":"picard_group(v::AbstractNormalToricVariety)\n\nReturn the Picard group of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> picard_group(p2)\nGrpAb: Z\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#torusinvariant_weil_divisor_group-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"torusinvariant_weil_divisor_group","text":"torusinvariant_weil_divisor_group(v::AbstractNormalToricVariety)\n\nReturn the torusinvariant divisor group of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> torusinvariant_weil_divisor_group(p2)\nGrpAb: Z^3\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#torusinvariant_prime_divisors-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"torusinvariant_prime_divisors","text":"torusinvariant_prime_divisors(v::AbstractNormalToricVariety)\n\nReturn the list of all torus invariant prime divisors in a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> torusinvariant_prime_divisors(p2)\n3-element Vector{ToricDivisor}:\n A torus-invariant, prime divisor on a normal toric variety\n A torus-invariant, prime divisor on a normal toric variety\n A torus-invariant, prime divisor on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Cones-and-Fans","page":"Normal Toric Varieties","title":"Cones and Fans","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"fan(v::AbstractNormalToricVariety)\ncone(v::AffineNormalToricVariety)\nmori_cone(v::NormalToricVariety)\nnef_cone(v::NormalToricVariety)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#fan-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"fan","text":"fan(v::AbstractNormalToricVariety)\n\nReturn the fan of an abstract normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> fan(p2)\nA polyhedral fan in ambient dimension 2\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#cone-Tuple{AffineNormalToricVariety}","page":"Normal Toric Varieties","title":"cone","text":"cone(v::AffineNormalToricVariety)\n\nReturn the cone of the affine normal toric variety v.\n\nExamples\n\njulia> cone(AffineNormalToricVariety(Oscar.positive_hull([1 1; -1 1])))\nA polyhedral cone in ambient dimension 2\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#mori_cone-Tuple{NormalToricVariety}","page":"Normal Toric Varieties","title":"mori_cone","text":"mori_cone(v::NormalToricVariety)\n\nReturn the mori cone of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> mori = mori_cone(p2)\nA polyhedral cone in ambient dimension 1\n\njulia> dim(mori)\n1\n\n\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#nef_cone-Tuple{NormalToricVariety}","page":"Normal Toric Varieties","title":"nef_cone","text":"nef_cone(v::NormalToricVariety)\n\nReturn the nef cone of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> nef = nef_cone(p2)\nA polyhedral cone in ambient dimension 1\n\njulia> dim(nef)\n1\n\n\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Dimensions","page":"Normal Toric Varieties","title":"Dimensions","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"dim(v::AbstractNormalToricVariety)\ndim_of_torusfactor(v::AbstractNormalToricVariety)\neuler_characteristic(v::AbstractNormalToricVariety)\nbetti_number(v::AbstractNormalToricVariety, i::Int)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#dim-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"dim","text":"dim(v::AbstractNormalToricVariety)\n\nReturn the dimension of the normal toric variety v.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = AffineNormalToricVariety(C);\n\njulia> dim(antv)\n1\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#dim_of_torusfactor-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"dim_of_torusfactor","text":"dim_of_torusfactor(v::AbstractNormalToricVariety)\n\nReturn the dimension of the torus factor of the normal toric variety v.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = AffineNormalToricVariety(C);\n\njulia> dim_of_torusfactor(antv)\n1\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#euler_characteristic-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"euler_characteristic","text":"euler_characteristic(v::AbstractNormalToricVariety)\n\nReturn the Euler characteristic of the normal toric variety v.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = AffineNormalToricVariety(C);\n\njulia> euler_characteristic(antv)\n1\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#betti_number-Tuple{Oscar.AbstractNormalToricVariety, Int64}","page":"Normal Toric Varieties","title":"betti_number","text":"betti_number(v::AbstractNormalToricVariety, i::Int)\n\nCompute the i-th Betti number of the normal toric variety v.  Specifically, this method returns the dimension of the i-th  simplicial homology group (with rational coefficients) of v.  The employed algorithm is derived from theorem 12.3.12 in  David A. Cox, John B. Little, Henry K. Schenck (2011). Note that this theorem requires that the normal  toric variety v is both complete and simplicial.\n\nExamples\n\njulia> P3 = projective_space(NormalToricVariety,3)\nA normal, non-affine, smooth, projective, gorenstein, fano, 3-dimensional toric variety without torusfactor\n\njulia> betti_number(P3,0)\n1\n\njulia> betti_number(P3,1)\n0\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Rings-and-ideals","page":"Normal Toric Varieties","title":"Rings and ideals","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"We support the following rings and ideals for toric varieties:","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Cox ring (also termed the \"total coordinate ring\" in David A. Cox, John B. Little, Henry K. Schenck (2011)),\ncoordinate ring of torus,\ncohomology_ring,\nChow ring,\nirrelevant ideal,\nStanley-Reisner ideal,\nideal of linear relations,\ntoric ideal.","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Of course, for any of these coordinate names and the coefficient ring have to be chosen. We provide the following setter and getter functions:","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"coordinate_names(v::AbstractNormalToricVariety)\nset_coordinate_names(v::AbstractNormalToricVariety, coordinate_names::Vector{String})\ncoefficient_ring(v::AbstractNormalToricVariety)\nset_coefficient_ring(v::AbstractNormalToricVariety, coefficient_ring::AbstractAlgebra.Ring)\ncoordinate_names_of_torus(v::AbstractNormalToricVariety)\nset_coordinate_names_of_torus(v::AbstractNormalToricVariety, coordinate_names::Vector{String})","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#coordinate_names-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"coordinate_names","text":"coordinate_names(v::AbstractNormalToricVariety)\n\nThis method returns the names of the homogeneous coordinates of  the normal toric variety v. The default is x1,...,xn.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = AffineNormalToricVariety(C);\n\njulia> coordinate_names(antv)\n1-element Vector{String}:\n \"x1\"\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#set_coordinate_names-Tuple{Oscar.AbstractNormalToricVariety, Vector{String}}","page":"Normal Toric Varieties","title":"set_coordinate_names","text":"set_coordinate_names(v::AbstractNormalToricVariety, coordinate_names::Vector{String})\n\nAllows to set the names of the homogeneous coordinates.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = AffineNormalToricVariety(C);\n\njulia> set_coordinate_names(antv,[\"u\"])\n\njulia> coordinate_names(antv)\n1-element Vector{String}:\n \"u\"\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#coefficient_ring-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"coefficient_ring","text":"coefficient_ring(v::AbstractNormalToricVariety)\n\nThis method returns the coefficient_ring of the normal toric variety v. The default is the ring QQ.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = AffineNormalToricVariety(C);\n\njulia> coefficient_ring(antv) == QQ\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#set_coefficient_ring-Tuple{Oscar.AbstractNormalToricVariety, AbstractAlgebra.Ring}","page":"Normal Toric Varieties","title":"set_coefficient_ring","text":"set_coefficient_ring(v::AbstractNormalToricVariety, coefficient_ring::AbstractAlgebra.Ring)\n\nAllows to set the coefficient_ring. If the Cox ring of the variety has already been computed, we do not allow this to be changed. In this case an error is triggered.\n\nExamples\n\njulia> C = Oscar.positive_hull([1 0]);\n\njulia> antv = AffineNormalToricVariety(C);\n\njulia> set_coefficient_ring(antv, ZZ)\n\njulia> coefficient_ring(antv) == ZZ\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#coordinate_names_of_torus-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"coordinate_names_of_torus","text":"coordinate_names_of_torus(v::AbstractNormalToricVariety)\n\nThis method returns the names of the coordinates of the torus of the normal toric variety v. The default is x1,...,xn.\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#set_coordinate_names_of_torus-Tuple{Oscar.AbstractNormalToricVariety, Vector{String}}","page":"Normal Toric Varieties","title":"set_coordinate_names_of_torus","text":"set_coordinate_names_of_torus(v::AbstractNormalToricVariety, coordinate_names::Vector{String})\n\nAllows to set the names of the coordinates of the torus.\n\nExamples\n\njulia> F3 = hirzebruch_surface(3);\n\njulia> set_coordinate_names_of_torus(F3,[\"u\",\"v\"])\n\njulia> coordinate_names_of_torus(F3)\n2-element Vector{String}:\n \"u\"\n \"v\"\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"In order to efficiently construct algebraic cycles (elements of the Chox ring), cohomology classes (elements of the cohomology ring), or in order to compare ideals, it is imperative to fix the choices of coordinates and coefficient rings. This happens once any of the above rings is computed for the variety. One can check the status as follows:","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"is_finalized(v::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#is_finalized-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"is_finalized","text":"is_finalized(v::AbstractNormalToricVariety)\n\nChecks if the Cox ring, the coordinate ring of the torus, the cohomology_ring, the Chow ring, the Stanley-Reisner ideal, the irrelevant ideal, the ideal of linear relations or the toric ideal has been cached. If any of these has been cached, then this function returns true and otherwise false.\n\nExamples\n\njulia> is_finalized(del_pezzo(3))\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"The default value for coordinate names is [x1, x2, ... ]. The default for the coefficient ring is the field of rational numbers. The following methods provide access to the above rings and ideals:","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"cox_ring(v::AbstractNormalToricVariety)\nirrelevant_ideal(v::AbstractNormalToricVariety)\nideal_of_linear_relations(v::AbstractNormalToricVariety)\nstanley_reisner_ideal(v::AbstractNormalToricVariety)\ntoric_ideal(antv::AffineNormalToricVariety)\ncoordinate_ring_of_torus(v::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#cox_ring-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"cox_ring","text":"cox_ring(v::AbstractNormalToricVariety)\n\nComputes the Cox ring of the normal toric variety v. Note that David A. Cox, John B. Little, Henry K. Schenck (2011) refers to this ring as the \"total coordinate ring\".\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> set_coordinate_names(p2, [\"y1\", \"y2\", \"y3\"])\n\njulia> set_coefficient_ring(p2, ZZ)\n\njulia> cox_ring(p2)\nMultivariate Polynomial Ring in y1, y2, y3 over Integer Ring graded by \n  y1 -> [1]\n  y2 -> [1]\n  y3 -> [1]\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#irrelevant_ideal-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"irrelevant_ideal","text":"irrelevant_ideal(v::AbstractNormalToricVariety)\n\nReturn the irrelevant ideal of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> length(gens(irrelevant_ideal(p2)))\n3\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#ideal_of_linear_relations-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"ideal_of_linear_relations","text":"ideal_of_linear_relations(v::AbstractNormalToricVariety)\n\nReturn the ideal of linear relations of the simplicial and complete toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> ngens(ideal_of_linear_relations(p2))\n2\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#stanley_reisner_ideal-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"stanley_reisner_ideal","text":"stanley_reisner_ideal(v::AbstractNormalToricVariety)\n\nReturn the Stanley-Reisner ideal of a normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> ngens(stanley_reisner_ideal(p2))\n1\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#toric_ideal-Tuple{AffineNormalToricVariety}","page":"Normal Toric Varieties","title":"toric_ideal","text":"toric_ideal(antv::AffineNormalToricVariety)\n\nReturn the toric ideal defining the affine normal toric variety.\n\nExamples\n\nTake the cone over the square at height one. The resulting toric variety has one defining equation. In projective space this corresponds to mathbbP^1timesmathbbP^1. Note that this cone is self-dual, the toric ideal comes from the dual cone.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 0 1; 1 1 1])\nA polyhedral cone in ambient dimension 3\n\njulia> antv = AffineNormalToricVariety(C)\nA normal, affine toric variety\n\njulia> toric_ideal(antv)\nideal(-x1*x2 + x3*x4)\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#coordinate_ring_of_torus-Tuple{Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"coordinate_ring_of_torus","text":"coordinate_ring_of_torus(v::AbstractNormalToricVariety)\n\nComputes the coordinate ring of the torus of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> set_coordinate_names_of_torus(p2, [\"y1\", \"y2\"])\n\njulia> coordinate_ring_of_torus(p2)\nQuotient of Multivariate Polynomial Ring in y1, y2, y1_, y2_ over Rational Field by ideal(y1*y1_ - 1, y2*y2_ - 1)\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"After the variety finalized, one can enforce obtain the above ideals in different rings. Also, one can opt to compute the above rings with a different choice of coordinate names or a different coefficient ring. To this end, once provides a custom ring (which reflects the desired choice of coordinate names and coefficient ring) as first argument. However, note that the cached ideals and rings are not altered.","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"cox_ring(R::MPolyRing, v::AbstractNormalToricVariety)\nirrelevant_ideal(R::MPolyRing, v::AbstractNormalToricVariety)\nideal_of_linear_relations(R::MPolyRing, v::AbstractNormalToricVariety)\nstanley_reisner_ideal(R::MPolyRing, v::AbstractNormalToricVariety)\ntoric_ideal(R::MPolyRing, antv::AffineNormalToricVariety)\ncoordinate_ring_of_torus(R::MPolyRing, v::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#cox_ring-Tuple{MPolyRing, Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"cox_ring","text":"cox_ring(R::MPolyRing, v::AbstractNormalToricVariety)\n\nComputes the Cox ring of the normal toric variety v, in this case by adding the Cox grading to the given ring R. Note that David A. Cox, John B. Little, Henry K. Schenck (2011) refers to this ring as the \"total coordinate ring\".\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R,_ = PolynomialRing(QQ, 3);\n\njulia> cox_ring(R, p2)\nMultivariate Polynomial Ring in x1, x2, x3 over Rational Field graded by \n  x1 -> [1]\n  x2 -> [1]\n  x3 -> [1]\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#irrelevant_ideal-Tuple{MPolyRing, Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"irrelevant_ideal","text":"irrelevant_ideal(R::MPolyRing, v::AbstractNormalToricVariety)\n\nReturn the irrelevant ideal of a normal toric variety v as an ideal in R.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R,_ = PolynomialRing(QQ, 3);\n\njulia> length(gens(irrelevant_ideal(R, p2)))\n3\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#ideal_of_linear_relations-Tuple{MPolyRing, Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"ideal_of_linear_relations","text":"ideal_of_linear_relations(R::MPolyRing, v::AbstractNormalToricVariety)\n\nReturn the ideal of linear relations of the simplicial and complete toric variety v in the ring R.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R,_ = PolynomialRing(QQ, 3);\n\njulia> ngens(ideal_of_linear_relations(R, p2))\n2\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#stanley_reisner_ideal-Tuple{MPolyRing, Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"stanley_reisner_ideal","text":"stanley_reisner_ideal(R::MPolyRing, v::AbstractNormalToricVariety)\n\nReturn the Stanley-Reisner ideal of a normal toric variety v as an ideal of R.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R,_ = PolynomialRing(QQ, 3);\n\njulia> ngens(stanley_reisner_ideal(R, p2))\n1\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#toric_ideal-Tuple{MPolyRing, AffineNormalToricVariety}","page":"Normal Toric Varieties","title":"toric_ideal","text":"toric_ideal(R::MPolyRing, antv::AffineNormalToricVariety)\n\nReturn the toric ideal defining the affine normal toric variety as an ideal in R.\n\nExamples\n\nTake the cone over the square at height one. The resulting toric variety has one defining equation. In projective space this corresponds to mathbbP^1timesmathbbP^1. Note that this cone is self-dual, the toric ideal comes from the dual cone.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 0 1; 1 1 1])\nA polyhedral cone in ambient dimension 3\n\njulia> antv = AffineNormalToricVariety(C)\nA normal, affine toric variety\n\njulia> R,_ = PolynomialRing(QQ, 4);\n\njulia> toric_ideal(R, antv)\nideal(-x1*x2 + x3*x4)\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#coordinate_ring_of_torus-Tuple{MPolyRing, Oscar.AbstractNormalToricVariety}","page":"Normal Toric Varieties","title":"coordinate_ring_of_torus","text":"coordinate_ring_of_torus(R::MPolyRing, v::AbstractNormalToricVariety)\n\nComputes the coordinate ring of the torus of the normal toric variety v in the given polynomial ring R.\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"Along the same lines, characters can be turned into rational functions:","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"character_to_rational_function(v::AbstractNormalToricVariety, character::Vector{fmpz})\ncharacter_to_rational_function(R::MPolyRing, v::AbstractNormalToricVariety, character::Vector{fmpz})","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#character_to_rational_function-Tuple{Oscar.AbstractNormalToricVariety, Vector{fmpz}}","page":"Normal Toric Varieties","title":"character_to_rational_function","text":"character_to_rational_function(v::AbstractNormalToricVariety, character::Vector{fmpz})\n\nComputes the rational function corresponding to a character of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> character_to_rational_function(p2, [-1,2])\nx2^2*x1_\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#character_to_rational_function-Tuple{MPolyRing, Oscar.AbstractNormalToricVariety, Vector{fmpz}}","page":"Normal Toric Varieties","title":"character_to_rational_function","text":"character_to_rational_function(R::MPolyRing, v::AbstractNormalToricVariety, character::Vector{fmpz})\n\nComputes the rational function corresponding to a character of the normal toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> R,_ = PolynomialRing(QQ, 4);\n\njulia> character_to_rational_function(R, p2, [-1,2])\nx2^2*x3\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#Auxillary-Methods","page":"Normal Toric Varieties","title":"Auxillary Methods","text":"","category":"section"},{"location":"ToricVarieties/NormalToricVarieties/","page":"Normal Toric Varieties","title":"Normal Toric Varieties","text":"binomial_exponents_to_ideal(binoms::Union{AbstractMatrix, fmpz_mat})\ntoric_ideal(pts::fmpz_mat)","category":"page"},{"location":"ToricVarieties/NormalToricVarieties/#binomial_exponents_to_ideal-Tuple{Union{fmpz_mat, AbstractMatrix{T} where T}}","page":"Normal Toric Varieties","title":"binomial_exponents_to_ideal","text":"binomial_exponents_to_ideal(binoms::Union{AbstractMatrix, fmpz_mat})\n\nThis function converts the rows of a matrix to binomials. Each row r is written as r=u-v with uvge 0 by splitting into positive and negative entries. Then the row r corresponds to x^u-x^v.  The resulting ideal is returned.\n\nExamples\n\njulia> A = [-1 -1 0 2; 2 3 -2 -1]\n2×4 Matrix{Int64}:\n -1  -1   0   2\n  2   3  -2  -1\n\njulia> binomial_exponents_to_ideal(A)\nideal(-x1*x2 + x4^2, x1^2*x2^3 - x3^2*x4)\n\n\n\n","category":"method"},{"location":"ToricVarieties/NormalToricVarieties/#toric_ideal-Tuple{fmpz_mat}","page":"Normal Toric Varieties","title":"toric_ideal","text":"toric_ideal(pts::fmpz_mat)\n\nReturn the toric ideal generated from the linear relations between the points pts. This is the ideal generated by the set of binomials x^u-x^v  uvinmathbbZ^n_ge 0 (pts)^Tcdot(u-v)=0\n\nExamples\n\njulia> C = positive_hull([-2 5; 1 0]);\n\njulia> H = hilbert_basis(C);\n\njulia> toric_ideal(H)\nideal(x2*x3 - x4^2, -x1*x3 + x2^2*x4, -x1*x4 + x2^3, -x1*x3^2 + x2*x4^3, -x1*x3^3 + x4^5)\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#NfOrdIdlLink","page":"Ideals","title":"Ideals","text":"","category":"section"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"(Integral) ideals in orders are always free Z-module of the same rank as the order, hence have a representation via a Z-basis. This can be made unique by normalising the corresponding matrix to be in reduced row echelon form (HNF).","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"For ideals in maximal orders Z_K, we also have a second presentation coming from the Z_K module structure and the fact that Z_K is a Dedekind ring: ideals can be generated by 2 elements, one of which can be any non-zero element in the ideal.","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"For efficiency, we will choose the 1st generator to be an integer.","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"Ideals here are of type NfAbsOrdIdl, which is, similar to the elements above, also indexed by the type of the field and their elements: NfAbsOrdIdl{AnticNumberField,nf_elem} for ideals in simple absolute fields.","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"Different to elements, the parentof an ideal is teh set of all ideals in the ring, of type NfAbsOrdIdlSet.","category":"page"},{"location":"Hecke/orders/ideals/#Creation","page":"Ideals","title":"Creation","text":"","category":"section"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"ideal(::NfOrd, ::fmpz)\nideal(::NfOrd, ::fmpz_mat)\nideal(::NfOrd, ::NfOrdElem)\nideal(::NfOrd, ::fmpz, ::NfOrdElem)\nideal(::NfAbsOrd, ::fmpz, ::NfAbsOrdElem)\nideal(::NfAbsOrd, ::fmpz)\nideal(::NfAbsOrd, ::NfAbsOrdElem)\n\n*(::NfOrd, ::NfOrdElem)\nfactor(::NfOrdIdl)\nfactor(::nf_elem, ::NfOrdIdlSet)\ncoprime_base(::Vector{NfOrdIdl})","category":"page"},{"location":"Hecke/orders/ideals/#ideal-Tuple{NfOrd, fmpz}","page":"Ideals","title":"ideal","text":"ideal(O::NfOrd, a::fmpz) -> NfAbsOrdIdl\nideal(O::NfOrd, a::Integer) -> NfAbsOrdIdl\n\nReturns the ideal of mathcal O which is generated by a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ideal-Tuple{NfOrd, fmpz_mat}","page":"Ideals","title":"ideal","text":"ideal(O::NfOrd, x::fmpz_mat, check::Bool = false, x_in_hnf::Bool = false) -> NfAbsOrdIdl\n\nCreates the ideal of mathcal O with basis matrix x. If check is set, then it is checked whether x defines an ideal (expensive). If x_in_hnf is set, then it is assumed that x is already in lower left HNF.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ideal-Tuple{NfOrd, NfOrdElem}","page":"Ideals","title":"ideal","text":"ideal(O::NfOrd, x::NfOrdElem) -> NfAbsOrdIdl\n\nCreates the principal ideal (x) of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ideal-Tuple{NfOrd, fmpz, NfOrdElem}","page":"Ideals","title":"ideal","text":"ideal(O::NfOrd, x::fmpz, y::NfOrdElem) -> NfAbsOrdIdl\nideal(O::NfOrd, x::Integer, y::NfOrdElem) -> NfAbsOrdIdl\n\nCreates the ideal (x y) of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ideal-Tuple{NfAbsOrd, fmpz, NfAbsOrdElem}","page":"Ideals","title":"ideal","text":"ideal(O::NfOrd, x::fmpz, y::NfOrdElem) -> NfAbsOrdIdl\nideal(O::NfOrd, x::Integer, y::NfOrdElem) -> NfAbsOrdIdl\n\nCreates the ideal (x y) of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ideal-Tuple{NfAbsOrd, fmpz}","page":"Ideals","title":"ideal","text":"ideal(O::NfOrd, a::fmpz) -> NfAbsOrdIdl\nideal(O::NfOrd, a::Integer) -> NfAbsOrdIdl\n\nReturns the ideal of mathcal O which is generated by a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ideal-Tuple{NfAbsOrd, NfAbsOrdElem}","page":"Ideals","title":"ideal","text":"ideal(O::NfOrd, x::NfOrdElem) -> NfAbsOrdIdl\n\nCreates the principal ideal (x) of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#*-Tuple{NfOrd, NfOrdElem}","page":"Ideals","title":"*","text":"*(O::NfOrd, x::NfOrdElem) -> NfAbsOrdIdl\n*(x::NfAbsOrdElem, O::NfAbsOrd) -> NfAbsOrdIdl\n\nReturns the principal ideal (x) of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#factor-Tuple{NfOrdIdl}","page":"Ideals","title":"factor","text":"factor(A::NfOrdIdl) -> Dict{NfOrdIdl, Int}\n\nComputes the prime ideal factorization A as a dictionary, the keys being the prime ideal divisors: If lp = factor_dict(A), then keys(lp) are the prime ideal divisors of A and lp[P] is the P-adic valuation of A for all P in keys(lp).\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#factor-Tuple{nf_elem, Hecke.NfAbsOrdIdlSet{AnticNumberField, nf_elem}}","page":"Ideals","title":"factor","text":"factor(a::nf_elem, I::NfOrdIdlSet) -> Dict{NfOrdIdl, fmpz}\n\nFactors the principal ideal generated by a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#coprime_base-Tuple{Vector{NfOrdIdl}}","page":"Ideals","title":"coprime_base","text":"coprime_base(A::Vector{NfOrdIdl}) -> Vector{NfOrdIdl}\ncoprime_base(A::Vector{NfOrdElem}) -> Vector{NfOrdIdl}\n\nA coprime base for the (principal) ideals in A, i.e. the returned array generated multiplicatively the same ideals as the input and are pairwise coprime.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#Arithmetic","page":"Ideals","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"All the usual operations are supported:","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"==, +, *\ndivexact, divides\nlcm, gcd\nin","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"intersect(::NfOrdIdl, ::NfOrdIdl)\ncolon(::NfOrdIdl, ::NfOrdIdl)\nin(::NfOrdElem, ::NfAbsOrdIdl)\nispower(::NfAbsOrdIdl, ::Int)\nispower(::NfAbsOrdIdl)\nisinvertible(::NfOrdIdl)\nisone(::NfOrdIdl)","category":"page"},{"location":"Hecke/orders/ideals/#intersect-Tuple{NfOrdIdl, NfOrdIdl}","page":"Ideals","title":"intersect","text":"intersect(x::NfOrdIdl, y::NfOrdIdl) -> NfOrdIdl\n\nReturns x cap y.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#colon-Tuple{NfOrdIdl, NfOrdIdl}","page":"Ideals","title":"colon","text":"colon(a::NfAbsOrdIdl, b::NfAbsOrdIdl) -> NfOrdFracIdl\n\nThe ideal (ab) = x in K  xb subseteq a = hom(b a) where K is the number field.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#in-Tuple{NfOrdElem, NfAbsOrdIdl}","page":"Ideals","title":"in","text":"in(x::NumFieldOrdElem, y::NumFieldOrdIdl)\nin(x::NumFieldElem, y::NumFieldOrdIdl)\nin(x::fmpz, y::NumFieldOrdIdl)\n\nReturns whether x is contained in y.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ispower-Tuple{NfAbsOrdIdl, Int64}","page":"Ideals","title":"ispower","text":"ispower(A::NfAbsOrdIdl, n::Int) -> Bool, NfAbsOrdIdl\nispower(A::NfOrdFracIdl, n::Int) -> Bool, NfOrdFracIdl\n\nComputes, if possible, an ideal B s.th. B^n==A holds. In this case, true and B are returned.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ispower-Tuple{NfAbsOrdIdl}","page":"Ideals","title":"ispower","text":"ispower(I::NfAbsOrdIdl) -> Int, NfAbsOrdIdl\nispower(a::NfOrdFracIdl) -> Int, NfOrdFracIdl\n\nWrites a = r^e with e maximal. Note: 1 = 1^0.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#isinvertible-Tuple{NfOrdIdl}","page":"Ideals","title":"isinvertible","text":"isinvertible(A::NfAbsOrdIdl) -> Bool, NfOrdFracIdl\n\nReturns true and an inverse of A or false and an ideal B such that A*B subsetneq order(A), if A is not invertible.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#isone-Tuple{NfOrdIdl}","page":"Ideals","title":"isone","text":"isone(A::NfAbsOrdIdl) -> Bool\nisunit(A::NfAbsOrdIdl) -> Bool\n\nTests if A is the trivial ideal generated by 1.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#Class-Group","page":"Ideals","title":"Class Group","text":"","category":"section"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"The group of invertable ideals in any order forms a group and the principal ideals a subgroup.  The finite quotient is called class group for maximal orders and Picard group or ring class group in general.","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"class_group(::NfOrd)\nnarrow_class_group(::NfOrd)\npicard_group(::NfOrd)\nring_class_group(::NfAbsOrd)","category":"page"},{"location":"Hecke/orders/ideals/#class_group-Tuple{NfOrd}","page":"Ideals","title":"class_group","text":"class_group(O::NfOrd; bound = -1, method = 3, redo = false, large = 1000) -> GrpAbFinGen, Map\n\nReturns a group A and a map f from A to the set of ideals of O. The inverse of the map is the projection onto the group of ideals modulo the group of principal ideals. redo allows to trigger a re-computation, thus avoiding the cache. bound, when given, is the bound for the factor base.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#narrow_class_group-Tuple{NfOrd}","page":"Ideals","title":"narrow_class_group","text":"narrow_class_group(O::NfOrd) -> GrpAbFinGen, Map\n\nComputes the narrow (or strict) class group of O, ie. the group of invertable ideals modulo principal ideals generated by elements that are positive at all real places.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#picard_group-Tuple{NfOrd}","page":"Ideals","title":"picard_group","text":"picard_group(O::NfOrd) -> GrpAbFinGen, MapClassGrp\n\nReturns the Picard group of O and a map from the group in the set of (invertible) ideals of O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ring_class_group-Tuple{NfAbsOrd}","page":"Ideals","title":"ring_class_group","text":"ring_class_group(O::NfAbsOrd)\n\nThe ring class group (Picard group) of O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"using Hecke # hide\nk, a = wildanger_field(3, 13);\nzk = maximal_order(k);\nc, mc = class_group(zk)\nlp = prime_ideals_up_to(zk, 20);\n[ mc \\ I for I = lp]\nmc(c[1])\norder(c[1])\nmc(c[1])^Int(order(c[1]))\nmc \\ ans","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"The class group, or more precisely the information used to compute it also allows for principal ideal testing and related tasks. In general, due to the size of the objetcs, the fac_elem versions are more effcient.","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"Hecke.isprincipal(::NfOrdIdl)\nisprincipal_fac_elem(::NfAbsOrdIdl{AnticNumberField,nf_elem})\npower_class(::NfOrdIdl,::fmpz)\npower_product_class(::Vector{NfOrdIdl}, ::Vector{fmpz})\npower_reduce(::NfAbsOrdIdl{AnticNumberField,nf_elem},::fmpz)\nclass_group_ideal_relation(::NfAbsOrdIdl{AnticNumberField,nf_elem}, ::Hecke.ClassGrpCtx)\nfactor_base_bound_grh(::NfOrd)\nfactor_base_bound_bach(::NfOrd)\nprime_ideals_up_to","category":"page"},{"location":"Hecke/orders/ideals/#isprincipal-Tuple{NfOrdIdl}","page":"Ideals","title":"isprincipal","text":"isprincipal(A::NfOrdIdl) -> Bool, NfOrdElem\nisprincipal(A::NfOrdFracIdl) -> Bool, NfOrdElem\n\nTests if A is principal and returns (mathtttrue alpha) if A = langle alpharangle or (mathttfalse 1) otherwise.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#isprincipal_fac_elem-Tuple{NfOrdIdl}","page":"Ideals","title":"isprincipal_fac_elem","text":"isprincipal_fac_elem(A::NfOrdIdl) -> Bool, FacElem{nf_elem, NumberField}\n\nTests if A is principal and returns (mathtttrue alpha) if A = langle alpharangle or (mathttfalse 1) otherwise. The generator will be in factored form.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#power_class-Tuple{NfOrdIdl, fmpz}","page":"Ideals","title":"power_class","text":"power_class(A::NfOrdIdl, e::fmpz) -> NfOrdIdl\n\nComputes a (small) ideal in the same class as A^e.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#power_product_class-Tuple{Vector{NfOrdIdl}, Vector{fmpz}}","page":"Ideals","title":"power_product_class","text":"power_product_class(A::Vector{NfOrdIdl}, e::Vector{fmpz}) -> NfOrdIdl\n\nComputes a (small) ideal in the same class as prod A_i^e_i.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#power_reduce-Tuple{NfOrdIdl, fmpz}","page":"Ideals","title":"power_reduce","text":"power_reduce(A::NfOrdIdl, e::fmpz) -> NfOrdIdl, FacElem{nf_elem}\n\nComputes B and alpha in factored form, such that alpha B = A^e B has small norm.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#class_group_ideal_relation-Tuple{NfOrdIdl, Hecke.ClassGrpCtx}","page":"Ideals","title":"class_group_ideal_relation","text":"class_group_ideal_relation(I::NfOrdIdl, c::ClassGrpCtx) -> nf_elem, SRow{fmpz}\n\nFinds a number field element alpha such that alpha I factors over the factor base in c.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#factor_base_bound_grh-Tuple{NfOrd}","page":"Ideals","title":"factor_base_bound_grh","text":"factor_base_bound_grh(O::NfOrd) -> Int\n\nReturns an integer B, such that under GRH the ideal class group of mathcal O is generated by the prime ideals of norm bounded by B.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#factor_base_bound_bach-Tuple{NfOrd}","page":"Ideals","title":"factor_base_bound_bach","text":"factor_base_bound_bach(O::NfOrd) -> Int\n\nUse the theorem of Bach to find B such that under GRH the ideal class group of mathcal O is generated by the prime ideals of norm bounded by B.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#prime_ideals_up_to","page":"Ideals","title":"prime_ideals_up_to","text":"prime_ideals_up_to(O::NfOrd,\n                   B::Int;\n                   degree_limit::Int = 0, index_divisors::Bool = true) -> Vector{NfOrdIdl}\n\nComputes the prime ideals mathcal O with norm up to B.\n\nIf degree_limit is a nonzero integer k, then prime ideals mathfrak p with deg(mathfrak p)  k will be discarded. If 'index_divisors' is set to false, only primes not dividing the index of the order will be computed.\n\n\n\nprime_ideals_up_to(O::NfOrd,\n                   B::Int;\n                   complete::Bool = false,\n                   degree_limit::Int = 0,\n                   F::Function,\n                   bad::fmpz)\n\nComputes the prime ideals mathcal O with norm up to B.\n\nIf degree_limit is a nonzero integer k, then prime ideals mathfrak p with deg(mathfrak p)  k will be discarded.\n\nThe function F must be a function on prime numbers not dividing bad such that F(p) = deg(mathfrak p) for all prime ideals mathfrak p lying above p.\n\n\n\n","category":"function"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"I = mc(c[1])\nHecke.isprincipal(I)\nI = I^Int(order(c[1]))\nHecke.isprincipal(I)\nHecke.isprincipal_fac_elem(I)","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"The computation of S-units is also tied to the class group:","category":"page"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"torsion_units(::NfOrd)\ntorsion_unit_group(::NfOrd)\ntorsion_units_generator(::NfOrd)\nHecke.torsion_units_gen_order(::NfOrd)\nunit_group(::NfOrd)\nunit_group_fac_elem(::NfOrd)\nsunit_group(::Vector{NfOrdIdl})\nsunit_group_fac_elem(::Vector{NfOrdIdl})\nsunit_mod_units_group_fac_elem(::Vector{NfOrdIdl})","category":"page"},{"location":"Hecke/orders/ideals/#torsion_units-Tuple{NfOrd}","page":"Ideals","title":"torsion_units","text":"torsion_units(O::NfOrd) -> Vector{NfOrdElem}\n\nGiven an order O, compute the torsion units of O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#torsion_unit_group-Tuple{NfOrd}","page":"Ideals","title":"torsion_unit_group","text":"torsion_unit_group(O::NfOrd) -> GrpAb, Map\n\nGiven an order mathcal O, returns the torsion units as an abelian group G together with a map G to mathcal O^times.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#torsion_units_generator-Tuple{NfOrd}","page":"Ideals","title":"torsion_units_generator","text":"torsion_units_generator(O::NfOrd) -> NfOrdElem\n\nGiven an order O, compute a generator of the torsion units of O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#torsion_units_gen_order-Tuple{NfOrd}","page":"Ideals","title":"torsion_units_gen_order","text":"torsion_units_gen_order(O::NfOrd) -> NfOrdElem\n\nGiven an order O, compute a generator of the torsion units of O as well as its order.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#unit_group-Tuple{NfOrd}","page":"Ideals","title":"unit_group","text":"unit_group(O::NfOrd) -> GrpAbFinGen, Map\n\nReturns a group U and an isomorphism map f colon U to mathcal O^times. A set of fundamental units of mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_group_rank(O) ]. f(U[1]) will give a generator for the torsion subgroup.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#unit_group_fac_elem-Tuple{NfOrd}","page":"Ideals","title":"unit_group_fac_elem","text":"unit_group_fac_elem(O::NfOrd) -> GrpAbFinGen, Map\n\nReturns a group U and an isomorphism map f colon U to mathcal O^times. A set of fundamental units of mathcal O can be obtained via [ f(U[1+i]) for i in 1:unit_group_rank(O) ]. f(U[1]) will give a generator for the torsion subgroup. All elements will be returned in factored form.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#sunit_group-Tuple{Vector{NfOrdIdl}}","page":"Ideals","title":"sunit_group","text":"sunit_group(I::Vector{NfOrdIdl}) -> GrpAb, Map\n\nFor an array I of (coprime prime) ideals, find the S-unit group defined by I, ie. the group of non-zero field elements which are only divisible by ideals in I.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#sunit_group_fac_elem-Tuple{Vector{NfOrdIdl}}","page":"Ideals","title":"sunit_group_fac_elem","text":"sunit_group_fac_elem(I::Vector{NfOrdIdl}) -> GrpAb, Map\n\nFor an array I of (coprime prime) ideals, find the S-unit group defined by I, ie. the group of non-zero field elements which are only divisible by ideals in I. The map will return elements in factored form.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#sunit_mod_units_group_fac_elem-Tuple{Vector{NfOrdIdl}}","page":"Ideals","title":"sunit_mod_units_group_fac_elem","text":"sunit_mod_units_group_fac_elem(I::Vector{NfOrdIdl}) -> GrpAb, Map\n\nFor an array I of (coprime prime) ideals, find the S-unit group defined by I, ie. the group of non-zero field elements which are only divisible by ideals in I modulo the units of the field. The map will return elements in factored form.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"u, mu = unit_group(zk)\nmu(u[2])\nu, mu = unit_group_fac_elem(zk)\nmu(u[2])\nevaluate(ans)\nlp = factor(6*zk)\ns, ms = Hecke.sunit_group(collect(keys(lp)))\nms(s[4])\nnorm(ans)\nfactor(numerator(ans))","category":"page"},{"location":"Hecke/orders/ideals/#Miscaellenous","page":"Ideals","title":"Miscaellenous","text":"","category":"section"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"order(::NfAbsOrdIdl)\norder(::NfAbsOrdFracIdl)\norder(::NfRelOrdIdl)\norder(::NfRelOrdFracIdl)\nnf(::NfAbsOrdIdl)\nbasis(::NfOrdIdl)\nHecke.lll_basis(::NfOrdIdl)\nbasis_matrix(::NfAbsOrdIdl)\nbasis_mat_inv(::NfOrdIdl)\nHecke.assure_has_basis_mat_inv(::NfOrdIdl)\nHecke.has_basis(::NfOrdIdl)\nHecke.has_basis_matrix(::NfOrdIdl)\nHecke.has_2_elem(::NfOrdIdl)\nHecke.has_2_elem_normal(::NfOrdIdl)\nHecke.has_weakly_normal(::NfOrdIdl)\nHecke.has_princ_gen_special(::NfOrdIdl)\nHecke.principal_generator(::NfOrdIdl)\nHecke.principal_generator_fac_elem(::NfOrdIdl)\nminimum(::NfOrdIdl)\nminimum(::NfRelOrdIdl)\nminimum(::NfAbsOrdIdl)\nhas_minimum(::NfOrdIdl)\nnorm(::NfOrdIdl)\nHecke.has_norm(::NfOrdIdl)\nidempotents(::NfOrdIdl, ::NfOrdIdl)\nisprime(::NfOrdIdl)\nHecke.isprime_known(::NfOrdIdl)\nisramified(::NfOrd, ::Union{Int, fmpz})\nramification_index(::NfOrdIdl)\ndegree(::NfOrdIdl)\nvaluation(::nf_elem, ::NfOrdIdl)\nvaluation(::NfOrdElem, ::NfOrdIdl)\nvaluation(::NfOrdIdl, ::NfOrdIdl)\nvaluation(::Integer, ::NfOrdIdl)\nvaluation(::fmpz, ::NfOrdIdl)\nvaluation(::NfOrdFracIdl, ::NfOrdIdl)\nidempotents(::NfAbsOrdIdl, ::NfAbsOrdIdl)","category":"page"},{"location":"Hecke/orders/ideals/#order-Tuple{NfAbsOrdIdl}","page":"Ideals","title":"order","text":"order(I::NumFieldOrdIdl) -> NfOrd\n\nReturns the order of I.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#order-Tuple{Hecke.NfAbsOrdFracIdl}","page":"Ideals","title":"order","text":"order(a::NfAbsOrdFracIdl) -> NfAbsOrd\n\nThe order that was used to define the ideal a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#order-Tuple{Hecke.NfRelOrdIdl}","page":"Ideals","title":"order","text":"order(I::NumFieldOrdIdl) -> NfOrd\n\nReturns the order of I.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#order-Tuple{Hecke.NfRelOrdFracIdl}","page":"Ideals","title":"order","text":"order(a::NfRelOrdFracIdl) -> NfRelOrd\n\nReturns the order of a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#nf-Tuple{NfAbsOrdIdl}","page":"Ideals","title":"nf","text":"nf(x::NumFieldOrdIdl) -> AnticNumberField\n\nReturns the number field, of which x is an integral ideal.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#basis-Tuple{NfOrdIdl}","page":"Ideals","title":"basis","text":"basis(A::NfAbsOrdIdl) -> Vector{NfOrdElem}\n\nReturns the basis of A.\n\n\n\nbasis(I::NfAbsOrdFracIdl) -> Vector{nf_elem}\n\nReturns the mathbf Z-basis of I.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#lll_basis-Tuple{NfOrdIdl}","page":"Ideals","title":"lll_basis","text":"lll_basis(I::NumFieldOrdIdl) -> Vector{NumFieldElem}\n\nA basis for I that is reduced using the LLL algorithm for the Minkowski metric.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#basis_matrix-Tuple{NfAbsOrdIdl}","page":"Ideals","title":"basis_matrix","text":"basis_matrix(A::NfAbsOrdIdl) -> fmpz_mat\n\nReturns the basis matrix of A.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#basis_mat_inv-Tuple{NfOrdIdl}","page":"Ideals","title":"basis_mat_inv","text":"basis_mat_inv(O::NfAbsOrd) -> FakeFmpqMat\n\nReturns the inverse of the basis matrix of mathcal O.\n\n\n\nbasis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat\n\nReturns the inverse basis matrix of A.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#assure_has_basis_mat_inv-Tuple{NfOrdIdl}","page":"Ideals","title":"assure_has_basis_mat_inv","text":"basis_mat_inv(A::NfAbsOrdIdl) -> FakeFmpqMat\n\nReturns the inverse of the basis matrix of A.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#has_basis-Tuple{NfOrdIdl}","page":"Ideals","title":"has_basis","text":"has_basis(A::NfAbsOrdIdl) -> Bool\n\nReturns whether A has a basis already computed.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#has_basis_matrix-Tuple{NfOrdIdl}","page":"Ideals","title":"has_basis_matrix","text":"has_basis_matrix(A::NfAbsOrdIdl) -> Bool\n\nReturns whether A knows its basis matrix.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#has_2_elem-Tuple{NfOrdIdl}","page":"Ideals","title":"has_2_elem","text":"has_2_elem(A::NfAbsOrdIdl) -> Bool\n\nReturns whether A is generated by two elements.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#has_2_elem_normal-Tuple{NfOrdIdl}","page":"Ideals","title":"has_2_elem_normal","text":"has_2_elem_normal(A::NfAbsOrdIdl) -> Bool\n\nReturns whether A has normal two element generators.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#has_weakly_normal-Tuple{NfOrdIdl}","page":"Ideals","title":"has_weakly_normal","text":"has_weakly_normal(A::NfAbsOrdIdl) -> Bool\n\nReturns whether A has weakly normal two element generators.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#has_princ_gen_special-Tuple{NfOrdIdl}","page":"Ideals","title":"has_princ_gen_special","text":"has_princ_gen_special(A::NfAbsOrdIdl) -> Bool\n\nReturns whether A knows if it is generated by a rational integer.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#principal_generator-Tuple{NfOrdIdl}","page":"Ideals","title":"principal_generator","text":"principal_generator(A::NfOrdIdl) -> NfOrdElem\n\nFor a principal ideal A, find a generator.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#principal_generator_fac_elem-Tuple{NfOrdIdl}","page":"Ideals","title":"principal_generator_fac_elem","text":"principal_generator_fac_elem(A::NfOrdIdl) -> FacElem{nf_elem, NumberField}\n\nFor a principal ideal A, find a generator in factored form.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#minimum-Tuple{NfOrdIdl}","page":"Ideals","title":"minimum","text":"minimum(A::NfAbsOrdIdl) -> fmpz\n\nReturns the smallest nonnegative element in A cap mathbf Z.\n\n\n\n  minimum(A::NfRelOrdIdl) -> NfOrdIdl\n  minimum(A::NfRelOrdIdl) -> NfRelOrdIdl\n\nReturns the ideal A cap O where O is the maximal order of the coefficient ideals of A.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#minimum-Tuple{Hecke.NfRelOrdIdl}","page":"Ideals","title":"minimum","text":"  minimum(A::NfRelOrdIdl) -> NfOrdIdl\n  minimum(A::NfRelOrdIdl) -> NfRelOrdIdl\n\nReturns the ideal A cap O where O is the maximal order of the coefficient ideals of A.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#minimum-Tuple{NfAbsOrdIdl}","page":"Ideals","title":"minimum","text":"minimum(A::NfAbsOrdIdl) -> fmpz\n\nReturns the smallest nonnegative element in A cap mathbf Z.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#has_minimum-Tuple{NfOrdIdl}","page":"Ideals","title":"has_minimum","text":"has_minimum(A::NfAbsOrdIdl) -> Bool\n\nReturns whether A knows its mininum.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#norm-Tuple{NfOrdIdl}","page":"Ideals","title":"norm","text":"norm(A::NfAbsOrdIdl) -> fmpz\n\nReturns the norm of A, that is, the cardinality of mathcal OA, where mathcal O is the order of A.\n\n\n\nnorm(a::NfRelOrdIdl) -> NfOrdIdl\n\nReturns the norm of a.\n\n\n\nnorm(a::NfRelOrdFracIdl{T, S}) -> S\n\nReturns the norm of a.\n\n\n\nnorm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq\n\nReturns the norm of a considered as an (possibly fractional) ideal of O.\n\n\n\nnorm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true)\n  where { S, T, U } -> T\n\nReturns the norm of a considered as an (possibly fractional) ideal of O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#has_norm-Tuple{NfOrdIdl}","page":"Ideals","title":"has_norm","text":"has_norm(A::NfAbsOrdIdl) -> Bool\n\nReturns whether A knows its norm.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#idempotents-Tuple{NfOrdIdl, NfOrdIdl}","page":"Ideals","title":"idempotents","text":"idempotents(x::NfOrdIdl, y::NfOrdIdl) -> NfOrdElem, NfOrdElem\n\nReturns a tuple (e, f) consisting of elements e in x, f in y such that 1 = e + f.\n\nIf the ideals are not coprime, an error is raised.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#isprime-Tuple{NfOrdIdl}","page":"Ideals","title":"isprime","text":"isprime(A::NfOrdIdl) -> Bool\n\nReturns whether A is a prime ideal.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#isprime_known-Tuple{NfOrdIdl}","page":"Ideals","title":"isprime_known","text":"isprime_known(A::NfOrdIdl) -> Bool\n\nReturns whether A knows if it is prime.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#isramified-Tuple{NfOrd, Union{Int64, fmpz}}","page":"Ideals","title":"isramified","text":"isramified(O::NfOrd, p::Int) -> Bool\n\nReturns whether the integer p is ramified in mathcal O. It is assumed that p is prime.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ramification_index-Tuple{NfOrdIdl}","page":"Ideals","title":"ramification_index","text":"ramification_index(P::NfOrdIdl) -> Int\n\nThe ramification index of the prime-ideal P.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#degree-Tuple{NfOrdIdl}","page":"Ideals","title":"degree","text":"degree(P::NfOrdIdl) -> Int\n\nThe inertia degree of the prime-ideal P.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#valuation-Tuple{nf_elem, NfOrdIdl}","page":"Ideals","title":"valuation","text":"valuation(a::NumFieldElem, p::NfOrdIdl) -> fmpz\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#valuation-Tuple{NfOrdElem, NfOrdIdl}","page":"Ideals","title":"valuation","text":"valuation(a::nf_elem, p::NfOrdIdl) -> fmpz\nvaluation(a::NfOrdElem, p::NfOrdIdl) -> fmpz\nvaluation(a::fmpz, p::NfOrdIdl) -> fmpz\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#valuation-Tuple{NfOrdIdl, NfOrdIdl}","page":"Ideals","title":"valuation","text":"valuation(A::NfOrdIdl, p::NfOrdIdl) -> fmpz\n\nComputes the mathfrak p-adic valuation of A, that is, the largest i such that A is contained in mathfrak p^i.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#valuation-Tuple{Integer, NfOrdIdl}","page":"Ideals","title":"valuation","text":"valuation(a::Integer, p::NfOrdIdl) -> fmpz\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#valuation-Tuple{fmpz, NfOrdIdl}","page":"Ideals","title":"valuation","text":"valuation(a::nf_elem, p::NfOrdIdl) -> fmpz\nvaluation(a::NfOrdElem, p::NfOrdIdl) -> fmpz\nvaluation(a::fmpz, p::NfOrdIdl) -> fmpz\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#valuation-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}, NfOrdIdl}","page":"Ideals","title":"valuation","text":"valuation(A::NfAbsOrdFracIdl, p::NfAbsOrdIdl)\n\nThe valuation of A at p.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#idempotents-Tuple{NfAbsOrdIdl, NfAbsOrdIdl}","page":"Ideals","title":"idempotents","text":"idempotents(x::NfOrdIdl, y::NfOrdIdl) -> NfOrdElem, NfOrdElem\n\nReturns a tuple (e, f) consisting of elements e in x, f in y such that 1 = e + f.\n\nIf the ideals are not coprime, an error is raised.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#Quotient-Rings","page":"Ideals","title":"Quotient Rings","text":"","category":"section"},{"location":"Hecke/orders/ideals/","page":"Ideals","title":"Ideals","text":"quo(::Union{NfAbsOrd, AlgAssAbsOrd}, ::Union{NfAbsOrdIdl, AlgAssAbsOrdIdl})\nResidueRing(::NfOrd, ::NfOrdIdl)\nResidueField(::NfOrd, ::NfOrdIdl, ::Bool)\nmod(::NfOrdElem, ::NfAbsOrdIdl)\ncrt(::NfOrdElem, ::NfOrdIdl, ::NfOrdElem, ::NfOrdIdl)\neuler_phi(::NfOrdIdl)\nHecke.multiplicative_group(::NfOrdQuoRing)\nHecke.multiplicative_group_generators(::NfOrdQuoRing)","category":"page"},{"location":"Hecke/orders/ideals/#quo-Tuple{Union{Hecke.AlgAssAbsOrd, NfAbsOrd}, Union{Hecke.AlgAssAbsOrdIdl, NfAbsOrdIdl}}","page":"Ideals","title":"quo","text":"quo(O::NfOrd, I::NfOrdIdl) -> NfOrdQuoRing, Map\nquo(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl) -> AbsOrdQuoRing, Map\n\nThe quotient ring OI as a ring together with the section M OI to O. The pointwise inverse of M is the canonical projection Oto OI.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ResidueRing-Tuple{NfOrd, NfOrdIdl}","page":"Ideals","title":"ResidueRing","text":"ResidueRing(O::NfOrd, I::NfOrdIdl) -> NfOrdQuoRing\nResidueRing(O::AlgAssAbsOrd, I::AlgAssAbsOrdIdl) -> AbsOrdQuoRing\n\nThe quotient ring O modulo I as a new ring.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#ResidueField-Tuple{NfOrd, NfOrdIdl, Bool}","page":"Ideals","title":"ResidueField","text":"ResidueField(O::NfOrd, P::NfOrdIdl, check::Bool = true) -> Field, Map\n\nReturns the residue field of the prime ideal P together with the projection map. If check is true, the ideal is checked for being prime.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#mod-Tuple{NfOrdElem, NfAbsOrdIdl}","page":"Ideals","title":"mod","text":"mod(x::NfOrdElem, I::NfAbsOrdIdl)\n\nReturns the unique element y of the ambient order of x with x equiv y bmod I and the following property: If a_1dotsca_d in mathbfZ_geq 1 are the diagonal entries of the unique HNF basis matrix of I and (b_1dotscb_d) is the coefficient vector of y, then 0 leq b_i  a_i for 1 leq i leq d.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#crt-Tuple{NfOrdElem, NfOrdIdl, NfOrdElem, NfOrdIdl}","page":"Ideals","title":"crt","text":"crt(r1::NfOrdElem, i1::NfOrdIdl, r2::NfOrdElem, i2::NfOrdIdl) -> NfOrdElem\n\nFind x such that x equiv r_1 bmod i_1 and x equiv r_2 bmod i_2 using idempotents.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#euler_phi-Tuple{NfOrdIdl}","page":"Ideals","title":"euler_phi","text":"euler_phi(A::NfOrdIdl) -> fmpz\n\nThe ideal version of the totient function returns the size of the unit group of the residue ring modulo the ideal.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#multiplicative_group-Tuple{NfOrdQuoRing}","page":"Ideals","title":"multiplicative_group","text":"multiplicative_group(Q::NfOrdQuoRing) -> GrpAbFinGen, Map{GrpAbFinGen, NfOrdQuoRing}\nunit_group(Q::NfOrdQuoRing) -> GrpAbFinGen, Map{GrpAbFinGen, NfOrdQuoRing}\n\nReturns the unit group of Q as an abstract group A and an isomorphism map f colon A to Q^times.\n\n\n\n","category":"method"},{"location":"Hecke/orders/ideals/#multiplicative_group_generators-Tuple{NfOrdQuoRing}","page":"Ideals","title":"multiplicative_group_generators","text":"multiplicative_group_generators(Q::NfOrdQuoRing) -> Vector{NfOrdQuoRingElem}\n\nReturn a set of generators for Q^times.\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/serialization/#Serialization","page":"Serialization","title":"Serialization","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"warning: Warning\nNever load data from an untrusted source. Loading data is inherently unsafe and at this point allows arbitrary code execution on your machine. Just as you should never run a program from someone you do not trust, you should also not load their data.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"warning: Warning\nSerialization development has just started and the concrete design may still change drastically. In particular the mechanism for upgrading old data to newer versions is not in place yet, so at this point we do not yet guarantee that old data can be read.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"This document summarises the serialization efforts of OSCAR, how it is supposed to work, how it works and the overall goal. Serialization broadly speaking is the process of writing data to and reading data from files. There are many reasons for needing this feature in OSCAR, but the main reason is communication on mathematics by mathematicians.","category":"page"},{"location":"DeveloperDocumentation/serialization/#How-it-works","page":"Serialization","title":"How it works","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The mechanism for saving and loading is very simple. It is implemented via two methods save and load, and works in the following manner:","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"julia> t = 42\n42\n\njulia> save(t, \"fourtitwo.json\");\n\njulia> tt = load(\"fourtitwo.json\");\n\njulia> t == tt\ntrue","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"As hinted by the filename, OSCAR writes a file in JSON format. The file looks as follow:","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"{\n    \"_ns\": {\n        \"Oscar\": [\n            \"https://github.com/oscar-system/Oscar.jl\",\n            {\n                \"major\": 0,\n                \"minor\": 8,\n                \"patch\": 3,\n                \"prerelease\": [\n                    \"DEV\"\n                ],\n                \"build\": []\n            }\n        ]\n    },\n    \"id\": \"-1\",\n    \"type\": \"Base.Int\",\n    \"data\": \"42\"\n}","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"It contains the version of OSCAR it was written by, its type, and the actual content, in this case as a string.","category":"page"},{"location":"DeveloperDocumentation/serialization/#The-id","page":"Serialization","title":"The id","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"If you look at the file src/Serialization/main.jl, you will see that all save methods hand down a SerializerState, and all load methods have a DeserializerState. These two objects are very simple, they just contain dictionaries connecting objects and their id. We use this to avoid saving or loading larger objects twice (or multiple times). Consider the following example code snippet:","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"c = cube(3);\nLP0 = LinearProgram(c, [2,2,-3]);\nLP1 = LinearProgram(c, [2,2,4]);\nv = [LP0, LP1];\nsave(v, \"vector_of_lp.json\")","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"This creates two linear programs on the cube, stores them in a vector and then writes this vector to a file. It would be wasteful to store the cube twice for each linear program, instead it is only stored once and the second linear program just gets the id of the cube in its serialized form. Please take some time to look at the file written in this concrete example.","category":"page"},{"location":"DeveloperDocumentation/serialization/#The-version-number","page":"Serialization","title":"The version number","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"We will use the version number for checking compatibility of the data with the current OSCAR version before attempting to load it. If the data version is lower than the OSCAR version we will provide appropriate upgrade scripts such that the data can be loaded. We will not provide scripts for attempting to downgrade data, but we will throw a warning or even error in this case. We may provide an option for attempting to load anyway in such a scenario.","category":"page"},{"location":"DeveloperDocumentation/serialization/#Implementation","page":"Serialization","title":"Implementation","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"All files for serialization can be found in the folder src/Serialization. The naming conventions of the files there follows the overall structure of OSCAR, i.e. the file src/Serialization/PolyhedralGeometry.jl contains functions for serializing objects of the polyhedral geometry section.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The file main.jl contains the core of the serialization process, namely:","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"reading and writing files;\nthe SerializerState and DeserializerState objects;\nwriting and reading vesions; and\ngeneric functions for attempting to serialize objects that do not have their own dedicated serialization methods.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"If you want to write a serialization routine for an object, the way to go is to implement the following two functions, here in the example for fmpz:","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"function load_internal(s::DeserializerState, ::Type{fmpz}, str::String)\n    return fmpz(str)\nend\n\nfunction save_internal(s::SerializerState, z::fmpz)\n    return string(z)\nend","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Then the main serialization methods will dispatch to load_internal and save_internal for fmpz instead of attempting the generic serialization.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Often the generic serialization will fail and it is necessary to provide a save_internal and load_internal function. In that case, please have a look at the existing functions to get an idea of how these work, and maybe use something of this as a blueprint.","category":"page"},{"location":"DeveloperDocumentation/serialization/#Challenges","page":"Serialization","title":"Challenges","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"This section documents the various challenges we (will) encounter while implementing this feature.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"OSCAR is based on several subsystems, some of which already have their own serialization. We want this to be compatible, if possible in both directions.\nMany mathematical objects need context to be understood. A polynomial needs the ring it lives in, a group element needs the surrounding group, a divisor needs the underlying variety, etc. We will need a way to store this context along the objects.\nContext should not be stored twice: A matrix of polynomials should only store the surrounding ring once.\nSupport other data formats: It has been proposed to not only support JSON, but binary formats needed for HPC communication as well. It is unclear whether this needs a separate implementation.\nVersioning and upgrading: Work on OSCAR will change what its objects look like. Nevertheless, we still want to be able load data written by older versions of OSCAR. For this we inted to develop an upgrade mechanism.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"Another important point is the wider mathematical context of the data and code. For data associated to a publication, this context is provided by the paper.","category":"page"},{"location":"DeveloperDocumentation/serialization/#Goals","page":"Serialization","title":"Goals","text":"","category":"section"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The general goal is to make mathematical data FAIR, a goal for which we cooperate with the MaRDI project.","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"The ramifications of making mathematical data FAIR are manifold. ","category":"page"},{"location":"DeveloperDocumentation/serialization/","page":"Serialization","title":"Serialization","text":"It becomes easier to exchange data and code with fellow mathematicians, enhancing communication and boosting research.\nComputer experiments and new implementations require a lot of work and hence deserve to be recognized in form of a publication. Standardizing data plays an important role for this process.\nFuture generations of mathematicians will be able to reuse both data and code if we establish a FAIR culture.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Univariate-polynomials-over-a-noncommutative-ring","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"AbstractAlgebra.jl provides a module, implemented in src/NCPoly.jl for univariate polynomials over any noncommutative ring in the AbstractAlgebra type hierarchy.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Generic-type-for-univariate-polynomials-over-a-noncommutative-ring","page":"Univariate polynomials over a noncommutative ring","title":"Generic type for univariate polynomials over a noncommutative ring","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"AbstractAlgebra.jl implements a generic univariate polynomial type over noncommutative rings in src/generic/NCPoly.jl.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"These generic polynomials have type Generic.NCPoly{T} where T is the type of elements of the coefficient ring. Internally they consist of a Julia array of coefficients and some additional fields for length and a parent object, etc. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Parent objects of such polynomials have type Generic.NCPolyRing{T}.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"The string representation of the variable of the polynomial ring and the base/coefficient ring R is stored in the parent object.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Abstract-types","page":"Univariate polynomials over a noncommutative ring","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"The polynomial element types belong to the abstract type NCPolyElem{T} and the polynomial ring types belong to the abstract type NCPolyRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra polynomial type.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"note: Note\nNote that both the generic polynomial ring type Generic.NCPolyRing{T} and the abstract type it belongs to, NCPolyRing{T} are both called NCPolyRing. The  former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Polynomial-ring-constructors","page":"Univariate polynomials over a noncommutative ring","title":"Polynomial ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"In order to construct polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"PolynomialRing(R::NCRing, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Given a base ring R and string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new polynomial ring S = Rx and the generator x of the ring. By default the parent object S will depend only on R and  x and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"A shorthand version of this function is provided: given a base ring R, we abbreviate the constructor as follows.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"R[\"x\"]","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Here are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> U, z = R[\"z\"]\n(Univariate Polynomial Ring in z over Matrix Algebra of degree 2 over Integers, z)\n\njulia> f = S()\n0\n\njulia> g = S(123)\n[123 0; 0 123]\n\njulia> h = T(BigInt(1234))\n[1234 0; 0 1234]\n\njulia> k = T(x + 1)\nx + 1\n\njulia> m = U(z + 1)\nz + 1\n","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"All of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a PolynomialRing constructor to allow creation of their polynomial rings.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Basic-ring-functionality","page":"Univariate polynomials over a noncommutative ring","title":"Basic ring functionality","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"The easiest way is simply using the generator returned by the PolynomialRing constructor and build up the polynomial using basic arithmetic, as described in the Ring interface. ","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"The Julia language also has special syntax for the construction of polynomials in terms of a generator, e.g. we can write 2x instead of 2*x.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"The polynomial rings in AbstractAlgebra.jl implement the full Ring interface. Of course the entire Univariate Polynomial Ring interface is also implemented.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"We give some examples of such functionality.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x^3 + 3x + 21\nx^3 + [3 0; 0 3]*x + [21 0; 0 21]\n\njulia> g = (x + 1)*y^2 + 2x + 1\n(x + 1)*y^2 + [2 0; 0 2]*x + 1\n\njulia> h = zero(T)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = length(g)\n3\n\njulia> U = base_ring(T)\nUnivariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers\n\njulia> V = base_ring(y + 1)\nUnivariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers\n\njulia> v = var(T)\n:y\n\njulia> U = parent(y + 1)\nUnivariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers\n\njulia> g == deepcopy(g)\ntrue","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Polynomial-functionality-provided-by-AbstractAlgebra.jl","page":"Univariate polynomials over a noncommutative ring","title":"Polynomial functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"The functionality listed below is automatically provided by AbstractAlgebra.jl for any polynomial module that implements the full Univariate Polynomial Ring interface over a noncommutative ring. This includes AbstractAlgebra.jl's own generic polynomial rings.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"But if a C library provides all the functionality documented in the Univariate Polynomial Ring interface over a noncommutative ring, then all the functions described here will also be automatically supplied by AbstractAlgebra.jl for that polynomial type.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Of course, modules are free to provide specific implementations of the functions described here, that override the generic implementation.","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Basic-functionality","page":"Univariate polynomials over a noncommutative ring","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"leading_coefficient(::NCPolyElem)\ntrailing_coefficient(::NCPolyElem)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#leading_coefficient-Tuple{NCPolyElem}","page":"Univariate polynomials over a noncommutative ring","title":"leading_coefficient","text":"leading_coefficient(a::PolynomialElem)\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/#trailing_coefficient-Tuple{NCPolyElem}","page":"Univariate polynomials over a noncommutative ring","title":"trailing_coefficient","text":"trailing_coefficient(a::PolynomialElem)\n\nReturn the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial is the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"gen(::NCPolyRing)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#gen-Tuple{AbstractAlgebra.NCPolyRing}","page":"Univariate polynomials over a noncommutative ring","title":"gen","text":"gen(R::NCPolyRing)\n\nReturn the generator of the given polynomial ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"isgen(::NCPolyElem)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#isgen-Tuple{NCPolyElem}","page":"Univariate polynomials over a noncommutative ring","title":"isgen","text":"isgen(a::PolynomialElem)\n\nReturn true if the given polynomial is the constant generator of its polynomial ring, otherwise return false.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"ismonomial(::NCPolyElem)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#ismonomial-Tuple{NCPolyElem}","page":"Univariate polynomials over a noncommutative ring","title":"ismonomial","text":"ismonomial(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"isterm(::NCPolyElem)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#isterm-Tuple{NCPolyElem}","page":"Univariate polynomials over a noncommutative ring","title":"isterm","text":"isterm(a::PolynomialElem)\n\nReturn true if the given polynomial has one term.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> a = zero(T)\n0\n\njulia> b = one(T)\n1\n\njulia> c = BigInt(1)*y^2 + BigInt(1)\ny^2 + 1\n\njulia> d = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> f = leading_coefficient(d)\nx\n\njulia> y = gen(T)\ny\n\njulia> g = isgen(y)\ntrue\n\njulia> m = isunit(b)\ntrue\n\njulia> n = degree(d)\n2\n\njulia> isterm(2y^2)\ntrue\n\njulia> ismonomial(y^2)\ntrue\n","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Truncation","page":"Univariate polynomials over a noncommutative ring","title":"Truncation","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"truncate(::NCPolyElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#truncate-Tuple{NCPolyElem, Int64}","page":"Univariate polynomials over a noncommutative ring","title":"truncate","text":"truncate(a::PolynomialElem, n::Int)\n\nReturn a truncated to n terms.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"mullow(::NCPolyElem{T}, ::NCPolyElem{T}, ::Int) where T <: NCRingElem","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#mullow-Union{Tuple{T}, Tuple{NCPolyElem{T}, NCPolyElem{T}, Int64}} where T<:NCRingElem","page":"Univariate polynomials over a noncommutative ring","title":"mullow","text":"mullow(a::NCPolyElem{T}, b::NCPolyElem{T}, n::Int) where T <: NCRingElem\n\nReturn atimes b truncated to n terms.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + [2 0; 0 2]*x + [2 0; 0 2]\n\njulia> h = truncate(f, 1)\n[3 0; 0 3]\n\njulia> k = mullow(f, g, 4)\n(x^2 + x)*y^3 + (x^4 + [3 0; 0 3]*x^2 + [4 0; 0 4]*x + 1)*y^2 + (x^4 + x^3 + [2 0; 0 2]*x^2 + [7 0; 0 7]*x + [5 0; 0 5])*y + [3 0; 0 3]*x^3 + [6 0; 0 6]*x + [6 0; 0 6]\n","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Reversal","page":"Univariate polynomials over a noncommutative ring","title":"Reversal","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"reverse(::NCPolyElem, ::Int)\nreverse(::NCPolyElem)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#reverse-Tuple{NCPolyElem, Int64}","page":"Univariate polynomials over a noncommutative ring","title":"reverse","text":"reverse(x::PolynomialElem, len::Int)\n\nReturn the reverse of the polynomial x, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length). The resulting polynomial is normalised. If len is negative we throw a DomainError().\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/#reverse-Tuple{NCPolyElem}","page":"Univariate polynomials over a noncommutative ring","title":"reverse","text":"reverse(x::PolynomialElem)\n\nReturn the reverse of the polynomial x, i.e. the leading coefficient of x becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> g = reverse(f, 7)\n[3 0; 0 3]*y^6 + (x + 1)*y^5 + x*y^4\n\njulia> h = reverse(f)\n[3 0; 0 3]*y^2 + (x + 1)*y + x\n","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Shifting","page":"Univariate polynomials over a noncommutative ring","title":"Shifting","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"shift_left(::NCPolyElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#shift_left-Tuple{NCPolyElem, Int64}","page":"Univariate polynomials over a noncommutative ring","title":"shift_left","text":"shift_left(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"shift_right(::NCPolyElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#shift_right-Tuple{NCPolyElem, Int64}","page":"Univariate polynomials over a noncommutative ring","title":"shift_right","text":"shift_right(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted right by n terms, i.e. divided by x^n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> g = shift_left(f, 7)\nx*y^9 + (x + 1)*y^8 + [3 0; 0 3]*y^7\n\njulia> h = shift_right(f, 2)\nx\n","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Evaluation","page":"Univariate polynomials over a noncommutative ring","title":"Evaluation","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"evaluate{T <: NCRingElem}(::NCPolyElem{T}, ::T)\nevaluate(::NCPolyElem, ::Integer)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#evaluate-Union{Tuple{T}, Tuple{NCPolyElem{T}, T}} where T<:NCRingElem","page":"Univariate polynomials over a noncommutative ring","title":"evaluate","text":"evaluate(a::NCPolyElem, b::T) where T <: NCRingElem\n\nEvaluate the polynomial a at the value b and return the result.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/#evaluate-Tuple{NCPolyElem, Integer}","page":"Univariate polynomials over a noncommutative ring","title":"evaluate","text":"evaluate(a::NCPolyElem, b::Union{Integer, Rational, AbstractFloat})\n\nEvaluate the polynomial a at the value b and return the result.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"We also overload the functional notation so that the polynomial f can be evaluated at a by writing f(a). ","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> k = evaluate(f, 3)\n[12 0; 0 12]*x + [6 0; 0 6]\n\njulia> m = evaluate(f, x^2 + 2x + 1)\nx^5 + [4 0; 0 4]*x^4 + [7 0; 0 7]*x^3 + [7 0; 0 7]*x^2 + [4 0; 0 4]*x + [4 0; 0 4]\n\njulia> r = f(23)\n[552 0; 0 552]*x + [26 0; 0 26]\n","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#Derivative","page":"Univariate polynomials over a noncommutative ring","title":"Derivative","text":"","category":"section"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"derivative(::NCPolyElem)","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/#derivative-Tuple{NCPolyElem}","page":"Univariate polynomials over a noncommutative ring","title":"derivative","text":"derivative(a::PolynomialElem)\n\nReturn the derivative of the polynomial a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ncpolynomial/","page":"Univariate polynomials over a noncommutative ring","title":"Univariate polynomials over a noncommutative ring","text":"julia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> S, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, x)\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Matrix Algebra of degree 2 over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + [3 0; 0 3]\n\njulia> h = derivative(f)\n[2 0; 0 2]*x*y + x + 1\n","category":"page"},{"location":"Hecke/abelian/structural/#Structural-Computations","page":"-","title":"Structural Computations","text":"","category":"section"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"Abelian groups support a wide range of structural operations such as","category":"page"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"enumeration of subgroups\n(outer) direct products\ntensor and hom constructions\nfree resolutions and general complexes\n(co)-homology and tensor and hom-functors","category":"page"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"snf(A::GrpAbFinGen)\nHecke.find_isomorphism(G, op, A::Hecke.GrpAb)","category":"page"},{"location":"Hecke/abelian/structural/#snf-Tuple{GrpAbFinGen}","page":"-","title":"snf","text":"snf(A::GrpAbFinGen) -> GrpAbFinGen, Map\n\nReturns a pair (G f), where G is an abelian group in canonical Smith normal form isomorphic to G and an isomorphism f  G to A.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#find_isomorphism-Tuple{Any, Any, Hecke.GrpAb}","page":"-","title":"find_isomorphism","text":"find_isomorphism(G, op, A::GrpAb) -> Dict, Dict\n\nGiven an abelian group A and a collection G which is an abelian group with the operation op, this functions returns isomorphisms G to A and A to G encoded as dictionaries.\n\nIt is assumed that G and A are isomorphic.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#Subgroups-and-Quotients","page":"-","title":"Subgroups and Quotients","text":"","category":"section"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"torsion_subgroup(G::GrpAbFinGen)\nsub(G::GrpAbFinGen, s::Vector{GrpAbFinGenElem})\nsub(s::Vector{GrpAbFinGenElem})\nsub(G::GrpAbFinGen, M::fmpz_mat)\nsub(G::GrpAbFinGen, n::fmpz)\nsub(G::GrpAbFinGen, n::Integer)\npsylow_subgroup(G::GrpAbFinGen, p::Union{fmpz, Integer})\nHecke.has_quotient(G::GrpAbFinGen, invariant::Vector{Int})\nHecke.has_complement(f::GrpAbFinGenMap)","category":"page"},{"location":"Hecke/abelian/structural/#torsion_subgroup-Tuple{GrpAbFinGen}","page":"-","title":"torsion_subgroup","text":"torsion_subgroup(G::GrpAbFinGen) -> GrpAbFinGen, Map\n\nReturns the torsion subgroup of G.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#sub-Tuple{GrpAbFinGen, Vector{GrpAbFinGenElem}}","page":"-","title":"sub","text":"sub(G::GrpAbFinGen, s::Vector{GrpAbFinGenElem}) -> GrpAbFinGen, Map\n\nCreate the subgroup H of G generated by the elements in s together with the injection iota  H to G.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#sub-Tuple{Vector{GrpAbFinGenElem}}","page":"-","title":"sub","text":"sub(s::Vector{GrpAbFinGenElem}) -> GrpAbFinGen, Map\n\nAssuming that the non-empty array s contains elements of an abelian group G, this functions returns the subgroup H of G generated by the elements in s together with the injection iota  H to G.\n\n\n\nsub(A::SMat, r::UnitRange, c::UnitRange) -> SMat\n\nReturn the submatrix of A, where the rows correspond to r and the columns correspond to c.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#sub-Tuple{GrpAbFinGen, fmpz_mat}","page":"-","title":"sub","text":"sub(G::GrpAbFinGen, M::fmpz_mat) -> GrpAbFinGen, Map\n\nCreate the subgroup H of G generated by the elements corresponding to the rows of M together with the injection iota  H to G.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#sub-Tuple{GrpAbFinGen, fmpz}","page":"-","title":"sub","text":"sub(G::GrpAbFinGen, n::fmpz) -> GrpAbFinGen, Map\n\nCreate the subgroup n cdot G of G together with the injection iota  ncdot G to G.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#sub-Tuple{GrpAbFinGen, Integer}","page":"-","title":"sub","text":"sub(G::GrpAbFinGen, n::Integer) -> GrpAbFinGen, Map\n\nCreate the subgroup n cdot G of G together with the injection iota  n cdot G to G.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#psylow_subgroup-Tuple{GrpAbFinGen, Union{Integer, fmpz}}","page":"-","title":"psylow_subgroup","text":"psylow_subgroup(G::GrpAbFinGen, p::IntegerUnion) -> GrpAbFinGen, Map\n\nReturns the p-Sylow subgroup of G.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#has_quotient-Tuple{GrpAbFinGen, Vector{Int64}}","page":"-","title":"has_quotient","text":"has_quotient(G::GrpAbFinGen, invariant::Vector{Int}) -> Bool\n\nGiven an abelian group G, returns true if it has a quotient with given elementary divisors and false otherwise.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#has_complement-Tuple{GrpAbFinGenMap}","page":"-","title":"has_complement","text":"has_complement(f::GrpAbFinGenMap) -> Bool, GrpAbFinGenMap\n\nGiven a map representing a subgroup of a group G, returns either true and an injection of a complement in G, or false.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"A sophisticated algorithm for the enumeration of all (or selected) subgroups of a finite abelian group is available.","category":"page"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"psubgroups(g::GrpAbFinGen, p::Integer)","category":"page"},{"location":"Hecke/abelian/structural/#psubgroups-Tuple{GrpAbFinGen, Integer}","page":"-","title":"psubgroups","text":"psubgroups(g::GrpAbFinGen, p::Integer;\n           subtype = :all,\n           quotype = :all,\n           index = -1,\n           order = -1)\n\nReturn an iterator for the subgroups of G of the specific form. Note that subtype (and quotype) is the type of the subgroup as an abelian p-group.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"using Hecke # hide\nG = abelian_group([6, 12])\nshapes = MSet{Vector{fmpz}}()\nfor U = psubgroups(G, 2)\n  push!(shapes, elementary_divisors(U[1]))\nend\nshapes","category":"page"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"So there are 2 subgroups isomorphic to C_4 (fmpz[4] : 2), 1 isomorphic to C_2times C_4, 1 trivial and 3 C_2 subgroups.","category":"page"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"subgroups(g::GrpAbFinGen)","category":"page"},{"location":"Hecke/abelian/structural/#subgroups-Tuple{GrpAbFinGen}","page":"-","title":"subgroups","text":"subgroups(g::GrpAbFinGen;\n          subtype = :all ,\n          quotype = :all,\n          index = -1,\n          order = -1)\n\nReturn an iterator for the subgroups of G of the specific form.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"for U = subgroups(G, subtype = [2])\n  @show U[1], map(U[2], gens(U[1]))\nend\nfor U = subgroups(G, quotype = [2])\n  @show U[1], map(U[2], gens(U[1]))\nend","category":"page"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"quo(G::GrpAbFinGen, s::Vector{GrpAbFinGenElem})\nquo(G::GrpAbFinGen, M::fmpz_mat)\nquo(G::GrpAbFinGen, n::Integer)\nquo(G::GrpAbFinGen, n::fmpz)\nquo(G::GrpAbFinGen, U::GrpAbFinGen)","category":"page"},{"location":"Hecke/abelian/structural/#quo-Tuple{GrpAbFinGen, Vector{GrpAbFinGenElem}}","page":"-","title":"quo","text":"quo(G::GrpAbFinGen, s::Vector{GrpAbFinGenElem}) -> GrpAbFinGen, Map\n\nCreate the quotient H of G by the subgroup generated by the elements in s, together with the projection p  G to H.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#quo-Tuple{GrpAbFinGen, fmpz_mat}","page":"-","title":"quo","text":"quo(G::GrpAbFinGen, M::fmpz_mat) -> GrpAbFinGen, Map\n\nCreate the quotient H of G by the subgroup generated by the elements corresponding to the rows of M, together with the projection p  G to H.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#quo-Tuple{GrpAbFinGen, Integer}","page":"-","title":"quo","text":"quo(G::GrpAbFinGen, n::Integer}) -> GrpAbFinGen, Map\nquo(G::GrpAbFinGen, n::fmpz}) -> GrpAbFinGen, Map\n\nReturns the quotient H = GnG together with the projection p  G to H.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#quo-Tuple{GrpAbFinGen, fmpz}","page":"-","title":"quo","text":"quo(G::GrpAbFinGen, n::Integer}) -> GrpAbFinGen, Map\nquo(G::GrpAbFinGen, n::fmpz}) -> GrpAbFinGen, Map\n\nReturns the quotient H = GnG together with the projection p  G to H.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#quo-Tuple{GrpAbFinGen, GrpAbFinGen}","page":"-","title":"quo","text":"quo(G::GrpAbFinGen, U::GrpAbFinGen) -> GrpAbFinGen, Map\n\nCreate the quotient H of G by U, together with the projection p  G to H.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"For 2 subgroups U and V of the same group G, U+V returns the smallest subgroup of G containing both. Similarly, Ucap V computes the intersection and U \\subset V tests for inclusion. The difference between issubset = subset and issubgroup is that the inclusion map is also returned in the 2nd call.","category":"page"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"intersect(mG::GrpAbFinGenMap, mH::GrpAbFinGenMap)","category":"page"},{"location":"Hecke/abelian/structural/#intersect-Tuple{GrpAbFinGenMap, GrpAbFinGenMap}","page":"-","title":"intersect","text":"intersect(mG::GrpAbFinGenMap, mH::GrpAbFinGenMap) -> GrpAbFinGen, Map\n\nGiven two injective maps of abelian groups with the same codomain G, return the intersection of the images as a subgroup of G.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#Direct-Products","page":"-","title":"Direct Products","text":"","category":"section"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"direct_product(G::GrpAbFinGen...)\nHecke.canonical_injection(G::GrpAbFinGen, i::Int)\nHecke.canonical_projection(G::GrpAbFinGen, i::Int)\nflat(G::GrpAbFinGen)","category":"page"},{"location":"Hecke/abelian/structural/#direct_product-Tuple{Vararg{GrpAbFinGen, N} where N}","page":"-","title":"direct_product","text":"direct_product(G::GrpAbFinGen...; task::Symbol = :prod) -> GrpAbFinGen, GrpAbFinGenMap, GrpAbFinGenMap\n\nReturns the direct product D of the abelian groups G_i. task can be \":sum\", \":prod\", \":both\" or \":none\" and determines which canonical maps are computed as well: \":sum\" for the injections, \":prod\" for the projections.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#canonical_injection-Tuple{GrpAbFinGen, Int64}","page":"-","title":"canonical_injection","text":"canonical_injection(G::GrpAbFinGen, i::Int) -> Map\n\nGiven a group G that was created as a direct product, return the injection from the ith component.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#canonical_projection-Tuple{GrpAbFinGen, Int64}","page":"-","title":"canonical_projection","text":"canonical_projection(G::GrpAbFinGen, i::Int) -> Map\n\nGiven a group G that was created as a direct product, return the projection onto the ith component.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#flat-Tuple{GrpAbFinGen}","page":"-","title":"flat","text":"flat(G::GrpAbFinGen) -> GrpAbFinGen, Map\n\nGiven a group G that is created using (iterated) direct products, or (iterated) tensor product, return a group that is a flat product: (A oplus B) oplus C is returned as A oplus B oplus C, (resp. otimes) together with the  isomorphism.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#Tensor-Producs","page":"-","title":"Tensor Producs","text":"","category":"section"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"tensor_product(G::GrpAbFinGen...)\nhom(G::GrpAbFinGen, H::GrpAbFinGen, A::Vector{ <: Map{GrpAbFinGen, GrpAbFinGen}})","category":"page"},{"location":"Hecke/abelian/structural/#tensor_product-Tuple{Vararg{GrpAbFinGen, N} where N}","page":"-","title":"tensor_product","text":"tensor_product(G::GrpAbFinGen...; task::Symbol = :map) -> GrpAbFinGen, Map\n\nGiven groups G_i, compute the tensor product G_1otimes cdots otimes G_n. If task is set to \":map\", a map phi is returned that maps tuples in G_1 times cdots times G_n to pure tensors g_1 otimes cdots otimes g_n. The map admits a preimage as well.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#hom-Tuple{GrpAbFinGen, GrpAbFinGen, Vector{var\"#s271\"} where var\"#s271\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}","page":"-","title":"hom","text":"hom(G::GrpAbFinGen, H::GrpAbFinGen, A::Vector{ <: Map{GrpAbFinGen, GrpAbFinGen}}) -> Map\n\nGiven groups G = G_1 otimes cdots otimes G_n and H = H_1 otimes cdot otimes H_n as well as maps phi_i G_ito H_i, compute the tensor product of the maps.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/structural/#Hom-Group","page":"-","title":"Hom-Group","text":"","category":"section"},{"location":"Hecke/abelian/structural/","page":"-","title":"-","text":"hom(::GrpAbFinGen, ::GrpAbFinGen)","category":"page"},{"location":"Hecke/abelian/structural/#hom-Tuple{GrpAbFinGen, GrpAbFinGen}","page":"-","title":"hom","text":"hom(G::GrpAbFinGen, H::GrpAbFinGen; task::Symbol = :map) -> GrpAbFinGen, Map\n\nComputes the group of all homomorpisms from G to H as an abstract group. If task is \":map\", then a map phi is computed that can be used to obtain actual homomorphisms. This map also allows preimages. Set task to \":none\" to not compute the map.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"using Oscar","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Pages = [\"rings.md\"]","category":"page"},{"location":"CommutativeAlgebra/rings/#Creating-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"In this section, we illustrate by examples how to create multivariate polynomial rings and their elements, while at the same time introducing and illustrating a special ring type for modelling multivariate polynomial rings with (multi)gradings. For more details on multivariate polynomial rings, their coefficient rings (fields), and their elements, we refer to the chapters on rings and fields. ","category":"page"},{"location":"CommutativeAlgebra/rings/#Types","page":"Creating Multivariate Rings","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"OSCAR provides types for dense univariate and sparse multivariate polynomials. The univariate ring types belong to the abstract type PolyRing{T}, their elements have abstract type PolyRingElem{T}. The multivariate ring types belong to the abstract type MPolyRing{T}, their elements have abstract type MPolyRingElem{T}. Here, T is the element type of the coefficient ring of the polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/rings/#Constructors","page":"Creating Multivariate Rings","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"The basic constructor below allows one to build multivariate polynomial rings:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"PolynomialRing(C::Ring, V::Vector{String}; ordering=:lex, cached = true)","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Its return value is a tuple, say R, vars, consisting of a polynomial ring R with coefficient ring C and a vector vars of generators (variables) which print according to the strings in the vector V . The input ordering=:lex refers to the lexicograpical monomial ordering which specifies the default way of storing and displaying polynomials in OSCAR  (terms are sorted in descending order). The other possible choices are :deglex and :degrevlex. Gröbner bases, however, can be computed with respect to any monomial ordering. See the section on Gröbner bases.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nCaching is used to ensure that a given ring constructed from given parameters is unique in the system. For example, there is only one ring of multivariate polynomials over  mathbbZ in the variables x, y, z with ordering=:lex.","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"R, (x, y, z) = PolynomialRing(ZZ, [\"x\", \"y\", \"z\"])\ntypeof(R)\ntypeof(x)\nS, (x, y, z) = PolynomialRing(ZZ, [\"x\", \"y\", \"z\"])\nR === S","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"R1, x = PolynomialRing(QQ, [\"x\"])\ntypeof(x)\nR2, (x,) = PolynomialRing(QQ, [\"x\"])\ntypeof(x)\nR3, x = PolynomialRing(QQ, \"x\")\ntypeof(x)","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"V = [\"x[1]\", \"x[2]\"]\nT, x = PolynomialRing(GF(3), V)\nx","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"The constructor illustrated below allows for the convenient handling of variables with multi-indices:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"R, x, y, z = PolynomialRing(QQ, \"x\" => (1:3, 1:4), \"y\" => 1:2, \"z\" => (1:1, 1:1, 1:1))\nx\ny\nz","category":"page"},{"location":"CommutativeAlgebra/rings/#Coefficient-Rings","page":"Creating Multivariate Rings","title":"Coefficient Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Gröbner bases are implemented for multivariate polynomial rings over the fields and rings from this list:","category":"page"},{"location":"CommutativeAlgebra/rings/#The-field-of-rational-numbers-\\mathbb{Q}","page":"Creating Multivariate Rings","title":"The field of rational numbers mathbbQ","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"QQ","category":"page"},{"location":"CommutativeAlgebra/rings/#Finite-fields-\\mathbb{F_p},-p-a-prime","page":"Creating Multivariate Rings","title":"Finite fields mathbbF_p, p a prime","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"GF(3)\nGF(ZZ(2)^127 - 1)","category":"page"},{"location":"CommutativeAlgebra/rings/#Finite-fields-\\mathbb{F}_{pn}-with-pn-elements,-p-a-prime","page":"Creating Multivariate Rings","title":"Finite fields mathbbF_p^n with p^n elements, p a prime","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"FiniteField(2, 70, \"a\")","category":"page"},{"location":"CommutativeAlgebra/rings/#Simple-algebraic-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p","page":"Creating Multivariate Rings","title":"Simple algebraic extensions of mathbbQ or mathbbF_p","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"T, t = PolynomialRing(QQ, \"t\")\nK, a = NumberField(t^2 + 1, \"a\")\nF = GF(3)\nT, t = PolynomialRing(F, \"t\")\nK, a = FiniteField(t^2 + 1, \"a\")","category":"page"},{"location":"CommutativeAlgebra/rings/#Purely-transcendental-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p","page":"Creating Multivariate Rings","title":"Purely transcendental extensions of mathbbQ or mathbbF_p","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"T, t = PolynomialRing(QQ, \"t\")\nQT = FractionField(T)\nparent(t)\nparent(1//t)\nT, (s, t) = PolynomialRing(GF(3), [\"s\", \"t\"]);\nQT = FractionField(T)","category":"page"},{"location":"CommutativeAlgebra/rings/#The-ring-of-integers-\\mathbb{Z}","page":"Creating Multivariate Rings","title":"The ring of integers mathbbZ","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"ZZ","category":"page"},{"location":"CommutativeAlgebra/rings/#Gradings","page":"Creating Multivariate Rings","title":"Gradings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given a polynomial ring R = Cx_1 dots x_n, we may endow R with various gradings. The standard mathbb Z-grading  on R is the decomposition R=bigoplus_din mathbb Z R_d=bigoplus_dgeq 0 R_d by the usual degree of polynomials. More general mathbb Z-gradings are obtained by assigning integer weights to the variables and considering the corresponding weighted degrees. Even more generally, we may consider multigradings: Given a finitely generated abelian group G, a multigrading on R by G, or a G-grading, or simply a grading, corresponds to a semigroup homomorphism phi mathbb N^n rightarrow G: Given phi, the degree of a monomial x^alpha is the image deg(x^alpha)=phi(alpha)in G; the induced G-grading on R is the decomposition R = bigoplus_gin G R_g satisfying R_gcdot R_hsubset R_g+h, where R_g is the free C-module generated by the monomials of degree g. This grading is determined by assigning the weights deg(x_i) to the x_i. In other words, it is determined by  the weight vector W = (deg(x_1) dots deg(x_n))in G^n If G = mathbb Z^m for some m, the degrees are thought of as column vectors in mathbb Z^m, and W as an m times n-matrix with entries in mathbb Z. In particular, if G = mathbb Z, then W is thought of as a row vector in mathbb Z^n.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"We refer to the textbooks Ezra Miller, Bernd Sturmfels (2005) and Martin Kreuzer, Lorenzo Robbiano (2005) for details on multigradings. With respect to notation, we follow the former book.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nGiven a G-grading on R, we also say that R is G-graded, or simply that R is graded. If R is a polynomial ring over a field, we say that a G-grading on R is positive if G is torsion-free and each graded part R_g, gin G, has finite dimension. We then also say that say that R is positively graded (by G). Note that the positivity condition can be equivalently expressed by asking that the degree zero part consists of the constants only (see Theorem 8.6 in Ezra Miller, Bernd Sturmfels (2005)).","category":"page"},{"location":"CommutativeAlgebra/rings/#Types-2","page":"Creating Multivariate Rings","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Multivariate rings with gradings are modelled by objects of type MPolyRing_dec{T, S}  :< MPolyRing{T}, with elements of type MPolyRingElem_dec{T, S}  :< MPolyRingElem{T}. Here, S is the element type of the multivariate ring, and  T is the element type of its coefficient ring as above.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nThe types MPolyRing_dec{T, S} and MPolyRingElem_dec{T, S} are also meant to eventually model multivariate rings with filtrations and their elements.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"The following function allows one to distinguish between graded and filtered rings:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"isgraded(R::MPolyRing_dec)","category":"page"},{"location":"CommutativeAlgebra/rings/#isgraded-Tuple{MPolyRing_dec}","page":"Creating Multivariate Rings","title":"isgraded","text":"isgraded(R::MPolyRing_dec)\n\nReturn true if R is graded, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Constructors-for-Graded-Rings","page":"Creating Multivariate Rings","title":"Constructors for Graded Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"There are two basic ways of creating multivariate rings with gradings: While the grade function allows one to assign a grading to a polynomial ring already constructed, the GradedPolynomialRing function is meant to create a graded polynomial ring all at once.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"grade(R::MPolyRing, W::Vector{GrpAbFinGenElem})","category":"page"},{"location":"CommutativeAlgebra/rings/#grade-Tuple{MPolyRing, Vector{GrpAbFinGenElem}}","page":"Creating Multivariate Rings","title":"grade","text":"grade(R::MPolyRing, W::Vector{GrpAbFinGenElem})\n\nGiven a vector W of ngens(R) elements of a finitely generated Abelian group G, say,  define a  G-grading on R by assigning weights to the variables according to the entries of W. Return the graded ring as an object of type MPolyRing_dec, together with the vector of variables.\n\nExamples\n\njulia> R, (t, x, y) = PolynomialRing(QQ, [\"t\", \"x\", \"y\"])\n(Multivariate Polynomial Ring in t, x, y over Rational Field, fmpq_mpoly[t, x, y])\n\njulia> typeof(R)\nFmpqMPolyRing\n\njulia>  typeof(x)\nfmpq_mpoly\n\njulia> G = abelian_group([0])\nGrpAb: Z\n\njulia> S, (t, x, y) = grade(R, [-gen(G, 1), gen(G, 1), gen(G, 1)])\n(Multivariate Polynomial Ring in t, x, y over Rational Field graded by\n  t -> [-1]\n  x -> [1]\n  y -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[t, x, y])\n\njulia> typeof(S)\nMPolyRing_dec{fmpq, FmpqMPolyRing}\n\njulia> S isa MPolyRing\ntrue\n\njulia> typeof(x)\nMPolyElem_dec{fmpq, fmpq_mpoly}\n\njulia> R, x, y = PolynomialRing(QQ, \"x\" => 1:2, \"y\" => 1:3)\n(Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field, fmpq_mpoly[x[1], x[2]], fmpq_mpoly[y[1], y[2], y[3]])\n\njulia> G = abelian_group([0, 0])\nGrpAb: Z^2\n\njulia> g = gens(G)\n2-element Vector{GrpAbFinGenElem}:\n Element of\nGrpAb: Z^2\nwith components [1 0]\n Element of\nGrpAb: Z^2\nwith components [0 1]\n\njulia> W = [g[1], g[1], g[2], g[2], g[2]];\n\njulia> S, _ = grade(R, W)\n(Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field graded by\n  x[1] -> [1 0]\n  x[2] -> [1 0]\n  y[1] -> [0 1]\n  y[2] -> [0 1]\n  y[3] -> [0 1], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], y[1], y[2], y[3]])\n\njulia> typeof(x[1])\nfmpq_mpoly\n\njulia> x = map(S, x)\n2-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n x[1]\n x[2]\n\njulia> y = map(S, y)\n3-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n y[1]\n y[2]\n y[3]\n\njulia> typeof(x[1])\nMPolyElem_dec{fmpq, fmpq_mpoly}\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:5)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5]])\n\njulia> G = abelian_group([0, 0, 2, 2])\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\n\njulia> g = gens(G)\n4-element Vector{GrpAbFinGenElem}:\n Element of\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\nwith components [1 0 0 0]\n Element of\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\nwith components [0 1 0 0]\n Element of\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\nwith components [0 0 1 0]\n Element of\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\nwith components [0 0 0 1]\n\njulia> W = [g[1]+g[3]+g[4], g[2]+g[4], g[1]+g[3], g[2], g[1]+g[2]];\n\njulia> S, x = grade(R, W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field graded by\n  x[1] -> [1 0 1 1]\n  x[2] -> [0 1 0 1]\n  x[3] -> [1 0 1 0]\n  x[4] -> [0 1 0 0]\n  x[5] -> [1 1 0 0], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3], x[4], x[5]])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"grade(R::MPolyRing, W::Union{fmpz_mat, Matrix{<:IntegerUnion}})","category":"page"},{"location":"CommutativeAlgebra/rings/#grade-Tuple{MPolyRing, Union{fmpz_mat, Matrix{var\"#s271\"} where var\"#s271\"<:Union{Integer, fmpz}}}","page":"Creating Multivariate Rings","title":"grade","text":"grade(R::MPolyRing, W::Union{fmpz_mat, Matrix{<:IntegerUnion}})\n\nGiven an integer matrix W with ngens(R) columns and, say,  m rows, define a mathbb Z^m-grading on R by  converting the column vectors of W to elements of the group mathbb Z^m, and assigning these elements as weights  to the variables. Return the graded ring as an object of type MPolyRing_dec, together with the vector of variables.\n\ngrade(R::MPolyRing, W::Vector{<:Vector{<:IntegerUnion}})\n\nGiven a vector W of ngens(R) integer vectors of the same size m, say, define a mathbb Z^m-grading on R by  converting the vectors of W to elements of the group mathbb Z^m, and assigning these elements as weights  to the variables. Return the graded ring as an object of type MPolyRing_dec, together with the vector of variables.\n\nExamples\n\njulia> R, x, y = PolynomialRing(QQ, \"x\" => 1:2, \"y\" => 1:3)\n(Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field, fmpq_mpoly[x[1], x[2]], fmpq_mpoly[y[1], y[2], y[3]])\n\njulia> W = [1 1 0 0 0; 0 0 1 1 1]\n2×5 Matrix{Int64}:\n 1  1  0  0  0\n 0  0  1  1  1\n\njulia> grade(R, W)\n(Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field graded by\n  x[1] -> [1 0]\n  x[2] -> [1 0]\n  y[1] -> [0 1]\n  y[2] -> [0 1]\n  y[3] -> [0 1], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], y[1], y[2], y[3]])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"grade(R::MPolyRing, W::Vector{<:IntegerUnion})","category":"page"},{"location":"CommutativeAlgebra/rings/#grade-Tuple{MPolyRing, Vector{var\"#s271\"} where var\"#s271\"<:Union{Integer, fmpz}}","page":"Creating Multivariate Rings","title":"grade","text":"grade(R::MPolyRing, W::Vector{<:IntegerUnion})\n\nGiven a vector W of ngens(R) integers, define a mathbb Z-grading on R by  converting the entries of W to elements of the group mathbb Z, and assigning  these elements as weights to the variables. Return the graded ring as an object  of type MPolyRing_dec, together with the vector of variables.\n\ngrade(R::MPolyRing)\n\nDefine a mathbb Z-grading on R by assigning mathbb Z-weight 1 to each variable.  Return the graded ring as an object of type MPolyRing_dec, together with the vector of variables. \n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> W = [1, 2, 3];\n\njulia> S, (x, y, z) = grade(R, W)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [2]\n  z -> [3], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> T, (x, y, z) = grade(R)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"GradedPolynomialRing(C::Ring, V::Vector{String}, W; ordering=:lex)","category":"page"},{"location":"CommutativeAlgebra/rings/#GradedPolynomialRing-Tuple{AbstractAlgebra.Ring, Vector{String}, Any}","page":"Creating Multivariate Rings","title":"GradedPolynomialRing","text":"GradedPolynomialRing(C::Ring, V::Vector{String}, W; ordering=:lex)\n\nCreate a multivariate polynomial ring with coefficient ring C and variables which print according to the strings in vars, and grade this ring according to the data provided by W (see the documentation of the grade-function for what is possible). Return the graded ring as an object of type MPolyRing_dec, together  with the vector of variables.\n\nGradedPolynomialRing(C::Ring, V::Vector{String}; ordering=:lex)\n\nAs above, with mathbb Z-weight 1 assigned to each variable. \n\nExamples\n\njulia> W = [[1, 0], [0, 1], [1, 0], [4, 1]]\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [1, 0]\n [4, 1]\n\njulia> R, x = GradedPolynomialRing(QQ, [\"x[1]\", \"x[2]\", \"x[3]\", \"x[4]\"], W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4] over Rational Field graded by \n  x[1] -> [1 0]\n  x[2] -> [0 1]\n  x[3] -> [1 0]\n  x[4] -> [4 1], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3], x[4]])\n\njulia> S, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [2]\n  z -> [3], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> T, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by \n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Tests-on-Graded-Rings","page":"Creating Multivariate Rings","title":"Tests on Graded Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_standard_graded(R::MPolyRing_dec)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_standard_graded-Tuple{MPolyRing_dec}","page":"Creating Multivariate Rings","title":"is_standard_graded","text":"is_standard_graded(R::MPolyRing_dec)\n\nReturn true if R is mathbb Z-graded with weight 1 assigned to each variable, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> W = [1, 2, 3];\n\njulia> S, (x, y, z) = grade(R, W)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by \n  x -> [1]\n  y -> [2]\n  z -> [3], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> is_standard_graded(S)\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_z_graded(R::MPolyRing_dec)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_z_graded-Tuple{MPolyRing_dec}","page":"Creating Multivariate Rings","title":"is_z_graded","text":"is_z_graded(R::MPolyRing_dec)\n\nReturn true if R is mathbb Z-graded, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> W = [1, 2, 3];\n\njulia> S, (x, y, z) = grade(R, W)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by \n  x -> [1]\n  y -> [2]\n  z -> [3], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> is_z_graded(S)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_zm_graded(R::MPolyRing_dec)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_zm_graded-Tuple{MPolyRing_dec}","page":"Creating Multivariate Rings","title":"is_zm_graded","text":"is_zm_graded(R::MPolyRing_dec)\n\nReturn true if R is mathbb Z^m-graded for some m, false otherwise.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:5)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5]])\n\njulia> G = abelian_group([0, 0, 2, 2])\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\n\njulia> g = gens(G);\n\njulia> W = [g[1]+g[3]+g[4], g[2]+g[4], g[1]+g[3], g[2], g[1]+g[2]];\n\njulia> S, x = grade(R, W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field graded by \n  x[1] -> [1 0 1 1]\n  x[2] -> [0 1 0 1]\n  x[3] -> [1 0 1 0]\n  x[4] -> [0 1 0 0]\n  x[5] -> [1 1 0 0], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3], x[4], x[5]])\n\njulia> is_zm_graded(S)\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"is_positively_graded(R::MPolyRing_dec)","category":"page"},{"location":"CommutativeAlgebra/rings/#is_positively_graded-Tuple{MPolyRing_dec}","page":"Creating Multivariate Rings","title":"is_positively_graded","text":"is_positively_graded(R::MPolyRing_dec)\n\nReturn true if R is positively graded, false otherwise.\n\nHere, R is called positively graded by a finitely generated abelian group G if the coeffcient ring of R is a field, G is torsion-free, and each graded part  R_g, gin G, has finite dimension.\n\nExamples\n\njulia> R, (t, x, y) = PolynomialRing(QQ, [\"t\", \"x\", \"y\"])\n(Multivariate Polynomial Ring in t, x, y over Rational Field, fmpq_mpoly[t, x, y])\n\njulia> G = abelian_group([0])\nGrpAb: Z\n\njulia> S, (t, x, y) = grade(R, [-1, 1, 1])\n(Multivariate Polynomial Ring in t, x, y over Rational Field graded by\n  t -> [-1]\n  x -> [1]\n  y -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[t, x, y])\n\njulia> is_positively_graded(S)\nfalse\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> G = abelian_group([0, 2])\n(General) abelian group with relation matrix\n[0 0; 0 2]\n\njulia> W = [gen(G, 1)+gen(G, 2), gen(G, 1)]\n2-element Vector{GrpAbFinGenElem}:\n Element of\n(General) abelian group with relation matrix\n[0 0; 0 2]\nwith components [1 1]\n Element of\n(General) abelian group with relation matrix\n[0 0; 0 2]\nwith components [1 0]\n\njulia> S, (x, y) = grade(R, W)\n(Multivariate Polynomial Ring in x, y over Rational Field graded by \n  x -> [1 1]\n  y -> [1 0], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y])\n\njulia> is_positively_graded(S)\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Data-Associated-to-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Data Associated to Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given  a multivariate polynomial ring R with coefficient ring C, ","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"coefficient_ring(R) refers to C,\ngens(R) to the generators (variables) of R,\nngens(R) to the number of these generators, and\ngen(R, i) as well as R[i] to the i-th such generator.","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples-2","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\ncoefficient_ring(R)\ngens(R)\ngen(R, 2)\nR[3] \nngens(R)","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"In the graded case, we additionally have:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"grading_group(R::MPolyRing_dec)","category":"page"},{"location":"CommutativeAlgebra/rings/#grading_group-Tuple{MPolyRing_dec}","page":"Creating Multivariate Rings","title":"grading_group","text":"grading_group(R::MPolyRing_dec)\n\nIf R is, say, G-graded, return G.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by \n  x -> [1]\n  y -> [2]\n  z -> [3], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> grading_group(R)\nGrpAb: Z\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"homogeneous_component(R::MPolyRing_dec, g::GrpAbFinGenElem)","category":"page"},{"location":"CommutativeAlgebra/rings/#homogeneous_component-Tuple{MPolyRing_dec, GrpAbFinGenElem}","page":"Creating Multivariate Rings","title":"homogeneous_component","text":"homogeneous_component(R::MPolyRing_dec, g::GrpAbFinGenElem)\n\nGiven a polynomial ring R which is graded by a finitely generated Abelian group without torsion, and given an element g of that group, return the homogeneous component of R of degree g. Additionally, return the embedding of the component into R.\n\nhomogeneous_component(R::MPolyRing_dec, g::Vector{<:IntegerUnion})\n\nGiven a mathbb  Z^m-graded polynomial ring, and given a vector g of m integers, convert g into an element of the group  mathbb  Z^m, and return the homogeneous component of R whose degree  is that element. Additionally, return the embedding of the component into R.\n\nhomogeneous_component(R::MPolyRing_dec, g::IntegerUnion)\n\nGiven a mathbb  Z-graded polynomial ring, and given an integer g, convert g into an element of the group mathbb  Z,  and return the homogeneous component of R whose degree is that element. Additionally, return the embedding of the component into R.\n\nExamples\n\njulia> R, x, y = PolynomialRing(QQ, \"x\" => 1:2, \"y\" => 1:3);\n\njulia> W = [1 1 0 0 0; 0 0 1 1 1]\n2×5 Matrix{Int64}:\n 1  1  0  0  0\n 0  0  1  1  1\n\njulia> S, _ = grade(R, W);\n\njulia> G = grading_group(S)\nGrpAb: Z^2\n\njulia> L = homogeneous_component(S, [1, 1]);\n\njulia> L[1]\nhomogeneous component of Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field graded by\n  x[1] -> [1 0]\n  x[2] -> [1 0]\n  y[1] -> [0 1]\n  y[2] -> [0 1]\n  y[3] -> [0 1] of degree graded by [1 1]\n\njulia> FG = gens(L[1]);\n\njulia> EMB = L[2]\nMap from\nhomogeneous component of Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field graded by\n  x[1] -> [1 0]\n  x[2] -> [1 0]\n  y[1] -> [0 1]\n  y[2] -> [0 1]\n  y[3] -> [0 1] of degree graded by [1 1]\n to Multivariate Polynomial Ring in x[1], x[2], y[1], y[2], y[3] over Rational Field graded by\n  x[1] -> [1 0]\n  x[2] -> [1 0]\n  y[1] -> [0 1]\n  y[2] -> [0 1]\n  y[3] -> [0 1] defined by a julia-function with inverse\n\njulia> for i in 1:length(FG) println(EMB(FG[i])) end\nx[2]*y[3]\nx[2]*y[2]\nx[2]*y[1]\nx[1]*y[3]\nx[1]*y[2]\nx[1]*y[1]\n\njulia> T, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> G = grading_group(T)\nGrpAb: Z\n\njulia> L = homogeneous_component(T, 2)\n(homogeneous component of Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1] of degree graded by [2]\n, Map from\nhomogeneous component of Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1] of degree graded by [2]\n to Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1] defined by a julia-function with inverse)\n\njulia> FG = gens(L[1]);\n\njulia> EMB = L[2];\n\njulia> for i in 1:length(FG) println(EMB(FG[i])) end\nz^2\ny*z\ny^2\nx*z\nx*y\nx^2\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Elements-of-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Elements of Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/#Constructors-2","page":"Creating Multivariate Rings","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"One way to create elements of a multivariate  polynomial ring is to build up polynomials from the generators (variables) of the ring using basic arithmetic as shown below:","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples-3","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\nf = 3*x^2+y*z\ntypeof(f)\nS, (x, y, z) = grade(R)\ng = 3*x^2+y*z\ntypeof(g)\ng == S(f)","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Alternatively, there is the following constructor:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"(R::MPolyRing{T})(c::Vector{T}, e::Vector{Vector{Int}}) where T <: RingElem","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Its return value is the element of  R  whose nonzero coefficients are specified by the elements of c, with exponent vectors given by the elements of e.","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples-4","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\nf = 3*x^2+y*z\ng = R(QQ.([3, 1]), [[2, 0, 0], [0, 1, 1]])\nf == g","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"An often more effective way to create polynomials is to use the MPoly build context as indicated below:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\nB = MPolyBuildCtx(R)\nfor i = 1:5 push_term!(B, QQ(i), [i, i-1]) end\nfinish(B)","category":"page"},{"location":"CommutativeAlgebra/rings/#Special-Elements","page":"Creating Multivariate Rings","title":"Special Elements","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given a multivariate polynomial ring R, zero(R) and one(R) refer to the additive and multiplicative identity of R, respectively. Relevant test calls on an element f of R are  iszero(f) and isone(f).","category":"page"},{"location":"CommutativeAlgebra/rings/#Data-Associated-to-Elements-of-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Data Associated to Elements of Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given an element f of a multivariate polynomial ring R or a graded version of such a ring, ","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"parent(f) refers to R,\ntotal_degree(f) to the total degree of f,\nmonomial(f, i) to the i-th monomial of f, \nterm(f, i) to the i-th term of f,\ncoeff(f, i) to the coefficient of the i-th term of f, and\nexponent_vector(f, i) to the exponent vector of the i-th term of f.","category":"page"},{"location":"CommutativeAlgebra/rings/#Examples-5","page":"Creating Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"R, (x, y) = PolynomialRing(GF(5), [\"x\", \"y\"])\nc = map(GF(5), [1, 2, 3])\ne = [[3, 2], [1, 0], [0, 1]]\nf = R(c, e)\nparent(f)\ntotal_degree(f)\ncoeff(f, 2)\nexponent_vector(f, 2)\nmonomial(f, 2)\nterm(f, 2)","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Further functionality is available in the graded case:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"homogeneous_components(f::MPolyElem_dec{T, S}) where {T, S}","category":"page"},{"location":"CommutativeAlgebra/rings/#homogeneous_components-Union{Tuple{MPolyElem_dec{T, S}}, Tuple{S}, Tuple{T}} where {T, S}","page":"Creating Multivariate Rings","title":"homogeneous_components","text":"homogeneous_components(f::MPolyElem_dec{T, S}) where {T, S}\n\nReturn the homogeneous components of f.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by \n  x -> [1]\n  y -> [2]\n  z -> [3], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> f = x^2+y+z\nx^2 + y + z\n\njulia> homogeneous_components(f)\nDict{GrpAbFinGenElem, MPolyElem_dec{fmpq, fmpq_mpoly}} with 2 entries:\n  [2] => x^2 + y\n  [3] => z\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:5)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5]])\n\njulia> G = abelian_group([0, 0, 2, 2])\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\n\njulia> g = gens(G);\n\njulia> W = [g[1]+g[3]+g[4], g[2]+g[4], g[1]+g[3], g[2], g[1]+g[2]];\n\njulia> S, x = grade(R, W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field graded by \n  x[1] -> [1 0 1 1]\n  x[2] -> [0 1 0 1]\n  x[3] -> [1 0 1 0]\n  x[4] -> [0 1 0 0]\n  x[5] -> [1 1 0 0], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3], x[4], x[5]])\n\njulia> f = x[1]^2+x[3]^2+x[5]^2\nx[1]^2 + x[3]^2 + x[5]^2\n\njulia> homogeneous_components(f)\nDict{GrpAbFinGenElem, MPolyElem_dec{fmpq, fmpq_mpoly}} with 2 entries:\n  [2 2 0 0] => x[5]^2\n  [2 0 0 0] => x[1]^2 + x[3]^2\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"homogeneous_component(f::MPolyElem_dec, g::GrpAbFinGenElem)","category":"page"},{"location":"CommutativeAlgebra/rings/#homogeneous_component-Tuple{MPolyElem_dec, GrpAbFinGenElem}","page":"Creating Multivariate Rings","title":"homogeneous_component","text":"homogeneous_component(f::MPolyElem_dec, g::GrpAbFinGenElem)\n\nGiven an element f of a polynomial ring which is graded by a finitely generated Abelian group, and given an element g of that group, return the homogeneous component of f of degree g.\n\nhomogeneous_component(f::MPolyElem_dec, g::Vector{<:IntegerUnion})\n\nGiven an element f of a mathbb  Z^m-graded polynomial ring, and given a vector g of m integers, convert g into an element of the group  mathbb  Z^m, and return the homogeneous component of f whose degree  is that element.\n\nhomogeneous_component(f::MPolyElem_dec, g::IntegerUnion)\n\nGiven an element f of a mathbb  Z-graded polynomial ring, and given an integer g, convert g into an element of the group mathbb  Z,  and return the homogeneous component of f whose degree is that element.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:5)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5]])\n\njulia> G = abelian_group([0, 0, 2, 2])\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\n\njulia> g = gens(G);\n\njulia> W = [g[1]+g[3]+g[4], g[2]+g[4], g[1]+g[3], g[2], g[1]+g[2]];\n\njulia> S, x = grade(R, W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field graded by \n  x[1] -> [1 0 1 1]\n  x[2] -> [0 1 0 1]\n  x[3] -> [1 0 1 0]\n  x[4] -> [0 1 0 0]\n  x[5] -> [1 1 0 0], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3], x[4], x[5]])\n\njulia> f = x[1]^2+x[3]^2+x[5]^2\nx[1]^2 + x[3]^2 + x[5]^2\n\njulia> homogeneous_component(f, 2*g[1])\nx[1]^2 + x[3]^2\n\njulia> W = [[1, 0], [0, 1], [1, 0], [4, 1]]\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [1, 0]\n [4, 1]\n\njulia> R, x = GradedPolynomialRing(QQ, [\"x[1]\", \"x[2]\", \"x[3]\", \"x[4]\"], W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4] over Rational Field graded by \n  x[1] -> [1 0]\n  x[2] -> [0 1]\n  x[3] -> [1 0]\n  x[4] -> [4 1], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3], x[4]])\n\njulia> f = x[1]^2*x[2]+x[4]\nx[1]^2*x[2] + x[4]\n\njulia> homogeneous_component(f, [2, 1])\nx[1]^2*x[2]\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by \n  x -> [1]\n  y -> [2]\n  z -> [3], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> f = x^2+y+z\nx^2 + y + z\n\njulia> homogeneous_component(f, 1)\n0\n\njulia> homogeneous_component(f, 2)\nx^2 + y\n\njulia> homogeneous_component(f, 3)\nz\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"ishomogeneous(f::MPolyElem_dec)","category":"page"},{"location":"CommutativeAlgebra/rings/#ishomogeneous-Tuple{MPolyElem_dec}","page":"Creating Multivariate Rings","title":"ishomogeneous","text":"ishomogeneous(f::MPolyElem_dec)\n\nReturn true if f is homogeneous, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by \n  x -> [1]\n  y -> [2]\n  z -> [3], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> f = x^2+y*z\nx^2 + y*z\n\njulia> ishomogeneous(f)\nfalse\n\njulia> W = [1 2 1 0; 3 4 0 1]\n2×4 Matrix{Int64}:\n 1  2  1  0\n 3  4  0  1\n\njulia> S, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"], W)\n(Multivariate Polynomial Ring in w, x, y, z over Rational Field graded by\n  w -> [1 3]\n  x -> [2 4]\n  y -> [1 0]\n  z -> [0 1], MPolyElem_dec{fmpq, fmpq_mpoly}[w, x, y, z])\n\njulia> F = w^3*y^3*z^3 + w^2*x*y^2*z^2 + w*x^2*y*z + x^3\nw^3*y^3*z^3 + w^2*x*y^2*z^2 + w*x^2*y*z + x^3\n\njulia> ishomogeneous(F)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"degree(f::MPolyElem_dec)","category":"page"},{"location":"CommutativeAlgebra/rings/#degree-Tuple{MPolyElem_dec}","page":"Creating Multivariate Rings","title":"degree","text":"degree(f::MPolyElem_dec)\n\nGiven a homogeneous element f of a graded polynomial ring, return the degree of f.\n\ndegree(::Type{Vector{Int}}, f::MPolyElem_dec)\n\nGiven a homogeneous element f of a mathbb Z^m-graded polynomial ring, return the degree of f, converted to a vector of integer numbers.\n\ndegree(::Type{Int}, f::MPolyElem_dec)\n\nGiven a homogeneous element f of a mathbb Z-graded polynomial ring, return the degree of f, converted to an integer number.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:5)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5]])\n\njulia> G = abelian_group([0, 0, 2, 2])\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\n\njulia> g = gens(G);\n\njulia> W = [g[1]+g[3]+g[4], g[2]+g[4], g[1]+g[3], g[2], g[1]+g[2]];\n\njulia> S, x = grade(R, W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4], x[5] over Rational Field graded by\n  x[1] -> [1 0 1 1]\n  x[2] -> [0 1 0 1]\n  x[3] -> [1 0 1 0]\n  x[4] -> [0 1 0 0]\n  x[5] -> [1 1 0 0], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3], x[4], x[5]])\n\njulia> f = x[2]^2+2*x[4]^2\nx[2]^2 + 2*x[4]^2\n\njulia> degree(f)\nElement of\n(General) abelian group with relation matrix\n[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]\nwith components [0 2 0 0]\n\njulia> W = [[1, 0], [0, 1], [1, 0], [4, 1]]\n4-element Vector{Vector{Int64}}:\n [1, 0]\n [0, 1]\n [1, 0]\n [4, 1]\n\njulia> R, x = GradedPolynomialRing(QQ, [\"x[1]\", \"x[2]\", \"x[3]\", \"x[4]\"], W)\n(Multivariate Polynomial Ring in x[1], x[2], x[3], x[4] over Rational Field graded by\n  x[1] -> [1 0]\n  x[2] -> [0 1]\n  x[3] -> [1 0]\n  x[4] -> [4 1], MPolyElem_dec{fmpq, fmpq_mpoly}[x[1], x[2], x[3], x[4]])\n\njulia> f = x[1]^4*x[2]+x[4]\nx[1]^4*x[2] + x[4]\n\njulia> degree(f)\ngraded by [4 1]\n\njulia> degree(Vector{Int}, f)\n2-element Vector{Int64}:\n 4\n 1\n\njulia>  R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"], [1, 2, 3])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [2]\n  z -> [3], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> f = x^6+y^3+z^2\nx^6 + y^3 + z^2\n\njulia> degree(f)\ngraded by [6]\n\njulia> typeof(degree(f))\nGrpAbFinGenElem\n\njulia> degree(Int, f)\n6\n\njulia> typeof(degree(Int, f))\nInt64\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/#Homomorphisms-From-Multivariate-Rings","page":"Creating Multivariate Rings","title":"Homomorphisms From Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"If R is a multivariate polynomial ring, and S is any ring, then a ring homomorphism R rightarrow S is determined by specifying its restriction to the coefficient ring of R, and by assigning an image to each variable of R. In OSCAR, such homomorphisms are created by using the following constructor:","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"hom(R::MPolyRing, S::NCRing, coeff_map, images::Vector; check::Bool = true)","category":"page"},{"location":"CommutativeAlgebra/rings/#hom-Tuple{MPolyRing, AbstractAlgebra.NCRing, Any, Vector{T} where T}","page":"Creating Multivariate Rings","title":"hom","text":"hom(R::MPolyRing, S::NCRing, coeff_map, images::Vector; check::Bool = true)\n\nhom(R::MPolyRing, S::NCRing, images::Vector; check::Bool = true)\n\nGiven a homomorphism coeff_map from C to S, where C is the  coefficient ring of R, and given a vector images of nvars(R)  elements of S, return the homomorphism R to S whose restriction  to C is coeff_map, and which sends the i-th variable of R to the  i-th entry of images.\n\nIf no coefficient map is entered, invoke a canonical homomorphism of C to S, if such a homomorphism exists, and throw an error, otherwise.\n\nnote: Note\nIn case check = true (default), the function checks the conditions below:If S is graded, the assigned images must be homogeneous with respect to the given grading.\nIf S is noncommutative, the assigned images must pairwise commute. \n\nExamples\n\njulia> K, a = FiniteField(2, 2, \"a\");\n\njulia> R, (x, y) = PolynomialRing(K, [\"x\", \"y\"]);\n\njulia> F = hom(R, R, z -> z^2, [y, x])\nMap with following data\nDomain:\n=======\nMultivariate Polynomial Ring in x, y over Finite field of degree 2 over F_2\nCodomain:\n=========\nMultivariate Polynomial Ring in x, y over Finite field of degree 2 over F_2\n\njulia> F(a * y)\n(a + 1)*x\n\njulia> Qi, i = quadratic_field(-1)\n(Imaginary quadratic field defined by x^2 + 1, sqrt(-1))\n\njulia> S, (x, y) = PolynomialRing(Qi, [\"x\", \"y\"]);\n\njulia> G = hom(S, S, hom(Qi, Qi, -i), [x^2, y^2])\nMap with following data\nDomain:\n=======\nMultivariate Polynomial Ring in x, y over Imaginary quadratic field defined by x^2 + 1\nCodomain:\n=========\nMultivariate Polynomial Ring in x, y over Imaginary quadratic field defined by x^2 + 1\n\njulia> G(x+i*y)\nx^2 - sqrt(-1)*y^2\n\njulia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"]);\n\njulia> f = 3*x^2+2*x+1;\n\njulia> S, (x, y) = PolynomialRing(GF(2), [\"x\", \"y\"]);\n\njulia> H = hom(R, S, gens(S))\nMap with following data\nDomain:\n=======\nMultivariate Polynomial Ring in x, y over Integer Ring\nCodomain:\n=========\nMultivariate Polynomial Ring in x, y over Galois field with characteristic 2\n\njulia> H(f)\nx^2 + 1\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"Given a ring homomorphism F from R to S as above, domain(F) and codomain(F) refer to R and S, respectively.","category":"page"},{"location":"CommutativeAlgebra/rings/","page":"Creating Multivariate Rings","title":"Creating Multivariate Rings","text":"note: Note\nThe OSCAR homomorphism type AffAlgHom models ring homomorphisms R to S such that the type of both R and S  is a subtype of Union{MPolyRing{T}, MPolyQuo{U}}, where T <: FieldElem and U <: MPolyElem{T}. Functionality for these homomorphism is discussed in the section on affine algebras.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/function_field/#Rational-function-fields","page":"Rational function fields","title":"Rational function fields","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/RationalFunctionField.jl for rational function fields k(x) over a field k.","category":"page"},{"location":"AbstractAlgebra/function_field/#Generic-rational-function-field-type","page":"Rational function fields","title":"Generic rational function field type","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Rational functions in k(x) have type Generic.Rat{T} where T is the type of elements of the coefficient field k. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Parent objects corresponding to the rational function field k have type Generic.RationalFunctionField{T}.","category":"page"},{"location":"AbstractAlgebra/function_field/#Abstract-types","page":"Rational function fields","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"The rational function types belong to the abstract type Field and the rational function field types belong to the abstract type FieldElem.","category":"page"},{"location":"AbstractAlgebra/function_field/#Rational-function-field-constructors","page":"Rational function fields","title":"Rational function field constructors","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"In order to construct rational functions in AbstractAlgebra.jl, one can first construct the function field itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"RationalFunctionField(k::Field, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Given a coefficient field k return a tuple (S, x) consisting of the parent object of the rational function field over k and the generator x. By default the parent object S will depend only on R and s and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Here are some examples of creating rational function fields and making use of the resulting parent objects to coerce various elements into the function field.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"julia> S, x = RationalFunctionField(QQ, \"x\")\n(Rational function field over Rationals, x)\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1\n\njulia> m = S(numerator(x + 1, false), numerator(x + 2, false))\n(x + 1)//(x + 2)","category":"page"},{"location":"AbstractAlgebra/function_field/#Basic-rational-function-field-functionality","page":"Rational function fields","title":"Basic rational function field functionality","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Fraction fields in AbstractAlgebra.jl implement the full Field interface and the entire fraction field interface.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"We give some examples of such functionality.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"julia> S, x = RationalFunctionField(QQ, \"x\")\n(Rational function field over Rationals, x)\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> m = characteristic(S)\n0\n\njulia> U = base_ring(S)\nRationals\n\njulia> V = base_ring(f)\nRationals\n\njulia> T = parent(f)\nRational function field over Rationals\n\njulia> r = deepcopy(f)\nx + 1\n\njulia> n = numerator(g)\nx^2 + x + 1\n\njulia> d = denominator(g)\nx^3 + 3*x + 1\n","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Note that numerator and denominator are returned as elements of a polynomial ring whose variable is printed the same way as that of the generator of the rational function field.","category":"page"},{"location":"AbstractAlgebra/function_field/#Rational-function-field-functionality-provided-by-AbstractAlgebra.jl","page":"Rational function fields","title":"Rational function field functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"The following functionality is provided for rational function fields.","category":"page"},{"location":"AbstractAlgebra/function_field/#Greatest-common-divisor","page":"Rational function fields","title":"Greatest common divisor","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"gcd(::Generic.Rat{T}, ::Generic.Rat{T}) where T <: FieldElement","category":"page"},{"location":"AbstractAlgebra/function_field/#gcd-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.Rat{T}, AbstractAlgebra.Generic.Rat{T}}} where T<:FieldElement","page":"Rational function fields","title":"gcd","text":"gcd(a::Rat{T}, b::Rat{T}) where {T <: RingElem}\n\nReturn a greatest common divisor of a and b if one exists. N.B: we define the GCD of ab and cd to be gcd(ad bc)bd, reduced to lowest terms.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"julia> R, x = RationalFunctionField(QQ, \"x\")\n(Rational function field over Rationals, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 2x + 1)//(x^2 + x + 1)\n(x^2 + 2*x + 1)//(x^2 + x + 1)\n\njulia> h = gcd(f, g)\n(x + 1)//(x^5 + x^4 + 4*x^3 + 4*x^2 + 4*x + 1)\n","category":"page"},{"location":"AbstractAlgebra/function_field/#Square-root","page":"Rational function fields","title":"Square root","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"issquare(::Generic.Rat{T}) where T <: FieldElem","category":"page"},{"location":"AbstractAlgebra/function_field/#issquare-Union{Tuple{AbstractAlgebra.Generic.Rat{T}}, Tuple{T}} where T<:FieldElem","page":"Rational function fields","title":"issquare","text":"issquare(f::PolyElem{T}) where T <: RingElement\n\nReturn true if f is a perfect square.\n\n\n\nissquare(a::FracElem{T}) where T <: RingElem\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Base.sqrt(::Generic.Rat{T}) where T <: FieldElem","category":"page"},{"location":"AbstractAlgebra/function_field/#sqrt-Union{Tuple{AbstractAlgebra.Generic.Rat{T}}, Tuple{T}} where T<:FieldElem","page":"Rational function fields","title":"sqrt","text":"sqrt(a::FieldElem)\n\nReturn the square root of the element a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"julia> R, x = RationalFunctionField(QQ, \"x\")\n(Rational function field over Rationals, x)\n\njulia> a = (21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> sqrt(a^2)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> issquare(a^2)\ntrue","category":"page"},{"location":"AbstractAlgebra/function_field/#Univariate-function-fields","page":"Rational function fields","title":"Univariate function fields","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Univariate function fields in AbstractAlgebra are algebraic extensions Kk(x) of a rational function field k(x) over a field k.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"These are implemented in a module implemented in src/generic/FunctionField.jl.","category":"page"},{"location":"AbstractAlgebra/function_field/#Generic-function-field-types","page":"Rational function fields","title":"Generic function field types","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Function field objects Kk(x) in AbstractAlgebra have type Generic.FunctionField{T} where T is the type of elements of the field k.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Corresponding function field elements have type Generic.FunctionFieldElement{T}. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/function_field/#Abstract-types-2","page":"Rational function fields","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Function field types belong to the abstract type Field and their elements to the abstract type FieldElem.","category":"page"},{"location":"AbstractAlgebra/function_field/#Function-field-constructors","page":"Rational function fields","title":"Function field constructors","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"In order to construct function fields in AbstractAlgebra.jl, one first constructs the rational function field they are an extension of, then supplies a polynomial over this field to the following constructor:","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"FunctionField(p::Poly{Rat{T}}, s::AbstractString; cached::Bool=true) where T <: FieldElement","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Given an irreducible polynomial p over a rational function field return a tuple (S, z) consisting of the parent object of the function field defined by that polynomial over k(x) and the generator z. By default the parent object S will depend only on p and s and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Here are some examples of creating function fields and making use of the resulting parent objects to coerce various elements into the function field.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"julia> R1, x1 = RationalFunctionField(QQ, \"x1\") # characteristic 0\n(Rational function field over Rationals, x1)\n\njulia> U1, z1 = R1[\"z1\"]\n(Univariate Polynomial Ring in z1 over Rational function field over Rationals, z1)\n\njulia> f = (x1^2 + 1)//(x1 + 1)*z1^3 + 4*z1 + 1//(x1 + 1)\n(x1^2 + 1)//(x1 + 1)*z1^3 + 4*z1 + 1//(x1 + 1)\n\njulia> S1, y1 = FunctionField(f, \"y1\")\n(Function Field over Rationals with defining polynomial (x1^2 + 1)*y1^3 + (4*x1 + 4)*y1 + 1, y1)\n\njulia> a = S1()\n0\n\njulia> b = S1((x1 + 1)//(x1 + 2))\n(x1 + 1)//(x1 + 2)\n\njulia> c = S1(1//3)\n1//3\n\njulia> R2, x2 = RationalFunctionField(GF(23), \"x1\") # characteristic p\n(Rational function field over Finite field F_23, x1)\n\njulia> U2, z2 = R2[\"z2\"]\n(Univariate Polynomial Ring in z2 over Rational function field over Finite field F_23, z2)\n\njulia> g = z2^2 + 3z2 + 1\nz2^2 + 3*z2 + 1\n\njulia> S2, y2 = FunctionField(g, \"y2\")\n(Function Field over Finite field F_23 with defining polynomial y2^2 + 3*y2 + 1, y2)\n\njulia> d = S2(R2(5))\n5\n\njulia> e = S2(y2)\ny2","category":"page"},{"location":"AbstractAlgebra/function_field/#Basic-function-field-functionality","page":"Rational function fields","title":"Basic function field functionality","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Function fields implement the full Ring and Field interfaces. We give some examples of such functionality.","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"julia> R, x = RationalFunctionField(GF(23), \"x\") # characteristic p\n(Rational function field over Finite field F_23, x)\n\njulia> U, z = R[\"z\"]\n(Univariate Polynomial Ring in z over Rational function field over Finite field F_23, z)\n\njulia> g = z^2 + 3z + 1\nz^2 + 3*z + 1\n\njulia> S, y = FunctionField(g, \"y\")\n(Function Field over Finite field F_23 with defining polynomial y^2 + 3*y + 1, y)\n\njulia> f = (x + 1)*y + 1\n(x + 1)*y + 1\n\njulia> base_ring(f)\nRational function field over Finite field F_23\n\njulia> f^2\n(20*x^2 + 19*x + 22)*y + 22*x^2 + 21*x\n\njulia> f*inv(f)\n1","category":"page"},{"location":"AbstractAlgebra/function_field/#Function-field-functionality-provided-by-AbstractAlgebra.jl","page":"Rational function fields","title":"Function field functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"The following functionality is provided for function fields.","category":"page"},{"location":"AbstractAlgebra/function_field/#Basic-manipulation","page":"Rational function fields","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"base_field(::Generic.FunctionField)","category":"page"},{"location":"AbstractAlgebra/function_field/#base_field-Tuple{AbstractAlgebra.Generic.FunctionField}","page":"Rational function fields","title":"base_field","text":"base_field(R::FunctionField)\n\nReturn the rational function field that the field R is an extension of. Synonymous with base_ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"var(::Generic.FunctionField)","category":"page"},{"location":"AbstractAlgebra/function_field/#var-Tuple{AbstractAlgebra.Generic.FunctionField}","page":"Rational function fields","title":"var","text":"var(R::FunctionField)\n\nReturn the variable name of the generator of the function field R as a symbol.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"characteristic(S::Generic.FunctionField)","category":"page"},{"location":"AbstractAlgebra/function_field/#characteristic-Tuple{AbstractAlgebra.Generic.FunctionField}","page":"Rational function fields","title":"characteristic","text":"characteristic(R::FunctionField)\n\nReturn the characteristic of the underlying rational function field.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"defining_polynomial(R::Generic.FunctionField)","category":"page"},{"location":"AbstractAlgebra/function_field/#defining_polynomial-Tuple{AbstractAlgebra.Generic.FunctionField}","page":"Rational function fields","title":"defining_polynomial","text":"defining_polynomial(R::FunctionField)\nmodulus(R::FunctionField)\n\nReturn the original polynomial that was used to define the function field R.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Base.numerator(::Generic.FunctionField{T}, ::Bool=true) where T <: FieldElement","category":"page"},{"location":"AbstractAlgebra/function_field/#numerator-Union{Tuple{AbstractAlgebra.Generic.FunctionField{T}}, Tuple{T}, Tuple{AbstractAlgebra.Generic.FunctionField{T}, Bool}} where T<:FieldElement","page":"Rational function fields","title":"numerator","text":"Base.numerator(R::FunctionField{T}, canonicalise::Bool=true) where T <: FieldElement\nBase.denominator(R::FunctionField{T}, canonicalise::Bool=true) where T <: FieldElement\n\nThinking of elements of the rational function field as fractions, put the defining polynomial of the function field over a common denominator and return the numerator/denominator respectively. Note that the resulting polynomials belong to a different ring than the original defining polynomial. The canonicalise is ignored, but exists for compatibility with the Generic interface.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Base.numerator(::Generic.FunctionFieldElem{T}, ::Bool=true) where T <: FieldElement","category":"page"},{"location":"AbstractAlgebra/function_field/#numerator-Union{Tuple{AbstractAlgebra.Generic.FunctionFieldElem{T}}, Tuple{T}, Tuple{AbstractAlgebra.Generic.FunctionFieldElem{T}, Bool}} where T<:FieldElement","page":"Rational function fields","title":"numerator","text":"Base.numerator(a::FunctionFieldElem{T}, canonicalise::Bool=true) where T <: FieldElement\nBase.denominator(a::FunctionFieldElem{T}, canonicalise::Bool=true) where T <: FieldElement\n\nReturn the numerator and denominator of the function field element a. Note that elements are stored in fraction free form so that the denominator is a common denominator for the coefficients of the element a. If canonicalise is set to true the fraction is first canonicalised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"degree(::Generic.FunctionField)","category":"page"},{"location":"AbstractAlgebra/function_field/#degree-Tuple{AbstractAlgebra.Generic.FunctionField}","page":"Rational function fields","title":"degree","text":"degree(S::FunctionField)\n\nReturn the degree of the defining polynomial of the function field, i.e. the degree of the extension that the function field makes of the underlying rational function field.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"gen(::Generic.FunctionField{T}) where T <: FieldElement","category":"page"},{"location":"AbstractAlgebra/function_field/#gen-Union{Tuple{AbstractAlgebra.Generic.FunctionField{T}}, Tuple{T}} where T<:FieldElement","page":"Rational function fields","title":"gen","text":"gen(S::FunctionField{T}) where T <: FieldElement\n\nReturn the generator of the function field returned by the function field constructor.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"isgen(a::Generic.FunctionFieldElem)","category":"page"},{"location":"AbstractAlgebra/function_field/#isgen-Tuple{AbstractAlgebra.Generic.FunctionFieldElem}","page":"Rational function fields","title":"isgen","text":"isgen(a::FunctionFieldElem)\n\nReturn true if a is the generator of the function field returned by the function field constructor.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"coeff(::Generic.FunctionFieldElem, ::Int)\nnum_coeff(::Generic.FunctionFieldElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/function_field/#coeff-Tuple{AbstractAlgebra.Generic.FunctionFieldElem, Int64}","page":"Rational function fields","title":"coeff","text":"coeff(a::FunctionFieldElem, n::Int)\n\nReturn the degree n coefficient of the element a in its polynomial representation in terms of the generator of the function field. The coefficient is returned as an element of the underlying rational function field.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/#num_coeff-Tuple{AbstractAlgebra.Generic.FunctionFieldElem, Int64}","page":"Rational function fields","title":"num_coeff","text":"num_coeff(a::FunctionFieldElem, n::Int)\n\nReturn the degree n coefficient of the numerator of the element a (in its polynomial representation in terms of the generator of the function field, rationalised as per numerator/denominator described above). The coefficient will be an polynomial over the base_ring of the underlying rational function field.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"julia> R, x = RationalFunctionField(QQ, \"x\")\n(Rational function field over Rationals, x)\n\njulia> U, z = R[\"z\"]\n(Univariate Polynomial Ring in z over Rational function field over Rationals, z)\n\njulia> g = z^2 + 3*(x + 1)//(x + 2)*z + 1\nz^2 + (3*x + 3)//(x + 2)*z + 1\n\njulia> S, y = FunctionField(g, \"y\")\n(Function Field over Rationals with defining polynomial (x + 2)*y^2 + (3*x + 3)*y + x + 2, y)\n\njulia> base_field(S)\nRational function field over Rationals\n\njulia> var(S)\n:y\n\njulia> characteristic(S)\n0\n\njulia> defining_polynomial(S)\nz^2 + (3*x + 3)//(x + 2)*z + 1\n\njulia> numerator(S)\n(x + 2)*y^2 + (3*x + 3)*y + x + 2\n\njulia> denominator(S)\nx + 2\n\njulia> a = (x + 1)//(x^2 + 1)*y + 3x + 2\n((x + 1)*y + 3*x^3 + 2*x^2 + 3*x + 2)//(x^2 + 1)\n\njulia> numerator(a, false)\n(x + 1)*y + 3*x^3 + 2*x^2 + 3*x + 2\n\njulia> denominator(a, false)\nx^2 + 1\n\njulia> degree(S)\n2\n\njulia> gen(S)\ny\n\njulia> isgen(y)\ntrue\n\njulia> coeff(a, 1)\n(x + 1)//(x^2 + 1)\n\njulia> num_coeff(a, 1)\nx + 1","category":"page"},{"location":"AbstractAlgebra/function_field/#Trace-and-norm","page":"Rational function fields","title":"Trace and norm","text":"","category":"section"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"norm(::Generic.FunctionFieldElem)","category":"page"},{"location":"AbstractAlgebra/function_field/#norm-Tuple{AbstractAlgebra.Generic.FunctionFieldElem}","page":"Rational function fields","title":"norm","text":"norm(a::FunctionFieldElem)\n\nReturn the absolute norm of a as an element of the underlying rational function field.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/function_field/","page":"Rational function fields","title":"Rational function fields","text":"julia> R, x = RationalFunctionField(QQ, \"x\")\n(Rational function field over Rationals, x)\n\njulia> U, z = R[\"z\"]\n(Univariate Polynomial Ring in z over Rational function field over Rationals, z)\n\njulia> g = z^2 + 3*(x + 1)//(x + 2)*z + 1\nz^2 + (3*x + 3)//(x + 2)*z + 1\n\njulia> S, y = FunctionField(g, \"y\")\n(Function Field over Rationals with defining polynomial (x + 2)*y^2 + (3*x + 3)*y + x + 2, y)\n\njulia> f = (-3*x - 5//3)//(x - 2)*y + (x^3 + 1//9*x^2 + 5)//(x - 2)\n((-3*x - 5//3)*y + x^3 + 1//9*x^2 + 5)//(x - 2)\n\njulia> norm(f)\n(x^7 + 20//9*x^6 + 766//81*x^5 + 2027//81*x^4 + 110//3*x^3 + 682//9*x^2 + 1060//9*x + 725//9)//(x^3 - 2*x^2 - 4*x + 8)\n\njulia> tr(f)\n(2*x^4 + 38//9*x^3 + 85//9*x^2 + 24*x + 25)//(x^2 - 4)","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"using Oscar","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"Pages = [\"autgroup.md\"]","category":"page"},{"location":"Groups/autgroup/#Groups-of-automorphisms","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"","category":"section"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"Groups of automorphisms over a group G have parametric type AutomorphismGroup{T}, where T is the type of G. The group of automorphisms over a group G is defined by the following instruction:","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"AutomorphismGroup{T}\nautomorphism_group(G)","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"The evaluation of the automorphism f in the element x is analogous to the homomorphism evaluation: it can be obtained by typing either f(x) or x^f.","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"It is possible to turn an automorphism f into a homomorphism by typing hom(f). The converse is also possible: if g is a bijective homomorphism from the group G to itself and A is the automorphism group of G, then the instruction A(g) returns g as automorphism of G. This is the standard way to build explicitly an automorphism (another way, available for inner automorphisms, is shown in Section Inner_automorphisms).","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"automorphism_group(G::GAPGroup)","category":"page"},{"location":"Groups/autgroup/#automorphism_group-Tuple{Oscar.GAPGroup}","page":"Groups of automorphisms","title":"automorphism_group","text":"automorphism_group(G::Group) -> A::AutomorphismGroup{T}\n\nReturn the full automorphism group of G. If f is an object of type GAPGroupHomomorphism and it is bijective from G to itself, then A(f) return the embedding of f in A.\n\nElements of A can be multiplied with other elements of A or by elements of type GAPGroupHomomorphism; in this last case, the result has type GAPGroupHomomorphism.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"Example:","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"julia> S=symmetric_group(4);\n\njulia> A=automorphism_group(S);\n\njulia> g=hom(S,S,x->x^S[1]);\n\njulia> g in A\nfalse\n\njulia> au=A(g);\n\njulia> au in A\ntrue\n\njulia> g==hom(au)\ntrue\n\njulia> x=cperm(S,[1,2,3]);\n\njulia> au(x)\n(2,3,4)\n\njulia> g(x)==au(x)\ntrue","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"In Oscar it is possible to multiply homomorphisms and automorphisms (whenever it makes sense); in such cases, the output is always a variable of type GAPGroupHomomorphism{S,T}.","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"S=symmetric_group(4);\nA=automorphism_group(S);\ng=hom(S,S,x->x^S[1]);\nf=A(g);\ntypeof(g*f)","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"The following functions are available for automorphisms, some of them similar to the corresponding functions for homomorphisms of groups.","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"isinvariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::T) where T<:GAPGroup\nrestrict_automorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::T, A=automorphism_group(H)) where T <: GAPGroup\ninduced_automorphism(f::GAPGroupHomomorphism, mH::GAPGroupHomomorphism)\nhom(x::GAPGroupElem{AutomorphismGroup{T}}) where T <: GAPGroup","category":"page"},{"location":"Groups/autgroup/#isinvariant-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}}, T}} where T<:Oscar.GAPGroup","page":"Groups of automorphisms","title":"isinvariant","text":"isinvariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::T)\n\nReturn whether f(H) == H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#restrict_automorphism-Union{Tuple{T}, Tuple{GAPGroupElem{AutomorphismGroup{T}}, T}, Tuple{GAPGroupElem{AutomorphismGroup{T}}, T, Any}} where T<:Oscar.GAPGroup","page":"Groups of automorphisms","title":"restrict_automorphism","text":"restrict_automorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::T)\n\nReturn the restriction of f to H as an automorphism of H. An exception is thrown if H is not invariant under f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#induced_automorphism-Tuple{GAPGroupHomomorphism, GAPGroupHomomorphism}","page":"Groups of automorphisms","title":"induced_automorphism","text":"induced_automorphism(f::GAPGroupHomomorphism, g::GAPGroupHomomorphism)\ninduced_automorphism(f::GAPGroupHomomorphism, g::GAPGroupElem{AutomorphismGroup{T}})\n\nReturn the automorphism h of the image of f such that h(f) == f(g), where g is an automorphism of a group G and f is a group homomorphism defined over G such that the kernel of f is invariant under g\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#hom-Union{Tuple{GAPGroupElem{AutomorphismGroup{T}}}, Tuple{T}} where T<:Oscar.GAPGroup","page":"Groups of automorphisms","title":"hom","text":"hom(f::GAPGroupElem{AutomorphismGroup{T}}) where T\n\nReturn the element f of type GAPGroupHomomorphism{T,T}.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#inner_automorphisms","page":"Groups of automorphisms","title":"Inner automorphisms","text":"","category":"section"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"Oscar disposes of the following functions to handle inner automorphisms of a group.","category":"page"},{"location":"Groups/autgroup/","page":"Groups of automorphisms","title":"Groups of automorphisms","text":"inner_automorphism(g::GAPGroupElem)\nisinner_automorphism(f::GAPGroupHomomorphism)\ninner_automorphisms_group(A::AutomorphismGroup{T}) where T <: GAPGroup","category":"page"},{"location":"Groups/autgroup/#inner_automorphism-Tuple{GAPGroupElem}","page":"Groups of automorphisms","title":"inner_automorphism","text":"inner_automorphism(g::GAPGroupElem)\n\nReturn the inner automorphism in automorphism_group(parent(g)) defined by x -> x^g.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#isinner_automorphism-Tuple{GAPGroupHomomorphism}","page":"Groups of automorphisms","title":"isinner_automorphism","text":"isinner_automorphism(f::GAPGroupHomomorphism)\nisinner_automorphism(f::GAPGroupElem{AutomorphismGroup{T}})\n\nReturn whether f is an inner automorphism.\n\n\n\n\n\n","category":"method"},{"location":"Groups/autgroup/#inner_automorphisms_group-Union{Tuple{AutomorphismGroup{T}}, Tuple{T}} where T<:Oscar.GAPGroup","page":"Groups of automorphisms","title":"inner_automorphisms_group","text":"inner_automorphisms_group(A::AutomorphismGroup{T})\n\nReturn the subgroup of A of the inner automorphisms.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/puiseux/#Generic-Puiseux-series","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"AbstractAlgebra.jl allows the creation of Puiseux series over any computable commutative ring R.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Puiseux series are power series of the form a_jx^jm + a_j+1x^(j+1)m + cdots + a_k-1x^(k-1)m + O(x^km) for some integer m  0 where i geq 0, a_i in R and the relative precision k - j is at most equal to some specified precision n.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The generic Puiseux series module is implemented in src/generic/PuiseuxSeries.jl.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"As well as implementing the Series Ring interface, the Puiseux series module in AbstractAlgebra.jl implements the generic algorithms described below.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"All of the generic functionality is part of the Generic submodule of AbstractAlgebra.jl. This is exported by default so that it is not necessary to qualify function names.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Types-and-parent-objects","page":"Generic Puiseux series","title":"Types and parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The types of generic Puiseux series implemented by AbstractAlgebra.jl are Generic.PuiseuxSeriesRingElem{T} and Generic.PuiseuxSeriesFieldElem{T}.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Both series element types belong to the union type Generic.PuiseuxSeriesElem.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Puiseux series elements belong directly to either RingElem or FieldElem since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are Puiseux series.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The parent types for Puiseux series, Generic.PuiseuxSeriesRing{T} and Generic.PuiseuxSeriesField{T} respectively, belong to Ring and Field respectively.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The default precision, string representation of the variable and base ring R of a generic Puiseux series are stored in its parent object.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Puiseux-series-ring-constructors","page":"Generic Puiseux series","title":"Puiseux series ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"In order to construct Puiseux series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"PuiseuxSeriesRing(R::Ring, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"PuiseuxSeriesRing(R::Field, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"PuiseuxSeriesField(R::Field, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Given a base ring R, a maximum relative precision and a string s specifying how the generator (variable) should be printed, return a typle S, x representing the Puiseux series ring and its generator.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"By default, S will depend only on S, x and the maximum precision and will be cached. Setting the optional argument cached to false will prevent this.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Here are some examples of constructing various kinds of Puiseux series rings and coercing various elements into those rings.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = PuiseuxSeriesRing(ZZ, 10, \"x\")\n(Puiseux series ring in x over Integers, x + O(x^11))\n\njulia> S, y = PuiseuxSeriesField(QQ, 10, \"y\")\n(Puiseux series field in y over Rationals, y + O(y^11))\n\njulia> f = R()\nO(x^10)\n\njulia> g = S(123)\n123 + O(y^10)\n\njulia> h = R(BigInt(1234))\n1234 + O(x^10)\n\njulia> k = S(y + 1)\n1 + y + O(y^10)\n","category":"page"},{"location":"AbstractAlgebra/puiseux/#Big-oh-notation","page":"Generic Puiseux series","title":"Big-oh notation","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"O(x::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = PuiseuxSeriesRing(ZZ, 10, \"x\")\n(Puiseux series ring in x over Integers, x + O(x^11))\n\njulia> f = 1 + 2x + O(x^5)\n1 + 2*x + O(x^5)\n\njulia> g = 2x^(1//3) + 7x^(2//3) + O(x^(7//3))\n2*x^(1//3) + 7*x^(2//3) + O(x^(7//3))","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"What is happening here in practice is that O(x^n) is creating the series 0 + O(x^n) and the rules for addition of series dictate that if this is added to a series of greater precision, then the lower of the two precisions must be used.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Of course it may be that the precision of the series that O(x^n) is added to is already lower than n, in which case adding O(x^n) has no effect. This is the case if the default precision is too low, since x on its own has the default precision.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Puiseux-series-implementation","page":"Generic Puiseux series","title":"Puiseux series implementation","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Puiseux series have their maximum relative precision capped at some value prec_max. This refers to the internal Laurent series used to store the Puiseux series, i.e. the series without denominators in the exponents.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The Puiseux series type stores such a Laurent series and a scale or denominator for the exponents. For example, f(x) = 1 + x^13 + 2x^23 + O(x^73) would be stored as a Laurent series 1 + x + 2x^2 + O(x^7) and a scale of 3..","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The maximum precision is also used as a default (Laurent) precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"In all models we say that two Puiseux series are equal if they agree up to the minimum absolute precision of the two power series.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Thus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Sometimes it is necessary to compare Puiseux series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"For example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"There are a number of technicalities that must be observed when working with Puiseux series. As these are the same as for the other series rings in AbstractAlgebra.jl, we refer the reader to the documentation of series rings for information about these issues.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Basic-ring-functionality","page":"Generic Puiseux series","title":"Basic ring functionality","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"All Puiseux series provide the functionality described in the Ring and Series Ring interfaces with the exception of the pol_length and polcoeff functions. Naturally the set_precision!, set_valuation! and coeff functions can take a rational exponent.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> S, x = PuiseuxSeriesRing(ZZ, 10, \"x\")\n(Puiseux series ring in x over Integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^10)\n1 + 3*x + x^3 + O(x^10)\n\njulia> g = 1 + 2x^(1//3) + x^(2//3) + O(x^(7//3))\n1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))\n\njulia> h = zero(S)\nO(x^10)\n\njulia> k = one(S)\n1 + O(x^10)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> coeff(g, 1//3)\n2\n\njulia> U = base_ring(S)\nIntegers\n\njulia> v = var(S)\n:x\n\njulia> T = parent(x + 1)\nPuiseux series ring in x over Integers\n\njulia> g == deepcopy(g)\ntrue\n\njulia> t = divexact(2g, 2)\n1 + 2*x^(1//3) + x^(2//3) + O(x^(7//3))\n\njulia> p = precision(f)\n10//1\n","category":"page"},{"location":"AbstractAlgebra/puiseux/#Puiseux-series-functionality-provided-by-AbstractAlgebra.jl","page":"Generic Puiseux series","title":"Puiseux series functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"The functionality below is automatically provided by AbstractAlgebra.jl for any Puiseux series.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Of course, modules are encouraged to provide specific implementations of the functions described here, that override the generic implementation.","category":"page"},{"location":"AbstractAlgebra/puiseux/#Basic-functionality","page":"Generic Puiseux series","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"coeff(a::Generic.PuiseuxSeriesElem, n::Int)","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"coeff(a::Generic.PuiseuxSeriesElem, n::Rational{Int})","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Return the coefficient of the term of exponent n of the given power series. If n exceeds the current precision of the power series or does not correspond to a nonzero term of the Puiseux series, the function returns a zero coefficient.","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"modulus{T <: ResElem}(::Generic.PuiseuxSeriesElem{T})","category":"page"},{"location":"AbstractAlgebra/puiseux/#modulus-Union{Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}}}, Tuple{T}} where T<:ResElem","page":"Generic Puiseux series","title":"modulus","text":"modulus(a::Generic.PuiseuxSeriesElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given Puiseux series.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"isgen(::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#isgen-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"isgen","text":"isgen(a::Generic.PuiseuxSeriesElem)\n\nReturn true if the given Puiseux series is arithmetically equal to the generator of its Puiseux series ring to its current precision, otherwise return false.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, t = PuiseuxSeriesRing(QQ, 10, \"t\")\n(Puiseux series field in t over Rationals, t + O(t^11))\n\njulia> S, x = PuiseuxSeriesRing(R, 30, \"x\")\n(Puiseux series field in x over Puiseux series field in t over Rationals, x + O(x^31))\n\njulia> a = O(x^4)\nO(x^4)\n\njulia> b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)\n(3 + t + O(t^10))*x + (1 + t^2 + O(t^10))*x^2 + O(x^4)\n\njulia> k = isgen(gen(R))\ntrue\n\njulia> m = isunit(-1 + x^(1//3) + 2x^2)\ntrue\n\njulia> n = valuation(a)\n4//1\n\njulia> p = valuation(b)\n1//1\n\njulia> c = coeff(b, 2)\n1 + t^2 + O(t^10)\n","category":"page"},{"location":"AbstractAlgebra/puiseux/#Division","page":"Generic Puiseux series","title":"Division","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Base.inv(::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#inv-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"inv","text":"inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix over a ring, return an ntimes n matrix X such that MX = I_n, where I_n is the ntimes n identity matrix. If M is not invertible over the base ring an exception is raised.\n\n\n\nBase.inv(a::PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the inverse of the power series a, i.e. 1a, if it exists. Otherwise an exception is raised.\n\n\n\n inv(a::LocElem{T}, checked::Bool = true)  where {T <: RingElem}\n\nReturns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = PuiseuxSeriesRing(QQ, 30, \"x\")\n(Puiseux series field in x over Rationals, x + O(x^31))\n\njulia> a = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> b = R(-1)\n-1 + O(x^30)\n\njulia> c = inv(a)\n1 - x - x^2 + 3*x^3 - x^4 + O(x^5)\n\njulia> d = inv(b)\n-1 + O(x^30)\n","category":"page"},{"location":"AbstractAlgebra/puiseux/#Derivative-and-integral","page":"Generic Puiseux series","title":"Derivative and integral","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"derivative(a::Generic.PuiseuxSeriesElem)\nintegral(a::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#derivative-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"derivative","text":"derivative(f::AbsSeriesElem{T})\n\nReturn the derivative of the power series f.\n\n\n\nderivative(f::RelSeriesElem{T})\n\nReturn the derivative of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\nderivative(f::AbstractAlgebra.MPolyElem{T}, j::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\nderivative(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\nderivative(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the derivative of the given Puiseux series a.\n\n\n\nderivative(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable of index n.\n\n\n\nderivative(x::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable v.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/#integral-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"integral","text":"integral(f::AbsSeriesElem{T})\n\nReturn the integral of the power series f.\n\n\n\nintegral(f::RelSeriesElem{T})\n\nReturn the integral of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\nintegral(f::RelSeriesElem{T}) -> RelSeriesElem\n\nReturn the integral of the power series f.\n\n\n\nintegral(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the integral of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, x = PuiseuxSeriesRing(QQ, 10, \"x\")\n(Puiseux series field in x over Rationals, x + O(x^11))\n\njulia> f = x^(5//3) + x^(7//3) + x^(11//3)\nx^(5//3) + x^(7//3) + x^(11//3) + O(x^5)\n\njulia> derivative(f)\n5//3*x^(2//3) + 7//3*x^(4//3) + 11//3*x^(8//3) + O(x^4)\n\njulia> derivative(integral(f)) == f\ntrue","category":"page"},{"location":"AbstractAlgebra/puiseux/#Special-functions","page":"Generic Puiseux series","title":"Special functions","text":"","category":"section"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Base.log(a::Generic.PuiseuxSeriesElem)\nBase.exp(a::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#log-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"log","text":"log(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the logarithm of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/#exp-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"exp","text":"exp(a::AbsSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::RelSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Base.sqrt(a::Generic.PuiseuxSeriesElem)","category":"page"},{"location":"AbstractAlgebra/puiseux/#sqrt-Tuple{Union{AbstractAlgebra.Generic.PuiseuxSeriesFieldElem{T}, AbstractAlgebra.Generic.PuiseuxSeriesRingElem{T}} where T<:RingElement}","page":"Generic Puiseux series","title":"sqrt","text":"Base.sqrt(f::PolyElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/puiseux/","page":"Generic Puiseux series","title":"Generic Puiseux series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PuiseuxSeriesRing(R, 30, \"x\")\n(Puiseux series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> T, z = PuiseuxSeriesRing(QQ, 30, \"z\")\n(Puiseux series field in z over Rationals, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> b = z + 2z^2 + 5z^3 + O(z^5)\nz + 2*z^2 + 5*z^3 + O(z^5)\n\njulia> c = exp(x + O(x^40))\n1 + x + 1//2*x^2 + 1//6*x^3 + 1//24*x^4 + 1//120*x^5 + 1//720*x^6 + 1//5040*x^7 + 1//40320*x^8 + 1//362880*x^9 + 1//3628800*x^10 + 1//39916800*x^11 + 1//479001600*x^12 + 1//6227020800*x^13 + 1//87178291200*x^14 + 1//1307674368000*x^15 + 1//20922789888000*x^16 + 1//355687428096000*x^17 + 1//6402373705728000*x^18 + 1//121645100408832000*x^19 + 1//2432902008176640000*x^20 + 1//51090942171709440000*x^21 + 1//1124000727777607680000*x^22 + 1//25852016738884976640000*x^23 + 1//620448401733239439360000*x^24 + 1//15511210043330985984000000*x^25 + 1//403291461126605635584000000*x^26 + 1//10888869450418352160768000000*x^27 + 1//304888344611713860501504000000*x^28 + 1//8841761993739701954543616000000*x^29 + 1//265252859812191058636308480000000*x^30 + O(x^31)\n\njulia> d = divexact(x, exp(x + O(x^40)) - 1)\n1 - 1//2*x + 1//12*x^2 - 1//720*x^4 + 1//30240*x^6 - 1//1209600*x^8 + 1//47900160*x^10 - 691//1307674368000*x^12 + 1//74724249600*x^14 - 3617//10670622842880000*x^16 + 43867//5109094217170944000*x^18 - 174611//802857662698291200000*x^20 + 77683//14101100039391805440000*x^22 - 236364091//1693824136731743669452800000*x^24 + 657931//186134520519971831808000000*x^26 - 3392780147//37893265687455865519472640000000*x^28 + O(x^29)\n\njulia> f = exp(b)\n1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)\n\njulia> h = sqrt(a)\n1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)\n","category":"page"},{"location":"DeveloperDocumentation/documentation/#Documenting-OSCAR-code","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"The general philosophy of the OSCAR documentation is to put as much of the information as possible into the docstrings and only use the doc pages for collecting this information and provide some additional general context. Exceptions to this philosophy are the developer and general pages.","category":"page"},{"location":"DeveloperDocumentation/documentation/#Docstrings-of-exported-functions","page":"Documenting OSCAR code","title":"Docstrings of exported functions","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Exported function should have docstrings, which look like","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Markdown.@doc doc\"\"\"\n    functionname(x::ArgumentType, b::OtherArgument; c::Keyword = default) -> Int, Int\n\nA short description of the function. It is allowed to use $\\LaTeX$.\n\"\"\"\nfunctionname(x...,b...; c = ...)","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"If the signature is too long, use linebreaks to fit 80 characters.","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Please also do provide an example within the docstring if possible, preferrably as a jldoctest, i.e.","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Markdown.@doc doc\"\"\"\n    functionname(x::ArgumentType, b::OtherArgument; c::Keyword = default) -> Int, Int\n\nA short description of the function. It is allowed to use $\\LaTeX$.\n\n# Examples\nThis shows that `functionname` does the right thing for input `input`\n```jldoctest\njulia> input = ...\n\njulia> functionname(input)\noutput\n```\n\"\"\"\nfunctionname(x...,b...; c = ...)","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"This allows the user to immediately see how the function can be used, gives them some code that they can copy-paste and manipulate, and, as a bonus, provides a testcase as well.","category":"page"},{"location":"DeveloperDocumentation/documentation/#The-folder-docs","page":"Documenting OSCAR code","title":"The folder docs","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"The folder docs/src contains the OSCAR documentation website. Most of the pages are relatively sparse and consist of","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"```@docs\nsome_function\nsome_other_function\n[...]\n```","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"blocks that simply pull in the docstring from the corresponding source file. If you add a new page in docs/src, you will have to modify docs/doc.main to include your new page in the appropriate place.","category":"page"},{"location":"DeveloperDocumentation/documentation/#Building-the-OSCAR-documentation","page":"Documenting OSCAR code","title":"Building the OSCAR documentation","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"To build the OSCAR documentation (especially when editing it, which usually requires rebuilding it several times to test the outcome), we recommend the following steps:","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"Install the Julia package Revise into the environment in which you run your Oscar dev version:\n using Pkg ; Pkg.add(\"Revise\")\nStart a fresh Julia session and load Revise before Oscar:\n using Revise, Oscar\nBuild the manual as follows:\n Oscar.build_doc()\nTo rebuild the documentation, just repeat the same command as in step 3, without exiting Julia. Thanks to the Revise package, any runs after the first will be much faster.","category":"page"},{"location":"DeveloperDocumentation/documentation/#Updating-the-bibliography","page":"Documenting OSCAR code","title":"Updating the bibliography","text":"","category":"section"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"When editing docs/oscar_references.bib please follow the style of the existing entries. An easy way to do that is to add your new BibTeX entry, then run bibtool by invoking it as follows from the root directory of the Oscar.jl repository:","category":"page"},{"location":"DeveloperDocumentation/documentation/","page":"Documenting OSCAR code","title":"Documenting OSCAR code","text":"bibtool docs/oscar_references.bib -o docs/oscar_references.bib","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"Pages = [\"architecture.md\"]","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"CurrentModule = Oscar","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"using Oscar","category":"page"},{"location":"General/architecture/#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"This page aims to give a short technical overview of the architecture of Oscar. A more in-depth overview of the various components of Oscar is given on the Oscar homepage.","category":"page"},{"location":"General/architecture/#Julia-packages","page":"Architecture","title":"Julia packages","text":"","category":"section"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"Oscar is developed as a pure julia package Oscar.jl and builds on the features and interfaces provided by the julia packages for the cornerstones:","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"ANTIC: AbstractAlgebra.jl,        Hecke.jl,        Nemo.jl\nGAP.jl\nPolymake.jl\nSingular.jl","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"The packages are integrated into the julia package manager and will be installed automatically as dependencies of Oscar. They can be accessed directly by their names once Oscar is loaded.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"The current versions of these packages can be inspected with the Oscar.versioninfo command:","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"Oscar.versioninfo()","category":"page"},{"location":"General/architecture/#Binary-packages-for-non-julia-libraries","page":"Architecture","title":"Binary packages for non-julia libraries","text":"","category":"section"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"In addition to the pure julia packages, Oscar builds on many non-julia libraries for the cornerstones (FLINT, GAP, polymake, Singular) and their dependencies.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"Both Polymake.jl and Singular.jl use CxxWrap.jl together with the corresponding libcxxwrap-julia library as an intermediate layer between the julia packages and the C / C++ libraries.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"All dependencies have been integrated into the BinaryBuilder ecosystem which provides precompiled binaries for all supported architectures. The build-recipes are maintained in julia's Yggdrasil repository. These are used to automatically build binary artifacts together with the corresponding jll packages which allow automatic installation of all required binaries as dependencies for Oscar.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"The binary packages can be found under the JuliaBinaryWrappers organization. Each repository has an autogenerated Readme file which gives some details on the original sources, supported platforms, and dependencies.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"The Oscar.versioninfo function can also include the versions of all binary packages that are maintained by the Oscar developers:","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"Oscar.versioninfo(jll=true)","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"For a full list of all dependencies of the current project please use using Pkg; Pkg.status(mode=PKGMODE_MANIFEST) or the Pkg REPL command ]st -m.","category":"page"},{"location":"General/architecture/","page":"Architecture","title":"Architecture","text":"versioninfo","category":"page"},{"location":"General/architecture/#versioninfo","page":"Architecture","title":"versioninfo","text":"Oscar.versioninfo(io::IO=stdout; branch=false, jll=false, julia=false)\n\nPrint the versions of all Oscar-related dependencies.\n\nArguments\n\nbranch::Bool=false: include git branch name in the output\njll::Bool=false   : include binary packages (jll) in the output\njulia::Bool=false : include julia versioninfo output\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/poly_interface/#Univariate-Polynomial-Ring-Interface","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"","category":"section"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Univariate polynomial rings are supported in AbstractAlgebra, and in addition to the standard Ring interface, numerous additional functions are required to be present for univariate polynomial rings.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Univariate polynomial rings can be built over both commutative and noncommutative rings.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Univariate polynomial rings over a field are also Euclidean and therefore such rings must implement the Euclidean interface.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Since a sparse distributed multivariate format can generally also handle sparse univariate polynomials, the univariate polynomial interface is designed around the assumption that they are dense. This is not a requirement, but it may be easier to use the multivariate interface for sparse univariate types.","category":"page"},{"location":"AbstractAlgebra/poly_interface/#Types-and-parents","page":"Univariate Polynomial Ring Interface","title":"Types and parents","text":"","category":"section"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"AbstractAlgebra provides two abstract types for polynomial rings and their elements over a commutative ring:","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"PolyRing{T} is the abstract type for univariate polynomial ring parent types\nPolyElem{T} is the abstract type for univariate polynomial types","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Similarly there are two abstract types for polynomial rings and their elements over a noncommutative ring:","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"NCPolyRing{T} is the abstract type for univariate polynomial ring parent types\nNCPolyElem{T} is the abstract type for univariate polynomial types","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"We have that PolyRing{T} <: Ring and PolyElem{T} <: RingElem. Similarly we have that NCPolyRing{T} <: NCRing and  NCPolyElem{T} <: NCRingElem.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Note that the abstract types are parameterised. The type T should usually be the type of elements of the coefficient ring of the polynomial ring. For example, in the case of mathbbZx the type T would be the type of an integer, e.g. BigInt.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"If the parent object for such a ring has type MyZX and polynomials in that ring have type MyZXPoly then one would have:","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"MyZX <: PolyRing{BigInt}\nMyZXPoly <: PolyElem{BigInt}","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Polynomial rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Polynomial rings should at least be distinguished based on their base (coefficient) ring. But if they have the same base ring and symbol (for their variable/generator), they should certainly have the same parent object.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"AbstractAlgebra/poly_interface/#Required-functionality-for-univariate-polynomials","page":"Univariate Polynomial Ring Interface","title":"Required functionality for univariate polynomials","text":"","category":"section"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"In addition to the required functionality for the Ring/NCRing interface (and in the case of polynomials over a field, the Euclidean Ring interface), the Polynomial Ring interface has the following required functions.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"We suppose that R is a fictitious base ring (coefficient ring) and that S is a univariate polynomial ring over R (i.e. S = Rx) with parent object S of type MyPolyRing{T}. We also assume the polynomials in the ring have type MyPoly{T}, where T is the type of elements of the base (coefficient) ring.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem or NCRingElem.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"We describe the functionality below for polynomials over commutative rings, i.e. with element type belonging to RingElem, however similar constructors should be available for element types belonging to NCRingElem instead, if the coefficient ring is noncommutative.","category":"page"},{"location":"AbstractAlgebra/poly_interface/#Constructors","page":"Univariate Polynomial Ring Interface","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"In addition to the standard constructors, the following constructors, taking an array of coefficients, must be available.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"(S::MyPolyRing{T})(A::Vector{T}) where T <: RingElem\n(S::MyPolyRing{T})(A::Vector{U}) where T <: RingElem, U <: RingElem\n(S::MyPolyRing{T})(A::Vector{U}) where T <: RingElem, U <: Integer","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Create the polynomial in the given ring whose degree i coefficient is given by A[1 + i]. The elements of the array are assumed to be able to be coerced into the base ring R. If the argument is an empty vector, the zero polynomial shall be returned.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"It may be desirable to have a additional version of the function that accepts an array of Julia Int values  if this can be done more efficiently.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"It is also possible to create polynomials directly without first creating the corresponding polynomial ring.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"polynomial(R::Ring, arr::Vector{T}, var::String=\"x\"; cached::Bool=true)","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Given an array of coefficients construct the polynomial with those coefficients over the given ring and with the given variable.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"note: Note\nIf cached is set to false then the parent ring of the created polynomial is not cached. However, this means that subsequent polynomials created in the same way will not be compatible. Instead, one should use the parent object of the first polynomial to create subsequent polynomials instead of calling this function repeatedly with cached=false.","category":"page"},{"location":"AbstractAlgebra/poly_interface/#Data-type-and-parent-object-methods","page":"Univariate Polynomial Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"var(S::MyPolyRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Return a Symbol representing the variable (generator) of the polynomial ring. Note that this is a Symbol not a String, though its string value will usually be used when printing polynomials.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"symbols(S::MyPolyRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Return the array [s] where s is a Symbol representing the variable of the given polynomial ring. This is provided for uniformity with the multivariate interface, where there is more than one variable and hence an array of symbols.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Custom polynomial types over a given ring should define the following function which returns the type of a polynomial object over that ring.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"dense_poly_type(::Type{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Return the type of a polynomial whose coefficients have the given type.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"This function is defined for generic polynomials and only needs to be defined for custom polynomial rings, e.g. ones defined by a C implementation.","category":"page"},{"location":"AbstractAlgebra/poly_interface/#Basic-manipulation-of-rings-and-elements","page":"Univariate Polynomial Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"length(f::MyPoly{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Return the length of the given polynomial. The length of the zero polynomial is defined to be 0, otherwise the length is the degree plus 1. The return value should be of type Int.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"set_length!(f::MyPoly{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"This function must zero any coefficients beyond the requested length n and then set the length of the polynomial to n. This function does not need to normalise the polynomial and is not useful to the user, but is used extensively by the AbstractAlgebra generic functionality.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"This function returns the resulting polynomial.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"coeff(f::MyPoly{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Return the coefficient of the polynomial f of degree n. If n is larger than the degree of the polynomial, it should return zero in the coefficient ring. ","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"setcoeff!(f::MyPoly{T}, n::Int, a::T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Set the degree n coefficient of f to a. This mutates the polynomial in-place if possible and returns the mutated polynomial (so that immutable types can also be supported). The function must not assume that the polynomial already has space for n + 1 coefficients. The polynomial must be resized if this is not the case.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Note that this function is not required to normalise the polynomial and is not necessarily useful to the user, but is used extensively by the generic functionality in AbstractAlgebra.jl. It is for setting raw coefficients in the representation.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"normalise(f::MyPoly{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Given a polynomial whose length is currently n, including any leading zero coefficients, return the length of the normalised polynomial (either zero or the length of the polynomial with nonzero leading coefficient). Note that the function does not actually perform the normalisation.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"fit!(f::MyPoly{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Ensure that the polynomial f internally has space for n coefficients. This function must mutate the function in-place if it is mutable. It does not return the mutated polynomial. Immutable types can still be supported by defining this function to do nothing.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Some interfaces for C polynomial types automatically manage the internal allocation of polynomials in every function that can be called on them. Explicit adjustment by the generic code in AbstractAlgebra.jl is not required. In such cases, this function can also be defined to do nothing.","category":"page"},{"location":"AbstractAlgebra/poly_interface/#Optional-functionality-for-polynomial-rings","page":"Univariate Polynomial Ring Interface","title":"Optional functionality for polynomial rings","text":"","category":"section"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Sometimes parts of the Euclidean Ring interface can and should be implemented for polynomials over a ring that is not necessarily a field.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"When divisibility testing can be implemented for a polynomial ring over a field, it  should be possible to implement the following functions from the Euclidean Ring interface:","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"divides\nremove\nvaluation","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"When the given polynomial ring is a GCD domain, with an effective GCD algorithm, it may be possible to implement the following functions:","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"gcd\nlcm","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Polynomial rings can optionally implement any part of the generic univariate polynomial functionality provided by AbstractAlgebra.jl, using the same interface. ","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Obviously additional functionality can also be added to that provided by AbstractAlgebra.jl on an ad hoc basis.","category":"page"},{"location":"AbstractAlgebra/poly_interface/#Similar","page":"Univariate Polynomial Ring Interface","title":"Similar","text":"","category":"section"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"The similar function is available for all univariate polynomial types, but new polynomial rings can define a specialised version of it if required.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"similar(x::MyPoly{T}, R::Ring=base_ring(x), var::String=String(var(parent(x)))) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Construct the zero polynomial with the given variable and coefficients in the given ring, if specified, and with the defaults shown if not.","category":"page"},{"location":"AbstractAlgebra/poly_interface/","page":"Univariate Polynomial Ring Interface","title":"Univariate Polynomial Ring Interface","text":"Custom polynomial rings may choose which polynomial type is best-suited to return for any given arguments. If they don't specialise the function the default polynomial type returned is a Generic.Poly.","category":"page"},{"location":"ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"ToricVarieties/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"The toric geometry part of OSCAR comprises algorithms addressing","category":"page"},{"location":"ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"normal toric varieties\ntorus-invariant divisors and line bundles on normal toric varieties\nobjects from commutative algebra and polyhedral geometry derived thereof.","category":"page"},{"location":"ToricVarieties/intro/","page":"Introduction","title":"Introduction","text":"We follow David A. Cox, John B. Little, Henry K. Schenck (2011). Our goal is to ensure that one can perform all computations of Appendix B. Currently, this project is work-in-progress.","category":"page"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"CurrentModule = Oscar","category":"page"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"using Oscar","category":"page"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"Pages = [\"matroids.md\"]","category":"page"},{"location":"Combinatorics/matroids/#Matroids","page":"Matroids","title":"Matroids","text":"","category":"section"},{"location":"Combinatorics/matroids/#Introduction","page":"Matroids","title":"Introduction","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"Matroids are a fundamental combinatorial object with connections to various fields of mathematics. It is an abstraction of linear independence in vector spaces and forests in graphs. One way to define a matroid is via the following two sets of data:","category":"page"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"a finite ground set E = 1ldotsn and\na nonempty finite set mathcalB subseteq mathcalP(E) of bases satisfying an exchange property.","category":"page"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"There are however many equivalent ways to define a matroid. One can also define a matroid via its circuits, hyperplanes, a graph, or a matrix. For a detailed introduction of matroids we refer to the textbook James Oxley (2011).","category":"page"},{"location":"Combinatorics/matroids/#Construction","page":"Matroids","title":"Construction","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"matroid_from_bases(bases::AbstractVector{T}, nelements::IntegerUnion; check::Bool=true) where T<:GroundsetType\nmatroid_from_nonbases(nonbases::AbstractVector{T}, nelements::IntegerUnion; check::Bool=true) where T<:GroundsetType\nmatroid_from_circuits(circuits::AbstractVector{T}, nelements::IntegerUnion) where T<:GroundsetType\nmatroid_from_hyperplanes(hyperplanes::AbstractVector{T}, nelements::IntegerUnion) where T<:GroundsetType\nmatroid_from_matrix_columns(A::MatrixElem; check::Bool=true)\nmatroid_from_matrix_rows(A::MatrixElem, ; check::Bool=true)\ncycle_matroid(g::Oscar.Graphs.Graph)\nbond_matroid(g::Oscar.Graphs.Graph)\ncocycle_matroid(g::Oscar.Graphs.Graph)\nMatroid(pm_matroid::Polymake.BigObjectAllocated, E::GroundsetType=Vector{Integer}(1:pm_matroid.N_ELEMENTS))\nmatroid_from_revlex_basis_encoding(rvlx::String, r::IntegerUnion, n::IntegerUnion)","category":"page"},{"location":"Combinatorics/matroids/#matroid_from_bases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T<:Union{AbstractSet, AbstractVector{T} where T}","page":"Matroids","title":"matroid_from_bases","text":"matroid_from_bases(B, [n, E])\n\nArguments\n\nB::AbstractVector: The set of bases of the matroid.\nn::InterUnion: The size of the ground set. The ground set will be {1,..n} in this case.\nE::AbstractVector: An explicit ground set passed as vector.\n\nConstruct a matroid with bases B on the ground set E (which can be the empty set). The set B is a non-empty collection of subsets of the ground set E satisfying an exchange property, and the default value for E is the set {1,..n} for a non-negative value n.\n\nSee Section 1.2 of James Oxley (2011).\n\nExamples\n\nTo construct a rank two matroid with five bases on four elements you can write:\n\njulia> B = [[1,2],[1,3],[1,4],[2,3],[2,4]];\n\njulia> M = matroid_from_bases(B,4)\nMatroid of rank 2 on 4 elements\n\nTo construct the same matroid on the four elements 1,2,i,j you may write:\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j'])\nMatroid of rank 2 on 4 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_nonbases-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T<:Union{AbstractSet, AbstractVector{T} where T}","page":"Matroids","title":"matroid_from_nonbases","text":"matroid_from_nonbases(N, [n, E])\n\nArguments\n\nN::AbstractVector: The set of nonbases of the matroid.\nn::InterUnion: The size of the ground set. The ground set will be {1,..n} in this case.\nE::AbstractVector: An explicit ground set passed as vector.\n\nConstruct a matroid with nonbases N on the ground set E (which can be the empty set). That means that the matroid has as bases all subsets of the size |N[1]| of the ground set that are not in N. The set N can't be empty in this function. The described complement of N needs to be a non-empty collection of subsets of the ground set E satisfying an exchange property, and the default value for E is the set {1,..n} for a non-negative value n.\n\nSee Section 1.2 of James Oxley (2011).\n\nExamples\n\nTo construct the Fano matroid you may write:\n\njulia> H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];\n\njulia> M = matroid_from_nonbases(H,7)\nMatroid of rank 3 on 7 elements\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_circuits-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T<:Union{AbstractSet, AbstractVector{T} where T}","page":"Matroids","title":"matroid_from_circuits","text":"matroid_from_circuits(C, [n, E])\n\nArguments\n\nC::AbstractVector: The set of circuits of the matroid.\nn::InterUnion: The size of the ground set. The ground set will be {1,..n} in this case.\nE::AbstractVector: An explicit ground set passed as vector.\n\nA matroid with circuits C on the ground set E (which can be the empty set). The set C is a collection of subsets of the ground set E satisfying an exchange property, and the default value for E is the set {1,..n} for a non-negative value n. \n\nSee Section 1.1 of James Oxley (2011).\n\nExamples\n\nTo construct a rank two matroid with five bases on four elements by its circuits you may write:\n\njulia> C = [[1,2,3],[1,2,4],[3,4]];\n\njulia> M = matroid_from_circuits(C,4)\nMatroid of rank 2 on 4 elements\n\nTo construct the same matroid on the ground set {1,2,i,j} you may write:\n\njulia> C = [[1,2,'j'],[1,2,'i'],['i','j']];\n\njulia> M = matroid_from_circuits(C,[1,2,'i','j'])\nMatroid of rank 2 on 4 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_hyperplanes-Union{Tuple{T}, Tuple{AbstractVector{T}, Union{Integer, fmpz}}} where T<:Union{AbstractSet, AbstractVector{T} where T}","page":"Matroids","title":"matroid_from_hyperplanes","text":"matroid_from_hyperplanes(H, [n, E])\n\nArguments\n\nH::AbstractVector: The set of hyperplanes of the matroid.\nn::InterUnion: The size of the ground set. The ground set will be {1,..n} in this case.\nE::AbstractVector: An explicit ground set passed as vector.\n\nA matroid with hyperplanes H on the ground set E (which can be the empty set). A hyperplane is a flat of rank r-1. The set H is a collection of subsets of the ground set E satisfying an exchange property, and the default value for E is the set {1,..n} for a non-negative value n. \n\nSee Section 1.4 of James Oxley (2011).\n\nExamples\n\nTo construct the Fano matroid you may write:\n\njulia> H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];\n\njulia> M = matroid_from_hyperplanes(H,7)\nMatroid of rank 3 on 7 elements\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_matrix_columns-Tuple{MatrixElem{T} where T}","page":"Matroids","title":"matroid_from_matrix_columns","text":"matroid_from_matrix_columns(A::MatrixElem)\n\nA matroid represented by the column vectors of a matrix A.\n\nSee Section 1.1 of James Oxley (2011).\n\nExamples\n\nTo construct the vector matroid (a.k.a linear matroid) of the matrix A over the field with two elements write:\n\njulia> A = matrix(GF(2),[[1,0,1,1],[0,1,1,1]]);\n\njulia> M = matroid_from_matrix_columns(A)\nMatroid of rank 2 on 4 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#matroid_from_matrix_rows-Tuple{MatrixElem{T} where T}","page":"Matroids","title":"matroid_from_matrix_rows","text":"matroid_from_matrix_columns(A::MatrixElem)\n\nA matroid represented by the row vectors of a matrix.\n\nSee Section 1.1 of James Oxley (2011).\n\nExamples\n\nTo construct the linear matroid of the rows of the matrix A over the field with two elements write:\n\njulia> A = matrix(GF(2),[[1,0],[0,1],[1,1],[1,1]]);\n\njulia> M = matroid_from_matrix_rows(A)\nMatroid of rank 2 on 4 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cycle_matroid-Tuple{Oscar.Graphs.Graph}","page":"Matroids","title":"cycle_matroid","text":"cycle_matroid(g::Oscar.Graphs.Graph)\n\nThe cycle matroid of a graph g.\n\nSee Section 1.1 of James Oxley (2011).\n\nExamples\n\nTo construct the cycle matroid of the complete graph of 4 vertices write:\n\njulia> g = Oscar.Graphs.complete_graph(4);\n\njulia> M = cycle_matroid(g)\nMatroid of rank 3 on 6 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#bond_matroid-Tuple{Oscar.Graphs.Graph}","page":"Matroids","title":"bond_matroid","text":"bond_matroid(g::Oscar.Graphs.Graph)\n\nThe \"bond matroid\" or \"cocycle matroid\" of a graph which is the dual of a cycle matroid, i.e., cographic.\n\nSee Section 2.3 of James Oxley (2011).\n\nExamples\n\nTo construct the bond or cocycle matroid of the complete graph of 4 vertices write:\n\njulia> g = Oscar.Graphs.complete_graph(4);\n\njulia> M = bond_matroid(g)\nMatroid of rank 3 on 6 elements\n\nor equivalently\n\njulia> g = Oscar.Graphs.complete_graph(4);\n\njulia> M = cocycle_matroid(g)\nMatroid of rank 3 on 6 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cocycle_matroid-Tuple{Oscar.Graphs.Graph}","page":"Matroids","title":"cocycle_matroid","text":"See bond_matroid.\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Matroid","page":"Matroids","title":"Matroid","text":"Matroid(pm_matroid::Polymake.BigObjectAllocated, E::GroundsetType)\n\nConstruct a matroid from a polymake matroid M on the default ground set {1,...,n}.\n\n\n\n","category":"type"},{"location":"Combinatorics/matroids/#matroid_from_revlex_basis_encoding-Tuple{String, Union{Integer, fmpz}, Union{Integer, fmpz}}","page":"Matroids","title":"matroid_from_revlex_basis_encoding","text":"matroid_from_revlex_basis_encoding(rvlx::String, r::IntegerUnion, n::IntegerUnion)\n\nConstruct a matroid from a revlex-basis-encoding-string rvlx of rank r and size n.\n\nExamples\n\njulia> matroid_from_revlex_basis_encoding(\"0******0******0***0******0*0**0****\", 3, 7)\nMatroid of rank 3 on 7 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Examples","page":"Matroids","title":"Examples","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"uniform_matroid(r::IntegerUnion,n::IntegerUnion)\nfano_matroid()\nnon_fano_matroid()\nnon_pappus_matroid()\npappus_matroid()\nvamos_matroid()\nall_subsets_matroid(r::Int)\nprojective_plane(q::Int)\nprojective_geometry(r::Int, q::Int; check::Bool=false)\naffine_geometry(r::Int, q::Int; check::Bool=false)","category":"page"},{"location":"Combinatorics/matroids/#uniform_matroid-Tuple{Union{Integer, fmpz}, Union{Integer, fmpz}}","page":"Matroids","title":"uniform_matroid","text":"uniform_matroid(r,n)\n\nConstruct the uniform matroid of rank r on the n elements {1,...,n}.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#fano_matroid-Tuple{}","page":"Matroids","title":"fano_matroid","text":"fano_matroid()\n\nConstruct the Fano matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#non_fano_matroid-Tuple{}","page":"Matroids","title":"non_fano_matroid","text":"non_fano_matroid()\n\nConstruct the non-Fano matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#non_pappus_matroid-Tuple{}","page":"Matroids","title":"non_pappus_matroid","text":"non_pappus_matroid()\n\nConstruct the non-Pappus matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#pappus_matroid-Tuple{}","page":"Matroids","title":"pappus_matroid","text":"pappus_matroid()\n\nConstruct the Pappus matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#vamos_matroid-Tuple{}","page":"Matroids","title":"vamos_matroid","text":"vamos_matroid()\n\nConstruct the Vamos matroid.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#all_subsets_matroid-Tuple{Int64}","page":"Matroids","title":"all_subsets_matroid","text":"all_subsets_matroid(r)\n\nConstruct the all-subsets-matroid of rank r, a.k.a. the matroid underlying the resonance arrangement or rank r.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#projective_plane-Tuple{Int64}","page":"Matroids","title":"projective_plane","text":"projective_plane(q::Int)\n\nThe projective plane of order q. Note that this only works for prime numbers q for now.\n\nSee Section 6.1 of James Oxley (2011).\n\nExamples\n\njulia> M = projective_plane(3)\nMatroid of rank 3 on 13 elements\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#projective_geometry-Tuple{Int64, Int64}","page":"Matroids","title":"projective_geometry","text":"projective_geometry(r::Int, q::Int)\n\nThe projective geometry of order q and rank r+1. Note that this only works for prime numbers q for now.\n\nSee Section 6.1 of James Oxley (2011). Warning: Following the book of Oxley, the rank of the resulting matroid is r+1.\n\nExamples\n\njulia> M = projective_geometry(2, 3)\nMatroid of rank 3 on 13 elements\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#affine_geometry-Tuple{Int64, Int64}","page":"Matroids","title":"affine_geometry","text":"affine_geometry(r::Int, q::Int)\n\nThe affine geometry of order q and rank r+1. Note that this only works for prime numbers q for now.\n\nSee Section 6.1 of James Oxley (2011). Warning: Following the book of Oxley, the rank of the resulting matroid is r+1.\n\nExamples\n\njulia> M = affine_geometry(2, 3)\nMatroid of rank 3 on 9 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Modifying-matroids","page":"Matroids","title":"Modifying matroids","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"dual_matroid(M::Matroid)\ndirect_sum(M::Matroid, N::Matroid)\ndeletion(M::Matroid,set::GroundsetType)\nrestriction(M::Matroid, set::GroundsetType)\ncontraction(M::Matroid,set::GroundsetType)\nminor(M::Matroid, set_del::GroundsetType, set_cont::GroundsetType)\nprincipal_extension(M::Matroid, set::GroundsetType, elem::ElementType)\nfree_extension(M::Matroid, elem::ElementType)\nseries_extension(M::Matroid, old::ElementType, new::ElementType)\nparallel_extension(M::Matroid, old::ElementType, new::ElementType)","category":"page"},{"location":"Combinatorics/matroids/#dual_matroid-Tuple{Matroid}","page":"Matroids","title":"dual_matroid","text":"dual_matroid(M::Matroid)\n\nThe dual matroid of a given matroid M.\n\nSee page 65 and Sectrion 2 in James Oxley (2011).\n\nExamples\n\nTo construct the dual of the Fano matroid write:\n\njulia> M = dual_matroid(fano_matroid())\nMatroid of rank 4 on 7 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#direct_sum-Tuple{Matroid, Matroid}","page":"Matroids","title":"direct_sum","text":"direct_sum(M::Matroid, N::Matroid)\n\nThe direct sum of the matroids M and N. Optionally one can also pass a vector of matroids.\n\nSee Section 4.2 of James Oxley (2011).\n\nTo obtain the direct sum of the Fano and a uniform matroid type:\n\nExamples\n\njulia> direct_sum(fano_matroid(), uniform_matroid(2,4))\nMatroid of rank 5 on 11 elements\n\nTo take the sum of three uniform matroids use:\n\nExamples\n\njulia> matroids = Vector([uniform_matroid(2,4), uniform_matroid(1,3), uniform_matroid(3,4)]);\n\njulia> M = direct_sum(matroids)\nMatroid of rank 6 on 11 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#deletion-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"deletion","text":"deletion(M, [S, e])\n\nArguments\n\nM::Matroid: A matroid M.\nS::GroundsetType: A subset S of the ground set of M.\ne::ElementType: An element e of the ground set of M.\n\nThe deletion M\\S of an element e or a subset S of the ground set E of the matroid M.\n\nSee Section 3 of James Oxley (2011).\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = deletion(M,'i')\nMatroid of rank 2 on 3 elements\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = deletion(M,['i','j'])\nMatroid of rank 2 on 2 elements\n\njulia> matroid_groundset(N)\n2-element Vector{Any}:\n 1\n 2\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#restriction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"restriction","text":"restriction(M, S)\n\nArguments\n\nM::Matroid: A matroid M.\nS::GroundSetType: A subset S of the ground set of M.\n\nThe restriction M|S on a subset S of the ground set E of the matroid M.\n\nSee Section 3 of James Oxley (2011).\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = restriction(M,[1,2])\nMatroid of rank 2 on 2 elements\n\njulia> matroid_groundset(N)\n2-element Vector{Any}:\n 1\n 2\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#contraction-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"contraction","text":"contraction(M, [S, e])\n\nArguments\n\nM::Matroid: A matroid M.\nS::GroundSetType: A subset S of the ground set of M.\ne::ElementType: An element e of the ground set of M.\n\nThe contraction M/S of an element or a subset S of the ground set E of the matroid M.\n\nSee Section 3 of James Oxley (2011).\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = contraction(M,'i')\nMatroid of rank 1 on 3 elements\n\nExamples\n\njulia> M = matroid_from_bases([[1,2],[1,'i'],[1,'j'],[2,'i'],[2,'j']],[1,2,'i','j']);\n\njulia> N = contraction(M,['i','j'])\nMatroid of rank 1 on 2 elements\n\njulia> matroid_groundset(N)\n2-element Vector{Any}:\n 1\n 2\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#minor-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"minor","text":"minor(M::Matroid, set_del::GroundsetType, set_cont::GroundsetType)\n\nThe minor M\\S/T of disjoint subsets  S and T of the ground set E of the matroid M.\n\nSee also contraction and deletion. You can find more in Section 3 of James Oxley (2011).\n\nExamples\n\njulia> M = fano_matroid();\n\njulia> S = [1,2,3];\n\njulia> T = [4];\n\njulia>  N = minor(M,S,T) \nMatroid of rank 2 on 3 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#principal_extension-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, fmpz}}","page":"Matroids","title":"principal_extension","text":"principal_extension(M::Matroid, F::GroundsetType, e::ElementType)\n\nThe principal extension M +_F e of a matroid M where the element e is freely added to the flat F.\n\nSee Section 7.2 of James Oxley (2011).\n\nExamples\n\nTo add 5 freely to the flat {1,2} of the uniform matroid U_{3,4} do\n\njulia> M = uniform_matroid(3,4);\n\njulia> N = principal_extension(M,[1,2],5)\nMatroid of rank 3 on 5 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#free_extension-Tuple{Matroid, Union{Char, Integer, String, fmpz}}","page":"Matroids","title":"free_extension","text":"free_extension(M::Matroid, e::ElementType)\n\nThe free extension M +_E e of a matroid M where the element e.\n\nSee principal_extension and Section 7.2 of James Oxley (2011).\n\nExamples\n\nTo add 5 freely to the uniform matroid U_{3,4} do\n\njulia> M = uniform_matroid(3,4);\n\njulia>  N = free_extension(M,5)\nMatroid of rank 3 on 5 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#series_extension-Tuple{Matroid, Union{Char, Integer, String, fmpz}, Union{Char, Integer, String, fmpz}}","page":"Matroids","title":"series_extension","text":"series_extension(M::Matroid, f::ElementType, e::ElementType)\n\nThe series extension of a matroid M where the element e is added in series to f.\n\nThis is actually a coextension see also Section 7.2 of James Oxley (2011).\n\nExamples\n\nTo add e in series to 1 in the uniform matroid U_{3,4} do\n\njulia> M = uniform_matroid(1,4);\n\njulia> N = series_extension(M,1,'e')\nMatroid of rank 2 on 5 elements\n\njulia> cocircuits(N)[1]\n2-element Vector{Any}:\n 1\n  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#parallel_extension-Tuple{Matroid, Union{Char, Integer, String, fmpz}, Union{Char, Integer, String, fmpz}}","page":"Matroids","title":"parallel_extension","text":"parallel_extension(M::Matroid, f::ElementType, e::ElementType)\n\nThe parallel extension M +_{cl(f)} e of a matroid M where the element e is added parallel to (the closure of) f.\n\nSee Section 7.2 of James Oxley (2011).\n\nExamples\n\nTo add e parallel to 1 in the uniform matroid U_{3,4} do\n\njulia> M = uniform_matroid(3,4);\n\njulia> N = parallel_extension(M,1,'e')\nMatroid of rank 3 on 5 elements\n\njulia> circuits(N)[1]\n2-element Vector{Any}:\n 1\n  'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Properties","page":"Matroids","title":"Properties","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"matroid_groundset(M::Matroid)\nlength(M::Matroid)\nrank(M::Matroid)\nrank(M::Matroid, set::GroundsetType)\nbases(M::Matroid)\nnonbases(M::Matroid)\ncircuits(M::Matroid)\nhyperplanes(M::Matroid)\nflats(M::Matroid, r::Union{Int,Nothing}=nothing)\ncyclic_flats(M::Matroid, r::Union{Int,Nothing}=nothing)\nclosure(M::Matroid, set::GroundsetType)\nnullity(M::Matroid, set::GroundsetType)\nfundamental_circuit(M::Matroid, basis::GroundsetType, elem::ElementType)\nfundamental_cocircuit(M::Matroid, basis::GroundsetType, elem::ElementType)\nindependent_sets(M::Matroid)\nspanning_sets(M::Matroid)\ncobases(M::Matroid)\ncocircuits(M::Matroid)\ncohyperplanes(M::Matroid)\ncorank(M::Matroid, set::GroundsetType)\nis_clutter(sets::AbstractVector{T}) where T <: GroundsetType\nis_regular(M::Matroid)\nis_binary(M::Matroid)\nis_ternary(M::Matroid)\nn_connected_components(M::Matroid)\nconnected_components(M::Matroid)\nis_connected(M::Matroid)\nloops(M::Matroid)\ncoloops(M::Matroid)\nis_loopless(M::Matroid)\nis_coloopless(M::Matroid)\nis_simple(M::Matroid)\ndirect_sum_components(M::Matroid)\nconnectivity_function(M::Matroid, set::GroundsetType)\nis_vertical_k_separation(M::Matroid,k::IntegerUnion, set::GroundsetType) \nis_k_separation(M::Matroid,k::IntegerUnion, set::GroundsetType)\nvertical_connectivity(M::Matroid)\ngirth(M::Matroid, set::GroundsetType=M.groundset)\ntutte_connectivity(M::Matroid)\ntutte_polynomial(M::Matroid)\ncharacteristic_polynomial(M::Matroid)\nreduced_characteristic_polynomial(M::Matroid)\nrevlex_basis_encoding(M::Matroid)\nis_isomorphic(M1::Matroid, M2::Matroid)\nis_minor(M::Matroid, N::Matroid)","category":"page"},{"location":"Combinatorics/matroids/#matroid_groundset-Tuple{Matroid}","page":"Matroids","title":"matroid_groundset","text":"matroid_groundset(M::Matroid)\n\nThe ground set E of a matroid M.\n\nTo obtain the ground set of the Fano matroid write:\n\nExamples\n\njulia> matroid_groundset(fano_matroid())\n7-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#length-Tuple{Matroid}","page":"Matroids","title":"length","text":"length(M::Matroid)\n\nReturn the size of the ground set of the matroid M.\n\nExamples\n\njulia> length(fano_matroid())\n7\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#rank-Tuple{Matroid}","page":"Matroids","title":"rank","text":"rank(M::matroid)\n\nReturn the rank of the matroid M.\n\nExamples\n\njulia> rank(fano_matroid())\n3\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#rank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"rank","text":"rank(M::matroid, set::Vector)\n\nReturn the rank of set in the matroid M.\n\nExamples\n\njulia> M = fano_matroid();\n\njulia> rank(M, [1,2,3])\n2\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#bases-Tuple{Matroid}","page":"Matroids","title":"bases","text":"bases(M::matroid)\n\nReturn the list of bases of the matroid M.\n\nExamples\n\njulia> bases(uniform_matroid(2, 3))\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 3]\n [2, 3]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#nonbases-Tuple{Matroid}","page":"Matroids","title":"nonbases","text":"nonbases(M::matroid)\n\nReturn the list of nonbases of the matroid M.\n\nExamples\n\njulia> nonbases(fano_matroid())\n7-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 4, 7]\n [3, 5, 6]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#circuits-Tuple{Matroid}","page":"Matroids","title":"circuits","text":"circuits(M::matroid)\n\nReturn the list of circuits of the matroid M.\n\nExamples\n\njulia> circuits(uniform_matroid(2, 4))\n4-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 2, 4]\n [1, 3, 4]\n [2, 3, 4]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#hyperplanes-Tuple{Matroid}","page":"Matroids","title":"hyperplanes","text":"hyperplanes(M::matroid)\n\nReturn the list of hyperplanes of the matroid M.\n\nExamples\n\njulia> hyperplanes(fano_matroid())\n7-element Vector{Vector{Int64}}:\n [3, 5, 6]\n [3, 4, 7]\n [2, 5, 7]\n [2, 4, 6]\n [1, 6, 7]\n [1, 4, 5]\n [1, 2, 3]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#flats","page":"Matroids","title":"flats","text":"flats(M::matroid)\nflats(M::matroid, r::Int)\n\nReturn the list of flats of the matroid M. By default all flats are returned. One may specify a rank r as the second parameter in which case only the flats of rank r are returned.\n\nExamples\n\njulia> M = fano_matroid()\nMatroid of rank 3 on 7 elements\n\njulia> flats(M)\n16-element Vector{Vector{T} where T}:\n Any[]\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n [7]\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 5, 6]\n [3, 4, 7]\n [1, 2, 3, 4, 5, 6, 7]\n\njulia> flats(M, 2)\n7-element Vector{Vector{T} where T}:\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 5, 6]\n [3, 4, 7]\n\n\n\n","category":"function"},{"location":"Combinatorics/matroids/#cyclic_flats","page":"Matroids","title":"cyclic_flats","text":"cyclic_flats(M::matroid)\ncyclic_flats(M::matroid, r::Int)\n\nReturn the list of cyclic flats of the matroid M. These are the flats that are the union of cycles. See Section 2.1 in James Oxley (2011).\n\nBy default all cylic flats are returned. One may specify a rank r as the second parameter. In this case only the cylic flats of this rank are returned.\n\nExamples\n\njulia> M = fano_matroid()\nMatroid of rank 3 on 7 elements\n\njulia> cyclic_flats(M)\n9-element Vector{Vector{T} where T}:\n Any[]\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 5, 6]\n [3, 4, 7]\n [1, 2, 3, 4, 5, 6, 7]\n\njulia> cyclic_flats(M, 2)\n7-element Vector{Vector{T} where T}:\n [1, 2, 3]\n [1, 4, 5]\n [1, 6, 7]\n [2, 4, 6]\n [2, 5, 7]\n [3, 5, 6]\n [3, 4, 7]\n\n\n\n","category":"function"},{"location":"Combinatorics/matroids/#closure-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"closure","text":"closure(M::matroid, set::Vector)\n\nReturn the closure of set in the matroid M.\n\nExamples\n\njulia> closure(fano_matroid(), [1,2])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#nullity-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"nullity","text":"nullity(M::matroid, set::Vector)\n\nReturn the nullity of set in the matroid M. This is defined to be |set| - rk(set).\n\nExamples\n\njulia> M = fano_matroid();\n\njulia> nullity(M, [1,2,3])\n1\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#fundamental_circuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, fmpz}}","page":"Matroids","title":"fundamental_circuit","text":"fundamental_circuit(M::matroid, basis::Vector, elem::ElementType)\n\nReturn the unique circuit contained in the union of basis and elem of the matroid M. See Section 1.2 of James Oxley (2011). Note that elem needs to be in the complement of the basis in this case.\n\nExamples\n\njulia> M = fano_matroid();\n\njulia> fundamental_circuit(M, [1,2,4], 7)\n4-element Vector{Int64}:\n 1\n 2\n 4\n 7\n\njulia> fundamental_circuit(M, [1,2,4], 3)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#fundamental_cocircuit-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}, Union{Char, Integer, String, fmpz}}","page":"Matroids","title":"fundamental_cocircuit","text":"fundamental_cocircuit(M::matroid, cobasis::Vector, elem::ElementType)\n\nReturn the unique circuit of the dual matroid of M in the union of the complement of basis and elem. See Section 2.1 of James Oxley (2011). Note that elem needs to be an element of the basis in this case.\n\nExamples\n\njulia> fundamental_cocircuit(fano_matroid(), [1,2,4], 4)\n4-element Vector{Int64}:\n 4\n 5\n 6\n 7\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#independent_sets-Tuple{Matroid}","page":"Matroids","title":"independent_sets","text":"independet_sets(M::matroid)\n\nReturn the list of independent sets of the matroid M. These are all subsets of the bases.\n\nExamples\n\njulia> independent_sets(uniform_matroid(2, 3))\n7-element Vector{Vector{Integer}}:\n []\n [1]\n [2]\n [3]\n [1, 3]\n [2, 3]\n [1, 2]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#spanning_sets-Tuple{Matroid}","page":"Matroids","title":"spanning_sets","text":"spanning_sets(M::matroid)\n\nReturn the list of spanning sets of the matroid M. These are all sets containing a basis.\n\nExamples\n\njulia> spanning_sets(uniform_matroid(2, 3))\n4-element Vector{Vector{Integer}}:\n [1, 2]\n [1, 3]\n [2, 3]\n [1, 2, 3]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cobases-Tuple{Matroid}","page":"Matroids","title":"cobases","text":"cobases(M::matroid)\n\nReturn the bases of the dual matroid of M. See Section 2 in James Oxley (2011).\n\nExamples\n\njulia> cobases(uniform_matroid(2, 3))\n3-element Vector{Vector{Int64}}:\n [3]\n [2]\n [1]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cocircuits-Tuple{Matroid}","page":"Matroids","title":"cocircuits","text":"cocircuits(M::matroid)\n\nReturn the circuits of the dual matroid of M. See Section 2 in James Oxley (2011).\n\nExamples\n\njulia> cocircuits(uniform_matroid(2, 5))\n5-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [1, 2, 3, 5]\n [1, 2, 4, 5]\n [1, 3, 4, 5]\n [2, 3, 4, 5]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#cohyperplanes-Tuple{Matroid}","page":"Matroids","title":"cohyperplanes","text":"cohyperplanes(M::matroid)\n\nReturn the hyperplanes of the dual matroid of M. See Section 2 in James Oxley (2011).\n\nExamples\n\njulia> cohyperplanes(fano_matroid())\n14-element Vector{Vector{Int64}}:\n [4, 5, 6, 7]\n [2, 3, 6, 7]\n [2, 3, 4, 5]\n [1, 3, 5, 7]\n [1, 3, 4, 6]\n [1, 2, 5, 6]\n [1, 2, 4, 7]\n [3, 5, 6]\n [3, 4, 7]\n [2, 5, 7]\n [2, 4, 6]\n [1, 6, 7]\n [1, 4, 5]\n [1, 2, 3]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#corank-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"corank","text":"corank(M::matroid, set::Vector)\n\nReturn the rank of set in the dual matroid of M.\n\nExamples\n\njulia> corank(fano_matroid(), [1,2,3])\n3\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_clutter-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Union{AbstractSet, AbstractVector{T} where T}","page":"Matroids","title":"is_clutter","text":"is_clutter(sets)\n\nChecks if the collection of subsets sets is a clutter. A collection of subsets is a clutter if none of the sets is a proper subset of another. See Section 2.1 in James Oxley (2011).\n\nExamples\n\njulia> is_clutter([[1,2], [1,2,3]])\nfalse\n\njulia> is_clutter(circuits(fano_matroid()))\ntrue\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_regular-Tuple{Matroid}","page":"Matroids","title":"is_regular","text":"is_regular(M::Matroid)\n\nChecks if the matroid M is regular, that is representable over every field. See Section 6.6 in James Oxley (2011).\n\nExamples\n\njulia> is_regular(uniform_matroid(2, 3))\ntrue\n\njulia> is_regular(fano_matroid())\nfalse\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_binary-Tuple{Matroid}","page":"Matroids","title":"is_binary","text":"is_binary(M::Matroid)\n\nChecks if the matroid M is binary, that is representable over the finite field F_2. See Section 6.5 in James Oxley (2011).\n\nExamples\n\njulia> is_binary(uniform_matroid(2, 4))\nfalse\n\njulia> is_binary(fano_matroid())\ntrue\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_ternary-Tuple{Matroid}","page":"Matroids","title":"is_ternary","text":"is_ternary(M::Matroid)\n\nChecks if the matroid M is ternary, that is representable over the finite field F_3. See Section 4.1 in James Oxley (2011).\n\nExamples\n\njulia> is_ternary(uniform_matroid(2, 4))\ntrue\n\njulia> is_ternary(fano_matroid())\nfalse\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#n_connected_components-Tuple{Matroid}","page":"Matroids","title":"n_connected_components","text":"n_connected_components(M::Matroid)\n\nReturn the number of connected components of M. See Section 4.1 in James Oxley (2011).\n\nExamples\n\njulia> n_connected_components(fano_matroid())\n1\n\njulia> n_connected_components(uniform_matroid(3, 3))\n3\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#connected_components-Tuple{Matroid}","page":"Matroids","title":"connected_components","text":"connected_components(M::Matroid)\n\nReturn the connected components of M. The function returns a partition of the ground set where each part corresponds to one connected component.  See Section 4.1 in James Oxley (2011).\n\nExamples\n\njulia> connected_components(fano_matroid())\n1-element Vector{Vector{Int64}}:\n [1, 2, 3, 4, 5, 6, 7]\n\njulia> connected_components(uniform_matroid(3, 3))\n3-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_connected-Tuple{Matroid}","page":"Matroids","title":"is_connected","text":"is_connected(M::Matroid)\n\nCheck if the matroid M is connected, that is has one connected component See Section 4.1 in James Oxley (2011).\n\nExamples\n\njulia> is_connected(fano_matroid())\ntrue\n\njulia> is_connected(uniform_matroid(3, 3))\nfalse\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#loops-Tuple{Matroid}","page":"Matroids","title":"loops","text":"loops(M::Matroid)\n\nReturn the loops of M. A loop is an element of the ground set that is not contained in any basis.\n\nExamples\n\njulia> loops(matroid_from_bases([[1,2]], 4))\n2-element Vector{Int64}:\n 3\n 4\n\njulia> loops(fano_matroid())\nAny[]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#coloops-Tuple{Matroid}","page":"Matroids","title":"coloops","text":"coloops(M::Matroid)\n\nReturn the coloops of M. A coloop is an element of the ground set that is contained in every basis.\n\nExamples\n\njulia> coloops(matroid_from_bases([[1,2]], 4))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> coloops(fano_matroid())\nAny[]\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_loopless-Tuple{Matroid}","page":"Matroids","title":"is_loopless","text":"is_loopless(M::Matroid)\n\nCheck if M has a loop. Return true if M does not have a loop. See also loops.\n\nExamples\n\njulia> is_loopless(matroid_from_bases([[1,2]], 4))\nfalse\n\njulia> is_loopless(fano_matroid())\ntrue\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_coloopless-Tuple{Matroid}","page":"Matroids","title":"is_coloopless","text":"is_coloopless(M::Matroid)\n\nCheck if M has a coloop. Return true if M does not have a coloop. See also coloops.\n\nExamples\n\njulia> is_coloopless(matroid_from_bases([[1,2]], 4))\nfalse\n\njulia> is_coloopless(fano_matroid())\ntrue\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_simple-Tuple{Matroid}","page":"Matroids","title":"is_simple","text":"is_simple(M::Matroid)\n\nCheck if M has is simple. A matroid is simple if it doesn't have loops and doesn't have parallel elements. Return true if M is simple. See also loops.\n\nExamples\n\njulia> is_simple(matroid_from_bases([[1,2]], 4))\nfalse\n\njulia> is_simple(fano_matroid())\ntrue\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#direct_sum_components-Tuple{Matroid}","page":"Matroids","title":"direct_sum_components","text":"direct_sum_components(M::Matroid)\n\nReturn the connected components of M as a list of matroids. See Section 4.1 in James Oxley (2011).\n\nExamples\n\njulia> direct_sum_components(fano_matroid())\n1-element Vector{Matroid}:\n Matroid of rank 3 on 7 elements\n\njulia> direct_sum_components(uniform_matroid(3, 3))\n3-element Vector{Matroid}:\n Matroid of rank 1 on 1 elements\n Matroid of rank 1 on 1 elements\n Matroid of rank 1 on 1 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#connectivity_function-Tuple{Matroid, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"connectivity_function","text":"connectivity_function(M::Matroid, set::Vector)\n\nReturn the value of the connectivity function of set in the matroid M. See Section 8.1 in James Oxley (2011).\n\nExamples\n\njulia> connectivity_function(fano_matroid(), [1,2,4])\n3\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_vertical_k_separation-Tuple{Matroid, Union{Integer, fmpz}, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"is_vertical_k_separation","text":"is_vertical_k_separation(M::Matroid, k::Int, set::Vector)\n\nCheck if set together with its complement defines a k separation in M See Section 8.6 in James Oxley (2011).\n\nExamples\n\njulia> is_vertical_k_separation(fano_matroid(), 2, [1,2,4])\nfalse\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_k_separation-Tuple{Matroid, Union{Integer, fmpz}, Union{AbstractSet, AbstractVector{T} where T}}","page":"Matroids","title":"is_k_separation","text":"is_k_separation(M::Matroid, k::Int, set::Vector)\n\nCheck if set together with its complement defines a k separation in M See Section 8.1 in James Oxley (2011).\n\nExamples\n\njulia> is_k_separation(fano_matroid(), 2, [1,2,4])\nfalse\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#vertical_connectivity-Tuple{Matroid}","page":"Matroids","title":"vertical_connectivity","text":"vertical_connectivity(M::Matroid)\n\nIf 'M' has two disjoint cocircuits, its vertical connectivity is defined to be least positive integer k such that M has a vertical k separation. Otherwise its vertical connectivity is defined to be the rank of M. See Section 8.6 in James Oxley (2011).\n\nExamples\n\njulia> vertical_connectivity(fano_matroid())\n3\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#girth","page":"Matroids","title":"girth","text":"girth(M::Matroid, set::Vector)\n\nReturn the girth of set in the matroid M. This is the size of the smalles circuit contained in set and infintie otherwise. See Section 8.6 in James Oxley (2011).\n\nExamples\n\njulia> girth(fano_matroid(), [1,2,3,4])\n3\n\n\n\n\n","category":"function"},{"location":"Combinatorics/matroids/#tutte_connectivity-Tuple{Matroid}","page":"Matroids","title":"tutte_connectivity","text":"tutte_connectivity(M::Matroid)\n\nThe Tutte connectivity of M is the least integer k such that M has a k separation. It can be infinte if no k separation exists. See Section 8.6 in James Oxley (2011).\n\nExamples\n\njulia> tutte_connectivity(fano_matroid())\n3\n\njulia> tutte_connectivity(uniform_matroid(2,4))\nPosInf()\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#tutte_polynomial-Tuple{Matroid}","page":"Matroids","title":"tutte_polynomial","text":"tutte_polynomial(M::Matroid)\n\nReturn the Tutte polynomial of M. This is polynomial in the variables x and y with integral coefficients. See Section 15.3 in James Oxley (2011).\n\nExamples\n\njulia> tutte_polynomial(fano_matroid())\nx^3 + 4*x^2 + 7*x*y + 3*x + y^4 + 3*y^3 + 6*y^2 + 3*y\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#characteristic_polynomial-Tuple{Matroid}","page":"Matroids","title":"characteristic_polynomial","text":"characteristic_polynomial(M::Matroid)\n\nReturn the characteristic polynomial of M. This is polynomial in the variable q with integral coefficients. It is computed as an evaluation of the Tutte polynmomial. See Section 15.2 in James Oxley (2011).\n\nExamples\n\njulia> characteristic_polynomial(fano_matroid())\nq^3 - 7*q^2 + 14*q - 8\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#reduced_characteristic_polynomial-Tuple{Matroid}","page":"Matroids","title":"reduced_characteristic_polynomial","text":"reduced_characteristic_polynomial(M::Matroid)\n\nReturn the reduced characteristic polynomial of M. This is the quotient of the characteristic polynomial by (q-1). See Section 15.2 in James Oxley (2011).\n\nExamples\n\njulia> reduced_characteristic_polynomial(fano_matroid())\nq^2 - 6*q + 8\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#revlex_basis_encoding-Tuple{Matroid}","page":"Matroids","title":"revlex_basis_encoding","text":"revlex_basis_encoding(M::Matroid)\n\nComputes the revlex basis encoding and the minimal revlex basis encoding among isomorphic matroids \n\nExamples\n\nTo get the revlex basis encoding of the fano matroid and to preduce a matrod form the encoding write:\n\njulia> string1, string2 = revlex_basis_encoding(fano_matroid())\n(\"0******0******0***0******0*0**0****\", \"0******0******0***0******0*0**0****\")\n\njulia> matroid_from_revlex_basis_encoding(string2, 3, 7)\nMatroid of rank 3 on 7 elements\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_isomorphic-Tuple{Matroid, Matroid}","page":"Matroids","title":"is_isomorphic","text":"is_isomorphic(M1::Matroid, M2::Matroid)\n\nChecks if the matroid M1 is isomorphic to the matroid M2 under the action of the symmetric group that acts on their groundsets.\n\nExamples\n\nTo compare two matrods write:\n\njulia> H = [[1,2,4],[2,3,5],[1,3,6],[3,4,7],[1,5,7],[2,6,7],[4,5,6]];\n\njulia> M = matroid_from_hyperplanes(H,7);\n\njulia> is_isomorphic(M,fano_matroid())\ntrue\n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#is_minor-Tuple{Matroid, Matroid}","page":"Matroids","title":"is_minor","text":"is_minor(M::Matroid, N::Matroid)\n\nChecks if the matroid M is isomorphic to a minor of the matroid N.\n\nExamples\n\njulia> is_minor(direct_sum(uniform_matroid(0,1), uniform_matroid(2,2)), fano_matroid())\nfalse\n\njulia> is_minor(direct_sum(uniform_matroid(0,1), uniform_matroid(2,2)), parallel_extension(uniform_matroid(3,4), 1, 5))\ntrue\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#Chow-Rings","page":"Matroids","title":"Chow Rings","text":"","category":"section"},{"location":"Combinatorics/matroids/","page":"Matroids","title":"Matroids","text":"chow_ring(M::Matroid; ring::Union{MPolyRing,Nothing}=nothing, extended::Bool=false)\naugmented_chow_ring(M::Matroid)","category":"page"},{"location":"Combinatorics/matroids/#chow_ring-Tuple{Matroid}","page":"Matroids","title":"chow_ring","text":"chow_ring(M::Matroid; ring::MPolyRing=nothing, extended::Bool=false)\n\nReturn the Chow ring of a matroid, optionally also with the simplicial generators and the polynomial ring.\n\nSee Karim Adiprasito, June Huh, Eric Katz (2018) and Spencer Backman, Christopher Eur, Connor Simpson (2019). \n\nExamples\n\nThe following computes the Chow ring of the Fano matroid.\n\njulia> M = fano_matroid();\n\njulia> R = chow_ring(M);\n\njulia> R[1]*R[8]\n-x_{3,4,7}^2\n\nThe following computes the Chow ring of the Fano matroid including variables for the simplicial generators.\n\njulia> M = fano_matroid();\n\njulia> R = chow_ring(M, extended=true);\n\njulia> f = R[22] + R[8] - R[29]\nx_{1,2,3} + h_{1,2,3} - h_{1,2,3,4,5,6,7}\n\njulia> f==0\ntrue\n\nThe following computes the Chow ring of the free matroid on three elements in a given graded polynomial ring.\n\njulia> M = uniform_matroid(3,3);\n\njulia> GR, _ = GradedPolynomialRing(QQ,[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"]);\n\njulia> R = chow_ring(M, ring=GR);\n\njulia> hilbert_series_reduced(R)\n(t^2 + 4*t + 1, 1) \n\n\n\n\n","category":"method"},{"location":"Combinatorics/matroids/#augmented_chow_ring-Tuple{Matroid}","page":"Matroids","title":"augmented_chow_ring","text":"augmented_chow_ring(M::Matroid)\n\nReturn an augmented Chow ring of a matroid. As described in Tom Braden, June Huh, Jacob P. Matherne, Nicholas Proudfoot, Botong Wang (2020). \n\nExamples\n\njulia> M = fano_matroid();\n\njulia> R = augmented_chow_ring(M);\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/visualization/","page":"Visualization","title":"Visualization","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/visualization/","page":"Visualization","title":"Visualization","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/visualization/","page":"Visualization","title":"Visualization","text":"Pages = [\"visualization.md\"]","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/visualization/","page":"Visualization","title":"Visualization","text":"visualize(P::Polyhedron)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/visualization/#visualize-Tuple{Polyhedron}","page":"Visualization","title":"visualize","text":"visualize(P::Polyhedron)\n\nVisualize a polyhedron.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/free_module/#Free-Modules-and-Vector-Spaces","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"AbstractAlgebra allows the construction of free modules of any rank over any Euclidean ring and the vector space of any dimension over a field. By default the system considers the free module of a given rank over a given ring or vector space of given dimension over a field to be unique.","category":"page"},{"location":"AbstractAlgebra/free_module/#Generic-free-module-and-vector-space-types","page":"Free Modules and Vector Spaces","title":"Generic free module and vector space types","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"AbstractAlgebra provides generic types for free modules and vector spaces, via the type FreeModule{T} for free modules, where T is the type of the elements of the ring R over which the module is built.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Elements of a free module have type FreeModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Vector spaces are simply free modules over a field.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"The implementation of generic free modules can be found in src/generic/FreeModule.jl.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"The free module of a given rank over a given ring is made unique on the system by caching them (unless an optional cache parameter is set to false).","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"AbstractAlgebra/free_module/#Abstract-types","page":"Free Modules and Vector Spaces","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"The type FreeModule{T} belongs to FPModule{T} and FreeModuleElem{T} to FPModuleElem{T}. Here the FP prefix stands for finitely presented.","category":"page"},{"location":"AbstractAlgebra/free_module/#Functionality-for-free-modules","page":"Free Modules and Vector Spaces","title":"Functionality for free modules","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"As well as implementing the entire module interface, free modules provide the following functionality.","category":"page"},{"location":"AbstractAlgebra/free_module/#Constructors","page":"Free Modules and Vector Spaces","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"FreeModule(R::Ring, rank::Int)\nVectorSpace(F::Field, dim::Int)","category":"page"},{"location":"AbstractAlgebra/free_module/#FreeModule-Tuple{AbstractAlgebra.Ring, Int64}","page":"Free Modules and Vector Spaces","title":"FreeModule","text":"FreeModule(R::NCRing, rank::Int; cached::Bool = true)\n\nReturn the free module over the ring R with the given rank.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/free_module/#VectorSpace-Tuple{AbstractAlgebra.Field, Int64}","page":"Free Modules and Vector Spaces","title":"VectorSpace","text":"VectorSpace(R::Field, dim::Int; cached::Bool = true)\n\nReturn the vector space over the field R with the given dimension.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Construct the free module/vector space of given rank/dimension.","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Examples","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n","category":"page"},{"location":"AbstractAlgebra/free_module/#Basic-manipulation","page":"Free Modules and Vector Spaces","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"rank(M::Generic.FreeModule{T}) where T <: RingElem\ndim(V::Generic.FreeModule{T}) where T <: FieldElem\nbasis(V::Generic.FreeModule{T}) where T <: FieldElem","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"Examples","category":"page"},{"location":"AbstractAlgebra/free_module/","page":"Free Modules and Vector Spaces","title":"Free Modules and Vector Spaces","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> rank(M)\n3\n\njulia> dim(V)\n2\n\njulia> basis(V)\n2-element Vector{AbstractAlgebra.Generic.FreeModuleElem{Rational{BigInt}}}:\n (1//1, 0//1)\n (0//1, 1//1)","category":"page"},{"location":"Hecke/abelian/elements/#Elements","page":"-","title":"Elements","text":"","category":"section"},{"location":"Hecke/abelian/elements/","page":"-","title":"-","text":"Elements in a finitely geenrated abelian group are of type GrpAbFinGenElem and are always given as a linear combination of the generators. Internally this representation is normliased to have a unique representative.","category":"page"},{"location":"Hecke/abelian/elements/#Creation","page":"-","title":"Creation","text":"","category":"section"},{"location":"Hecke/abelian/elements/","page":"-","title":"-","text":"In addition to the standard function id, zero and one that can be used to create the neutral element, we also support more targeted creation:","category":"page"},{"location":"Hecke/abelian/elements/","page":"-","title":"-","text":"gens(G::GrpAbFinGen)\nGrpAbFinGen(x::Vector{fmpz})\nGrpAbFinGen(x::fmpz_mat)\ngetindex(A::GrpAbFinGen, i::Int)\nrand(G::GrpAbFinGen)\nrand(G::GrpAbFinGen, B::fmpz)\nparent(x::GrpAbFinGenElem)","category":"page"},{"location":"Hecke/abelian/elements/#gens-Tuple{GrpAbFinGen}","page":"-","title":"gens","text":"gens(G::GrpAbFinGen) -> Vector{GrpAbFinGenElem}\n\nThe sequence of generators of G.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/elements/#GrpAbFinGen-Tuple{Vector{fmpz}}","page":"-","title":"GrpAbFinGen","text":"(A::GrpAbFinGen)(x::Vector{fmpz}) -> GrpAbFinGenElem\n\nGiven an array x of elements of type fmpz of the same length as ngens(A), this function returns the element of A with components x.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/elements/#GrpAbFinGen-Tuple{fmpz_mat}","page":"-","title":"GrpAbFinGen","text":"(A::GrpAbFinGen)(x::fmpz_mat) -> GrpAbFinGenElem\n\nGiven a matrix over the integers with 1 row and ngens(A) columns, this function returns the element of A with components x.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/elements/#getindex-Tuple{GrpAbFinGen, Int64}","page":"-","title":"getindex","text":"getindex(A::GrpAbFinGen, i::Int) -> GrpAbFinGenElem\n\nReturns the element of A with components (0dotsc010dotsc0), where the 1 is at the i-th position.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/elements/#rand-Tuple{GrpAbFinGen}","page":"-","title":"rand","text":"rand(G::GrpAbFinGen) -> GrpAbFinGenElem\n\nReturns an element of G chosen uniformly at random.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/elements/#rand-Tuple{GrpAbFinGen, fmpz}","page":"-","title":"rand","text":"rand(G::GrpAbFinGen, B::fmpz) -> GrpAbFinGenElem\n\nFor a (potentially infinite) abelian group G, return an element chosen uniformly at random with coefficients bounded by B.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/elements/#parent-Tuple{GrpAbFinGenElem}","page":"-","title":"parent","text":"parent(x::GrpAbFinGenElem) -> GrpAbFinGen\n\nReturns the parent of x.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/elements/#Access","page":"-","title":"Access","text":"","category":"section"},{"location":"Hecke/abelian/elements/","page":"-","title":"-","text":"getindex(x::GrpAbFinGenElem, i::Int)","category":"page"},{"location":"Hecke/abelian/elements/#getindex-Tuple{GrpAbFinGenElem, Int64}","page":"-","title":"getindex","text":"getindex(x::GrpAbFinGenElem, i::Int) -> fmpz\n\nReturns the i-th component of the element x.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/elements/#Predicates","page":"-","title":"Predicates","text":"","category":"section"},{"location":"Hecke/abelian/elements/","page":"-","title":"-","text":"We have the standard predicated iszero, isone and isidentity to test an element for being trivial.","category":"page"},{"location":"Hecke/abelian/elements/#Invariants","page":"-","title":"Invariants","text":"","category":"section"},{"location":"Hecke/abelian/elements/","page":"-","title":"-","text":"order(A::GrpAbFinGenElem)","category":"page"},{"location":"Hecke/abelian/elements/#order-Tuple{GrpAbFinGenElem}","page":"-","title":"order","text":"order(A::GrpAbFinGenElem) -> fmpz\n\nReturns the order of A. It is assumed that the order is finite.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/elements/#Iterator","page":"-","title":"Iterator","text":"","category":"section"},{"location":"Hecke/abelian/elements/","page":"-","title":"-","text":"One can iterate over the elements of a finite abelian group.","category":"page"},{"location":"Hecke/abelian/elements/","page":"-","title":"-","text":"using Hecke # hide\nG = abelian_group(fmpz[1 2; 3 4])\nfor g = G\n  println(g)\nend","category":"page"},{"location":"Experimental/introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"Experimental/introduction/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"Experimental/introduction/","page":"Introduction","title":"Introduction","text":"Pages = [\"introduction.md\"]","category":"page"},{"location":"Experimental/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Experimental/introduction/","page":"Introduction","title":"Introduction","text":"The Plane Curves module of OSCAR provides functionality for handling","category":"page"},{"location":"Experimental/introduction/","page":"Introduction","title":"Introduction","text":"Affine Plane Curves,\nProjective Plane Curves, in particular Elliptic Curves.","category":"page"},{"location":"Experimental/introduction/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"Experimental/introduction/","page":"Introduction","title":"Introduction","text":"William Fulton (1969)\nAndreas Gathmann (2018)\nHenri Cohen (1993)","category":"page"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"CurrentModule = Oscar","category":"page"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"using Oscar","category":"page"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"Pages = [\"divisors.md\"]","category":"page"},{"location":"Experimental/divisors/#Divisors","page":"Divisors","title":"Divisors","text":"","category":"section"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"In order to consider divisors on curves, we restrict our attention to smooth and irreducible curves.","category":"page"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"Let C be an affine or projective plane curve defined by an irreducible equation F. Then any polynomial function G which is not divisible by F will vanish on C only at finitely many points. A way to encode these points together with their intersection multiplicities is to consider a divisor. A divisor on a curve is a formal finite sum of points of the curve with integer coefficients. A natural operation of addition can be defined on the set of divisors of a curve, which turns it into an Abelian group.","category":"page"},{"location":"Experimental/divisors/#Constructors","page":"Divisors","title":"Constructors","text":"","category":"section"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"Divisors on curves are here introduced as a dictionary associating a point on the curve to its multiplicity.","category":"page"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"AffineCurveDivisor","category":"page"},{"location":"Experimental/divisors/#AffineCurveDivisor","page":"Divisors","title":"AffineCurveDivisor","text":"AffineCurveDivisor(C::AffinePlaneCurve{S}, D::Dict{Point{S}, Int}) where S <: FieldElem\n\nGiven a curve C which is assumed to be smooth and irreducible, return the divisor on the curve C defined by D.\n\nExamples\n\njulia> R, (x,y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^2 + y + x^2)\nAffine plane curve defined by x^2 + y^2 + y\n\njulia> P = Oscar.Point([QQ(0), QQ(0)])\nPoint with coordinates fmpq[0, 0]\n\njulia> Q = Oscar.Point([QQ(0), QQ(-1)])\nPoint with coordinates fmpq[0, -1]\n\njulia> Oscar.AffineCurveDivisor(C, Dict(P => 3, Q => -2))\n3*fmpq[0, 0] - 2*fmpq[0, -1]\n\n\n\n","category":"type"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"ProjCurveDivisor","category":"page"},{"location":"Experimental/divisors/#ProjCurveDivisor","page":"Divisors","title":"ProjCurveDivisor","text":"ProjCurveDivisor(C::ProjPlaneCurve{S}, D::Dict{Oscar.Geometry.ProjSpcElem{S}, Int}) where S <: FieldElem\n\nGiven a curve C which is assumed to be smooth and irreducible, return the divisor on the curve C defined by D.\n\nExamples\n\njulia> S, (x,y,z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = Oscar.ProjPlaneCurve(T(y^2 + y*z + x^2))\nProjective plane curve defined by x^2 + y^2 + y*z\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(0), QQ(1)])\n(0 : 0 : 1)\n\njulia> Q = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(-1), QQ(1)])\n(0 : -1 : 1)\n\njulia> D = Oscar.ProjCurveDivisor(C, Dict(P => 3, Q => -2))\n3*(0 : 0 : 1) - 2*(0 : 1 : -1)\n\n\n\n","category":"type"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"To define the divisor 0 of the group of divisors, one uses the following method:","category":"page"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"curve_zero_divisor(C::ProjPlaneCurve{S}) where S <: FieldElem\ncurve_zero_divisor(C::AffinePlaneCurve{S}) where S <: FieldElem","category":"page"},{"location":"Experimental/divisors/#curve_zero_divisor-Union{Tuple{ProjPlaneCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Divisors","title":"curve_zero_divisor","text":"curve_zero_divisor(C::ProjPlaneCurve{S}) where S <: FieldElem\n\nReturn the divisor 0 on the curve C.\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#curve_zero_divisor-Union{Tuple{AffinePlaneCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Divisors","title":"curve_zero_divisor","text":"curve_zero_divisor(C::AffinePlaneCurve{S}) where S <: FieldElem\n\nReturn the divisor 0 on the curve C.\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#Methods","page":"Divisors","title":"Methods","text":"","category":"section"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"The following functions on divisors of curves are implemented.","category":"page"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"curve(D::Oscar.PlaneCurveModule.CurveDivisor)\ndegree(D::Oscar.PlaneCurveModule.CurveDivisor)\niseffective(D::Oscar.PlaneCurveModule.CurveDivisor)\nislinearly_equivalent(D::ProjCurveDivisor, E::ProjCurveDivisor)\nisprincipal(D::ProjCurveDivisor{S}) where S <: FieldElem\nprincipal_divisor(D::ProjCurveDivisor{S}) where S <: FieldElem\nglobal_sections(D::ProjCurveDivisor)\ndimension_global_sections(D::ProjCurveDivisor)","category":"page"},{"location":"Experimental/divisors/#curve-Tuple{Oscar.PlaneCurveModule.CurveDivisor}","page":"Divisors","title":"curve","text":"curve(D::CurveDivisor)\n\nReturn the curve on which the divisor is considered.\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#degree-Tuple{Oscar.PlaneCurveModule.CurveDivisor}","page":"Divisors","title":"degree","text":"degree(D::CurveDivisor)\n\nReturn the degree of the divisor.\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#iseffective-Tuple{Oscar.PlaneCurveModule.CurveDivisor}","page":"Divisors","title":"iseffective","text":"iseffective(D::CurveDivisor)\n\nReturn true if D is an effective divisor, false otherwise.\n\nExamples\n\njulia> R, (x,y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^2 + y + x^2)\nAffine plane curve defined by x^2 + y^2 + y\n\njulia> P = Oscar.Point([QQ(0), QQ(0)])\nPoint with coordinates fmpq[0, 0]\n\njulia> Q = Oscar.Point([QQ(0), QQ(-1)])\nPoint with coordinates fmpq[0, -1]\n\njulia> D = Oscar.AffineCurveDivisor(C, Dict(P => 3, Q => -2))\n3*fmpq[0, 0] - 2*fmpq[0, -1]\n\njulia> Oscar.iseffective(D)\nfalse\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#islinearly_equivalent-Tuple{Oscar.PlaneCurveModule.ProjCurveDivisor, Oscar.PlaneCurveModule.ProjCurveDivisor}","page":"Divisors","title":"islinearly_equivalent","text":"islinearly_equivalent(D::ProjCurveDivisor, E::ProjCurveDivisor)\n\nReturn true if the divisors D and E are linearly equivalent, and false otherwise\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = Oscar.ProjPlaneCurve(T(y^2*z - x*(x-z)*(x+3*z)))\nProjective plane curve defined by -x^3 - 2*x^2*z + 3*x*z^2 + y^2*z\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(1), QQ(0)])\n(0 : 1 : 0)\n\njulia> R = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(0), QQ(1)])\n(0 : 0 : 1)\n\njulia> E = Oscar.ProjCurveDivisor(C, P)\n(0 : 1 : 0)\n\njulia> F = Oscar.ProjCurveDivisor(C, R)\n(0 : 0 : 1)\n\njulia> Oscar.islinearly_equivalent(E, F)\nfalse\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#isprincipal-Union{Tuple{Oscar.PlaneCurveModule.ProjCurveDivisor{S}}, Tuple{S}} where S<:FieldElem","page":"Divisors","title":"isprincipal","text":"isprincipal(D::ProjCurveDivisor{S}) where S <: FieldElem\n\nReturn true if the divisor D is principal, and false otherwise\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = Oscar.ProjPlaneCurve(T(y^2*z - x*(x-z)*(x+3*z)))\nProjective plane curve defined by -x^3 - 2*x^2*z + 3*x*z^2 + y^2*z\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(1), QQ(0)])\n(0 : 1 : 0)\n\njulia> E = Oscar.ProjCurveDivisor(C, P)\n(0 : 1 : 0)\n\njulia> Oscar.isprincipal(E)\nfalse\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#principal_divisor-Union{Tuple{Oscar.PlaneCurveModule.ProjCurveDivisor{S}}, Tuple{S}} where S<:FieldElem","page":"Divisors","title":"principal_divisor","text":"principal_divisor(D::ProjCurveDivisor{S}) where S <: FieldElem\n\nIf the divisor D is principal, return a rational function phi such that D is linearly equivalent to the divisor defined by phi.\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = Oscar.ProjPlaneCurve(T(y^2*z - x*(x-z)*(x+3*z)))\nProjective plane curve defined by -x^3 - 2*x^2*z + 3*x*z^2 + y^2*z\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(1), QQ(0)])\n(0 : 1 : 0)\n\njulia> R = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(0), QQ(1)])\n(0 : 0 : 1)\n\njulia> E = Oscar.ProjCurveDivisor(C, P, 2)\n2*(0 : 1 : 0)\n\njulia> F = Oscar.ProjCurveDivisor(C, R, 2)\n2*(0 : 0 : 1)\n\njulia> G = 2*E - 2*F\n-4*(0 : 0 : 1) + 4*(0 : 1 : 0)\n\njulia> Oscar.principal_divisor(G)\nx^2//z^2\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#global_sections-Tuple{Oscar.PlaneCurveModule.ProjCurveDivisor}","page":"Divisors","title":"global_sections","text":"global_sections(D::ProjCurveDivisor)\n\nReturn a set of generators of the global sections of the sheaf associated to the divisor D of a smooth and irreducible projective curve.\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = Oscar.ProjPlaneCurve(T(y^2*z - x*(x-z)*(x+3*z)))\nProjective plane curve defined by -x^3 - 2*x^2*z + 3*x*z^2 + y^2*z\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(1), QQ(0)])\n(0 : 1 : 0)\n\njulia> D = Oscar.ProjCurveDivisor(C, P, 4)\n4*(0 : 1 : 0)\n\njulia> Oscar.global_sections(D)\n4-element Vector{AbstractAlgebra.Generic.Frac{fmpq_mpoly}}:\n 1\n y//z\n x//z\n x^2//z^2\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#dimension_global_sections-Tuple{Oscar.PlaneCurveModule.ProjCurveDivisor}","page":"Divisors","title":"dimension_global_sections","text":"dimension_global_sections(D::ProjCurveDivisor)\n\nReturn the dimension of the global sections of the sheaf associated to the divisor D of a smooth and irreducible projective curve.\n\n\n\n","category":"method"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"In addition, the multiplicity of a polynomial or a fraction at a given point can be computed:","category":"page"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"multiplicity(C::AffinePlaneCurve{S}, phi::AbstractAlgebra.Generic.Frac{T}, P::Point{S}) where {S <: FieldElem, T <: MPolyElem{S}}\nmultiplicity(C::AffinePlaneCurve{S}, F::Oscar.MPolyElem{S}, P::Point{S}) where S <: FieldElem","category":"page"},{"location":"Experimental/divisors/#multiplicity-Union{Tuple{T}, Tuple{S}, Tuple{AffinePlaneCurve{S}, AbstractAlgebra.Generic.Frac{T}, Point{S}}} where {S<:FieldElem, T<:MPolyElem{S}}","page":"Divisors","title":"multiplicity","text":"multiplicity(C::AffinePlaneCurve{S}, phi::AbstractAlgebra.Generic.Frac{T}, P::Point{S}) where {S <: FieldElem, T <: MPolyElem{S}}\nmultiplicity(C::ProjPlaneCurve{S}, phi::AbstractAlgebra.Generic.Frac{T}, P::Oscar.Geometry.ProjSpcElem{S})  where {S <: FieldElem, T <: Oscar.MPolyElem_dec{S}}\n\nReturn the multiplicity of the rational function phi on the curve C at the point P.\n\nExamples\n\njulia> S, (x,y,z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = Oscar.ProjPlaneCurve(T(y^2 + y*z + x^2))\nProjective plane curve defined by x^2 + y^2 + y*z\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(0), QQ(1)])\n(0 : 0 : 1)\n\njulia> phi = T(x)//T(y)\nx//y\n\njulia> Oscar.multiplicity(C, phi, P)\n-1\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#multiplicity-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, MPolyElem{S}, Point{S}}} where S<:FieldElem","page":"Divisors","title":"multiplicity","text":"multiplicity(C::AffinePlaneCurve{S}, F::Oscar.MPolyElem{S}, P::Point{S}) where S <: FieldElem\nmultiplicity(C::ProjPlaneCurve{S}, F::Oscar.MPolyElem_dec{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\n\nReturn the multiplicity of the polynomial F on the curve C at the point P.\n\n\n\n","category":"method"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"The divisor of a polynomial or a fraction along a plane curve can be computed, but will give only the points which belong to the base field.","category":"page"},{"location":"Experimental/divisors/","page":"Divisors","title":"Divisors","text":"divisor(C::AffinePlaneCurve{S}, F::Oscar.MPolyElem{S}) where S <: FieldElem\ndivisor(C::AffinePlaneCurve{S}, phi::AbstractAlgebra.Generic.Frac{T}) where {S <: FieldElem, T <: MPolyElem{S}}\ndivisor([PP::Oscar.Geometry.ProjSpc{S}], C::ProjPlaneCurve{S}, F::Oscar.MPolyElem_dec{S}) where S <: FieldElem\ndivisor(PP::Oscar.Geometry.ProjSpc{S}, C::ProjPlaneCurve{S}, phi::AbstractAlgebra.Generic.Frac{T})  where {S <: FieldElem, T <: Oscar.MPolyElem_dec{S}}","category":"page"},{"location":"Experimental/divisors/#divisor-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, MPolyElem{S}}} where S<:FieldElem","page":"Divisors","title":"divisor","text":"divisor(C::AffinePlaneCurve{S}, F::Oscar.MPolyElem{S}) where S <: FieldElem\n\nReturn the divisor defined by the polynomial F on the curve C.\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#divisor-Union{Tuple{T}, Tuple{S}, Tuple{AffinePlaneCurve{S}, AbstractAlgebra.Generic.Frac{T}}} where {S<:FieldElem, T<:MPolyElem{S}}","page":"Divisors","title":"divisor","text":"divisor(C::AffinePlaneCurve{S}, phi::AbstractAlgebra.Generic.Frac{T}) where {S <: FieldElem, T <: MPolyElem{S}}\n\nReturn the divisor defined by the rational function phi on the curve C.\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#divisor-Union{Tuple{S}, Tuple{Oscar.Geometry.ProjSpc{S}, ProjPlaneCurve{S}, MPolyElem_dec{S, S1} where S1}} where S<:FieldElem","page":"Divisors","title":"divisor","text":"divisor([PP::Oscar.Geometry.ProjSpc{S}], C::ProjPlaneCurve{S}, F::Oscar.MPolyElem_dec{S}) where S <: FieldElem\n\nReturn the divisor defined by the polynomial F on the curve C. The points of the divisor are in the projective space PP if specified, or in a new projective space otherwise.\n\n\n\n","category":"method"},{"location":"Experimental/divisors/#divisor-Union{Tuple{T}, Tuple{S}, Tuple{Oscar.Geometry.ProjSpc{S}, ProjPlaneCurve{S}, AbstractAlgebra.Generic.Frac{T}}} where {S<:FieldElem, T<:(MPolyElem_dec{S, S1} where S1)}","page":"Divisors","title":"divisor","text":"divisor(PP::Oscar.Geometry.ProjSpc{S}, C::ProjPlaneCurve{S}, phi::AbstractAlgebra.Generic.Frac{T})  where {S <: FieldElem, T <: Oscar.MPolyElem_dec{S}}\n\nReturn the divisor defined by the rational function phi on the curve C.\n\nExamples\n\njulia> S, (x,y,z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = Oscar.ProjPlaneCurve(T(y^2 + y*z + x^2))\nProjective plane curve defined by x^2 + y^2 + y*z\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> phi = T(x)//T(y)\nx//y\n\njulia> Oscar.divisor(PP[1], C, phi)\n-(0 : 0 : 1) + (0 : 1 : -1)\n\n\n\n","category":"method"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/developer/parents/#Parent-objects","page":"Parent objects","title":"Parent objects","text":"","category":"section"},{"location":"Nemo/developer/parents/#The-use-of-parent-objects-in-Nemo","page":"Parent objects","title":"The use of parent objects in Nemo","text":"","category":"section"},{"location":"Nemo/developer/parents/#The-parent/element-model","page":"Parent objects","title":"The parent/element model","text":"","category":"section"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"As for other major computer algebra projects such as Sage and Magma, Nemo uses the parent/element model to manage its mathematical objects.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"As explained in the appendix to the AbstractAlgebra documentation, the standard type/object model used in most programming languages is insufficient for much of mathematics which often requires mathematical structures parameterised by other objects.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"For example a quotient ring by an ideal would be parameterised by the ideal. The ideal is an object in the system and not a type and so parameterised types are not sufficient to represent such quotient rings.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"This means that each mathematical \"domain\" in the system (set, group, ring, field, module, etc.) must be represented by an object in the system, rather than a type. Such objects are called parent objects.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Just as one would write typeof(a) to get the type of an object a in an object/type system of a standard programming language, we write parent(a) to return the parent of the object a.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"When talked about with reference to a parent in this way, the object a is referred to as an element of the parent. Thus the system is divided into elements and parents. For example a polynomial would be an element of a polynomial ring, the latter being the parent of the former.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Naturally the parent/element system leads to some issues in a programming language not built around this model. We discuss some of these issues below.","category":"page"},{"location":"Nemo/developer/parents/#Types-in-the-parent/element-model","page":"Parent objects","title":"Types in the parent/element model","text":"","category":"section"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"As all elements and parents in Nemo are objects, those objects have types which we refer to as the element type and parent type respectively.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"For example, Flint integers have type fmpz and the parent object they all belong to, FlintZZ has type FlintIntegerRing.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"More complex parents and elements are parameterised. For example, generic univariate polynomials over a base ring R are parameterised by R. The base ring of a ring S can be obtained by the call base_ring(S).","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"We have found it extremely useful to parameterise the type of both the parent and element objects of such a ring by the type of the elements of the base ring. Thus for example, a generic polynomial with Flint integer coefficients would have type Poly{fmpz}.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"In practice Flint already implements univariate polynomials over Flint integers, and these have type fmpz_poly. But both fmpz_poly and the generic polynomials Poly{fmpz} belong to the abstract type PolyElem{fmpz} making it possible to write functions for all univariate polynomials over Flint integers.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Given a specific element type or parent type it is possible to compute one from the other with the functions elem_type and parent_type. For example parent_type(fmpz_poly) returns FmpzPolyRing and elem_type(FmpzPolyRing) returns fmpz_poly. Similarly parent_type(Generic.Poly{fmpz}) returns Generic.PolyRing{fmpz} and so on.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"These functions are especially useful when writing type assertions or constructing arrays of elements insides function where only the parent object was passed.","category":"page"},{"location":"Nemo/developer/parents/#Other-functions-for-computing-types","page":"Parent objects","title":"Other functions for computing types","text":"","category":"section"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Sometimes one needs to know the type of a polynomial or matrix one would obtain if it were constructed over a given ring or with coefficients/entries of a given element type.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"This is especially important in generic code where it may not even be known which Julia package is being used. The user may be expecting an AbstractAlgebra object, a Nemo object or even some other kind of object to be constructed, depending on which package they are using.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"The function for returning the correct type for a dense matrix is dense_matrix_type to which one can pass either a base ring or an element type. For example, if AbstractAlgebra is being used, dense_matrix_type(ZZ) will return Mat{BigInt} whereas if Nemo is being used it will return fmpz_mat.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"We also have dense_poly_type for univariate polynomials, abs_series_type for absolute series and rel_series_type for relative series.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"In theory such functions should exist for all major object types, however they have in most cases not been implemented yet.","category":"page"},{"location":"Nemo/developer/parents/#Functions-for-creating-objects-of-a-similar-type","page":"Parent objects","title":"Functions for creating objects of a similar type","text":"","category":"section"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"A slightly more consistent interface for creating objects of a type that is suitable for the package currently in use is the similar interface.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"For example, given a matrix M one can create one with the same dimensions but over a different ring R by calling similar(M, R). Likewise one can create one over the same ring with different dimensions r x c by calling similar(M, r, c).","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"The similar system is sophisticated enough to know that there is no native type provided by Flint/Antic for matrices and polynomials over a number field. The system knows that in such cases it must create a generic matrix or polynomial over the given number field.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"A great deal of thought went into the design of the similar system so that developers would not be required to implement similar for every pair of types in the package.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Again this interface should exist for all major Nemo domains, but the functionality is still being implemented in some cases.","category":"page"},{"location":"Nemo/developer/parents/#Changing-base-rings-and-map","page":"Parent objects","title":"Changing base rings and map","text":"","category":"section"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Given a polynomial, matrix or other composite object over a base ring, it is often convenient to create a similar object but with all the entries or coefficients coerced into a different ring.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"For this purpose the function change_base_ring is provided.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Similarly it may be useful to create the matrix or polynomial that results by applying a given map/function/lambda to each of the entries or coefficients.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"For this purpose Julia's map function is overloaded. There are also functions specific to polynomials and matrices called map_coefficients and map_entries respectively, which essentially do the same thing.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Note that the implementation of such functions must make use of the functions discussed above to ensure that a matrix/polynomial of the right type is output.","category":"page"},{"location":"Nemo/developer/parents/#Parent-checking","page":"Parent objects","title":"Parent checking","text":"","category":"section"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"When applying binary operations to a pair of elements of a given ring, it is useful to check that they are in fact elements of the same ring. This is not possible by checking the types alone. For example elements of Z7Z and Z3Z would have the same type but different parents (one parameterised by the integer 7, the other by the integer 3).","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"In order to perform such a check in a function one uses check_parent(a, b) where a and b are the objects one wishes to assert must have the same parent. If not, an exception is raised by parent_check.","category":"page"},{"location":"Nemo/developer/parents/#Parent-object-constructors","page":"Parent objects","title":"Parent object constructors","text":"","category":"section"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Various functions are provided for constructing parent objects. For example a polynomial ring is constructed by calling a PolynomialRing function. Such functions are called parent object constructors.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"In general parent object constructors are intended for the user and should not be used in library code. There are a number of reasons for this.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Firstly, inside the Generic submodule of AbstractAlgebra the only parent object constructors that are directly accessible are the ones inside Generic. Thus if a Nemo function calls a function inside Generic and it creates a parent object using one of the parent object constructors, it will create a parent object for a generic ring rather than a Nemo one.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"One can work around this by calling AbstractAlgebra.PolynomialRing instead of simply PolynomialRing inside Generic, but even safer would be to find another way to construct the polynomials required.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"A second issue is that parent objects are allowed to be as large as one likes and they are cached by the system. They can also perform arbitrary precomputations for the ring/field/module etc. that is being constructed. Over time they tend to accumulate such precomputations, slowing down all generic code which made use of them. Both memory usage and performance may blow out in previously working code.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Thirdly, parent objects must be unique across the system for a given set of parameters. This means they must be cached globally. This is problematic for any future attempts to parallelise library code and in the worst case memory usage can balloon due to swelling caches.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Most parent object constructors take a cached keyword which specifies whether the parent object should be cached or not, but again it is better overall to simply eschew the use of parent object constructors in library code.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Instead, it is recommended to use functions such as similar, zero, zero_matrix, identity_matrix, change_base_ring, map, etc. for constructing polynomials and matrices directly.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"There are also functions that provide alternative ways of constructing objects, e.g. matrix provides a means of creating a matrix over a given ring with given dimensions. The constructor polynomial allows creation of a polynomial over a given base ring with given coefficients and abs_series and rel_series do similar things for absolute and relative series. These should be used in preference to parent object constructors where possible. Additional functions of this type should be added in future.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"However even when using these functions in library code, it is important to remember to pass cached=false so that the cache is not filled up by calls to the library code. But this creates an additional problem, namely that if one uses polynomial say, to construct two polynomials over the same base ring, they will not be compatible in the sense that they will have different parents.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"When one wishes to construct multiple elements in the same group/ring/field, it is convenient to be able to construct a parent just as a user would. For this purpose various light-weight and very safe parent constructors are provided for use in library code.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"For example there are the constructors PolyRing, AbsSeriesRing and RelSeriesRing. These functions return the parent ring R only and no generator (it can be obtained by calling gen(R)). They also set the variable for printing to a default (usually x). Moreover, these parents are not cached, so they are completely safe to use in library code. They can be thousands of times faster than the full parent constructors intended for users.","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Here is an example of their use:","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"R = PolyRing(ZZ)\np = R([1, 2, 3])\nq = R([2, 3, 4])\ns = p + q","category":"page"},{"location":"Nemo/developer/parents/","page":"Parent objects","title":"Parent objects","text":"Naturally functions like polynomial and matrix and the light-weight parent constructors are missing for other modules in Nemo at present and it is hoped that developers will fill in such infrastructure rather than simply push the can down the road for someone else to fix. Forcing the creating of full parent objects into as few bottlenecks as possible will make it much easier for developers to remove problems associated with such calls when they arise in future.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/developer/conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"AbstractAlgebra and Nemo have adopted a number of conventions to help maintain a uniform codebase.","category":"page"},{"location":"Nemo/developer/conventions/#Code-conventions","page":"Conventions","title":"Code conventions","text":"","category":"section"},{"location":"Nemo/developer/conventions/#Function-and-type-names","page":"Conventions","title":"Function and type names","text":"","category":"section"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Names of types in Julia follow the convention of CamelCase where the first letter of each word is capitalised, e.g. Int64 and AbstractString.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Function/method names in Julia use all lowercase with underscores between the words, e.g. zip and jacobi_symbol.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"We follow these conventions in Nemo with some exceptions:","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"When interfacing C libraries the types use the same spelling and capitalisation in Nemo as they do in C, e.g. the Flint library's fmpz_poly remains uncapitalised in Nemo.\nTypes such as gfp_poly which don't exist under that name on the C side also use the lowercase convention as they wrap an actual C type which must be split into more than one type on the Julia side. For example nmod_poly and gfp_poly on the Julia side both represent Flint nmod_poly's on the C side.\nTypes of rings and fields, modules, maps, etc. are capitalised whether they correspond to a C type or not, e.g. FqNmodFiniteField for the type of an object representing the field that fq_nmod's belong to.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":".","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"We omit an underscore if the first word of a method is \"is\" or \"has\", e.g. iseven.\nUnderscores are omitted if the method name is already well established without an underscore in Julia itself, e.g. setindex.\nConstructors with the same name as a type use the same spelling and capitalisation as that type, e.g. fmpz(1).\nFunctions for creating rings, fields, modules, maps, etc. (rather than the elements thereof) use CamelCase, e.g. PolynomialRing. We refer to these  functions as parent constructors. Note that we do not follow the Julia convention here, e.g. PolynomialRing is a function and not a type constructor (in fact we often return a tuple consisting of a parent object and other objects such as generators with this type of function) yet we capitalise it.\nWe prefer words to not be abbreviated, e.g. denominator instead of den.\nExceptions always exist where the result would be offensive in any major spoken language (example omitted).","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"It is easy to find counterexamples to virtually all these rules. However we have been making efforts to remove the most egregious cases from our codebase over time. As perfect consistency is not possible, work on this has to at times take a back seat.","category":"page"},{"location":"Nemo/developer/conventions/#Use-of-ASCII-characters","page":"Conventions","title":"Use of ASCII characters","text":"","category":"section"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"All code and printed output in Nemo should use ASCII characters only. This is because we have developers who are using versions of the WSL that cannot correctly display non-ASCII characters.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"This extends to function and operator names, which saves people having to learn how to enter them to use the system.","category":"page"},{"location":"Nemo/developer/conventions/#Spacing-and-tabs","page":"Conventions","title":"Spacing and tabs","text":"","category":"section"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"All function bodies and control blocks should be indented using spaces.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"A survey of existing code shows 2, 3 or 4 space indenting commonly used in our files. Values outside this range should not be used.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"When contributing to an existing file, follow the majority convention in that file. Consistency within a file is valued highly.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"If you are new to Nemo development and do not already have a very strong preference, new files should be started with 3 space indenting. This maximises the likelihood that copy and paste between files will be straightforward, though modern editors ease this to some degree.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Function signatures in docstrings should have four spaces before them.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Where possible, line lengths should not exceed 80 characters.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"We use a term/factor convention for spacing. This means that all (additive) terms have spaces before and after them, (multiplicative) factors usually do not.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"In practice this means that +, -, =, ==, !=, <, >, <=, >= all have spaces before and after them. The operators *, /, ^ and unary minus do not.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"As per English, commas are followed by a single space in expressions. This applies for example to function arguments and tuples.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"We do not put spaces immediately inside or before parentheses.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Colons used for ranges do not have spaces before or after them.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Logical operators, &, |, &&, etc. usually have spaces before and after them.","category":"page"},{"location":"Nemo/developer/conventions/#Comments","page":"Conventions","title":"Comments","text":"","category":"section"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Despite appearances to the contrary, we now prefer code comments explaining the algorithm as it proceeds.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"The hash when used for a comment should always be followed by a space. Full sentences are preferred.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"We do not generally use comments in Nemo for questions, complaints or proposals for future improvement. These are better off in a ticket on GitHub with a discussion that will be brought to the attention of all relevant parties.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Any (necessary) limitations of the implementation should be noted in docstrings.","category":"page"},{"location":"Nemo/developer/conventions/#Layout-of-files","page":"Conventions","title":"Layout of files","text":"","category":"section"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"In Nemo, all types are places in special files with the word \"Types\" in their name, e.g. FlintTypes.jl. This is because Julia must be aware of all types before they are used. Separation of types from implementations makes it easy to ensure this happens.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Abstract types should be put in the file called AbstractTypes.jl at the top level of the src directory.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Most implementation files present functions in a particular order, which is as follows:","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"A header stating what the file is for, and if needed, any copyright notices\nFunctions applying to any \"types\" used in the file, e.g. parent_type, elem_type, base_ring, parent, check_parent.\nBasic manipulation, including hashes, predicates, getters/setters, functions for creating special values (e.g. one, zero and the like), deepcopy_internal. These are usually fairly short functions, often a single line.\nIndexing (getindex, setindex), iteration, views.\nString I/O (expressify and file access, etc.)\nArithmetic operations, usually in multiple sections, such as unary operations, binary operations, ad hoc binary operations (e.g. multiplication of a complex object by a scalar), comparisons, ad hoc comparisons, division, etc.\nMore complex functionality separated into sections based on functionality provided, e.g. gcd, interpolation, special functions, solving, etc.\nFunctions for mapping between different types, coercion, changing base ring, etc.\nUnsafe operators, e.g. mul!, add!, addeq! etc.\nRandom generation\nPromotion rules\nParent object call overload (e.g. for implementing R(2) where R is an object representing a ring or field, etc.)\nAdditional constructors, e.g. matrix, which might be used instead of a parent object to construct elements.\nParent object constructors, e.g. PolynomialRing, etc.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"The exact order within the file is less important than generally following something like the above. This aids in finding functions in a file since all files are more or less set out the same way.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"For an example to follow, see the src/Poly.jl and src/generic/Poly.jl files in AbstractAlgebra which form the oldest and most canonical example.","category":"page"},{"location":"Nemo/developer/conventions/","page":"Conventions","title":"Conventions","text":"Headings for sections should be 80 characters wide and formed of hashes in the style that can be seen in each Nemo file.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"using Oscar","category":"page"},{"location":"CommutativeAlgebra/localizations/#Localizations-of-commutative-rings","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Suppose R is a commutative ring with unit and S subset R is a multiplicatively  closed set containing 1 in R. Then we can form the localization of R at S","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    RS^-1 = left fracpq  pq in R  q in S right","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"with its standard arithmetic for fractions. See, for instance, [Eis95] for an account on localizations.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Oscar provides a general framework for such localizations, originally intended to be used  with multivariate polynomial rings R over some base field mathbb k, but also  applicable to more general commutative rings.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"In the case of polynomials, the localization framework provides the structure for  certain algorithms using standard bases. Note that, in general, localizations of  polynomial algebras are not finitely generated  as algebras over mathbb k; for instance when localizing at some maximal  ideal mathfrak m subset R. However, many ideal- and module-theoretic questions in the localization  RS^-1, such as e.g. the ideal membership, can be transformed to questions on  ideals and modules over the base ring R and then solved using Groebner- or standard-basis  techniques. This makes it important to regard localizations RS^-1 as rings with  a history of creation from the original pair S subset R. ","category":"page"},{"location":"CommutativeAlgebra/localizations/#The-localization-interface","page":"Localizations of commutative rings","title":"The localization interface","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/#Localized-rings","page":"Localizations of commutative rings","title":"Localized rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The interface that needs to be implemented for any concrete  instance of localized rings is the following.  Multiplicatively closed sets are derived from the abstract type","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    AbsMultSet{RingType, RingElemType}","category":"page"},{"location":"CommutativeAlgebra/localizations/#AbsMultSet","page":"Localizations of commutative rings","title":"AbsMultSet","text":"AbsMultSet{RingType, RingElemType}\n\nAbstract type for a multiplicatively closed set in a commutative (Noetherian) ring  R of type RingType with elements of type RingElemType.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The basic functionality that has to be implemented for any concrete type derived from  this is to be able to check containment of elements via","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    in(f::RingElemType, S::AbsMultSet{RingType, RingElemType}) where {RingType, RingElemType}","category":"page"},{"location":"CommutativeAlgebra/localizations/#in-Union{Tuple{RingElemType}, Tuple{RingType}, Tuple{RingElemType, AbsMultSet{RingType, RingElemType}}} where {RingType, RingElemType}","page":"Localizations of commutative rings","title":"in","text":"in(f::RingElemType, S::AbsMultSet{RingType, RingElemType}) where {RingType, RingElemType}\n\nReturn true if f belongs to S; false otherwise.\n\nNote: If this routine is not implemented, the function call will default to the  execution of an error message. \n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"This is supposed to be an extension of the methods of the function Base.in.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"A localized ring should then be derived from ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    AbsLocalizedRing{RingType, RingElemType, MultSetType}","category":"page"},{"location":"CommutativeAlgebra/localizations/#AbsLocalizedRing","page":"Localizations of commutative rings","title":"AbsLocalizedRing","text":"AbsLocalizedRing{RingType, RingElemType, MultSetType}\n\nThe localization R[S⁻¹] of a ring R of type RingType with elements of type RingElemType at a  multiplicatively closed set S of type MultSetType. \n\nIn general, the arithmetic of such a localized ring R[S⁻¹] should be implemented using fractions  of elements in the original ring R. The methods provided for the multiplicatively closed set S  can be used to check whether a given denominator is admissible for the specific localization. \n\nDepending on the actual type of R and S, further functionality can then be provided using  different Groebner-basis driven backends. \n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The basic way to construct localized rings is to first  specify a multiplicative set S and then call ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    Localization(S::AbsMultSet)","category":"page"},{"location":"CommutativeAlgebra/localizations/#Localization-Tuple{AbsMultSet}","page":"Localizations of commutative rings","title":"Localization","text":"Localization(S::AbsMultSet)\n\nReturn the localization of the ambient_ring of S at S itself.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"This method must be implemented with a dispatch depending on  the concrete type of S.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"For any concrete instance of type AbsLocalizedRing the following methods must be implemented:","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    base_ring(W::AbsLocalizedRing) \n    inverted_set(W::AbsLocalizedRing)","category":"page"},{"location":"CommutativeAlgebra/localizations/#base_ring-Tuple{AbsLocalizedRing}","page":"Localizations of commutative rings","title":"base_ring","text":"base_ring(W::AbsLocalizedRing)\n\nReturn the base ring R for a localized ring of the form W = R[S⁻¹].\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#inverted_set-Tuple{AbsLocalizedRing}","page":"Localizations of commutative rings","title":"inverted_set","text":"inverted_set(W::AbsLocalizedRing)\n\nReturn the set S of at which has been localized for a localized ring W = R[S⁻¹].\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Also, conversion of fractions to elements of localized rings must be implemented in the form  (W::AbsLocalizedRing{RingType, RingElemType, MultSetType})(a::RingElemType) where {RingType, RingElemType, MultSetType}, taking a to the element fraca1. For more general fractions one needs (W::AbsLocalizedRing{RingType, RingElemType, MultSetType})(a::RingElemType, b::RingElemType) where {RingType, RingElemType, MultSetType}, mapping a pair (a b) to the fraction fracab.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The elements of localized rings must be derived from ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    AbsLocalizedRingElem{RingType, RingElemType, MultSetType}","category":"page"},{"location":"CommutativeAlgebra/localizations/#AbsLocalizedRingElem","page":"Localizations of commutative rings","title":"AbsLocalizedRingElem","text":"AbsLocalizedRingElem{RingType, RingElemType, MultSetType}\n\nThe abstract type of an element of the localization R[S⁻¹] of a commutative ring  R of type RingType with elements of type RingElemType at a multiplicatively  closed set S of type MultSetType.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"For any concrete instance F of AbsLocalizedRingElem there must be the following  methods:","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    numerator(f::AbsLocalizedRingElem) \n    denominator(f::AbsLocalizedRingElem) \n    parent(f::AbsLocalizedRingElem)","category":"page"},{"location":"CommutativeAlgebra/localizations/#numerator-Tuple{AbsLocalizedRingElem}","page":"Localizations of commutative rings","title":"numerator","text":"numerator(f::AbsLocalizedRingElem)\n\nReturn the numerator of f.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#denominator-Tuple{AbsLocalizedRingElem}","page":"Localizations of commutative rings","title":"denominator","text":"denominator(f::AbsLocalizedRingElem)\n\nReturn the denominator of f.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#parent-Tuple{AbsLocalizedRingElem}","page":"Localizations of commutative rings","title":"parent","text":"parent(f::AbsLocalizedRingElem)\n\nReturn the parent ring R[S⁻¹] of f.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"A default version of the arithmetic is implemented on the generic level using the above  functionality and the arithmetic for the original ring.  Depending on the actual concrete instance, one might wish to provide more fine-tuned methods,  starting e.g. by implementing ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    reduce_fraction(f::AbsLocalizedRingElem)","category":"page"},{"location":"CommutativeAlgebra/localizations/#reduce_fraction-Tuple{AbsLocalizedRingElem}","page":"Localizations of commutative rings","title":"reduce_fraction","text":"reduce_fraction(a::AbsLocalizedRingElem)\n\nReduce the fraction a = p/q. Warning: The catchall-implementation does nothing!\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Note that this is called after every arithmetic operation (addition, multiplication,...),  so the computations carried out here should be computationally cheap.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Two toy examples for implementations of this interface for localizations  of the integers mathbb Z and rings of the form mathbb Znmathbb Z  can be found in the test files  test/Rings/integer-localizations.jl and test/Rings/nmod-localizations.jl.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Note: Any concrete type for localized rings is also required to implement  the general Ring Interface of Oscar! This has not been done to a full extent  for the previous two examples, but for MPolyLocalizedRing; see below.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Homomorphisms-for-localized-rings","page":"Localizations of commutative rings","title":"Homomorphisms for localized rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Homomorphisms from localized rings to arbitrary algebras are of type ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    AbsLocalizedRingHom","category":"page"},{"location":"CommutativeAlgebra/localizations/#AbsLocalizedRingHom","page":"Localizations of commutative rings","title":"AbsLocalizedRingHom","text":"AbsLocalizedRingHom{\n    DomainType<:AbsLocalizedRing,\n    CodomainType<:Ring,\n    RestrictedMapType\n  } <: Map{\n    DomainType,\n    CodomainType,\n    SetMap,\n    AbsLocalizedRingHom\n  }\n\nHomomorphism ϕ  RU¹  S from the localization RU¹ of type  DomainType to an arbitrary ring S of type CodomainType. Such a  homomorphism is completely determined by its 'restriction'  ϕ  R  RU¹  S to the base_ring R before localization and  the type parameter RestrictedMapType is reserved for that map. \n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Note that, in order to be well-defined, we must have  that phi(u) in S must be a unit for every element u in U. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The getters associated to this type which need to be implemented are ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    domain(f::AbsLocalizedRingHom) \n    codomain(f::AbsLocalizedRingHom) \n    restricted_map(f::AbsLocalizedRingHom) ","category":"page"},{"location":"CommutativeAlgebra/localizations/#domain-Tuple{AbsLocalizedRingHom}","page":"Localizations of commutative rings","title":"domain","text":"domain(f::AbsLocalizedRingHom)\n\nReturn the domain of definition of f.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#codomain-Tuple{AbsLocalizedRingHom}","page":"Localizations of commutative rings","title":"codomain","text":"codomain(f::AbsLocalizedRingHom)\n\nReturn the codomain of f.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#restricted_map-Tuple{AbsLocalizedRingHom}","page":"Localizations of commutative rings","title":"restricted_map","text":"restricted_map(f::AbsLocalizedRingHom)\n\nFor a ring homomorphism ϕ  RU¹  S return the underlying  restriction ϕ  R  S.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Any concrete instance f of AbsLocalizedRingHom can then be applied to elements  a of domain(f) by calling f(a). ","category":"page"},{"location":"CommutativeAlgebra/localizations/#Ideals-in-localized-rings","page":"Localizations of commutative rings","title":"Ideals in localized rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"One of the main reasons to implement localizations in the first place  is that this process preserves the property of a ring to be Noetherian;  which is crucial for computer algebra. In this regard, we have ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    AbsLocalizedIdeal{RingType, RingElemType, MultSetType} ","category":"page"},{"location":"CommutativeAlgebra/localizations/#AbsLocalizedIdeal","page":"Localizations of commutative rings","title":"AbsLocalizedIdeal","text":"AbsLocalizedIdeal{RingType, RingElemType, MultSetType}\n\nAbstract type for finitely generated ideals I  RS¹ in localized rings. \n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The required getter methods are","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    gens(I::AbsLocalizedIdeal)\n    base_ring(I::AbsLocalizedIdeal)","category":"page"},{"location":"CommutativeAlgebra/localizations/#gens-Tuple{AbsLocalizedIdeal}","page":"Localizations of commutative rings","title":"gens","text":"gens(A::AbsAlgAss, return_full_basis::Typel{Val{T}} = Val{false};\n     thorough_search::Bool = false) where T\n  -> Vector{AbsAlgAssElem}\n\nReturns a subset of basis(A), which generates A as an algebra over base_ring(A). If return_full_basis is set to Val{true}, the function also returns a Vector{AbsAlgAssElem} containing a full basis consisting of monomials in the generators and a Vector{Vector{Tuple{Int, Int}}} containing the information on how these monomials are built. E. g.: If the function returns g, full_basis and v, then we have full_basis[i] = prod( g[j]^k for (j, k) in v[i] ). If thorough_search is true, the number of returned generators is possibly smaller. This will in general increase the runtime. It is not guaranteed that the number of generators is minimal in any case.\n\n\n\ngens(A::AlgGrp, return_full_basis::Type{Val{T}} = Val{false})\n  -> Vector{AlgGrpElem}\n\nReturns a subset of basis(A), which generates A as an algebra over base_ring(A). If return_full_basis is set to Val{true}, the function also returns a Vector{AbsAlgAssElem} containing a full basis consisting of monomials in the generators and a Vector{Vector{Tuple{Int, Int}}} containing the information on how these monomials are built. E. g.: If the function returns g, full_basis and v, then we have full_basis[i] = prod( g[j]^k for (j, k) in v[i] ).\n\n\n\ngens(M::SubQuo{T}) where T\n\nReturn the generators of M.\n\n\n\ngens(I::sideal)\n\nReturn the generators in the internal representation of the ideal I as an array.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#base_ring-Tuple{AbsLocalizedIdeal}","page":"Localizations of commutative rings","title":"base_ring","text":"base_ring(M::PMat)\n\nThe PMat M defines an R-module for some maximal order R. This function returns the R that was used to defined M.\n\n\n\nbase_ring(I::MPolyIdeal)\n\nReturn the ambient ring of I.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R, [x, y])^2\nideal(x^2, x*y, y^2)\n\njulia> base_ring(I)\nMultivariate Polynomial Ring in x, y over Rational Field\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The constructors to be implemented are","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, f::AbsLocalizedRingElem{RingType, RingElemType, MultSetType}) where {RingType, RingElemType, MultSetType}\n   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, f::RingElemType) where {RingType, RingElemType, MultSetType}\n   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, v::Vector{AbsLocalizedRingElem{RingType, RingElemType, MultSetType}}) where {RingType, RingElemType, MultSetType}\n   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, v::Vector{RingElemType}) where {RingType, RingElemType, MultSetType}","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"for a single and a list of generators from both the base_ring of W and from W itself.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The minimal functionality which should be implemented for ideals is the test  for ideal membership","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Base.in(\n    f::AbsLocalizedRingElem{RingType, RingElemType, MultSetType}, \n    I::AbsLocalizedIdeal{RingType, RingElemType, MultSetType}\n  ) where {RingType, RingElemType, MultSetType}","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"and again the same for elements f of type RingElemType.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Basic operations on ideals which are already implemented on the generic level are ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Base.:*(I::T, J::T) where {T<:AbsLocalizedIdeal}\nBase.:+(I::T, J::T) where {T<:AbsLocalizedIdeal}","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Everything else, such as e.g. intersections of ideals, has to be implemented for the specific  types by the user.","category":"page"},{"location":"CommutativeAlgebra/localizations/#Localizations-of-multivariate-polynomial-rings","page":"Localizations of commutative rings","title":"Localizations of multivariate polynomial rings","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Various primitive types of multiplicative sets are available, such as ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"MPolyComplementOfPrimeIdeal{\n    BaseRingType, \n    BaseRingElemType,\n    RingType,\n    RingElemType\n  } \nMPolyComplementOfKPointIdeal{\n    BaseRingType,\n    BaseRingElemType, \n    RingType,\n    RingElemType\n  } \nMPolyPowersOfElement{\n    BaseRingType,\n    BaseRingElemType, \n    RingType,\n    RingElemType\n  } ","category":"page"},{"location":"CommutativeAlgebra/localizations/#MPolyComplementOfPrimeIdeal","page":"Localizations of commutative rings","title":"MPolyComplementOfPrimeIdeal","text":"MPolyComplementOfPrimeIdeal{\n    BaseRingType, \n    BaseRingElemType,\n    RingType,\n    RingElemType\n  } <: AbsMPolyMultSet{\n    BaseRingType, \n    BaseRingElemType,\n    RingType,\n    RingElemType\n  }\n\nThe complement of a prime ideal P  𝕜x₁xₙ in a multivariate polynomial ring  with elements of type RingElemType over a base ring 𝕜 of type BaseRingType.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/#MPolyComplementOfKPointIdeal","page":"Localizations of commutative rings","title":"MPolyComplementOfKPointIdeal","text":"MPolyComplementOfKPointIdeal{\n    BaseRingType,\n    BaseRingElemType, \n    RingType,\n    RingElemType\n  } <: AbsMPolyMultSet{\n    BaseRingType,\n    BaseRingElemType, \n    RingType, \n    RingElemType\n  }\n\nComplement of a maximal ideal 𝔪 = x₁-a₁xₙ-aₙ 𝕜x₁xₙ with aᵢ 𝕜.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/#MPolyPowersOfElement","page":"Localizations of commutative rings","title":"MPolyPowersOfElement","text":"MPolyPowersOfElement{\n    BaseRingType,\n    BaseRingElemType, \n    RingType,\n    RingElemType\n  } <: AbsMPolyMultSet{\n    BaseRingType,\n    BaseRingElemType, \n    RingType, \n    RingElemType\n  }\n\nThe set S = { aᵏ : k ∈ ℕ₀ } for some a  R with R of type BaseRingType.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Moreover, such types can be combined to products: ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Definition (Products of multiplicative sets): Let T and U be multiplicative sets in a commutative ring R. The product  of T and U is defined as ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"  Tcdot U = left fcdot g  f in T textnormal and g in U right","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"A product of multiplicative sets U = U_1 cdot dots cdot U_r is called interreduced  if neither one of the factors U_i is contained in one of the others U_j j neq i.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Note that any product of multiplicative sets may be replaced by  an interreduced one. However, such an interreduced multiplicative set is  not unique as the following example shows:","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Example (interreduction of products of multiplicative sets): An interreduced factorization of a product of multiplicative sets may  not be unique: Consider the ring mathbb Zx and the multiplicative sets ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"  T  = left(5x)^k  k in mathbb N_0right quad\n  T = left x^k  k in mathbb N_0rightquad\n  S  = left c_0 cdot x^0  c_0 notin 7 mathbb Zright","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Then Tcdot S = left ax^k  a notin 7mathbb Z k in mathbb N_0 right = Tcdot S.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Upshot: Whenever a product is taken, some interreduced form of the  entire product is returned. Besides the obvious simplification in  case all factors are contained in a single one, it is difficult to  determine which interreduction is the best one.  Localizations of multivariate polynomial rings are of type ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The type for storing general products is ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"MPolyProductOfMultSets{\n  BaseRingType,\n  BaseRingElemType, \n  RingType,\n  RingElemType\n}","category":"page"},{"location":"CommutativeAlgebra/localizations/#MPolyProductOfMultSets","page":"Localizations of commutative rings","title":"MPolyProductOfMultSets","text":"MPolyProductOfMultSets{\n    BaseRingType,\n    BaseRingElemType, \n    RingType,\n    RingElemType\n  } <: AbsMPolyMultSet{\n    BaseRingType,\n    BaseRingElemType, \n    RingType, \n    RingElemType\n  }\n\nA finite product T⋅U = { a⋅b : a ∈ T, b∈ U} of arbitrary other  multiplicative sets in a multivariate polynomial ring.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"and products can be taken using the usual arithmetic","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"product(T::AbsMPolyMultSet, U::AbsMPolyMultSet)","category":"page"},{"location":"CommutativeAlgebra/localizations/#product-Tuple{Oscar.AbsMPolyMultSet, Oscar.AbsMPolyMultSet}","page":"Localizations of commutative rings","title":"product","text":"product(T::AbsMPolyMultSet, U::AbsMPolyMultSet)\n\nReturn the product of the multiplicative sets T and U. \n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Note: The methods of this function naturally attempt  to return a primitive type of multiplicative sets whenever possible.  Hence, they are not type-stable. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Localizations of polynomial rings are of type","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"MPolyLocalizedRing{\n    BaseRingType,\n    BaseRingElemType,\n    RingType,\n    RingElemType,\n    MultSetType\n  } ","category":"page"},{"location":"CommutativeAlgebra/localizations/#MPolyLocalizedRing","page":"Localizations of commutative rings","title":"MPolyLocalizedRing","text":"MPolyLocalizedRing{\n    BaseRingType,\n    BaseRingElemType,\n    RingType,\n    RingElemType,\n    MultSetType\n  } <: AbsLocalizedRing{\n    RingType,\n    RingType,\n    MultSetType\n  }\n\nThe localization of a multivariate polynomial ring R = 𝕜x₁xₙ over a  base field 𝕜 of type BaseRingType and with elements of type RingElemType  at a multiplicative set S  R of type MultSetType.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"with elements of type","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"MPolyLocalizedRingElem{\n    BaseRingType, \n    BaseRingElemType,\n    RingType,\n    RingElemType, \n    MultSetType\n  }","category":"page"},{"location":"CommutativeAlgebra/localizations/#MPolyLocalizedRingElem","page":"Localizations of commutative rings","title":"MPolyLocalizedRingElem","text":"MPolyLocalizedRingElem{\n    BaseRingType, \n    BaseRingElemType,\n    RingType,\n    RingElemType, \n    MultSetType\n  } <: AbsLocalizedRingElem{\n    RingType,\n    RingElemType, \n    MultSetType\n  }\n\nElements of localizations of polynomial rings.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Ideals in localized polynomial rings are of type ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"MPolyLocalizedIdeal{BRT, BRET, RT, RET, MST}","category":"page"},{"location":"CommutativeAlgebra/localizations/#MPolyLocalizedIdeal","page":"Localizations of commutative rings","title":"MPolyLocalizedIdeal","text":"MPolyLocalizedIdeal{BRT, BRET, RT, RET, MST} <: AbsLocalizedIdeal{RT, RET, MST}\n\nIdeals in localizations of polynomial rings.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Recall (see e.g. [Eis95]) that  if mathbb k is a Noetherian ring, any localization W = RU^-1 of a  multivariate polynomial ring R = mathbb kx_1dotsx_n is again Noetherian and  any ideal I subset W is of the form I = Icdot W for some ideal I subset R.  This correspondence is not 1:1 but for any ideal I subset W we always  have that ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"  J = left xin R  exists u in U  ucdot x in I right","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"is the unique element which is maximal among all ideals I in R for  which I = Icdot W. We call this the saturated ideal of the localization  and it can be obtained using ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"saturated_ideal(I::MPolyLocalizedIdeal)","category":"page"},{"location":"CommutativeAlgebra/localizations/#saturated_ideal-Tuple{MPolyLocalizedIdeal}","page":"Localizations of commutative rings","title":"saturated_ideal","text":"saturated_ideal(I::MPolyLocalizedIdeal)\n\nFor an ideal I  RS¹ in a localized polynomial ring this returns  the unique ideal J  R which is maximal among all those ideals  I  R for which I  S¹ = I.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Groebner bases for the saturated ideal can be used to bring the numerators  of any fraction fracab in RS^-1 into normal form and check for  ideal membership and/or equality of elements modulo ideals in RS^-1. But for some cases, e.g. when using local orderings for localizations at  mathbb k-points, it is desirable, to have the groebner- and standard  basis functionality available directly in the localized ring.   To this end we have ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"LocalizedBiPolyArray{BRT, BRET, RT, RET, MST}","category":"page"},{"location":"CommutativeAlgebra/localizations/#LocalizedBiPolyArray","page":"Localizations of commutative rings","title":"LocalizedBiPolyArray","text":"LocalizedBiPolyArray{BRT, BRET, RT, RET, MST}\n\nMain workhorse for binding of ideals in localizations RS¹ of  multivariate polynomial rings R = 𝕜x₁xₙ to Singular.  To a set of elements f₁g₁ fᵣgᵣ  RS¹ this associates  the numerators ϕ(f₁)ϕ(fᵣ) as polynomials in Singular,  possibly after applying a shift ϕ  xᵢ  xᵢ- aᵢ with constants  aᵢ 𝕜 depending on the type MST of the multiplicative set.\n\nNote: The optional coordinate shift is to make local orderings  available for localizations at arbitrary 𝕜-points.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"which has a monomial ordering and a Singular ring associated to it. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Note: Transfering an element fracab in RS^-1 of a localized  ring to the Singular-side drops all denominators and only  the numerators appear as polynomials in Singular!  Hence, a LocalizedBiPolyArray is not really a 1:1-correspondence  of elements and in particular, the Oscar fractions can not be recovered  from the Singular side. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"This is also the type returned by any Groebner- or standard basis  computation. We make the following convention: ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Definition: Let mathbb kx_1dotsx_nS^-1 be  a localized polynomial ring with R = mathbb kx_1dotsx_n.  A monomial ordering geq is compatible with the localization, if  every unit in the localization R_geq is also a unit in RS^-1. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"For an ideal I subset RS^-1 and a compatible monomial ordering geq  we say that a set of elements fracg_11dotsfracg_r1 in RS^-1 is a  groebner/standard basis for I if the elements g_1dotsg_r are  a standard basis for the saturated ideal J of I in R. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Note: When localizing at mathbb k-points a = (a_1dotsa_n) in mathbb k^n outside the origin, the transfer of polynomials from the Oscar to the  Singular side in LocalizedBiPolyArray shifts the coordinates such that  a becomes zero. A monomial ordering is always considered after application  of such shifts. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Groebner and standard bases of ideals can be computed for explicit  orderings using ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"    groebner_basis(I::MPolyLocalizedIdeal, ord::Symbol)","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Note that depending on the type parameters of I, this method  is dispatched differently, which will also lead to different  interpretations of the ordering. For instance, for multiplicative  sets of type MPolyComplementOfKPointIdeal, a shift of variables  taking the geometric point to the origin is applied to all polynomials  when passing to the singular side. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"If the second argument is omitted, a default ordering  will be chosen, depending on the type of the multiplicative set. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Remark: Why bother introducing Groebner and standard basis for  localized ideals in the first place and not only work with the  saturated ideal? The main reason is that for localizations at  mathbb k-points, the computation of the saturated ideal is  quite expensive: It involves a primary decomposition using a  global ordering and discarding components outside the point  at which has been localized. Using local orderings, on the other hand,  we can decide ideal membership or equality of elements without  computing the saturated ideal explicitly.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The following method might be of practical interest: ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"as_affine_algebra(\n  L::MPolyLocalizedRing{BRT, BRET, RT, RET, \n  MPolyPowersOfElement{BRT, BRET, RT, RET}}; \n  inverse_name::String=\"θ\"\n) where {BRT, BRET, RT, RET}","category":"page"},{"location":"CommutativeAlgebra/localizations/#as_affine_algebra-Union{Tuple{MPolyLocalizedRing{BRT, BRET, RT, RET, MPolyPowersOfElement{BRT, BRET, RT, RET}}}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}} where {BRT, BRET, RT, RET}","page":"Localizations of commutative rings","title":"as_affine_algebra","text":"as_affine_algebra(\n  L::MPolyLocalizedRing{BRT, BRET, RT, RET, \n  MPolyPowersOfElement{BRT, BRET, RT, RET}}; \n  inverse_name::String=\"θ\"\n) where {BRT, BRET, RT, RET}\n\nFor a localized polynomial ring L = 𝕜x₁xₙf¹ this returns a  quintuple (A I d ϕ θ) consisting of \n\nan AffineAlgebra A = 𝕜x₁xₙθ1 - θd isomorphic to L\nthe ideal 1 - θd\nan element d  𝕜x₁xₙ at which has been localized\nthe natural inclusion ϕ  𝕜x₁xₙ  A\nthe localization variable θ corresponding to d¹.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#Localizations-of-affine-algebras","page":"Localizations of commutative rings","title":"Localizations of affine algebras","text":"","category":"section"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Let R = 𝕜x₁xₘ be a polynomial ring, I  R some ideal  and P = RI its quotient. Then P is naturally an R-module  and localization of P as a ring coincides with localization  as an R-module in the sense that for every multiplicative  set T  R there is a commutative diagram ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"beginmatrix\n        R      P = RI\n                  \n  W = RT¹    PT¹\nendmatrix","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Observe that, moreover, for every multiplicative set  T  P the preimage T of T in R is also a multiplicative set. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"We may therefore treat localizations of polynomial algebras  as localizations of modules over free polynomial rings: and apply the following ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Convention: For localizations of affine algebras  L = (𝕜x₁xₙI)S¹ ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"ideals in L are given by ideals in W = 𝕜x₁xₙS¹ containing Icdot S^-1.\nthe available multiplicative sets for L are exclusively those for 𝕜x₁xₙ.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Note that this leads to the following differences compared to the  standard usage of the localization interface:","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The base_ring returns neither P, nor W, but R.\nThe BaseRingType is the type of R and similar for  the other ring-based type parameters.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"This is to make the data structure most accessible for  the computational backends.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"The type returned by numerator and denominator  on an element of type MPolyQuoLocalizedRingElem is  not RingElemType, but the type of P. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"This is to comply with the purely mathematical viewpoint where elements of localized rings are fractions of  residue classes rather than residue classes of fractions. ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Localizations of affine algebras are realized by ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"MPolyQuoLocalizedRing{\n  BaseRingType,\n  BaseRingElemType,\n  RingType,\n  RingElemType,\n  MultSetType <: AbsMultSet{RingType, RingElemType}\n}","category":"page"},{"location":"CommutativeAlgebra/localizations/#MPolyQuoLocalizedRing","page":"Localizations of commutative rings","title":"MPolyQuoLocalizedRing","text":"MPolyQuoLocalizedRing{\n    BaseRingType,\n    BaseRingElemType,\n    RingType,\n    RingElemType,\n    MultSetType <: AbsMultSet{RingType, RingElemType}\n  } <: AbsLocalizedRing{\n    RingType,\n    RingElemType,\n    MultSetType\n  }\n\nLocalization L = (𝕜x₁xₙI)S¹ of a quotient 𝕜x₁xₙI of a polynomial ring P = 𝕜x₁xₙ of type RingType over a base ring 𝕜 of type BaseRingType at a multiplicative set S  P of type MultSetType.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"which have the additional methods ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"quotient_ring(L::MPolyQuoLocalizedRing)\nlocalized_ring(L::MPolyQuoLocalizedRing)","category":"page"},{"location":"CommutativeAlgebra/localizations/#quotient_ring-Tuple{MPolyQuoLocalizedRing}","page":"Localizations of commutative rings","title":"quotient_ring","text":"quotient_ring(L::MPolyQuoLocalizedRing)\n\nFor L = (𝕜x₁xₙI)S¹ this returns 𝕜x₁xₙI.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#localized_ring-Tuple{MPolyQuoLocalizedRing}","page":"Localizations of commutative rings","title":"localized_ring","text":"localized_ring(L::MPolyQuoLocalizedRing)\n\nFor L = (𝕜x₁xₙI)S¹ this returns 𝕜x₁xₙS¹.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"returning the other two computationally important rings in its construction.","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"Elements of such rings are of the form ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"MPolyQuoLocalizedRingElem{\n  BaseRingType, \n  BaseRingElemType,\n  RingType,\n  RingElemType, \n  MultSetType\n}","category":"page"},{"location":"CommutativeAlgebra/localizations/#MPolyQuoLocalizedRingElem","page":"Localizations of commutative rings","title":"MPolyQuoLocalizedRingElem","text":"MPolyQuoLocalizedRingElem{\n  BaseRingType, \n  BaseRingElemType,\n  RingType,\n  RingElemType, \n  MultSetType\n} <: AbsLocalizedRingElem{\n  RingType,\n  RingElemType, \n  MultSetType\n}\n\nElements ab of localizations L = (𝕜x₁xₙI)S¹ of type  MPolyQuoLocalizedRing{BaseRingType, BaseRingElemType, RingType, RingElemType, MultSetType}.\n\n\n\n\n\n","category":"type"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"In contrast to ordinary elements of a localized ring, they  have the additional methods ","category":"page"},{"location":"CommutativeAlgebra/localizations/","page":"Localizations of commutative rings","title":"Localizations of commutative rings","text":"lifted_numerator(a::MPolyQuoLocalizedRingElem)\nlifted_denominator(a::MPolyQuoLocalizedRingElem)\nfraction(a::MPolyQuoLocalizedRingElem)","category":"page"},{"location":"CommutativeAlgebra/localizations/#lifted_numerator-Tuple{MPolyQuoLocalizedRingElem}","page":"Localizations of commutative rings","title":"lifted_numerator","text":"lifted_numerator(a::MPolyQuoLocalizedRingElem)\n\nFor AB  (𝕜x₁xₙI)S¹ this returns a representative  a  𝕜x₁xₙ of the numerator. \n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#lifted_denominator-Tuple{MPolyQuoLocalizedRingElem}","page":"Localizations of commutative rings","title":"lifted_denominator","text":"lifted_denominator(a::MPolyQuoLocalizedRingElem)\n\nFor AB  (𝕜x₁xₙI)S¹ this returns a representative  b   𝕜x₁xₙ of the denominator.\n\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/localizations/#fraction-Tuple{MPolyQuoLocalizedRingElem}","page":"Localizations of commutative rings","title":"fraction","text":"fraction(a::MPolyQuoLocalizedRingElem)\n\nFor AB  (𝕜x₁xₙI)S¹ this returns a representative  ab  Quot(𝕜x₁xₙ) of the fraction. \n\n\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/SubObjectIterator/#SubObjectIterator","page":"SubObjectIterator","title":"SubObjectIterator","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Many of the objects in the field of Polyhedral Geometry mask a BigObject from Polymake.jl. These big objects have properties which can easily be accessed via julia's dot syntax. The return commonly does not adhere to the mathematical or the typing conventions of Oscar; many properties encode information about a collection of mathematical objects within a single data object.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The SubObjectIterator is a precise and flexible tool to directly access and/or process the desired properties of any Polymake.BigObject, but it requires specific interface definitions to work properly for each context. The user can thus profit from an easily understandable and usable iterator.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"This guide is meant to communicate the application of the SubObjectIterator for developers, utilizing existing code as reference and examples.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Creating-a-working-SubObjectIterator","page":"SubObjectIterator","title":"Creating a working SubObjectIterator","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The formal definition of the SubObjectIterator in src/PolyhedralGeometry/iterators is:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"struct SubObjectIterator{T} <: AbstractVector{T}\n    Obj::Polymake.BigObject\n    Acc::Function\n    n::Int\n    options::NamedTuple\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"An instance can be created by passing values for all fields, while options is optional.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Trivially, Obj is the Polymake.BigObject whose property is to be accessed. The other fields will each be explained in an upcoming section.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Length","page":"SubObjectIterator","title":"Length","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"As an AbstractVector, the SubObjectIterator has a length. Due to the nature of Polymake.BigObjects this length is constant for any property. Sometimes the length can easily be derived as a by-product of pre-computations when creating an instance of SubObjectIterator. To avoid performing unnecessary computations afterwards, the value is set at construction in n.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Access-function","page":"SubObjectIterator","title":"Access function","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Optimally retrieving and converting the elements varies strongly between the contexts in which a SubObjectIterator is created. Thus its getindex method redirects the call to the (internal) function Acc:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"function Base.getindex(iter::SubObjectIterator{T}, i::Base.Integer) where T\n    @boundscheck 1 <= i && i <= iter.n\n    return iter.Acc(T, iter.Obj, i; iter.options...)\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"From this call we can see that the access function's signature needs to satisfy certain requirements for the SubObjectIterator to work. The arguments are:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"T: The return type.\niter.Obj: The Polymake.BigObject whose property is to be accessed.\ni: The index.\niter.options: Additional arguments. Will be explained later.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Let us look at an example how we can utilize this interface. The following is the implementation to access the rays of a Cone:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"rays(as::Type{RayVector{T}}, C::Cone) where T = SubObjectIterator{as}(pm_object(C), _ray_cone, nrays(C))\n\n_ray_cone(::Type{T}, C::Polymake.BigObject, i::Base.Integer) where T = T(C.RAYS[i, :])","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Typing r = rays(RayVector{Polymake.Rational}, C) with a Cone C returns a SubObjectIterator over RayVector{Polymake.Rational} elements of length nrays(C) with access function _ray_cone. With the given method of this function, getindex(r, i) returns a RayVector{Polymake.Rational} constructed from the i-th row of the property RAYS of the Polymake.BigObject.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The user does never directly create a SubObjectIterator, so type restrictions made where it is created can be assumed to hold. In our example _ray_cone will always be called with T<:RayVector.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"One can define several methods of the access function to ideally read and process data. Consider facets(as::Type{T}, C::Cone). Depending on the return type we offer three methods:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"_facet_cone(::Type{T}, C::Polymake.BigObject, i::Base.Integer) where T<:Union{Polyhedron, AffineHalfspace} = T(-C.FACETS[[i], :], 0)\n\n_facet_cone(::Type{LinearHalfspace}, C::Polymake.BigObject, i::Base.Integer) = LinearHalfspace(-C.FACETS[[i], :])\n\n_facet_cone(::Type{Cone}, C::Polymake.BigObject, i::Base.Integer) = cone_from_inequalities(-C.FACETS[[i], :])","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Additional-Methods","page":"SubObjectIterator","title":"Additional Methods","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The SubObjectIterator can moreover be understood as a mathematical collection the sense that one can","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"ask for specific information encoded in the data or\nuse this collection as an argument for construction another mathematical object.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The first case is covered by adding methods to specific internal functions. Remember implementation of rays discussed above. It makes sense to define a vector_matrix method on its output, encoding the rays of the cone as a single matrix based on a convention applied throughout Oscar. The function's implementation a user calls in this case is evaluated to these lines:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"vector_matrix(iter::SubObjectIterator{<:AbstractVector{Polymake.Rational}}) = matrix(QQ, Matrix{fmpq}(_vector_matrix(Val(iter.Acc), iter.Obj; iter.options...)))\nvector_matrix(iter::SubObjectIterator{<:AbstractVector{Polymake.Integer}}) = matrix(ZZ, _vector_matrix(Val(iter.Acc), iter.Obj; iter.options...))\n_vector_matrix(::Any, ::Polymake.BigObject) = throw(ArgumentError(\"Vector Matrix not defined in this context.\"))","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Two functionalities are defined this way:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The call of vector_matrix(iter) is redirected to _vector_matrix(Val(iter.Acc), iter.Obj). If that method is not defined for the value type of the access function, it falls back to throwing an error.\nThe matrix received from step 1 is converted from Polymake.jl format to Oscar format.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"So by defining the following we have a fully functional vector_matrix method in the context of rays:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"_vector_matrix(::Val{_ray_cone}, C::Polymake.BigObject) = C.RAYS","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The second case is solved with defining a special _matrix_for_polymake method. One just hast to name the internal function that returns the desired matrix. This way one has the ability to precisely control how the iterator works internally in specific contexts, even if there happen to be multiple additional matrix functions.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Again, the call matrix_for_polymake(iter) will either redirect to the defined method or fall back to throwing an error if there is none:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"function matrix_for_polymake(iter::SubObjectIterator)\n    if hasmethod(_matrix_for_polymake, Tuple{Val{iter.Acc}})\n        return _matrix_for_polymake(Val(iter.Acc))(Val(iter.Acc), iter.Obj; iter.options...)\n    else\n        throw(ArgumentError(\"Matrix for Polymake not defined in this context.\"))\n    end\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"For rays(C::Cone) this reduces the implementation to the following line:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"_matrix_for_polymake(::Val{_ray_cone}) = _vector_matrix","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"With matrix_for_polymake the output of rays can be handled as a usual matrix and constructors or other functions can easily be extended by additionally allowing SubObjectIterator as an argument type. E.g. the signature of one of the Cone constructors now looks like this while the body has not changed:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Cone(R::Union{SubObjectIterator{<:RayVector}, Oscar.MatElem, AbstractMatrix}, L::Union{SubObjectIterator{<:RayVector}, Oscar.MatElem, AbstractMatrix, Nothing} = nothing; non_redundant::Bool = false)","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"There also are linear_matrix_for_polymake and affine_matrix_for_polymake used in the context of linear and affine halfspaces/hyperplanes. Defining this functionality in a context works the same way as for matrix_for_polymake; you can create a new method of _linear_matrix_for_polymake or _affine_matrix_for_polymake. It suffices to define the most relevant of these two; the other one will be derived, if possible. Also, halfspace_matrix_pair is defined in terms of affine_matrix_for_polymake, so this does not need another implementation.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The example code for rays(C::Cone) has covered every line of the implementation by now, but we had different code in between, so let us summarize and take a look at what the whole implementation actually looks like:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"rays(as::Type{RayVector{T}}, C::Cone) where T = SubObjectIterator{as}(pm_object(C), _ray_cone, nrays(C))\n\n_ray_cone(::Type{T}, C::Polymake.BigObject, i::Base.Integer) where T = T(C.RAYS[i, :])\n\n_vector_matrix(::Val{_ray_cone}, C::Polymake.BigObject) = C.RAYS\n\n_matrix_for_polymake(::Val{_ray_cone}) = _vector_matrix","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#options","page":"SubObjectIterator","title":"options","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"Sometimes you need further arguments to specify the returned data. These arguments are set at construction of the SubObjectIterator and later passed to the corresponding functions as keyword arguments.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"A good example how to use this is faces(C::Cone, face_dim::Int). It is not enough to know that our SubObjectIterator is set in the context of faces of cones; face_dim will be relevant for any type of access occurring in the future.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"function faces(C::Cone, face_dim::Int)\n   n = face_dim - length(lineality_space(C))\n   n < 1 && return nothing\n   return SubObjectIterator{Cone}(C.pm_cone, _face_cone, size(Polymake.polytope.faces_of_dim(pm_object(C), n), 1), (f_dim = n,))\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"When this method is called with meaningful input, it creates a SubObjectIterator where the last argument is a NamedTuple specifying that f_dim = n. The information encoded in this NamedTuple will be passed as keyword arguments when calling the access function or any additional method (reconsider their definitions). This allows us to directly ask for that data when implementing these methods:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"function _face_cone(::Type{Cone}, C::Polymake.BigObject, i::Base.Integer; f_dim::Int = 0)\n   return Cone(Polymake.polytope.Cone(RAYS = C.RAYS[collect(Polymake.to_one_based_indexing(Polymake.polytope.faces_of_dim(C, f_dim)[i])), :], LINEALITY_SPACE = C.LINEALITY_SPACE))\nend\n\nfunction _ray_indices(::Val{_face_cone}, C::Polymake.BigObject; f_dim::Int = 0)\n   f = Polymake.to_one_based_indexing(Polymake.polytope.faces_of_dim(C, f_dim))\n   return IncidenceMatrix([collect(f[i]) for i in 1:length(f)])\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/#Extending-the-interface","page":"SubObjectIterator","title":"Extending the interface","text":"","category":"section"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The additional methods offer an intuitive way of interaction for the user, but their current selection is not carved in stone. You can easily add more similar methods by extending the list that is iterated over to generate the code. Which list that is usually depends on the output format. vector_matrix returns matrices with either integer or rational elements. The same capabilities hold for point_matrix and generator_matrix:","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"for (sym, name) in ((\"point_matrix\", \"Point Matrix\"), (\"vector_matrix\", \"Vector Matrix\"), (\"generator_matrix\", \"Generator Matrix\"))\n    M = Symbol(sym)\n    _M = Symbol(string(\"_\", sym))\n    @eval begin\n        $M(iter::SubObjectIterator{<:AbstractVector{Polymake.Rational}}) = matrix(QQ, Matrix{fmpq}($_M(Val(iter.Acc), iter.Obj; iter.options...)))\n        $M(iter::SubObjectIterator{<:AbstractVector{Polymake.Integer}}) = matrix(ZZ, $_M(Val(iter.Acc), iter.Obj; iter.options...))\n        $_M(::Any, ::Polymake.BigObject) = throw(ArgumentError(string($name, \" not defined in this context.\")))\n    end\nend","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"The second string (name) of each pair determines the name that is printed in error messages.","category":"page"},{"location":"DeveloperDocumentation/SubObjectIterator/","page":"SubObjectIterator","title":"SubObjectIterator","text":"If required, one can of course write completely new functions to extend the interface.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/algebraic/#Algebraic-numbers","page":"Algebraic numbers","title":"Algebraic numbers","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Nemo allows working with exact real and complex algebraic numbers.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The default algebraic number type in Nemo is provided by Calcium. The associated field of algebraic numbers is represented by the constant parent object called CalciumQQBar.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"For convenience we define","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"QQBar = CalciumQQBar","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"so that algebraic numbers can be constructed using QQBar instead of CalciumQQBar. Note that this is the name of a specific parent object, not the name of its type.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Library Element type Parent type\nCalcium qqbar CalciumQQBarField","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Important note on performance","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The default algebraic number type represents algebraic numbers in canonical form using minimal polynomials. This works well for representing individual algebraic numbers, but it does not provide the best performance for field arithmetic. For fast calculation in overlinemathbbQ, CalciumField should typically be used instead (see the section on Exact real and complex numbers). Alternatively, to compute in a fixed subfield of overlinemathbbQ, you may fix a generator a and construct an Antic number field to represent mathbbQ(a).","category":"page"},{"location":"Nemo/algebraic/#Algebraic-number-functionality","page":"Algebraic numbers","title":"Algebraic number functionality","text":"","category":"section"},{"location":"Nemo/algebraic/#Constructing-algebraic-numbers","page":"Algebraic numbers","title":"Constructing algebraic numbers","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Methods to construct algebraic numbers include:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Conversion from other numbers and through arithmetic operations\nComputing the roots of a given polynomial\nComputing the eigenvalues of a given matrix\nRandom generation\nExact trigonometric functions (see later section)\nGuessing (see later section)","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Arithmetic:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> fmpz(QQBar(3))\n3\n\njulia> fmpq(QQBar(3) // 2)\n3//2\n\njulia> QQBar(-1) ^ (QQBar(1) // 3)\nRoot 0.500000 + 0.866025*im of x^2 - x + 1","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Solving the quintic equation:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rational Field, x)\n\njulia> v = roots(x^5-x-1, QQBar)\n5-element Vector{qqbar}:\n Root 1.16730 of x^5 - x - 1\n Root 0.181232 + 1.08395*im of x^5 - x - 1\n Root 0.181232 - 1.08395*im of x^5 - x - 1\n Root -0.764884 + 0.352472*im of x^5 - x - 1\n Root -0.764884 - 0.352472*im of x^5 - x - 1\n\njulia> v[1]^5 - v[1] - 1 == 0\ntrue","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Computing exact eigenvalues of a matrix:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> eigenvalues(ZZ[1 1 0; 0 1 1; 1 0 1], QQBar)\n3-element Vector{qqbar}:\n Root 2.00000 of x - 2\n Root 0.500000 + 0.866025*im of x^2 - x + 1\n Root 0.500000 - 0.866025*im of x^2 - x + 1","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"roots(f::fmpz_poly, R::CalciumQQBarField)\nroots(f::fmpq_poly, R::CalciumQQBarField)\neigenvalues(A::fmpz_mat, R::CalciumQQBarField)\neigenvalues(A::fmpq_mat, R::CalciumQQBarField)\nrand(R::CalciumQQBarField; degree::Int, bits::Int, randtype::Symbol=:null)","category":"page"},{"location":"Nemo/algebraic/#roots-Tuple{fmpz_poly, CalciumQQBarField}","page":"Algebraic numbers","title":"roots","text":"roots(f::fmpz_poly, R::CalciumQQBarField)\n\nReturn all the roots of the polynomial f in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Roots of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#roots-Tuple{fmpq_poly, CalciumQQBarField}","page":"Algebraic numbers","title":"roots","text":"roots(f::fmpq_poly, R::CalciumQQBarField)\n\nReturn all the roots of the polynomial f in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Roots of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#eigenvalues-Tuple{fmpz_mat, CalciumQQBarField}","page":"Algebraic numbers","title":"eigenvalues","text":"eigenvalues(A::fmpz_mat, R::CalciumQQBarField)\n\nReturn all the eigenvalues of the matrix A in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Eigenvalues of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#eigenvalues-Tuple{fmpq_mat, CalciumQQBarField}","page":"Algebraic numbers","title":"eigenvalues","text":"eigenvalues(A::fmpq_mat, R::CalciumQQBarField)\n\nReturn all the eigenvalues of the matrix A in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers. Eigenvalues of multiplicity higher than one are repeated according to their multiplicity.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#rand-Tuple{CalciumQQBarField}","page":"Algebraic numbers","title":"rand","text":"rand(R::CalciumQQBarField; degree::Int, bits::Int, randtype::Symbol=:null)\n\nReturn a random algebraic number with degree up to degree and coefficients up to bits in size. By default, both real and complex numbers are generated. Set the optional randtype to :real or :nonreal to generate a specific type of number. Note that nonreal numbers require degree at least 2.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Numerical-evaluation","page":"Algebraic numbers","title":"Numerical evaluation","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Algebraic numbers can be evaluated numerically to arbitrary precision by converting to real or complex Arb fields:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> RR = ArbField(64); RR(sqrt(QQBar(2)))\n[1.414213562373095049 +/- 3.45e-19]\n\njulia> CC = AcbField(32); CC(QQBar(-1) ^ (QQBar(1) // 4))\n[0.707106781 +/- 2.74e-10] + [0.707106781 +/- 2.74e-10]*im","category":"page"},{"location":"Nemo/algebraic/#Minimal-polynomials,-conjugates,-and-properties","page":"Algebraic numbers","title":"Minimal polynomials, conjugates, and properties","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Retrieving the minimal polynomial and algebraic conjugates of a given algebraic number:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> minpoly(PolynomialRing(ZZ, \"x\")[1], QQBar(1+2im))\nx^2 - 2*x + 5\n\njulia> conjugates(QQBar(1+2im))\n2-element Vector{qqbar}:\n Root 1.00000 + 2.00000*im of x^2 - 2x + 5\n Root 1.00000 - 2.00000*im of x^2 - 2x + 5","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"iszero(x::qqbar)\nisone(x::qqbar)\nisinteger(x::qqbar)\nisrational(x::qqbar)\nisreal(x::qqbar)\ndegree(x::qqbar)\nisalgebraic_integer(x::qqbar)\nminpoly(R::FmpzPolyRing, x::qqbar)\nminpoly(R::FmpqPolyRing, x::qqbar)\nconjugates(a::qqbar)\ndenominator(x::qqbar)\nnumerator(x::qqbar)\nheight(x::qqbar)\nheight_bits(x::qqbar)","category":"page"},{"location":"Nemo/algebraic/#iszero-Tuple{qqbar}","page":"Algebraic numbers","title":"iszero","text":"iszero(x::qqbar)\n\nReturn whether x is the number 0.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isone-Tuple{qqbar}","page":"Algebraic numbers","title":"isone","text":"isone(x::qqbar)\n\nReturn whether x is the number 1.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isinteger-Tuple{qqbar}","page":"Algebraic numbers","title":"isinteger","text":"isinteger(x::qqbar)\n\nReturn whether x is an integer.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isrational-Tuple{qqbar}","page":"Algebraic numbers","title":"isrational","text":"isrational(x::qqbar)\n\nReturn whether x is a rational number.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isreal-Tuple{qqbar}","page":"Algebraic numbers","title":"isreal","text":"isreal(x::qqbar)\n\nReturn whether x is a real number.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#degree-Tuple{qqbar}","page":"Algebraic numbers","title":"degree","text":"degree(x::qqbar)\n\nReturn the degree of the minimal polynomial of x.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isalgebraic_integer-Tuple{qqbar}","page":"Algebraic numbers","title":"isalgebraic_integer","text":"isalgebraic_integer(x::qqbar)\n\nReturn whether x is an algebraic integer.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#minpoly-Tuple{FmpzPolyRing, qqbar}","page":"Algebraic numbers","title":"minpoly","text":"minpoly(R::FmpzPolyRing, x::qqbar)\n\nReturn the minimal polynomial of x as an element of the polynomial ring R.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#minpoly-Tuple{FmpqPolyRing, qqbar}","page":"Algebraic numbers","title":"minpoly","text":"minpoly(R::FmpzPolyRing, x::qqbar)\n\nReturn the minimal polynomial of x as an element of the polynomial ring R.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#conjugates-Tuple{qqbar}","page":"Algebraic numbers","title":"conjugates","text":"conjugates(a::qqbar)\n\nReturn all the roots of the polynomial f in the field of algebraic numbers R. The output array is sorted in the default sort order for algebraic numbers.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#denominator-Tuple{qqbar}","page":"Algebraic numbers","title":"denominator","text":"denominator(x::qqbar)\n\nReturn the denominator of x, defined as the leading coefficient of the minimal polynomial of x. The result is returned as an fmpz.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#numerator-Tuple{qqbar}","page":"Algebraic numbers","title":"numerator","text":"numerator(x::qqbar)\n\nReturn the numerator of x, defined as x multiplied by its denominator. The result is an algebraic integer.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#height-Tuple{qqbar}","page":"Algebraic numbers","title":"height","text":"height(x::qqbar)\n\nReturn the height of the algebraic number x. The result is an fmpz integer.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#height_bits-Tuple{qqbar}","page":"Algebraic numbers","title":"height_bits","text":"height_bits(x::qqbar)\n\nReturn the height of the algebraic number x measured in bits. The result is a Julia integer.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Complex-parts","page":"Algebraic numbers","title":"Complex parts","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> real(sqrt(QQBar(1im)))\nRoot 0.707107 of 2x^2 - 1\n\njulia> abs(sqrt(QQBar(1im)))\nRoot 1.00000 of x - 1\n\njulia> floor(sqrt(QQBar(1000)))\nRoot 31.0000 of x - 31\n\njulia> sign(QQBar(-10-20im))\nRoot -0.447214 - 0.894427*im of 5x^4 + 6x^2 + 5","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"real(a::qqbar)\nimag(a::qqbar)\nabs(a::qqbar)\nabs2(a::qqbar)\nconj(a::qqbar)\nsign(a::qqbar)\ncsgn(a::qqbar)\nsign_real(a::qqbar)\nsign_imag(a::qqbar)\nfloor(a::qqbar)\nceil(a::qqbar)","category":"page"},{"location":"Nemo/algebraic/#real-Tuple{qqbar}","page":"Algebraic numbers","title":"real","text":"real(a::qqbar)\n\nReturn the real part of a.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#imag-Tuple{qqbar}","page":"Algebraic numbers","title":"imag","text":"imag(a::qqbar)\n\nReturn the imaginary part of a.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#abs-Tuple{qqbar}","page":"Algebraic numbers","title":"abs","text":"abs(a::qqbar)\n\nReturn the absolute value of a.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#abs2-Tuple{qqbar}","page":"Algebraic numbers","title":"abs2","text":"abs2(a::qqbar)\n\nReturn the squared absolute value of a.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#conj-Tuple{qqbar}","page":"Algebraic numbers","title":"conj","text":"conj(a::qqbar)\n\nReturn the complex conjugate of a.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#sign-Tuple{qqbar}","page":"Algebraic numbers","title":"sign","text":"sign(a::qqbar)\n\nReturn the complex sign of a, defined as zero if a is zero and as a  a otherwise.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#csgn-Tuple{qqbar}","page":"Algebraic numbers","title":"csgn","text":"csgn(a::qqbar)\n\nReturn the extension of the real sign function taking the value 1 strictly in the right half plane, -1 strictly in the left half plane, and the sign of the imaginary part when on the imaginary axis. Equivalently, operatornamecsgn(x) = x  sqrtx^2 except that the value is 0 at zero. The value is returned as a Julia integer.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#sign_real-Tuple{qqbar}","page":"Algebraic numbers","title":"sign_real","text":"sign_real(a::qqbar)\n\nReturn the sign of the real part of a as a Julia integer.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#sign_imag-Tuple{qqbar}","page":"Algebraic numbers","title":"sign_imag","text":"sign_imag(a::qqbar)\n\nReturn the sign of the imaginary part of a as a Julia integer.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#floor-Tuple{qqbar}","page":"Algebraic numbers","title":"floor","text":"floor(a::qqbar)\n\nReturn the floor function of a as an algebraic number. Use fmpz(floor(a)) to construct a Nemo integer instead.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#ceil-Tuple{qqbar}","page":"Algebraic numbers","title":"ceil","text":"ceil(a::qqbar)\n\nReturn the ceiling function of b as an algebraic number. Use fmpz(ceil(a)) to construct a Nemo integer instead.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Comparing-algebraic-numbers","page":"Algebraic numbers","title":"Comparing algebraic numbers","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The operators == and != check exactly for equality.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"We provide various comparison functions for ordering algebraic numbers:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Standard comparison for real numbers (<, isless)\nReal parts\nImaginary parts\nAbsolute values\nAbsolute values of real or imaginary parts\nRoot sort order ","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The standard comparison will throw if either argument is nonreal.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The various comparisons for complex parts are provided as separate operations since these functions are far more efficient than explicitly computing the complex parts and then doing real comparisons.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"The root sort order is a total order for complex algebraic numbers used to order the output of roots and conjugates canonically. We define this order as follows: real roots come first, in descending order. Nonreal roots are subsequently ordered first by real part in descending order, then in ascending order by the absolute value of the imaginary part, and then in descending order of the sign of the imaginary part. This implies that complex conjugate roots are adjacent, with the root in the upper half plane first.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> 1 < sqrt(QQBar(2)) < QQBar(3)//2\ntrue\n\njulia> x = QQBar(3+4im)\nRoot 3.00000 + 4.00000*im of x^2 - 6x + 25\n\njulia> isequal_abs(x, -x)\ntrue\n\njulia> isequal_abs_imag(x, 2-x)\ntrue\n\njulia> isless_real(x, x // 2)\nfalse","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"isequal_real(a::qqbar, b::qqbar)\nisequal_imag(a::qqbar, b::qqbar)\nisequal_abs(a::qqbar, b::qqbar)\nisequal_abs_real(a::qqbar, b::qqbar)\nisequal_abs_imag(a::qqbar, b::qqbar)\nisless_real(a::qqbar, b::qqbar)\nisless_imag(a::qqbar, b::qqbar)\nisless_abs(a::qqbar, b::qqbar)\nisless_abs_real(a::qqbar, b::qqbar)\nisless_abs_imag(a::qqbar, b::qqbar)\nisless_root_order(a::qqbar, b::qqbar)","category":"page"},{"location":"Nemo/algebraic/#isequal_real-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isequal_real","text":"isequal_real(a::qqbar, b::qqbar)\n\nCompares the real parts of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isequal_imag-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isequal_imag","text":"isequal_imag(a::qqbar, b::qqbar)\n\nCompares the imaginary parts of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isequal_abs-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isequal_abs","text":"isequal_abs(a::qqbar, b::qqbar)\n\nCompares the absolute values of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isequal_abs_real-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isequal_abs_real","text":"isequal_abs_real(a::qqbar, b::qqbar)\n\nCompares the absolute values of the real parts of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isequal_abs_imag-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isequal_abs_imag","text":"isequal_abs_imag(a::qqbar, b::qqbar)\n\nCompares the absolute values of the imaginary parts of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isless_real-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isless_real","text":"isless_real(a::qqbar, b::qqbar)\n\nCompares the real parts of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isless_imag-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isless_imag","text":"isless_imag(a::qqbar, b::qqbar)\n\nCompares the imaginary parts of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isless_abs-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isless_abs","text":"isless_abs(a::qqbar, b::qqbar)\n\nCompares the absolute values of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isless_abs_real-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isless_abs_real","text":"isless_abs_real(a::qqbar, b::qqbar)\n\nCompares the absolute values of the real parts of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isless_abs_imag-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isless_abs_imag","text":"isless_abs_imag(a::qqbar, b::qqbar)\n\nCompares the absolute values of the imaginary parts of a and b.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isless_root_order-Tuple{qqbar, qqbar}","page":"Algebraic numbers","title":"isless_root_order","text":"isless_root_order(a::qqbar, b::qqbar)\n\nCompares the a and b in root sort order.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Roots-and-trigonometric-functions","page":"Algebraic numbers","title":"Roots and trigonometric functions","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> root(QQBar(2), 5)\nRoot 1.14870 of x^5 - 2\n\njulia> sinpi(QQBar(7) // 13)\nRoot 0.992709 of 4096x^12 - 13312x^10 + 16640x^8 - 9984x^6 + 2912x^4 - 364x^2 + 13\n\njulia> tanpi(atanpi(sqrt(QQBar(2)) + 1))\nRoot 2.41421 of x^2 - 2x - 1\n\njulia> root_of_unity(QQBar, 5)\nRoot 0.309017 + 0.951057*im of x^4 + x^3 + x^2 + x + 1\n\njulia> root_of_unity(QQBar, 5, 4)\nRoot 0.309017 - 0.951057*im of x^4 + x^3 + x^2 + x + 1\n\njulia> w = (1 - sqrt(QQBar(-3)))//2\nRoot 0.500000 - 0.866025*im of x^2 - x + 1\n\njulia> isroot_of_unity(w)\ntrue\n\njulia> isroot_of_unity(w + 1)\nfalse\n\njulia> root_of_unity_as_args(w)\n(6, 5)","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"sqrt(a::qqbar)\nroot(a::qqbar, n::Int)\nroot_of_unity(C::CalciumQQBarField, n::Int)\nroot_of_unity(C::CalciumQQBarField, n::Int, k::Int)\nisroot_of_unity(a::qqbar)\nroot_of_unity_as_args(a::qqbar)\nexp_pi_i(a::qqbar)\nlog_pi_i(a::qqbar)\nsinpi(a::qqbar)\ncospi(a::qqbar)\ntanpi(a::qqbar)\nasinpi(a::qqbar)\nacospi(a::qqbar)\natanpi(a::qqbar)","category":"page"},{"location":"Nemo/algebraic/#sqrt-Tuple{qqbar}","page":"Algebraic numbers","title":"sqrt","text":"sqrt(a::qqbar; check::Bool=true)\n\nReturn the principal square root of a.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#root-Tuple{qqbar, Int64}","page":"Algebraic numbers","title":"root","text":"root(a::qqbar, n::Int)\n\nReturn the principal n-th root of a. Requires positive n.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#root_of_unity-Tuple{CalciumQQBarField, Int64}","page":"Algebraic numbers","title":"root_of_unity","text":"root_of_unity(C::CalciumQQBarField, n::Int)\n\nReturn the root of unity e^2 pi i  n as an element of the field of algebraic numbers C.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#root_of_unity-Tuple{CalciumQQBarField, Int64, Int64}","page":"Algebraic numbers","title":"root_of_unity","text":"root_of_unity(C::CalciumQQBarField, n::Int, k::Int)\n\nReturn the root of unity e^2 pi i k  n as an element of the field of algebraic numbers C.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#isroot_of_unity-Tuple{qqbar}","page":"Algebraic numbers","title":"isroot_of_unity","text":"isroot_of_unity(a::qqbar)\n\nReturn whether the given algebraic number is a root of unity.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#root_of_unity_as_args-Tuple{qqbar}","page":"Algebraic numbers","title":"root_of_unity_as_args","text":"root_of_unity_as_args(a::qqbar)\n\nReturn a pair of integers (q, p) such that the given a equals e^2 pi i p  q. The denominator q will be minimal, with 0 le p  q. Throws if a is not a root of unity.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#exp_pi_i-Tuple{qqbar}","page":"Algebraic numbers","title":"exp_pi_i","text":"exp_pi_i(a::qqbar)\n\nReturn e^pi i a as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#log_pi_i-Tuple{qqbar}","page":"Algebraic numbers","title":"log_pi_i","text":"log_pi_i(a::qqbar)\n\nReturn log(a)  (pi i) as an algebraic number. Throws if this value is transcendental or undefined.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#sinpi-Tuple{qqbar}","page":"Algebraic numbers","title":"sinpi","text":"sinpi(a::qqbar)\n\nReturn sin(pi a) as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#cospi-Tuple{qqbar}","page":"Algebraic numbers","title":"cospi","text":"cospi(a::qqbar)\n\nReturn cos(pi a) as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#tanpi-Tuple{qqbar}","page":"Algebraic numbers","title":"tanpi","text":"tanpi(a::qqbar)\n\nReturn tan(pi a) as an algebraic number. Throws if this value is transcendental or undefined.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#asinpi-Tuple{qqbar}","page":"Algebraic numbers","title":"asinpi","text":"asinpi(a::qqbar)\n\nReturn operatornameasin(a)  pi as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#acospi-Tuple{qqbar}","page":"Algebraic numbers","title":"acospi","text":"acospi(a::qqbar)\n\nReturn operatornameacos(a)  pi as an algebraic number. Throws if this value is transcendental.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#atanpi-Tuple{qqbar}","page":"Algebraic numbers","title":"atanpi","text":"atanpi(a::qqbar)\n\nReturn operatornameatan(a)  pi as an algebraic number. Throws if this value is transcendental or undefined.\n\n\n\n","category":"method"},{"location":"Nemo/algebraic/#Guessing","page":"Algebraic numbers","title":"Guessing","text":"","category":"section"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Examples","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"An algebraic number can be recovered from a numerical value:","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> RR = ArbField(53); guess(QQBar, RR(\"1.41421356 +/- 1e-6\"), 2)\nRoot 1.41421 of x^2 - 2","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Warning: the input should be an enclosure. If you have a floating-point approximation, you should add an error estimate; otherwise, the only algebraic number that can be guessed is the binary floating-point number itself.","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"julia> RR = ArbField(128);\n\njulia> x = RR(0.1);       # note: 53-bit binary approximation of 1//10 without radius\n\njulia> guess(QQBar, x, 1)\nRoot 0.100000 of 36028797018963968x - 3602879701896397\n\njulia> guess(QQBar, x + RR(\"+/- 1e-10\"), 1)\nRoot 0.100000 of 10x - 1","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"Interface","category":"page"},{"location":"Nemo/algebraic/","page":"Algebraic numbers","title":"Algebraic numbers","text":"guess(R::CalciumQQBarField, x::arb, maxdeg::Int, maxbits::Int=0)\nguess(R::CalciumQQBarField, x::acb, maxdeg::Int, maxbits::Int=0)","category":"page"},{"location":"Nemo/algebraic/#guess","page":"Algebraic numbers","title":"guess","text":"guess(R::CalciumQQBarField, x::acb, maxdeg::Int, maxbits::Int=0)\n\nTry to reconstruct an algebraic number from a given numerical enclosure x. The algorithm looks for candidates up to degree maxdeg and with coefficients up to size maxbits (which defaults to the precision of x if not given). Throws if no suitable algebraic number can be found.\n\nGuessing typically requires high precision to succeed, and it does not make much sense to call this function with input precision smaller than O(maxdeg cdot maxbits). If this function succeeds, then the output is guaranteed to be contained in the enclosure x, but failure does not prove that such an algebric number with the specified parameters does not exist.\n\nThis function does a single iteration with the target parameters. For best performance, one should invoke this function repeatedly with successively larger parameters when the size of the intended solution is unknown or may be much smaller than a worst-case bound.\n\n\n\n","category":"function"},{"location":"Nemo/algebraic/#guess-2","page":"Algebraic numbers","title":"guess","text":"guess(R::CalciumQQBarField, x::acb, maxdeg::Int, maxbits::Int=0)\n\nTry to reconstruct an algebraic number from a given numerical enclosure x. The algorithm looks for candidates up to degree maxdeg and with coefficients up to size maxbits (which defaults to the precision of x if not given). Throws if no suitable algebraic number can be found.\n\nGuessing typically requires high precision to succeed, and it does not make much sense to call this function with input precision smaller than O(maxdeg cdot maxbits). If this function succeeds, then the output is guaranteed to be contained in the enclosure x, but failure does not prove that such an algebric number with the specified parameters does not exist.\n\nThis function does a single iteration with the target parameters. For best performance, one should invoke this function repeatedly with successively larger parameters when the size of the intended solution is unknown or may be much smaller than a worst-case bound.\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"Pages = [\"fans.md\"]","category":"page"},{"location":"PolyhedralGeometry/fans/#Polyhedral-Fans","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/#Introduction","page":"Polyhedral Fans","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers and other fields are not yet supported everywhere in the implementation.","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"A nonempty finite collection mathcalF of (polyhedral) cones in mathbbF^n, for n fixed, is a (polyhedral) fan if","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"the set mathcalF is closed with respect to taking faces and\nif CDinmathcalF then Ccap D is a face of both, C and D.","category":"page"},{"location":"PolyhedralGeometry/fans/#Construction","page":"Polyhedral Fans","title":"Construction","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"To construct a polyhedral fan, you must pass the rays of each cone in the fan, along with an IncidenceMatrix encoding which rays generate which cones.","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"PolyhedralFan(Rays::Union{Oscar.MatElem,AbstractMatrix}, Incidence::IncidenceMatrix)","category":"page"},{"location":"PolyhedralGeometry/fans/#PolyhedralFan-Tuple{Union{MatElem, AbstractMatrix{T} where T}, IncidenceMatrix}","page":"Polyhedral Fans","title":"PolyhedralFan","text":"PolyhedralFan{T}(Rays, Cones) where T<:scalar_types\n\nArguments\n\nR::Matrix: Rays generating the cones of the fan; encoded row-wise as representative vectors.\nCones::IncidenceMatrix: An incidence matrix; there is a 1 at position (i,j) if cone i has ray j as extremal ray, and 0 otherwise.\n\nA polyhedral fan formed from rays and cones made of these rays. The cones are given as an IncidenceMatrix, where the columns represent the rays and the rows represent the cones.\n\nExamples\n\nTo obtain the upper half-space of the plane:\n\njulia> R = [1 0; 1 1; 0 1; -1 0; 0 -1];\n\njulia> IM=IncidenceMatrix([[1,2],[2,3],[3,4],[4,5],[1,5]]);\n\njulia> PF=PolyhedralFan(R,IM)\nA polyhedral fan in ambient dimension 2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"normal_fan(P::Polyhedron{T}) where T<:scalar_types\nface_fan(P::Polyhedron{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/fans/#normal_fan-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Polyhedral Fans","title":"normal_fan","text":"normal_fan(P::Polyhedron)\n\nReturn the normal fan of P. The maximal cones of the normal fan of P are dual to the edge cones at the vertices of P.\n\nExamples\n\nThe rays of a normal fan of a cube point in every positive and negative unit direction.\n\njulia> C = cube(3);\n\njulia> NF = normal_fan(C)\nA polyhedral fan in ambient dimension 3\n\njulia> rays(NF)\n6-element SubObjectIterator{RayVector{fmpq}}:\n [1, 0, 0]\n [-1, 0, 0]\n [0, 1, 0]\n [0, -1, 0]\n [0, 0, 1]\n [0, 0, -1]\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#face_fan-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Polyhedral Fans","title":"face_fan","text":"face_fan(P::Polyhedron)\n\nReturn the face fan of P. The polytope P has to contain the origin, then the maximal cones of the face fan of P are the cones over the facets of P.\n\nExamples\n\nBy definition, this bounded polyhedron's number of facets equals the amount of maximal cones of its face fan.\n\njulia> C = cross(3);\n\njulia> FF = face_fan(C)\nA polyhedral fan in ambient dimension 3\n\njulia> n_maximal_cones(FF) == nfacets(C)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#Saving-and-loading","page":"Polyhedral Fans","title":"Saving and loading","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"Objects of type PolyhedralFan can be saved to a file and loaded from a file in the following way:","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"square = cube(2)\nfan = normal_fan(square)\nsave(fan, \"F.fan\")\nf = load(\"F.fan\")\ncollect(rays(f))","category":"page"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"The file is in JSON format and contains all previously gathered data belonging to the underlying polymake object. In particular, this file can now be read by both polymake and Oscar.","category":"page"},{"location":"PolyhedralGeometry/fans/#Auxiliary-functions","page":"Polyhedral Fans","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"ambient_dim(PF::PolyhedralFan)\ndim(PF::PolyhedralFan)\nf_vector(PF::PolyhedralFan)\niscomplete(PF::PolyhedralFan)\nispointed(PF::PolyhedralFan)\nisregular(PF::PolyhedralFan)\nissimplicial(PF::PolyhedralFan)\nissmooth(PF::PolyhedralFan{fmpq})\nlineality_dim(PF::PolyhedralFan)\nlineality_space(PF::PolyhedralFan{T}) where T<:scalar_types\nmaximal_cones(PF::PolyhedralFan{T}) where T<:scalar_types\ncones(PF::PolyhedralFan{T}, cone_dim::Int) where T<:scalar_types\nn_maximal_cones(PF::PolyhedralFan)\nnrays(PF::PolyhedralFan)\nrays(PF::PolyhedralFan)\nprimitive_collections(PF::PolyhedralFan)\nstarsubdivision(PF::PolyhedralFan{T}, n::Int) where T<:scalar_types\n*(PF1::PolyhedralFan, PF2::PolyhedralFan)","category":"page"},{"location":"PolyhedralGeometry/fans/#ambient_dim-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"ambient_dim","text":"ambient_dim(PF::PolyhedralFan)\n\nReturn the ambient dimension PF, which is the dimension of the embedding space.\n\nThis is equal to the dimension of the fan if and only if the fan is full-dimensional.\n\nExamples\n\nThe normal fan of the 4-cube is embedded in the same ambient space.\n\njulia> ambient_dim(normal_fan(cube(4)))\n4\n\n\n\nambient_dim(T::TropicalVariety{M, EMB})\nambient_dim(T::TropicalCurve{M, EMB})\nambient_dim(T::TropicalHypersurface{M, EMB})\nambient_dim(T::TropicalLinearSpace{M, EMB})\n\nReturn the ambient dimension of T if it is embedded. Otherwise an error is thrown.\n\nExamples\n\nA tropical hypersurface in mathbbR^n is of ambient dimension n\n\njulia> RR = TropicalSemiring(min);\n\njulia> S,(x,y) = RR[\"x\",\"y\"];\n\njulia> f = x+y+1;\n\njulia> tropicalLine = TropicalHypersurface(f);\n\njulia> ambient_dim(tropicalLine)\n2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#dim-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"dim","text":"dim(PF::PolyhedralFan)\n\nReturn the dimension of PF.\n\nExamples\n\nThis fan in the plane contains a 2-dimensional cone and is thus 2-dimensional itself.\n\njulia> PF = PolyhedralFan([1 0; 0 1; -1 -1], IncidenceMatrix([[1, 2], [3]]));\n\njulia> dim(PF)\n2\n\n\n\ndim(T::TropicalVariety{M, EMB})\ndim(T::TropicalCurve{M, EMB})\ndim(T::TropicalHypersurface{M, EMB})\ndim(T::TropicalLinearSpace{M, EMB})\n\nReturn the dimension of T.\n\nExamples\n\nA tropical hypersurface in mathbbR^n is always of dimension n-1\n\njulia> RR = TropicalSemiring(min);\n\njulia> S,(x,y) = RR[\"x\",\"y\"];\n\njulia> f = x+y+1;\n\njulia> tropicalLine = TropicalHypersurface(f);\n\njulia> dim(tropicalLine)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#f_vector-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"f_vector","text":"f_vector(PF::PolyhedralFan)\n\nCompute the vector (f₁f₂f_dim(PF)-1)` where f_i is the number of faces of PF of dimension i.\n\nExamples\n\nThe f-vector of the normal fan of a polytope is the reverse of the f-vector of the polytope.\n\njulia> c = cube(3)\nA polyhedron in ambient dimension 3\n\njulia> f_vector(c)\n3-element Vector{fmpz}:\n 8\n 12\n 6\n\n\njulia> nfc = normal_fan(c)\nA polyhedral fan in ambient dimension 3\n\njulia> f_vector(nfc)\n3-element Vector{fmpz}:\n 6\n 12\n 8\n\n\n\nf_vector(T::TropicalVariety{M, EMB})\nf_vector(T::TropicalCurve{M, EMB})\nf_vector(T::TropicalHypersurface{M, EMB})\nf_vector(T::TropicalLinearSpace{M, EMB})\n\nReturn the f-Vector of T.\n\nExamples\n\nA tropical hypersurface in mathbbR^n is of lineality dimension n\n\njulia> RR = TropicalSemiring(min);\n\njulia> S,(x,y) = RR[\"x\",\"y\"];\n\njulia> f = x+y+1;\n\njulia> tropicalLine = TropicalHypersurface(f);\n\njulia> f_vector(tropicalLine)\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#iscomplete-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"iscomplete","text":"iscomplete(PF::PolyhedralFan)\n\nDetermine whether PF is complete, i.e. its support, the set-theoretic union of its cones, covers the whole space.\n\nExamples\n\nNormal fans of polytopes are complete.\n\njulia> iscomplete(normal_fan(cube(3)))\ntrue\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#ispointed-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"ispointed","text":"ispointed(PF::PolyhedralFan)\n\nDetermine whether PF is pointed, i.e. all its cones are pointed.\n\nExamples\n\nThe normal fan of a non-fulldimensional polytope is not pointed.\n\njulia> C = convex_hull([0 0; 1 0])\nA polyhedron in ambient dimension 2\n\njulia> isfulldimensional(C)\nfalse\n\njulia> nf = normal_fan(C)\nA polyhedral fan in ambient dimension 2\n\njulia> ispointed(nf)\nfalse\n\njulia> lineality_dim(nf)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#isregular-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"isregular","text":"isregular(PF::PolyhedralFan)\n\nDetermine whether PF is regular, i.e. the normal fan of a polytope.\n\nExamples\n\nThis fan is not complete and thus not regular.\n\njulia> PF = PolyhedralFan([1 0; 0 1; -1 -1], IncidenceMatrix([[1, 2], [3]]));\n\njulia> isregular(PF)\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#issimplicial-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"issimplicial","text":"issimplicial(PF::PolyhedralFan)\n\nDetermine whether PF is simplicial, i.e. every cone should be generated by a basis of the ambient space.\n\nExamples\n\nThe normal_fan of the cube is simplicial, while the face_fan is not.\n\njulia> issimplicial(normal_fan(cube(3)))\ntrue\n\njulia> issimplicial(face_fan(cube(3)))\nfalse\n\n\n\nissimplicial(T::TropicalVariety{M, EMB})\nissimplicial(T::TropicalCurve{M, EMB})\nissimplicial(T::TropicalHypersurface{M, EMB})\nissimplicial(T::TropicalLinearSpace{M, EMB})\n\nReturn true if T is a simplicial polyhedral complex, false otherwise.\n\nExamples\n\nA tropical hypersurface in mathbbR^n is of lineality dimension n\n\njulia> RR = TropicalSemiring(min);\n\njulia> S,(x,y) = RR[\"x\",\"y\"];\n\njulia> f = x+y+1;\n\njulia> tropicalLine = TropicalHypersurface(f);\n\njulia> issimplicial(tropicalLine)\ntrue\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#issmooth-Tuple{PolyhedralFan{fmpq}}","page":"Polyhedral Fans","title":"issmooth","text":"issmooth(PF::PolyhedralFan{fmpq})\n\nDetermine whether PF is smooth.\n\nExamples\n\nEven though the cones of this fan cover the positive orthant together, one of these und thus the whole fan is not smooth.\n\njulia> PF = PolyhedralFan([0 1; 2 1; 1 0], IncidenceMatrix([[1, 2], [2, 3]]));\n\njulia> issmooth(PF)\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#lineality_dim-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"lineality_dim","text":"lineality_dim(PF::PolyhedralFan)\n\nReturn the dimension of the lineality space of the polyhedral fan PF, i.e. the dimension of the largest linear subspace.\n\nExamples\n\nThe dimension of the lineality space is zero if and only if the fan is pointed.\n\njulia> C = convex_hull([0 0; 1 0])\nA polyhedron in ambient dimension 2\n\njulia> isfulldimensional(C)\nfalse\n\njulia> nf = normal_fan(C)\nA polyhedral fan in ambient dimension 2\n\njulia> ispointed(nf)\nfalse\n\njulia> lineality_dim(nf)\n1\n\n\n\nlineality_dim(T::TropicalVariety{M, EMB})\nlineality_dim(T::TropicalCurve{M, EMB})\nlineality_dim(T::TropicalHypersurface{M, EMB})\nlineality_dim(T::TropicalLinearSpace{M, EMB})\n\nReturn the dimension of the lineality space of T if it is embedded. Otherwise an error is thrown.\n\nExamples\n\nA tropical hypersurface in mathbbR^n is of lineality dimension n\n\njulia> RR = TropicalSemiring(min);\n\njulia> S,(x,y) = RR[\"x\",\"y\"];\n\njulia> f = x+y;\n\njulia> tropicalAndAffineLine = TropicalHypersurface(f);\n\njulia> lineality_dim(tropicalAndAffineLine)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#lineality_space-Union{Tuple{PolyhedralFan{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Polyhedral Fans","title":"lineality_space","text":"lineality_space(PF::PolyhedralFan)\n\nReturn a non-redundant matrix whose rows are generators of the lineality space of PF.\n\nExamples\n\nThis fan consists of two cones, one containing all the points with y  0 and one containing all the points with y  0. The fan's lineality is the common lineality of these two cones, i.e. in x-direction.\n\njulia> PF = PolyhedralFan([1 0; 0 1; -1 0; 0 -1], IncidenceMatrix([[1, 2, 3], [3, 4, 1]]))\nA polyhedral fan in ambient dimension 2\n\njulia> lineality_space(PF)\n1-element SubObjectIterator{RayVector{fmpq}}:\n [1, 0]\n\n\n\nlineality_space(T::TropicalVariety{M, EMB})\nlineality_space(T::TropicalCurve{M, EMB})\nlineality_space(T::TropicalHypersurface{M, EMB})\nlineality_space(T::TropicalLinearSpace{M, EMB})\n\nReturn the lineality space of T if it is embedded. Otherwise an error is thrown.\n\nExamples\n\nA tropical hypersurface in mathbbR^n is of lineality spaceension n\n\njulia> RR = TropicalSemiring(min);\n\njulia> S,(x,y) = RR[\"x\",\"y\"];\n\njulia> f = x+y;\n\njulia> tropicalAndAffineLine = TropicalHypersurface(f);\n\njulia> lineality_space(tropicalAndAffineLine)\n1-element SubObjectIterator{RayVector{fmpq}}:\n [-1, -1]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#maximal_cones-Union{Tuple{PolyhedralFan{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Polyhedral Fans","title":"maximal_cones","text":"maximal_cones(PF::PolyhedralFan)\n\nReturn the maximal cones of PF.\n\nExamples\n\nHere we ask for the the number of rays for each maximal cone of the face fan of the 3-cube and use that maximal_cones returns an iterator.\n\njulia> PF = face_fan(cube(3));\n\njulia> for c in maximal_cones(PF)\n       println(nrays(c))\n       end\n4\n4\n4\n4\n4\n4\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#cones-Union{Tuple{T}, Tuple{PolyhedralFan{T}, Int64}} where T<:Union{Float64, fmpq, nf_elem}","page":"Polyhedral Fans","title":"cones","text":"cones(PF::PolyhedralFan, cone_dim::Int)\n\nReturn an iterator over the cones of PF of dimension cone_dim.\n\nExamples\n\nThe 12 edges of the 3-cube correspond to the 2-dimensional cones of its face fan:\n\njulia> PF = face_fan(cube(3));\n\njulia> cones(PF, 2)\n12-element SubObjectIterator{Cone{fmpq}}:\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n A polyhedral cone in ambient dimension 3\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#n_maximal_cones-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"n_maximal_cones","text":"n_maximal_cones(PF::PolyhedralFan)\n\nReturn the number of maximal cones of PF.\n\nExamples\n\nThe cones given in this construction are non-redundant. Thus there are two maximal cones.\n\njulia> PF = PolyhedralFan([1 0; 0 1; -1 -1], IncidenceMatrix([[1, 2], [3]]));\n\njulia> n_maximal_cones(PF)\n2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#nrays-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"nrays","text":"nrays(PF::PolyhedralFan)\n\nReturn the number of rays of PF.\n\nExamples\n\nThe 3-cube has 8 vertices. Accordingly, its face fan has 8 rays.\n\njulia> nrays(face_fan(cube(3)))\n8\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#rays-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"rays","text":"rays(as::Type{T} = RayVector, P::Polyhedron)\n\nReturn a minimal set of generators of the cone of unbounded directions of P (i.e. its rays) in the format defined by as.\n\nOptional arguments for as include\n\nRayVector.\n\nExamples\n\nWe can verify that the positive orthant of the plane is generated by the two rays in positive unit direction:\n\njulia> PO = convex_hull([0 0], [1 0; 0 1]);\n\njulia> rays(RayVector, PO)\n2-element SubObjectIterator{RayVector{fmpq}}:\n [1, 0]\n [0, 1]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#primitive_collections-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"primitive_collections","text":"primitive_collections(PF::PolyhedralFan)\n\nReturn the primitive collections of a polyhedral fan.\n\nExamples\n\njulia> primitive_collections(normal_fan(simplex(3)))\n1-element Vector{Set{Int64}}:\n Set([4, 2, 3, 1])\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#starsubdivision-Union{Tuple{T}, Tuple{PolyhedralFan{T}, Int64}} where T<:Union{Float64, fmpq, nf_elem}","page":"Polyhedral Fans","title":"starsubdivision","text":"starsubdivision(PF::PolyhedralFan, n::Int)\n\nReturn the star subdivision of a polyhedral fan at its n-th maximal torus orbit.\n\nExamples\n\njulia> star = starsubdivision(normal_fan(simplex(3)), 1)\nA polyhedral fan in ambient dimension 3\n\njulia> rays(star)\n5-element SubObjectIterator{RayVector{fmpq}}:\n [0, 1, 0]\n [0, 0, 1]\n [-1, -1, -1]\n [1, 0, 0]\n [1, 1, 1]\n\njulia> ray_indices(maximal_cones(star))\n6×5 IncidenceMatrix\n[1, 2, 3]\n[2, 3, 4]\n[1, 3, 4]\n[2, 4, 5]\n[1, 2, 5]\n[1, 4, 5]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#*-Tuple{PolyhedralFan, PolyhedralFan}","page":"Polyhedral Fans","title":"*","text":"*(PF1::PolyhedralFan, PF2::PolyhedralFan)\n\nReturn the Cartesian/direct product of two polyhedral fans.\n\nExamples\n\njulia> normal_fan(simplex(2))*normal_fan(simplex(3))\nA polyhedral fan in ambient dimension 5\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/fans/#Visualization","page":"Polyhedral Fans","title":"Visualization","text":"","category":"section"},{"location":"PolyhedralGeometry/fans/","page":"Polyhedral Fans","title":"Polyhedral Fans","text":"visualize(PF::PolyhedralFan)","category":"page"},{"location":"PolyhedralGeometry/fans/#visualize-Tuple{PolyhedralFan}","page":"Polyhedral Fans","title":"visualize","text":"visualize(PF::PolyhedralFan)\n\nVisualize a polyhedral fan.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = :(using AbstractAlgebra)","category":"page"},{"location":"AbstractAlgebra/euclidean_interface/#Euclidean-Ring-Interface","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"","category":"section"},{"location":"AbstractAlgebra/euclidean_interface/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"If a ring provides a meaningful Euclidean structure such that a useful Euclidean remainder can be computed practically, various additional functionality is provided by AbstractAlgebra.jl for those rings. This functionality depends on the following functions existing. An implementation must provide divrem, and the remaining are optional as generic fallbacks exist.","category":"page"},{"location":"AbstractAlgebra/euclidean_interface/","page":"Euclidean Ring Interface","title":"Euclidean Ring Interface","text":"divrem\nmod(f::T, g::T) where T <: RingElem\nBase.div(f::T, g::T) where T <: RingElem\nmulmod(f::T, g::T, m::T) where T <: RingElem\npowermod(f::T, e::Int, m::T) where T <: RingElem\ninvmod(f::T, m::T) where T <: RingElem\ndivides(f::T, g::T) where T <: RingElem\nremove(f::T, p::T) where T <: RingElem\nvaluation(f::T, p::T) where T <: RingElem\ngcd(f::T, g::T) where T <: RingElem\nlcm(f::T, g::T) where T <: RingElem\ngcdx(f::T, g::T) where T <: RingElem\ngcdinv(f::T, g::T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/euclidean_interface/#divrem","page":"Euclidean Ring Interface","title":"divrem","text":"divrem(f::T, g::T) where T <: RingElem\n\nReturn a pair q, r consisting of the Euclidean quotient and remainder of f by g. A DivideError should be thrown if g is zero.\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/euclidean_interface/#mod-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"mod","text":"mod(f::T, g::T) where T <: RingElem\n\nReturn the Euclidean remainder of f by g. A DivideError should be thrown if g is zero.\n\nnote: Note\nFor best compatibility with the internal assumptions made by AbstractAlgebra, the Euclidean remainder function should provide unique representatives for the residue classes; the mod function should satisfymod(a_1, b) = mod(a_2, b) if and only if b divides a_1 - a_2, and\nmod(0, b) = 0.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#div-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"div","text":"div(f::T, g::T) where T <: RingElem\n\nReturn the Euclidean quotient of f by g. A DivideError should be thrown if g is zero.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#mulmod-Union{Tuple{T}, Tuple{T, T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"mulmod","text":"mulmod(f::T, g::T, m::T) where T <: RingElem\n\nReturn mod(f*g, m) but possibly computed more efficiently.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#powermod-Union{Tuple{T}, Tuple{T, Int64, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"powermod","text":"powermod(f::T, e::Int, m::T) where T <: RingElem\n\nReturn mod(f^e, m) but possibly computed more efficiently.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#invmod-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"invmod","text":"invmod(f::T, m::T) where T <: RingElem\n\nReturn an inverse of f modulo m, meaning that isone(mod(invmod(f,m)*f,m)) returns true.\n\nIf such an inverse doesn't exist, a NotInvertibleError should be thrown.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#divides-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"divides","text":"divides(f::T, g::T) where T <: RingElem\n\nReturn a pair, flag, q, where flag is set to true if g divides f, in which case q is set to the quotient, or flag is set to false and q is set to zero(f).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#remove-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"remove","text":"remove(f::T, p::T) where T <: RingElem\n\nReturn a pair v, q where p^v is the highest power of p dividing f and q is the cofactor after f is divided by this power.\n\nSee also valuation, which only returns the valuation.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#valuation-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"valuation","text":"valuation(f::T, p::T) where T <: RingElem\n\nReturn v where p^v is the highest power of p dividing f.\n\nSee also remove.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#gcd-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"gcd","text":"gcd(f::T, g::T) where T <: RingElem\n\nReturn a greatest common divisor of f and g, i.e., an element d which is a common divisor of f and g, and with the property that any other common divisor of f and g divides d.\n\nnote: Note\nFor best compatibility with the internal assumptions made by AbstractAlgebra, the return is expected to be unit-normalized in such a way that if the return is a unit, that unit should be one.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#lcm-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"lcm","text":"lcm(f::T, g::T) where T <: RingElem\n\nReturn a least common multiple of f and g, i.e., an element d which is a common multiple of f and g, and with the property that any other common multiple of f and g is a multiple of d.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#gcdx-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"gcdx","text":"gcdx(f::T, g::T) where T <: RingElem\n\nReturn a triple d, s, t such that d = gcd(f g) and d = sf + tg, with s loosely reduced modulo gd and t loosely reduced modulo fd.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/euclidean_interface/#gcdinv-Union{Tuple{T}, Tuple{T, T}} where T<:RingElem","page":"Euclidean Ring Interface","title":"gcdinv","text":"gcdinv(f::T, g::T) where T <: RingElem\n\nReturn a tuple d, s such that d = gcd(f g) and s = (fd)^-1 pmodgd. Note that d = 1 iff f is invertible modulo g, in which case s = f^-1 pmodg.\n\n\n\n","category":"method"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/developer/topics/#Specific-topics","page":"Specific topics","title":"Specific topics","text":"","category":"section"},{"location":"Nemo/developer/topics/#Julia-arithmetic","page":"Specific topics","title":"Julia arithmetic","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"At the console, Julia arithmetic is often defined in a way that a numerical person would expect. For example, 3/1 returns a floating point number 3.0, sqrt(4) returns the floating point number 2.0 and exp(0) returns the floating point number 1.0.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In each case the ring is changed from the input to the output of the function. Whilst this is often what one expects to happen in a computer algebra system, these are not the definitions one would want for algebraic operations.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In this section we describe the alternatives we have implemented to allow algebraic computations, particularly for rings and fields.","category":"page"},{"location":"Nemo/developer/topics/#divexact-and-divides","page":"Specific topics","title":"divexact and divides","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Nemo implements numerous kinds of division:","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"floating point division using the / operator as per Julia\nexact division in a ring using divexact and divides\nquotient field element construction using // as per Julia\nEuclidean division using div, rem, divrem, mod and %","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"The expression divexact(a, b) for a and b in a ring R returns a value c in R such that a = bc. If such an element of R does not exist, an exception is raised.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"To instead test whether such an element exists, divides(a, b) returns a tuple (flag, q) where flag is a boolean saying whether such an exact quotient exists in the ring and if so q is such a quotient.","category":"page"},{"location":"Nemo/developer/topics/#Euclidean-division","page":"Specific topics","title":"Euclidean division","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Nemo must provide Euclidean division, i.e. given a and b in a Euclidean ring R it must be able to find q and r such that a = bq + r with r smaller than a with respect to some fixed Euclidean function on R. There are some restrictions imposed by Julia however.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Firstly, % is a constant alias of rem in Julia, so these are not actually two independent functions but the same function.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Julia defines div, rem and divrem for integers as a triple of functions that return Euclidean quotient and remainder, where the remainder has the same sign as the dividend, e.g. rem(1, 3) == 1 but rem(-2, 3) == -2. In other words, this triple of functions gives Euclidean division, but without a consistent set of representatives.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"When using Nemo at the console (or indeed inside any other package without importing the internal Nemo definitions) div, rem and divrem return the same values as Julia and these functions follows the Julia convention of making the sign of the remainder the same as the dividend over ZZ, e.g. rem(ZZ(1), ZZ(3)) == 1 but rem(ZZ(-2), ZZ(3)) == -2.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Internally to Nemo however, this is not convenient. For example, Hermite normal form over ZZ will only return a unique result if there is a consistent choice of representatives for the Euclidean division. This applies to the generic HNF code in AbstractAlgebra, but similar problems exist for the generic finitely presented module code in AbstractAlgebra, even when used over Nemo integers. Thus the Julia definition of rem will not suffice.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Furthermore, as Nemo wraps Flint, it is convenient that Euclidean division inside Nemo should operate the way Flint operates. This is critical if for example one wants the result of a Hermite normal form coming from Flint to be reduced using the same definition of Euclidean remainder as used elsewhere throughout the Nemo module and to return the same answers as the generic HNF code in AbstractAlgebra for example.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In particular, Flint defines Euclidean remainder over the integers in line with the Julia function mod, namely by returning the smallest remainder with the same sign as the divisor, i.e. mod(1, 3) == 1 but mod(1, -3) == -2.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Therefore internally, Nemo chooses div, mod and divrem to be a consistent triple of functions for Euclidean division, with mod defined as per Julia. Thus in particular, div and divrem behave differently to Julia inside of Nemo itself, viz. Nemo.divrem(-1, 3) == (-1, 2).","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"The same definitions for div, mod and divrem are used internally to AbstractAlgebra as well, even for Julia integers, so that AbstractAlgebra and Nemo are both consistent internally. However, both AbstractAlgebra and Nemo export definitions in line with Julia so that behaviour at the console is consistent.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"The Nemo developers have given considerable thought to this compromise and the current situation has evolved over many iterations to the current state. We do not consider this to be a situation that needs 'fixing', though we are acutely aware that many tickets will be opened complaining about some inconsistency.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"When reflecting on the choice we have made, one must consider the following:","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Nemo must internally behave as Flint does for consistency\nThere are also functions such as powmod, invmod that reduce as per mod\nHNF requires a consistent set of representatives for uniqueness over ZZ","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Also note that Julia's rem does not provide symmetric mod, a misconception that often arises. The issues here are independent of the decision to use positive remainder (for positive modulus) in Flint, rather than symmetric mod.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"We are aware that the conventions we have chosen have inconsistencies with Julia and do not have the nice property that div, rem and divrem are a triple of Euclidean functions inside Nemo. However, we are sure that the convention we have chosen is one of only two sensible possibilities, and switching to the other convention (apart from being a huge amount of effort) would only succeed in replacing one kind of inconsistency with another.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"As a consequence of these choices, div, mod and divrem are a triple of functions for all Euclidean division across Nemo, not just for the integers. As generic code must use a consistent set of functions, we ask that developers respect this choice by using these three functions in all generic code. The functions rem and % should only be used for Julia integers, and only when one specifically wants the Julia definition.","category":"page"},{"location":"Nemo/developer/topics/#sqrt,-inv-and-exp","page":"Specific topics","title":"sqrt, inv and exp","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"As mentioned above, Julia does not perform computations within a given ring, but often returns a numerical result when given an exact input.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Whilst this is often what a user expects, it makes operations such as power series square root, inversion or exponentiation more tricky over an exact ring.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Therefore, AbstractAlgebra defines sqrt, inv and exp internally in a strictly algebraic way, returning a result only if it exists in the ring of the input and otherwise raising an exception.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"For example, AbstractAlgebra.sqrt(4) == 2, AbstractAlgebra.inv(-1) == -1 and AbstractAlgebra.exp(0) == 1.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Naturally these definitions are not so terribly useful to a user and are only needed for internal consistency. Therefore, of course these definitions are not exported by AbstractAlgebra so that the behaviour at the console is not affected by these definitions.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"There is currently some inconsistency in that Nemo follows the Julia numerical definitions internally rather than following the algebraic definitions provided internally in AbstractAlgebra. This may or may not change in future.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"It is worth recalling that Julia provides isqrt for integer square root. This is not sufficient to solve our problem as we require square root for all rings, not just integers. We don't feel that developers will want to type isqrt rather than sqrt internally for all rings.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"A number of changes are expected to be made with regard to the behaviour of root taking and division functions, including the ability to specify high performance alternatives that do not check the exactness of the computation. These changes are being discussed on the Nemo ticket https://github.com/Nemocas/Nemo.jl/issues/862 In particular, the table given there by thofma represents the current consensus on the changes that will be made in the future.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that many of the above issues with exact computations in rings exist for all the Julia transcendental functions, sin, cos, log, etc., of which there are many. If we ever add some kind of generic power series functions for these, we may extend the internal definitions to include exact algebraic versions of all these functions. At least for now this is not a pressing issue.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"The way that AbstractAlgebra deals with functions which must have a different definition inside the module than what it exports is as follows. Firstly, we do not import the functions from Base or export the functions at all. Internally we make our definitions as we want them, but then we overload the Base version explicitly to do what the console version of the function should do. This is done by explicitly defining Base.sqrt(::fmpz) for example without explicitly importing sqrt from Base, etc.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the Generic module discussed below, we import the definitions from AbstractAlgebra rather than Base.","category":"page"},{"location":"Nemo/developer/topics/#Determinant","page":"Specific topics","title":"Determinant","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Another function which Nemo handles differently to Julia is det for determinant of matrices. If the input is an integer matrix, Nemo outputs an integer rather than a floating point number for the determinant.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"However, this is not such an acute problem as Julia's det has now been placed in LinearAlgebra rather than Base. Moreover, Nemo has its own matrices and so does not conflict with the definition of det for Julia matrices.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"It is important for developers to understand this difference however. It is not generally wise to use the Julia linear algebra functionality on the Julia matrices underlying generic Nemo matrices for this reason.","category":"page"},{"location":"Nemo/developer/topics/#The-Generic-submodule","page":"Specific topics","title":"The Generic submodule","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In AbstractAlgebra we define a submodule called Generic. The purpose of this module is to allow generic constructions over a given base ring. For example in Nemo, R, x = Generic.PolynomialRing(ZZ, \"x\") will construct a generic polynomial ring over Nemo integers instead of constructing a Flint polynomial ring.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In other words x will have the type Generic.Poly{fmpz} instead of the usual fmpz_poly.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"The ability to construct generic polynomials and matrices and the like is useful for test code and for tracking down bugs in basic arithmetic. It is also useful for performance comparison of arithmetic defined for generic ring constructions vs the specialised implementations provided by C libraries like Flint.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Whilst most developers will not need to use the Generic module specifically, unless they have such needs, all Nemo developers need to understand how to define new generic ring constructions and functions for them. They also need to understand some subtleties that arise because of this mechanism.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Firstly, a generic construction like PolynomialRing must be defined inside the Generic submodule of AbstractAlgebra. All files inside the src/generic directory of AbstractAlgebra exist for this purpose. However, exporting from that submodule will not export the functionality to the Nemo user.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"To do this, one must add a function PolynomialRing for example, in src/Poly.jl, say, which calls Generic.PolynomialRing. Then one needs to export PolynomialRing from AbstractAlgebra (also in that file).","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Similarly, all functions provided for generic polynomial rings are not automatically available, even when exported from the Generic submodule. Two additional things are required, namely an import from Generic into AbstractAlgebra and then an export from AbstractAlgebra to the user.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"An exception to this is if there is a function with the same name in AbstractAlgebra (i.e. in the top level src directory). In this case it is sufficient to simply import that function into Generic in the file src/Generic.jl.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the former case, two large lists exist in src/AbstractAlgebra.jl with these imports and exports. These are kept in alphabetical order to prevent duplicate imports/exports being added over time.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"If one wishes to extend a definition provided by Base, one can simply overload Base.blah inside the Generic submodule directly. Exceptions to this include the div, mod, divrem, sqrt, inv and exp functions mentioned above.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"For AbstractAlgebra types, one still defines these exceptions blah by overloading Base.blah directly inside Generic. However, for the versions that would conflict with the Julia definition (e.g. the definition for Int), we instead define AbstractAlgebra.blah for that specific type and a fallback AbstractAlgebra.blah(a) = Base.blah(a) which calls the Base version of the function for all other types. Of course we do not export blah from AbstractAlgebra.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In order to make the AbstractAlgebra version available in Generic (rather than the Base version), we do not import blah from Base inside Generic, but instead import it from AbstractAlgebra. One can see these imports for the exceptional functions blah in the file src/Generic.jl.","category":"page"},{"location":"Nemo/developer/topics/#Unsafe-operations-and-aliasing","page":"Specific topics","title":"Unsafe operations and aliasing","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"As with most object oriented languages that overload arithmetic operators, Julia creates new objects when doing an arithmetic operation. For example, BigInt(3) + BigInt(5) creates a new BigInt object to return the value BigInt(8). This can be problematic when accumulating many such operations in a single coefficient of a polynomial or entry of a matrix due to the large number of temporary objects the garbage collector must allocate and clean up.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"To speed up such accumulations, Nemo provides numerous unsafe operators, which mutate the existing elements of the polynomial, matrix, etc. These include functions such as add!, addeq!, mul!, zero! and addmul!.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"These functions take as their first argument the object that should be modified with the return value.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that functions such as sub!, submul! and subeq! are not in the official interface and not provided consistently, thus generic code cannot rely on them existing. So far it has always been the case that when doing accumulation where subtraction is needed rather than addition, that a single negation can be performed outside the accumulation loop and then the additive versions of the functions can be called inside the loop where the performance matters.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"If we encounter cases in future where this is not the case, it may be necessary to add the versions that do subtraction to the interface. However, this can only be done if all rings in Nemo support it. One cannot define a fallback which turns a subtraction into a negation and an addition, as then the old performance characteristics of a new object being created per operation will result, meaning that the developer will not be able to reason about the likely performance of unsafe operators.","category":"page"},{"location":"Nemo/developer/topics/#Interaction-of-unsafe-operators-and-immutable-types","page":"Specific topics","title":"Interaction of unsafe operators and immutable types","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Because not all objects in Nemo are mutable, the unsafe operators somehow have to support immutable objects. This is done by also returning the \"modified\" return value from the unsafe operators. Naturally, this return value is not a mutated version of the original value, as that is not possible. However, it does allow the unsafe operators to accept immutable values in their first argument. Instead of modifying this value, the old value is replaced with the return value of the unsafe operator.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In order to make this work correctly, every single call to an unsafe operator must assign the return value to the original location. This requires discipline on the part of the developer using unsafe operators.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"For example, to set the existing value a to a + b one must write","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"a = addeq!(a, b)","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"i.e. one must have an explicit assignment to the left of the addeq! call and indeed all the unsafe operator calls.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the case of a mutable type, addeq! will simply modify the original a. The modified object will be returned and assigned to the exact same variable, which has no effect.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the case of an immutable type, addeq! does not modify the original object a as this is impossible, but it still returns the new value and assigns it to a which is what one wants.","category":"page"},{"location":"Nemo/developer/topics/#Aliasing-rules-and-mutation","page":"Specific topics","title":"Aliasing rules and mutation","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"One must be incredibly careful when mutating an existing value that one owns the value. If the user passes an object to a generic function for example and it changes the object without the user knowing, this can result in incorrect results in user code due to the value of their objects changing from under them.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In the first instance, functions should never modify their inputs. But further problems can also occur if the output of an unsafe operator happens to alias one of the other inputs. Such cases need to be handled exceptionally carefully.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"A second issue arises as Nemo is based on Flint, which has its own aliasing rules which are distinct from the default expectation in Julia. This leads to some interesting corner cases.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In particularly, Flint always allows aliasing of inputs and outputs in its polynomial functions but expects matrix functions to have output matrices that are distinct from their inputs, except in a handful of functions that are specially documented to be inplace operations.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Moreover, when assigning an element to a coefficient of a polynomial or entry of a matrix Flint always makes a copy of the element being assigned to that location. In Julia however, if one assigns an element to some index of an array, the existing object at that location is replaced with the new object. This means that inplace modification of Julia array elements is not safe as it would modify the original object that was assigned to that location, whereas in Flint inplace modification is highly desirable for performance reasons and is completely safe due to the fact that a copy was made when the value was assigned to that location.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"We have developed over a period of many years a set of rules that maximise the performance benefit we get from our unsafe operators, whilst keeping the burden imposed on the programmer to a minimum. It has been a very difficult task to arrive at the set of rules we have whilst respecting correctness of our code, and it would be extremely hard to change any of them.","category":"page"},{"location":"Nemo/developer/topics/#Arithmetic-operations-return-a-new-object","page":"Specific topics","title":"Arithmetic operations return a new object","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In order to make it easy for the Nemo developer to create a completely new object when one is needed, e.g. for accumulating values using unsafe operators, we developed the following rules.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Whenever an arithmetic operation is used, i.e. +, -, *, unary minus and ^, Nemo always returns a new object, in line with Julia. Naturally, deepcopy also makes a copy of an object which can be used in unsafe functions.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that if R is a type and an element a of that type is passed to it, e.g. R(a) then, the Julia convention is that the original object a will be returned rather than a copy of a. This convention ensures there is not an additional cost when coercing values that are already of the right type, e.g in generic code where coercion may or may not be needed depending on the type.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"We extend this convention to parent objects R and elements a of that parent. In particular, R(a) cannot be used to make a copy of a for use in an unsafe function if R is the parent of a.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"All other functions may also return the input object if they wish. In other words, the return value of all other functions is not suitable for use in an unsafe function. Only return values of arithmetic operations and deepcopy or objects freshly created using inner constructors will be suitable for such use.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"This convention has been chosen to maximise performance of Nemo. Low level operations (where performance matters) make a new object, even if the result is the same arithmetically as one of the inputs. But higher level functions will not necessarily make a new object, meaning that they cannot be used with unsafe functions.","category":"page"},{"location":"Nemo/developer/topics/#Aliasing-rules","page":"Specific topics","title":"Aliasing rules","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"We now summarise the aliasing rules used by Nemo and AbstractAlgebra. We are relatively confident by now that following these rules will result in correct code given the constraints mentioned above.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"matrices are viewed as containers which may contain elements that alias one another. Other objects, e.g. polynomials, series, etc., are constructed from objects that do not alias one another, even in part\nstandard unsafe operators, addeq!, mul!, addmul!, zero!, add! which mutate their outputs are allow to be used iff that output is entirely under the control of the caller, i.e. it was created for the purpose of accumulation, but otherwise must not be used\nall arithmetic functions i.e. unary minus, +, -, *, ^, and deepcopy must return new objects and cannot return one of their inputs\nall other functions are allowed to return their inputs as outputs\nmatrix functions with an exclamation mark should not mutate the objects that occur as entries of the output matrix, though should be allowed to arbitrarily replace/swap the entries that appear in the matrix. In other words, these functions should be interpreted as inplace operations, rather than operations that are allowed to mutate the actual entries themselves\nR(a) where R is the parent of a, always just returns a and not a copy\nsetcoeff! and setindex! and getcoeff and getindex should not make copies. Note that this implies that setcoeff! should not be passed an element that aliases another somewhere else, even in part\nConstructors for polynomials, series and similar ring element objects (that are not matrices) that take an array as input, must ensure that the coefficients being placed into the object do not alias, even in part","category":"page"},{"location":"Nemo/developer/topics/#The-SparsePoly-module","page":"Specific topics","title":"The SparsePoly module","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"The SparsePoly module in AbstractAlgebra is a generic module for sparse univariate polynomials over a given base ring.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"This module is used internally, e.g. in the generic multivariate gcd code, however it is not particularly suitable for general use.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Firstly, whilst the representation is sparse (recursive) the algorithms used generally are not. This is because the amount of time taken by the Jit in Julia is simply too large (upwards of 6s for the first multivariate gcd).","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Secondly, the order of terms in that representation is not the one which a developer would expect for a sparse univariate format.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"If the Julia Jit is ever made orders of magnitude faster, it may be worth cleaning up this module and making it generally available. But for now, it should be considered internal and heavily incomplete.","category":"page"},{"location":"Nemo/developer/topics/#Parent-object-caching","page":"Specific topics","title":"Parent object caching","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Parent objects in Nemo must be unique given the data that is used to create them. For this purpose most parent objects are cached globally and looked up upon creation. If a parent object with that data already exists, it is returned from the cache instead of creating a new one.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"There are two situations where this can be problematic however.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"The first situation is if one is doing some parallel programming. Here global objects are a blight and it may be necessary to turn off caching and simply ensure that that same data is only ever used once when creating parent objects.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"The second situation is when doing multimodular algorithms, where many similar parent objects with different moduli are created. The cache can become overwhelmed slowing the code down or even grinding to a halt.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"In both these situations one can pass false as an additional argument to a parent constructor to avoid caching the parent object it creates. This parameter normally has a default value of true and under normal circumstances doesn't need to be supplied.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that special light-weight parent constructors, PolyRing, AbsSeriesRing, RelSeriesRing, etc. are also provided which do not cache.","category":"page"},{"location":"Nemo/developer/topics/#Throw/nothrow-for-check_parent","page":"Specific topics","title":"Throw/nothrow for check_parent","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"By default the check_parent functions throw an exception if parents do not match. However sometimes one would like to know if they match without throwing.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"For this purpose one can pass an additional false argument to check_parent. This supresses the exception that would be thrown if the parent objects didn't match. Instead the function simply returns true or false to indicate whether they matched or not.","category":"page"},{"location":"Nemo/developer/topics/#Delayed-reduction","page":"Specific topics","title":"Delayed reduction","text":"","category":"section"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"When working in residue rings, various functions will perform an arithmetic operation followed by a reduction modulo the modulus of the residue ring.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Some accumulations, e.g. in linear algebra or polynomial arithmetic, can be dramatically sped up if one can delay the reductions that would happen after each operation in the accumulation.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Some of the Generic code in Nemo is designed to allow such delayed reduction if the ring supports it and to simply use fallbacks that do the reduction after every intermediate operation if they don't.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"To support delayed reduction, a ring must support the delayed reduction interface which we describe here.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Two additional functions must be supplied for the element type. We give examples for the Nemo nf_elem type:","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"mul_red!(z::nf_elem, x::nf_elem, y::nf_elem, red::Bool)","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"This function behaves as per mul! but only performs reduction if the additional boolean argument red is set to true. This function can assume that both the inputs are reduced.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"reduce!(x::nf_elem)","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"This function must perform reduction on an unreduced element (mutating it). Note that it must return the mutated value as per all unsafe operators.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Finally, the add! and addeq! operators must be able to add nonreduced values.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"If one wishes to speed up generic code for rings that provide delayed reduction, one makes use of the function addmul_delayed_reduction! in the accumulation loop. Here is an example for accumulation into a two dimensional matrix element in Generic in a matrix multiplication routine:","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"A[i, j] = base_ring(X)()\nfor k = 1:ncols(X)\n    A[i, j] = addmul_delayed_reduction!(A[i, j], x[i, k], y[k, j], C)\nend\nA[i, j] = reduce!(A[i, j])","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Here C is a temporary element of the same type as the other inputs which is used internally in addmul_delayed_reduction! if needed.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Notice the final call to reduce! to reduce the accumulated value after the accumulation loop has finished.","category":"page"},{"location":"Nemo/developer/topics/","page":"Specific topics","title":"Specific topics","text":"Note that mul_red! is never called directly but is called inside the generic implementation of addmul_delayed_reduction! for rings that support delayed reduction. That generic code falls back to a call to addmul! which in turn falls back to mul! and addeq! where delayed reduction or addmul! are not available.","category":"page"},{"location":"Hecke/function_fields/internal/","page":"-","title":"-","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/function_fields/internal/","page":"-","title":"-","text":"Function fields, in Hecke, come in several different types:","category":"page"},{"location":"Hecke/function_fields/internal/","page":"-","title":"-","text":"RationalFunctionField: a field of the form k(x) for a field k.\nFunctionField: a finite extension of a rational function field given by  a polynomial.","category":"page"},{"location":"Hecke/function_fields/internal/","page":"-","title":"-","text":"Function fields with the type FunctionField are referred to as simple fields in the rest of this document. They are also referred to as being absolute.","category":"page"},{"location":"Hecke/function_fields/internal/#Absolute-Simple-Fields","page":"-","title":"Absolute Simple Fields","text":"","category":"section"},{"location":"Hecke/function_fields/internal/","page":"-","title":"-","text":"Internally function fields of type FunctionField are essentially represented as a unvariate quotient with the arithmetic provided by the AbstractAlgebra and Nemo packages. As they are defined generically for all AbstractAlgebra, Nemo and Hecke fields k the function field type is implemented in AbstractAlgebra.","category":"page"},{"location":"Hecke/examples/reduction/#Reduction-of-polynomials-over-number-fields-modulo-a-prime-ideal","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"","category":"section"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"Given a polynomial f in Kx and a prime ideal mathfrak p of mathcal O_K, we want to determine the reduction bar f in Fx, where F = mathcal O_Kmathfrak p is the residue field. Concretely, we want to reduce the polynomial f = x^3 + (1 + ζ_7 + ζ_7^2)x^2 + (23 + 55ζ_7^5)x + (ζ_7 + 77)2 over mathbfQ(zeta_7). We begin by defining the cyclomotic field and the polynomial.","category":"page"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"using Hecke # hide\nK, ζ = cyclotomic_field(7);\nKx, x = K['x'];\nf = x^3 + (1 + ζ + ζ^2)*x^2 + (23 + 55ζ^5)x + (ζ + 77)//2","category":"page"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"Next we determine the ring of integers mathcal O_K and a prime ideal mathfrak p lying above the prime p = 29.","category":"page"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"OK = maximal_order(K);\np = 29;\nfrakp = prime_decomposition(OK, p)[1][1]","category":"page"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"We can now determine the residue field F = mathcalO_Kmathfrak p and the canonical map mathcal O_K to F.","category":"page"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"F, reduction_map_OK = ResidueField(OK, frakp);\nF\nreduction_map_OK","category":"page"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"Not that the reduction map has domain mathcal O_K and thus cannot be applied to elements of K. We can extend it to the set of mathfrak p-integral elements by invoking the extend function. Not that the domain of the extended map will be the whole K, but the map will throw an error when applied to elements which are not mathfrak p-integral.","category":"page"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"reduction_map_extended = extend(reduction_map_OK, K)\nreduction_map_extended(K(1//3))\nreduction_map_extended(K(1//29))","category":"page"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"Finally we can reduce f modulo mathfrak p, which we obtain by applying the reduction map to the coefficients.","category":"page"},{"location":"Hecke/examples/reduction/","page":"Reduction of polynomials over number fields modulo a prime ideal","title":"Reduction of polynomials over number fields modulo a prime ideal","text":"fbar = map_coefficients(reduction_map_extended, f)\nbase_ring(fbar) === F","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"using Oscar","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"Pages = [\"modules.md\"]","category":"page"},{"location":"CommutativeAlgebra/modules/#Modules-Over-Multivariate-Rings","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"In this section, the term module will refer to a finitely presented module over a multivariate polynomial ring. In OSCAR, the most general way of implementing such a module is that of a subquotient, that is, as a submodule of a quotient of a free module. Explicitly, a subquotient M over the ring R is a module of type","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"M = (textim  a + textim  b)textim  b","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"where","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"aR^s R^p text and  bR^t R^p","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"are two homomorphisms of free R-modules with the same codomain. We then refer to","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"the module M as the subquotient defined by a and b,\nthe codomain R^p as the ambient free module of M,\nthe images of the canonical basis vectors of R^s in R^p as the ambient representatives of the generators of M, and\nthe images of the canonical basis vectors of R^t in R^p as the relations of M.","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"Alternatively, we speak of the subquotient of textim  a by textim  b or the subquotient defined by A and B, where A and B are the matrices representing a and b, respectively.","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"Finally, we refer to","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"the quotient of R^p by the submodule generated by the relations of M as the ambient module of M,","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"and regard M as a submodule of that ambient module, embedded in the natural way.","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"note: Note\nRecall from the section on free modules that by a free R-module we mean a free module of type R^p , where we think of R^p as a free module with a given basis, namely the basis of standard unit vectors. Accordingly, elements of free modules are represented by coordinate vectors, and homomorphisms between free modules by matrices. Here, by convention, vectors are row vectors, and matrices operate by multiplication on the right.","category":"page"},{"location":"CommutativeAlgebra/modules/#Types","page":"Modules Over Multivariate Rings","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"All OSCAR types for finitely presented modules over multivariate polynomial rings belong to the abstract type ModuleFP{T}. For subquotients, OSCAR provides the abstract subtype AbstractSubQuo{T} <: ModuleFP{T} and its concrete descendant SubQuo{T}.","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"note: Note\nCanonical maps such us the canonical projection onto a quotient module arise in many  constructions in commutative algebra. The SubQuo type is designed so that it allows for the caching of such maps when executing functions. The tensor_product function discussed in this section provides an example.","category":"page"},{"location":"CommutativeAlgebra/modules/#Constructors","page":"Modules Over Multivariate Rings","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"subquotient(a::FreeModuleHom{T}, b::FreeModuleHom{T}) where T","category":"page"},{"location":"CommutativeAlgebra/modules/#subquotient-Union{Tuple{T}, Tuple{FreeModuleHom{T, T2} where T2, FreeModuleHom{T, T2} where T2}} where T","page":"Modules Over Multivariate Rings","title":"subquotient","text":"subquotient(a::FreeModuleHom{T}, b::FreeModuleHom{T}) where T\n\nGiven homomorphisms a and b between free modules such that  codomain(a) === codomain(b),  return (textim  a + textim  b)textim  b.\n\nsubquotient(F::FreeMod{T}, A::MatElem{T}, B::MatElem{T}) where T\n\nGiven matrices A and B with rank F columns, return   (textim  a + textim  b)textim  b, where a and b are the free module homomorphisms with codomain F represented by A and B.\n\nsubquotient(A::MatElem{T}, B::MatElem{T}) where T\n\nGiven matrices A and B with the same number of columns, create a free module F, say, whose rank  is that number, and return (textim  a + textim  b)textim  b, where a and b are as above.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, A, B)\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/#Data-Associated-to-Subqotients","page":"Modules Over Multivariate Rings","title":"Data Associated to Subqotients","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"If M is a subquotient with ambient free R-module F, then","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"base_ring(M) refers to R,\nambient_free_module(M) to F,\ngens(M) to the generators of M, \nngens(M) to the number of these generators, \nM[i], gen(M, i) to the ith such generator,\nambient_representatives_generators(M) to the ambient representatives of the generators of M in F,\nrelations(M) to the relations of M, and\nambient_module(M) to the ambient module of M.","category":"page"},{"location":"CommutativeAlgebra/modules/#Examples","page":"Modules Over Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\nF = free_module(R, 1)\nA = R[x; y]\nB = R[x^2; y^3; z^4]\nM = SubQuo(F, A, B)\nbase_ring(M)\nF === ambient_free_module(M)\ngens(M)\nngens(M)\ngen(M, 2)\nambient_representatives_generators(M)\nrelations(M)\nambient_module(M)","category":"page"},{"location":"CommutativeAlgebra/modules/#Elements-of-Subqotients","page":"Modules Over Multivariate Rings","title":"Elements of Subqotients","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"All OSCAR types for elements of finitely presented modules over multivariate polynomial rings belong to the abstract type ModuleElemFP{T}. For elements of subquotients, there  are the abstract subtype AbstractSubQuoElem{T} <: ModuleFPElem{T} and its concrete descendant SubQuoElem{T} which implements an element m of a subquotient M over a ring R as a sparse row, that is, as an object of type SRow{T}. This object specifies the coefficients of an R-linear combination of the generators of M giving m. To create an element, enter the coefficients as a sparse row or a vector: ","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"(M::SubQuo{T})(c::SRow{T}) where T","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"(M::SubQuo{T})(c::Vector{T}) where T","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"Alternatively, directly write the element as an R-linear combination of generators of M.","category":"page"},{"location":"CommutativeAlgebra/modules/#Examples-2","page":"Modules Over Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\nF = free_module(R, 1)\nA = R[x; y]\nB = R[x^2; y^3; z^4]\nM = SubQuo(F, A, B)\nm = M(sparse_row(R, [(1,z),(2,one(R))]))\nn = M([z, one(R)])\no = z*M[1] + M[2]\nm == n == o","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"Given an element m  of a subquotient M,","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"parent(m) refers to M, \ncoefficients(m) to  an object of type SRow{T} specifying the coefficients of an R-linear combination of the generators of M which gives m, and\nambient_representative(m) to an element of the ambient free module of M which represents m.","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"Given an element f of the ambient free module of a subquotient M such that f represents an element of M, the function below creates the represented element:","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"(M::SubQuo{T})(f::FreeModElem{T}; check::Bool = true) where T","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"By default (check = true), it is tested whether f indeed represents an element of M. If this is already clear, it may be convenient to omit the test (check = false).","category":"page"},{"location":"CommutativeAlgebra/modules/#Examples-3","page":"Modules Over Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\nF = free_module(R, 1)\nA = R[x; y]\nB = R[x^2; y^3; z^4]\nM = SubQuo(F, A, B)\nm = z*M[1] + M[2]\nparent(m)\ncoefficients(m)\nfm = ambient_representative(m)\ntypeof(m)\ntypeof(fm)\nparent(fm) === ambient_free_module(M)\nF = ambient_free_module(M)\nf = x*F[1]\nM(f)\ntypeof(f)\ntypeof(M(f))","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"The zero element of a subquotient is obtained as follows:","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"zero(M::SubQuo)","category":"page"},{"location":"CommutativeAlgebra/modules/#zero-Tuple{SubQuo}","page":"Modules Over Multivariate Rings","title":"zero","text":"zero(M::SubQuo)\n\nReturn the zero element of M.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"Whether a given element of a subquotient is zero can be tested as follows:","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"iszero(m::SubQuoElem)","category":"page"},{"location":"CommutativeAlgebra/modules/#iszero-Tuple{SubQuoElem}","page":"Modules Over Multivariate Rings","title":"iszero","text":"iszero(m::SubQuoElem)\n\nReturn true if m is zero, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, A, B)\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> iszero(M[1])\nfalse\n\njulia> iszero(x*M[1])\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/#Tests-on-Subqotients","page":"Modules Over Multivariate Rings","title":"Tests on Subqotients","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"issubset(M::SubQuo{T}, N::SubQuo{T}) where T","category":"page"},{"location":"CommutativeAlgebra/modules/#issubset-Union{Tuple{T}, Tuple{SubQuo{T}, SubQuo{T}}} where T","page":"Modules Over Multivariate Rings","title":"issubset","text":"issubset(M::SubQuo{T}, N::SubQuo{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return true if M is contained in N, where M and N are regarded as submodules  of the common ambient module.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, AM, BM)\nSubquotient of Submodule with 1 generator\n1 -> x*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> AN = R[x; y]\n[x]\n[y]\n\njulia> BN = R[x^2+y^4; y^3; z^4]\n[x^2 + y^4]\n[      y^3]\n[      z^4]\n\njulia> N = SubQuo(F, AN, BN)\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> (x^2 + y^4)*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> issubset(M, N)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"==(M::SubQuo{T}, N::SubQuo{T}) where T","category":"page"},{"location":"CommutativeAlgebra/modules/#==-Union{Tuple{T}, Tuple{SubQuo{T}, SubQuo{T}}} where T","page":"Modules Over Multivariate Rings","title":"==","text":"==(M::SubQuo{T}, N::SubQuo{T}) where {T}\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return true if M equals N, where M and N are regarded as submodules  of the common ambient module.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, AM, BM)\nSubquotient of Submodule with 1 generator\n1 -> x*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> AN = R[x; y]\n[x]\n[y]\n\njulia> BN = R[x^2+y^4; y^3; z^4]\n[x^2 + y^4]\n[      y^3]\n[      z^4]\n\njulia> N = SubQuo(F, AN, BN)\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> (x^2 + y^4)*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> M == N\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"iszero(M::SubQuo)","category":"page"},{"location":"CommutativeAlgebra/modules/#iszero-Tuple{SubQuo}","page":"Modules Over Multivariate Rings","title":"iszero","text":"iszero(M::SubQuo)\n\nReturn true if M is the zero module, false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> A = R[x^2+y^2;]\n[x^2 + y^2]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, A, B)\nSubquotient of Submodule with 1 generator\n1 -> (x^2 + y^2)*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> iszero(M)\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/#Basic-Operations-on-Subquotients","page":"Modules Over Multivariate Rings","title":"Basic Operations on Subquotients","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":":+(M::SubQuo{T},N::SubQuo{T}) where T","category":"page"},{"location":"CommutativeAlgebra/modules/#+-Union{Tuple{T}, Tuple{SubQuo{T}, SubQuo{T}}} where T","page":"Modules Over Multivariate Rings","title":"+","text":"+(M::SubQuo{T},N::SubQuo{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return the sum of M and N regarded as submodules of the common ambient module. \n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, AM, BM)\nSubquotient of Submodule with 1 generator\n1 -> x*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> AN = R[y;]\n[y]\n\njulia> BN = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> N = SubQuo(F, AN, BN)\nSubquotient of Submodule with 1 generator\n1 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> O = M + N\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"sum(M::SubQuo{T},N::SubQuo{T}) where T","category":"page"},{"location":"CommutativeAlgebra/modules/#sum-Union{Tuple{T}, Tuple{SubQuo{T}, SubQuo{T}}} where T","page":"Modules Over Multivariate Rings","title":"sum","text":"sum(M::SubQuo{T},N::SubQuo{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return the sum of M and N regarded as submodules of the common ambient module, together with the inclusion maps M to M + N and N to M + N.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, AM, BM)\nSubquotient of Submodule with 1 generator\n1 -> x*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> AN = R[y;]\n[y]\n\njulia> BN = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> N = SubQuo(F, AN, BN)\nSubquotient of Submodule with 1 generator\n1 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> O = sum(M, N);\n\njulia> O[1]\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> O[2]\nMap with following data\nDomain:\n=======\nSubquotient of Submodule with 1 generator\n1 -> x*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\nCodomain:\n=========\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> O[3]\nMap with following data\nDomain:\n=======\nSubquotient of Submodule with 1 generator\n1 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\nCodomain:\n=========\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"intersect(M::SubQuo{T}, N::SubQuo{T}) where T","category":"page"},{"location":"CommutativeAlgebra/modules/#intersect-Union{Tuple{T}, Tuple{SubQuo{T}, SubQuo{T}}} where T","page":"Modules Over Multivariate Rings","title":"intersect","text":"intersect(M::SubQuo{T}, N::SubQuo{T}) where T\n\nGiven subquotients M and N such that ambient_module(M) == ambient_module(N), return the intersection of M and N regarded as submodules of the common ambient module, together with the inclusion maps M cap N to M and M cap N to N.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> AM = R[x;]\n[x]\n\njulia> BM = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, AM, BM)\nSubquotient of Submodule with 1 generator\n1 -> x*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> AN = R[y;]\n[y]\n\njulia> BN = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> N = SubQuo(F, AN, BN)\nSubquotient of Submodule with 1 generator\n1 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> intersect(M, N)\n(Subquotient of Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> -x*y*e[1]\n3 -> x*z^4*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1], Map with following data\nDomain:\n=======\nSubquotient of Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> -x*y*e[1]\n3 -> x*z^4*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\nCodomain:\n=========\nSubquotient of Submodule with 1 generator\n1 -> x*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1], Map with following data\nDomain:\n=======\nSubquotient of Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> -x*y*e[1]\n3 -> x*z^4*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\nCodomain:\n=========\nSubquotient of Submodule with 1 generator\n1 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/#Submodules-and-Quotients","page":"Modules Over Multivariate Rings","title":"Submodules and Quotients","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"sub(F::FreeMod, O::Vector{<:FreeModElem}, task::Symbol = :none)","category":"page"},{"location":"CommutativeAlgebra/modules/#sub","page":"Modules Over Multivariate Rings","title":"sub","text":"sub(F::FreeMod, V::Vector{<:FreeModElem}, task::Symbol = :none)\n\nGiven a vector V of elements of F, return the submodule of F generated by these elements.\n\nPut more precisely, if N denotes this submodule, return N as an object of type SubQuo. Additionally,\n\nreturn the inclusion map N to F if task = :with_morphism,\nreturn and cache the inclusion map N to F if task = :cache_morphism,\ndo none of the above if task = :none (default).\n\nIf task = :only_morphism, return only the inclusion map.\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"sub(S::SubQuo, O::Vector{<:SubQuoElem}, task::Symbol = :none, check = true)","category":"page"},{"location":"CommutativeAlgebra/modules/#sub-2","page":"Modules Over Multivariate Rings","title":"sub","text":"sub(M::SubQuo, V::Vector{<:SubQuoElem}, task::Symbol = :none, check = true)\n\nGiven a vector V of elements of M, return the submodule of M generated by these elements.\n\nPut more precisely, if N denotes this submodule, return N as an object of type SubQuo. Additionally,\n\nreturn the inclusion map N to M if task = :with_morphism,\nreturn and cache the inclusion map N to M if task = :cache_morphism,\ndo none of the above if task = :none (default).\n\nIf task = :only_morphism, return only the inclusion map.\n\nIf check = false, the condition on V is not checked by the function.\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"quo(F::FreeMod, O::Vector{<:FreeModElem}, task::Symbol = :none)","category":"page"},{"location":"CommutativeAlgebra/modules/#quo","page":"Modules Over Multivariate Rings","title":"quo","text":"quo(F::FreeMod, V::Vector{<:FreeModElem}, task::Symbol = :none)\n\nGiven a vector V of elements of F, return the quotient of F by the submodule of F which is generated by these elements.\n\nPut more precisely, if N denotes this quotient, return N as an object of type SubQuo. Additionally,\n\nreturn the projection map F to N if task = :with_morphism,\nreturn and cache the projection map F to N if task = :cache_morphism,\ndo none of the above if task = :none (default).\n\nIf task = :only_morphism, return only the projection map.\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"quo(M::SubQuo, V::Vector{<:SubQuoElem}, task::Symbol = :none)","category":"page"},{"location":"CommutativeAlgebra/modules/#quo-2","page":"Modules Over Multivariate Rings","title":"quo","text":"quo(M::SubQuo, V::Vector{<:SubQuoElem}, task::Symbol = :none)\n\nGiven a vector V of elements of M, return the quotient of M by the submodule of M which is generated by these elements.\n\nPut more precisely, if N denotes this quotient, return N as an object of type SubQuo. Additionally,\n\nreturn the projection map M to N if task = :with_morphism,\nreturn and cache the projection map M to N if task = :cache_morphism,\ndo none of the above if task = :none (default).\n\nIf task = :only_morphism, return only the projection map.\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/modules/#Homomorphisms-From-Subqotients","page":"Modules Over Multivariate Rings","title":"Homomorphisms From Subqotients","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"In OSCAR, homomorphisms from subquotients have type SubQuoHom{T1, T2}, where T1 and T2 are the element types of the domain and codomain, respectively. They are created by using one of the following constructors:","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"hom(M::SubQuo{T}, N::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}) where T","category":"page"},{"location":"CommutativeAlgebra/modules/#hom-Union{Tuple{T}, Tuple{SubQuo{T}, ModuleFP{T}, Vector{var\"#s271\"} where var\"#s271\"<:ModuleFPElem{T}}} where T","page":"Modules Over Multivariate Rings","title":"hom","text":"hom(M::SubQuo{T}, N::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}) where T\n\nGiven a vector V of ngens(M) elements of N,  return the homomorphism M to N which sends the i-th generator M[i] of M to the i-th entry of V.\n\nhom(M::SubQuo{T}, N::ModuleFP{T},  A::MatElem{T})) where T\n\nGiven a matrix A with ngens(M) rows and ngens(N) columns, return the homomorphism M to N which sends the i-th generator M[i] of M to  the linear combination sum_j Aij*Nj of the generators N[j] of N.\n\nwarning: Warning\nThe functions do not check whether the resulting homomorphism is well-defined, that is, whether it sends the relations of M into the relations of N. \n\nIf you are uncertain with regard to well-definedness, use the function below. Note, however, that the check performed by the function requires a Gröbner basis computation. This may take some time.\n\niswelldefined(a::ModuleMap)\n\nReturn true if a is well-defined, and false otherwise.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, A, B)\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x*N[2]]\n2-element Vector{SubQuoElem{fmpq_mpoly}}:\n x*y^2*e[1]\n x*y*e[1]\n\njulia> a = hom(M, N, V)\nMap with following data\nDomain:\n=======\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\nCodomain:\n=========\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> iswelldefined(a)\ntrue\n\njulia> W = [y*N[1], x*N[2]]\n2-element Vector{SubQuoElem{fmpq_mpoly}}:\n x*y*e[1]\n x*y*e[1]\n\njulia> b = hom(M, N, W)\nMap with following data\nDomain:\n=======\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\nCodomain:\n=========\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> iswelldefined(b)\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"Given a homomorphism of type SubQuoHom, a matrix A as above is recovered by the following function:","category":"page"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"matrix(a::SubQuoHom)","category":"page"},{"location":"CommutativeAlgebra/modules/#matrix-Tuple{SubQuoHom}","page":"Modules Over Multivariate Rings","title":"matrix","text":"matrix(a::SubQuoHom)\n\nGiven a homomorphism a of type  SubQuoHom with domain M and codomain N, return a matrix A with ngens(M) rows and  ngens(N) columns such that a == hom(M, N, A).\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 1)\nFree module of rank 1 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> A = R[x; y]\n[x]\n[y]\n\njulia> B = R[x^2; y^3; z^4]\n[x^2]\n[y^3]\n[z^4]\n\njulia> M = SubQuo(F, A, B)\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> N = M;\n\njulia> V = [y^2*N[1], x*N[2]]\n2-element Vector{SubQuoElem{fmpq_mpoly}}:\n x*y^2*e[1]\n x*y*e[1]\n\njulia> a = hom(M, N, V)\nMap with following data\nDomain:\n=======\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\nCodomain:\n=========\nSubquotient of Submodule with 2 generators\n1 -> x*e[1]\n2 -> y*e[1]\nby Submodule with 3 generators\n1 -> x^2*e[1]\n2 -> y^3*e[1]\n3 -> z^4*e[1]\n\njulia> A = matrix(a)\n[y^2   0]\n[  0   x]\n\njulia> a(M[1])\nx*y^2*e[1]\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"The domain and codomain of a homomorphism a  of type SubQuoHom can be recovered by entering domain(a) and codomain(a), respectively.","category":"page"},{"location":"CommutativeAlgebra/modules/#Operations-on-Subquotients","page":"Modules Over Multivariate Rings","title":"Operations on Subquotients","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"direct_sum(M::ModuleFP{T}...; task::Symbol = :none) where T","category":"page"},{"location":"CommutativeAlgebra/modules/#direct_sum-Union{Tuple{Vararg{ModuleFP{T}, N} where N}, Tuple{T}} where T","page":"Modules Over Multivariate Rings","title":"direct_sum","text":"direct_sum(M::ModuleFP{T}...; task::Symbol = :none) where T\n\nGiven modules M_1dots M_n, say, return the direct sum bigoplus_i=1^n M_i.    Additionally, return \n\na vector containing the canonical injections  M_irightarrowbigoplus_i=1^n M_i if task = :sum (default),\na vector containing the canonical projections  bigoplus_i=1^n M_irightarrow M_i if task = :prod,\ntwo vectors containing the canonical injections and projections, respectively, if task = :both,\nnone of the above if task = :none.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"direct_product(M::ModuleFP{T}...; task::Symbol = :none) where T","category":"page"},{"location":"CommutativeAlgebra/modules/#direct_product-Union{Tuple{Vararg{ModuleFP{T}, N} where N}, Tuple{T}} where T","page":"Modules Over Multivariate Rings","title":"direct_product","text":"direct_product(M::ModuleFP{T}...; task::Symbol = :none) where T\n\nGiven modules M_1dots M_n, say, return the direct product prod_i=1^n M_i.\n\nAdditionally, return a vector containing\n\na vector containing the canonical projections  prod_i=1^n M_irightarrow M_i if task = :prod (default),\na vector containing the canonical injections  M_irightarrowprod_i=1^n M_i if task = :sum,\ntwo vectors containing the canonical projections and injections, respectively, if task = :both,\nnone of the above if task = :none.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/#Operations-on-Homomorphisms","page":"Modules Over Multivariate Rings","title":"Operations on Homomorphisms","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"hom_tensor(M::ModuleFP, N::ModuleFP, V::Vector{ <: ModuleMap})","category":"page"},{"location":"CommutativeAlgebra/modules/#hom_tensor-Tuple{ModuleFP, ModuleFP, Vector{var\"#s271\"} where var\"#s271\"<:ModuleMap}","page":"Modules Over Multivariate Rings","title":"hom_tensor","text":"hom_tensor(M::ModuleFP, N::ModuleFP, V::Vector{ <: ModuleMap})\n\nGiven modules M, N which are tensor products with the same number of factors, say M = M_1 otimes cdots otimes M_r, N = N_1 otimes cdots otimes N_r, and given a vector V of homomorphisms a_i  M_i to N_i, return  a_1 otimes cdots otimes a_r.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"hom_prod_prod(M::ModuleFP, N::ModuleFP, A::Matrix{<:ModuleMap})","category":"page"},{"location":"CommutativeAlgebra/modules/#hom_prod_prod-Tuple{ModuleFP, ModuleFP, Matrix{var\"#s271\"} where var\"#s271\"<:ModuleMap}","page":"Modules Over Multivariate Rings","title":"hom_prod_prod","text":"hom_prod_prod(M::ModuleFP, N::ModuleFP, A::Matrix{<:ModuleMap})\n\nGiven modules M, N which are products with the same number of factors,   say M = prod_i=1^r M_i, N = prod_j=1^r N_j, and given a matrix  A of homomorphisms a_ij  M_i to N_j, return the homomorphism M rightarrow N with ij-components a_ij.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/#Subquotients-Related-to-Homomorphisms","page":"Modules Over Multivariate Rings","title":"Subquotients Related to Homomorphisms","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/#Kernel","page":"Modules Over Multivariate Rings","title":"Kernel","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"kernel(h::FreeModuleHom)","category":"page"},{"location":"CommutativeAlgebra/modules/#kernel-Tuple{FreeModuleHom}","page":"Modules Over Multivariate Rings","title":"kernel","text":"kernel(a::FreeModuleHom)\n\nReturn the kernel of a as an object of type SubQuo.\n\nAdditionally, if K denotes this kernel, return the inclusion map K rightarrow domain(a).\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 3)\nFree module of rank 3 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> G = free_module(R, 2)\nFree module of rank 2 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{fmpq_mpoly}}:\n y*e[1]\n x*e[1] + y*e[2]\n z*e[2]\n\njulia> a = hom(F, G, V)\nMap with following data\nDomain:\n=======\nFree module of rank 3 over Multivariate Polynomial Ring in x, y, z over Rational Field\nCodomain:\n=========\nFree module of rank 2 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> kernel(a)\n(Submodule with 1 generator\n1 -> x*z*e[1] - y*z*e[2] + y^2*e[3]\nrepresented as subquotient with no relations., Map with following data\nDomain:\n=======\nSubmodule with 1 generator\n1 -> x*z*e[1] - y*z*e[2] + y^2*e[3]\nrepresented as subquotient with no relations.\nCodomain:\n=========\nFree module of rank 3 over Multivariate Polynomial Ring in x, y, z over Rational Field)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"kernel(h::SubQuoHom)","category":"page"},{"location":"CommutativeAlgebra/modules/#kernel-Tuple{SubQuoHom}","page":"Modules Over Multivariate Rings","title":"kernel","text":"kernel(a::SubQuoHom)\n\nReturn the kernel of a as an object of type SubQuo.\n\nAdditionally, if K denotes this kernel, return the inclusion map K rightarrow domain(a).\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/#Image","page":"Modules Over Multivariate Rings","title":"Image","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"image(h::FreeModuleHom)","category":"page"},{"location":"CommutativeAlgebra/modules/#image-Tuple{FreeModuleHom}","page":"Modules Over Multivariate Rings","title":"image","text":"image(a::FreeModuleHom)\n\nReturn the image of a as an object of type SubQuo.\n\nAdditionally, if I denotes this image, return the inclusion map I rightarrow codomain(a).\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 3)\nFree module of rank 3 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> G = free_module(R, 2)\nFree module of rank 2 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{fmpq_mpoly}}:\n y*e[1]\n x*e[1] + y*e[2]\n z*e[2]\n\njulia> a = hom(F, G, V)\nMap with following data\nDomain:\n=======\nFree module of rank 3 over Multivariate Polynomial Ring in x, y, z over Rational Field\nCodomain:\n=========\nFree module of rank 2 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> image(a)\n(Submodule with 3 generators\n1 -> y*e[1]\n2 -> x*e[1] + y*e[2]\n3 -> z*e[2]\nrepresented as subquotient with no relations., Map with following data\nDomain:\n=======\nSubmodule with 3 generators\n1 -> y*e[1]\n2 -> x*e[1] + y*e[2]\n3 -> z*e[2]\nrepresented as subquotient with no relations.\nCodomain:\n=========\nFree module of rank 2 over Multivariate Polynomial Ring in x, y, z over Rational Field)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"image(h::SubQuoHom)","category":"page"},{"location":"CommutativeAlgebra/modules/#image-Tuple{SubQuoHom}","page":"Modules Over Multivariate Rings","title":"image","text":"image(a::SubQuoHom)\n\nReturn the image of a as an object of type SubQuo.\n\nAdditionally, if I denotes this image, return the inclusion map I rightarrow codomain(a).\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/#Cokernel","page":"Modules Over Multivariate Rings","title":"Cokernel","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/","page":"Modules Over Multivariate Rings","title":"Modules Over Multivariate Rings","text":"cokernel(f::FreeModuleHom) ","category":"page"},{"location":"CommutativeAlgebra/modules/#cokernel-Tuple{FreeModuleHom}","page":"Modules Over Multivariate Rings","title":"cokernel","text":"cokernel(a::FreeModuleHom)\n\nGiven a homomorphism a between free modules, return the cokernel of a as an object of type SubQuo.\n\ncokernel(F::FreeMod{T}, A::MatElem{T}) where T\n\nGiven a matrix A with with rank F columns, return cokernel(a),  where a is the free module homomorphism with codomain F represented by A.\n\ncokernel(A::MatElem)\n\nCreate a free module F, say, with rank F columns, and return cokernel(F, A).\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> F = free_module(R, 3)\nFree module of rank 3 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> G = free_module(R, 2)\nFree module of rank 2 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> V = [y*G[1], x*G[1]+y*G[2], z*G[2]]\n3-element Vector{FreeModElem{fmpq_mpoly}}:\n y*e[1]\n x*e[1] + y*e[2]\n z*e[2]\n\njulia> a = hom(F, G, V)\nMap with following data\nDomain:\n=======\nFree module of rank 3 over Multivariate Polynomial Ring in x, y, z over Rational Field\nCodomain:\n=========\nFree module of rank 2 over Multivariate Polynomial Ring in x, y, z over Rational Field\n\njulia> cokernel(a)\nSubquotient of Submodule with 2 generators\n1 -> e[1]\n2 -> e[2]\nby Submodule with 3 generators\n1 -> y*e[1]\n2 -> x*e[1] + y*e[2]\n3 -> z*e[2]\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/modules/#Homology","page":"Modules Over Multivariate Rings","title":"Homology","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/#Presentations","page":"Modules Over Multivariate Rings","title":"Presentations","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/#Syzygies-and-Free-Resolutions","page":"Modules Over Multivariate Rings","title":"Syzygies and Free Resolutions","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/#Hom-and-Ext","page":"Modules Over Multivariate Rings","title":"Hom and Ext","text":"","category":"section"},{"location":"CommutativeAlgebra/modules/#Tensorproduct-and-Tor","page":"Modules Over Multivariate Rings","title":"Tensorproduct and Tor","text":"","category":"section"},{"location":"AbstractAlgebra/field_interface/#Field-Interface","page":"Field Interface","title":"Field Interface","text":"","category":"section"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all fields. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their fields.","category":"page"},{"location":"AbstractAlgebra/field_interface/#Types","page":"Field Interface","title":"Types","text":"","category":"section"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"Most fields must supply two types:","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"a type for the parent object (representing the field itself)\na type for elements of that field","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"For example, the generic fraction field type in AbstractAlgebra.jl provides two  types in generic/GenericTypes.jl: ","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"Generic.FracField{T} for the parent objects\nGeneric.Frac{T} for the actual fractions","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"The parent type must belong to Field and the element type must belong to FieldElem. Of course, the types may belong to these abstract types transitively.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"For parameterised fields, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"There can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.","category":"page"},{"location":"AbstractAlgebra/field_interface/#FieldElement-type-union","page":"Field Interface","title":"FieldElement type union","text":"","category":"section"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"Because of its lack of multiple inheritance, Julia does not allow Julia Base types to belong to FieldElem. To allow us to work equally with AbstractAlgebra and Julia types that represent elements of fields we define a union type FieldElement in src/julia/JuliaTypes.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"So far, in addition to FieldElem the  union type FieldElement includes the Julia types Rational and AbstractFloat.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"Most of the generic code in AbstractAlgebra makes use of the union type FieldElement instead of FieldElem so that the generic functions also accept the Julia Base field types.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"note: Note\nOne must be careful when defining ad hoc binary operations for field element types. It is often necessary to define separate versions of the functions for FieldElem then for each of the Julia types separately in order to avoid ambiguity warnings.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"Note that even though FieldElement is a union type we still have the following inclusion","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"FieldElement <: RingElement","category":"page"},{"location":"AbstractAlgebra/field_interface/#Parent-object-caches","page":"Field Interface","title":"Parent object caches","text":"","category":"section"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"In many cases, it is desirable to have only one object in the system to represent each field. This means that if the same field is constructed twice, elements of the two fields will be compatible as far as arithmetic is concerned.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"In order to facilitate this, global caches of fields are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the Generic.FracField parent objects are looked up in a dictionary FracDict to see if they have been previously defined.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"Whether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn't desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two fields are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two fields if they were constructed from identical data.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"If a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value cached to the inner constructor of the parent object. See generic/GenericTypes.jl for examples of how to construct and handle such caches.","category":"page"},{"location":"AbstractAlgebra/field_interface/#Required-functions-for-all-fields","page":"Field Interface","title":"Required functions for all fields","text":"","category":"section"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"In the following, we list all the functions that are required to be provided for fields in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"We give this interface for fictitious types MyParent for the type of the field parent object R and MyElem for the type of the elements of the field.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"note: Note\nGeneric functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for fields that implement that additional functionality, and should be documented as such.","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"In the first place, all fields are rings and therefore any field type must implement all of the Ring interface. The functionality below is in addition to this basic functionality.","category":"page"},{"location":"AbstractAlgebra/field_interface/#Data-type-and-parent-object-methods","page":"Field Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"characteristic(R::MyParent)","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"Return the characteristic of the field. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/field_interface/#Basic-manipulation-of-rings-and-elements","page":"Field Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"isunit(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/field_interface/","page":"Field Interface","title":"Field Interface","text":"Return true if the given element is invertible, i.e. nonzero in the field.","category":"page"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"using Oscar","category":"page"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"Pages = [\"products.md\"]","category":"page"},{"location":"Groups/products/#Products-of-groups","page":"Products of groups","title":"Products of groups","text":"","category":"section"},{"location":"Groups/products/#Direct-products","page":"Products of groups","title":"Direct products","text":"","category":"section"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"DirectProductGroup\ndirect_product(L::AbstractVector{<:GAPGroup}; morphisms=false)\ninner_direct_product(L::AbstractVector{T}; morphisms=false) where T<:Union{PcGroup,FPGroup}\nnumber_of_factors(G::DirectProductGroup)\ncartesian_power(G::GAPGroup, n::Int)\ninner_cartesian_power(G::T, n::Int; morphisms=false) where T<: GAPGroup\nfactor_of_direct_product(G::DirectProductGroup, j::Int)\nas_perm_group(G::DirectProductGroup)\nas_polycyclic_group(G::DirectProductGroup)\nembedding(G::DirectProductGroup, j::Int)\nprojection(G::DirectProductGroup, j::Int)\nwrite_as_full(G::DirectProductGroup)\nisfull_direct_product(G::DirectProductGroup)","category":"page"},{"location":"Groups/products/#DirectProductGroup","page":"Products of groups","title":"DirectProductGroup","text":"DirectProductGroup\n\nEither direct product of two or more groups of any type, or subgroup of a direct product of groups.\n\n\n\n\n\n","category":"type"},{"location":"Groups/products/#direct_product-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:Oscar.GAPGroup}","page":"Products of groups","title":"direct_product","text":"direct_product(L::AbstractVector{<:GAPGroup}; morphisms)\ndirect_product(L::GAPGroup...)\n\nReturn the direct product of the groups in the collection L.\n\nThe parameter morphisms is false by default. If it is set true, then the output is a triple (G, emb, proj), where emb and proj are the vectors of the embeddings (resp. projections) of the direct product G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#inner_direct_product-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Union{FPGroup, PcGroup}","page":"Products of groups","title":"inner_direct_product","text":"inner_direct_product(L::AbstractVector{T}; morphisms)\ninner_direct_product(L::T...)\n\nReturn a direct product of groups of the same type T as a group of type T. It works for T of the following types:\n\nPermGroup, PcGroup, FPGroup.\n\nThe parameter morphisms is false by default. If it is set true, then the output is a triple (G, emb, proj), where emb and proj are the vectors of the embeddings (resp. projections) of the direct product G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#number_of_factors-Tuple{DirectProductGroup}","page":"Products of groups","title":"number_of_factors","text":"number_of_factors(G::DirectProductGroup)\n\nReturn the number of factors of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#cartesian_power-Tuple{Oscar.GAPGroup, Int64}","page":"Products of groups","title":"cartesian_power","text":"cartesian_power(G::T, n::Int)\n\nReturn the direct product of n copies of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#inner_cartesian_power-Union{Tuple{T}, Tuple{T, Int64}} where T<:Oscar.GAPGroup","page":"Products of groups","title":"inner_cartesian_power","text":"inner_cartesian_power(G::T, n::Int; morphisms)\n\nReturn the direct product of n copies of G as group of type T.\n\nThe parameter morphisms is false by default. If it is set true, then the output is a triple (G, emb, proj), where emb and proj are the vectors of the embeddings (resp. projections) of the direct product G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#factor_of_direct_product-Tuple{DirectProductGroup, Int64}","page":"Products of groups","title":"factor_of_direct_product","text":"factor_of_direct_product(G::DirectProductGroup, j::Int)\n\nReturn the j-th factor of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#as_perm_group-Tuple{DirectProductGroup}","page":"Products of groups","title":"as_perm_group","text":"as_perm_group(G::DirectProductGroup)\n\nIf G is direct product of permutations groups, return G as permutation group.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#as_polycyclic_group-Tuple{DirectProductGroup}","page":"Products of groups","title":"as_polycyclic_group","text":"as_polycyclic_group(G::DirectProductGroup)\n\nIf G is direct product of polycyclic groups, return G as polycyclic group.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#embedding-Tuple{DirectProductGroup, Int64}","page":"Products of groups","title":"embedding","text":"embedding(G::DirectProductGroup, j::Int)\n\nReturn the embedding of the j-th component of G into G, for j = 1,...,#factors of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#projection-Tuple{DirectProductGroup, Int64}","page":"Products of groups","title":"projection","text":"projection(G::DirectProductGroup, j::Int)\n\nReturn the projection of G into the j-th component of G, for j = 1,...,#factors of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#write_as_full-Tuple{DirectProductGroup}","page":"Products of groups","title":"write_as_full","text":"write_as_full(G::DirectProductGroup)\n\nIf G is a subgroup of the direct product G_1 times G_2 times cdots times G_n such that G has the form H_1 times H_2 times cdots times H_n, for subgroups H_i of G_i, return this full direct product of the H_i.\n\nAn exception is thrown if such H_i do not exist.\n\n\n\n","category":"method"},{"location":"Groups/products/#isfull_direct_product-Tuple{DirectProductGroup}","page":"Products of groups","title":"isfull_direct_product","text":"isfull_direct_product(G::DirectProductGroup)\n\nReturn whether G is direct product of its factors (false if it is a proper subgroup).\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#Semidirect-products","page":"Products of groups","title":"Semidirect products","text":"","category":"section"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"SemidirectProductGroup{S<:GAPGroup, T<:GAPGroup}\nsemidirect_product(N::S, f::GAPGroupHomomorphism{T,AutomorphismGroup{S}}, H::T) where S <: GAPGroup where T <: GAPGroup\nnormal_subgroup(G::SemidirectProductGroup)\nacting_subgroup(G::SemidirectProductGroup)\nhomomorphism_of_semidirect_product(G::SemidirectProductGroup)\nisfull_semidirect_product(G::SemidirectProductGroup)\nembedding(G::SemidirectProductGroup, n::Int)\nprojection(G::SemidirectProductGroup)","category":"page"},{"location":"Groups/products/#SemidirectProductGroup","page":"Products of groups","title":"SemidirectProductGroup","text":"SemidirectProductGroup{S,T}\n\nSemidirect product of two groups of type S and T respectively, or subgroup of a semidirect product of groups.\n\n\n\n\n\n","category":"type"},{"location":"Groups/products/#semidirect_product-Union{Tuple{S}, Tuple{T}, Tuple{S, GAPGroupHomomorphism{T, AutomorphismGroup{S}}, T}} where {T<:Oscar.GAPGroup, S<:Oscar.GAPGroup}","page":"Products of groups","title":"semidirect_product","text":"semidirect_product(N::S, f::GAPGroupHomomorphism, H::T)\n\nReturn the semidirect product of N and H, of type SemidirectProductGroup{S,T}, where f is a group homomorphism from H to the automorphism group of N.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#normal_subgroup-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"normal_subgroup","text":"normal_subgroup(G::SemidirectProductGroup)\n\nReturn N, where G is the semidirect product of the normal subgroup N and H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#acting_subgroup-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"acting_subgroup","text":"acting_subgroup(G::SemidirectProductGroup)\n\nReturn H, where G is the semidirect product of the normal subgroup N and H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#homomorphism_of_semidirect_product-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"homomorphism_of_semidirect_product","text":"homomorphism_of_semidirect_product(G::SemidirectProductGroup)\n\nReturn f, where G is the semidirect product of the normal subgroup N and the group H acting on N via the homomorphism h.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#isfull_semidirect_product-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"isfull_semidirect_product","text":"isfull_semidirect_product(G::SemidirectProductGroup)\n\nReturn whether G is a semidirect product of two groups, instead of a proper subgroup.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#embedding-Tuple{SemidirectProductGroup, Int64}","page":"Products of groups","title":"embedding","text":"embedding(G::SemidirectProductGroup, n::Int)\n\nReturn the embedding of the n-th component of G into G, for n = 1,2. It is not defined for proper subgroups of semidirect products.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#projection-Tuple{SemidirectProductGroup}","page":"Products of groups","title":"projection","text":"projection(G::SemidirectProductGroup)\n\nReturn the projection of G into the second component of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#Wreath-products","page":"Products of groups","title":"Wreath products","text":"","category":"section"},{"location":"Groups/products/","page":"Products of groups","title":"Products of groups","text":"WreathProductGroup\nwreath_product(G::T, H::PermGroup) where T<: GAPGroup\nnormal_subgroup(W::WreathProductGroup)\nacting_subgroup(W::WreathProductGroup)\nhomomorphism_of_wreath_product(G::WreathProductGroup)\nisfull_wreath_product(G::WreathProductGroup)\nprojection(W::WreathProductGroup)\nembedding(W::WreathProductGroup, n::Int)","category":"page"},{"location":"Groups/products/#WreathProductGroup","page":"Products of groups","title":"WreathProductGroup","text":"WreathProductGroup\n\nWreath product of a group G and a group of permutations H, or a generic group H together with the homomorphism a from H to a permutation group.\n\n\n\n\n\n","category":"type"},{"location":"Groups/products/#wreath_product-Union{Tuple{T}, Tuple{T, PermGroup}} where T<:Oscar.GAPGroup","page":"Products of groups","title":"wreath_product","text":"wreath_product(G::T, H::S, a::GAPGroupHomomorphism{S,PermGroup})\nwreath_product(G::T, H::PermGroup) where T<: Group\n\nReturn the wreath product of the group G and the group H, where H acts on n copies of G through the homomorphism a from H to a permutation group, and n is the number of moved points of Image(a).\n\nIf a is not specified, then H must be a group of permutations. In this case, n is NOT the number of moved points, but the degree of H.\n\nIf W is a wreath product of G and H, {g_1, ..., g_n} are elements of G and h in H, the element (g_1, ..., h) of W can be obtained by typing\n\n    W(g_1,...,g_n, h).\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#normal_subgroup-Tuple{WreathProductGroup}","page":"Products of groups","title":"normal_subgroup","text":"normal_subgroup(W::WreathProductGroup)\n\nReturn G, where W is the wreath product of G and H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#acting_subgroup-Tuple{WreathProductGroup}","page":"Products of groups","title":"acting_subgroup","text":"acting_subgroup(W::WreathProductGroup)\n\nReturn H, where W is the wreath product of G and H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#homomorphism_of_wreath_product-Tuple{WreathProductGroup}","page":"Products of groups","title":"homomorphism_of_wreath_product","text":"homomorphism_of_wreath_product(G::WreathProductGroup)\n\nIf W is the wreath product of G and H, then return the homomorphism f from H to Sym(n), where n is the number of copies of G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#isfull_wreath_product-Tuple{WreathProductGroup}","page":"Products of groups","title":"isfull_wreath_product","text":"isfull_wreath_product(G::WreathProductGroup)\n\nReturn whether G is a wreath product of two groups, instead of a proper subgroup.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#projection-Tuple{WreathProductGroup}","page":"Products of groups","title":"projection","text":"projection(G::WreathProductGroup)\n\nReturn the projection of wreath_product(G,H) onto the permutation group H.\n\n\n\n\n\n","category":"method"},{"location":"Groups/products/#embedding-Tuple{WreathProductGroup, Int64}","page":"Products of groups","title":"embedding","text":"embedding(G::WreathProductGroup, n::Int)\n\nReturn the embedding of the n-th component of G into G.\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/fraction_interface/#Fraction-Field-Interface","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"","category":"section"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Fraction fields are supported in AbstractAlgebra.jl, at least for gcd domains. In addition to the standard Ring interface, some additional functions are required to be present for fraction fields.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/#Types-and-parents","page":"Fraction Field Interface","title":"Types and parents","text":"","category":"section"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"AbstractAlgebra provides two abstract types for fraction fields and their elements:","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"FracField{T} is the abstract type for fraction field parent types\nFracElem{T} is the abstract type for types of fractions","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"We have that FracField{T} <: Field and  FracElem{T} <: FieldElem.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Note that both abstract types are parameterised. The type T should usually be the type of elements of the base ring of the fraction field.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Fraction fields should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Fraction fields should at least be distinguished based on their base ring.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"AbstractAlgebra/fraction_interface/#Required-functionality-for-fraction-fields","page":"Fraction Field Interface","title":"Required functionality for fraction fields","text":"","category":"section"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"In addition to the required functionality for the Field interface the Fraction Field interface has the following required functions.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"We suppose that R is a fictitious base ring, and that S is the fraction field with  parent object S of type MyFracField{T}. We also assume the fractions in the field  have type MyFrac{T}, where T is the type of elements of the base ring.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/#Constructors","page":"Fraction Field Interface","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"The following constructors create fractions. Note that these constructors don't require construction of the parent object first. This is easier to achieve if the fraction element type doesn't contain a reference to the parent object, but merely contains a reference to the base ring. The parent object can then be constructed on demand.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"//(x::T, y::T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Return the fraction xy.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"//(x::T, y::FracElem{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Return xy where x is in the base ring of y.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"//(x::FracElem{T}, y::T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Return xy where y is in the base ring of x.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/#Basic-manipulation-of-fields-and-elements","page":"Fraction Field Interface","title":"Basic manipulation of fields and elements","text":"","category":"section"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"numerator(d::MyFrac{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Given a fraction d = ab return a, where ab is in lowest terms with respect to the canonical_unit and gcd functions on the base ring.","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"denominator(d::MyFrac{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/fraction_interface/","page":"Fraction Field Interface","title":"Fraction Field Interface","text":"Given a fraction d = ab return b, where ab is in lowest terms with respect to the canonical_unit and gcd functions on the base ring.","category":"page"},{"location":"AbstractAlgebra/interface_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"AbstractAlgebra/interface_introduction/","page":"Introduction","title":"Introduction","text":"AbstractAlgebra defines a series of interfaces that can be extended with new types that implement those interfaces. For example, if one were implementing a new polynomial ring type, one would implement all of the required functionality described in this chapter for the relevant AbstractAlgebra interfaces. This would include the Ring Interface and the Univariate Polynomial Ring Interface.","category":"page"},{"location":"AbstractAlgebra/interface_introduction/","page":"Introduction","title":"Introduction","text":"Once a new type implements all the required functionality, all the corresponding generic functionality would then function automatically for the new type.","category":"page"},{"location":"AbstractAlgebra/interface_introduction/","page":"Introduction","title":"Introduction","text":"One may then go on to implement some of the optional functionality for performance if the provided generic functionality is insufficient.","category":"page"},{"location":"AbstractAlgebra/interface_introduction/","page":"Introduction","title":"Introduction","text":"AbstractAlgebra tries to provide all generic constructions recursively so that one can have towers of generic constructions. This means that new interfaces should generally only be added if they cooperate with all the existing interfaces, at least so far as the theory exists to do so.","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"using Oscar","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/#General-schemes","page":"General schemes","title":"General schemes","text":"","category":"section"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"Arbitrary schemes over a base ring mathbb k which are given by means  of their affine patches and glueings are instances of ","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"Scheme{BaseRingType<:Ring, BaseRingElemType<:RingElement}","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/#Scheme","page":"General schemes","title":"Scheme","text":"Scheme{BaseRingType<:Ring, BaseRingElemType<:RingElement}\n\nA scheme over a ring 𝕜 of type BaseRingType with elements  of type BaseRingElemType.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/AffineSchemes/#Affine-schemes-over-noetherian-base-rings","page":"General schemes","title":"Affine schemes over noetherian base rings","text":"","category":"section"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"Let mathbb k be a commutative noetherian base ring  (in practice: an algebraic extension of mathbb Q or mathbb F_p).  An affine scheme X over mathbb k is given as ","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"    X = mathrmSpec left(mathbb kx_1dotsx_nIright)","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"for some polynomial ring R = mathbb kx_1dotsx_n and an ideal I subset R. More generally, we can form the Spec of any localized affine algebra L as an  instance of ","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"Spec{BRT, BRET, RT, RET, MST}","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/#Spec","page":"General schemes","title":"Spec","text":"Spec{BRT, BRET, RT, RET, MST} <: Scheme{BRT, BRET}\n\nAn affine scheme X = Spec ((RI)S¹) with R = kx₁xₙ a free  polynomial algebra of type RT over a base ring k of type  BRT, I  R a finitely generated ideal  with elements of type RET, and S a multiplicative set in R of  type MST.\n\n\n\n\n\n","category":"type"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"Internally, this merely stores an instance L of MPolyQuoLocalizedRing. This ring can be obtained using ","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"OO(X::Spec)","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/#OO-Tuple{Spec}","page":"General schemes","title":"OO","text":"OO(X::Spec)\n\nFor X = Spec ((𝕜x₁xₙI)S¹) this returns (𝕜x₁xₙI)S¹.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"One of the main reasons to allow such general schemes is that principal open subsets  U =  f neq 0 of affine schemes X, f in mathcal O_X(X) are again  affine; basically due to Rabinowitsch's trick:","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"    U = mathrmSpec left(mathcal O_X(X)f^-1right) = mathrmSpec left(mathcal O_X(X)tlangle 1 - tcdot f rangleright)","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"This flexibility allows us to introduce and handle subschemes using the natural  relations on their rings. Thus, we can, for instance, define subschemes via ","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"subscheme(X::Spec{BRT, BRET, RT, RET, MST}, f::RET) where {BRT, BRET, RT, RET, MST}\nhypersurface_complement(X::Spec{BRT, BRET, RT, RET, MST}, f::RET) where {BRT, BRET, RT, RET, MST<:MPolyPowersOfElement{BRT, BRET, RT, RET}}","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/#subscheme-Union{Tuple{MST}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}, Tuple{Spec{BRT, BRET, RT, RET, MST}, RET}} where {BRT, BRET, RT, RET, MST}","page":"General schemes","title":"subscheme","text":"subscheme(X::Spec{BRT, BRET, RT, RET, MST}, f::RET) where {BRT, BRET, RT, RET, MST}\n\nFor a scheme X = Spec ((𝕜x₁xₙI)S¹) and an element f  𝕜x₁xₙ  this returns the closed subscheme defined by the ideal I = I + f.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AffineSchemes/#hypersurface_complement-Union{Tuple{MST}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}, Tuple{Spec{BRT, BRET, RT, RET, MST}, RET}} where {BRT, BRET, RT, RET, MST<:MPolyPowersOfElement{BRT, BRET, RT, RET}}","page":"General schemes","title":"hypersurface_complement","text":"hypersurface_complement(X::Spec{BRT, BRET, RT, RET, MST}, f::RET) where {BRT, BRET, RT, RET, MST<:MPolyPowersOfElement{BRT, BRET, RT, RET}}\n\nFor a scheme X = Spec ((𝕜x₁xₙI)S¹) and an element f  𝕜x₁xₙ  this returns the open subscheme U = X  V(f) defined by the complement of the vanishing  locus of f.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"Containments can be checked using ","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"issubset(\n  X::Spec{BRT, BRET, RT, RET, MST1}, \n  Y::Spec{BRT, BRET, RT, RET, MST2}\n) where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}\nis_closed_embedding(\n  X::Spec{BRT, BRET, RT, RET, MST1}, \n  Y::Spec{BRT, BRET, RT, RET, MST2}\n) where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}\nis_open_embedding(\n  X::Spec{BRT, BRET, RT, RET, MST1}, \n  Y::Spec{BRT, BRET, RT, RET, MST2}\n) where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/#issubset-Union{Tuple{MST2}, Tuple{MST1}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}, Tuple{Spec{BRT, BRET, RT, RET, MST1}, Spec{BRT, BRET, RT, RET, MST2}}} where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}","page":"General schemes","title":"issubset","text":"issubset(\n  X::Spec{BRT, BRET, RT, RET, MST1}, \n  Y::Spec{BRT, BRET, RT, RET, MST2}\n) where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}\n\nChecks whether X is a subset of Y based on the comparison of their coordinate rings.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AffineSchemes/#is_closed_embedding-Union{Tuple{MST2}, Tuple{MST1}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}, Tuple{Spec{BRT, BRET, RT, RET, MST1}, Spec{BRT, BRET, RT, RET, MST2}}} where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}","page":"General schemes","title":"is_closed_embedding","text":"is_closed_embedding(\n  X::Spec{BRT, BRET, RT, RET, MST1}, \n  Y::Spec{BRT, BRET, RT, RET, MST2}\n) where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}\n\nChecks whether X is closed embedded in Y.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AffineSchemes/#is_open_embedding-Union{Tuple{MST2}, Tuple{MST1}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}, Tuple{Spec{BRT, BRET, RT, RET, MST1}, Spec{BRT, BRET, RT, RET, MST2}}} where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}","page":"General schemes","title":"is_open_embedding","text":"is_open_embedding(\n  X::Spec{BRT, BRET, RT, RET, MST1}, \n  Y::Spec{BRT, BRET, RT, RET, MST2}\n) where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}\n\nChecks whether X is openly embedded in Y.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"The closure of a subscheme can be computed via","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"closure(\n  X::Spec{BRT, BRET, RT, RET, MST1}, \n  Y::Spec{BRT, BRET, RT, RET, MST2}\n) where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/#closure-Union{Tuple{MST2}, Tuple{MST1}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}, Tuple{Spec{BRT, BRET, RT, RET, MST1}, Spec{BRT, BRET, RT, RET, MST2}}} where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}","page":"General schemes","title":"closure","text":"closure(\n  X::Spec{BRT, BRET, RT, RET, MST1}, \n  Y::Spec{BRT, BRET, RT, RET, MST2}\n) where {BRT, BRET, RT, RET, MST1<:MPolyPowersOfElement{BRT, BRET, RT, RET}, MST2<:MPolyPowersOfElement{BRT, BRET, RT, RET}}\n\nReturns the closure of X in Y.\n\n\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"Among the basic functionality for affine schemes we have ","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/","page":"General schemes","title":"General schemes","text":"product(X::Spec{BRT, BRET, RT, RET, MST}, Y::Spec{BRT, BRET, RT, RET, MST}) where {BRT, BRET, RT, RET, MST<:MPolyPowersOfElement}","category":"page"},{"location":"AlgebraicGeometry/AffineSchemes/#product-Union{Tuple{MST}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}, Tuple{Spec{BRT, BRET, RT, RET, MST}, Spec{BRT, BRET, RT, RET, MST}}} where {BRT, BRET, RT, RET, MST<:MPolyPowersOfElement}","page":"General schemes","title":"product","text":"product(X::Spec{BRT, BRET, RT, RET, MST}, Y::Spec{BRT, BRET, RT, RET, MST}) where {BRT, BRET, RT, RET, MST<:MPolyPowersOfElement}\n\nReturns a triple (XY p₁ p₂) consisting of the product XY and the two projections  p₁  XY  X and p₂  XY  Y.\n\n\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#Orders","page":"Orders","title":"Orders","text":"","category":"section"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"Orders, that is, unitary subrings that are free mathbfZ-modules of rank equal to the degree of the number field, are at the core of the arithmetic of number fields. In Hecke, orders are always represented using the module structure, be it the mathbfZ-module structure for orders of absolute numbers fields, or the structure as a module over the maximal order of the base field in the case of relative number fields. In this chapter we mainly deal with orders of absolute fields. However, many functions apply in same way to relative extensions. There are more general definitions of orders in number fields available, but those are (currently) not implemented in Hecke.","category":"page"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"Among all orders in a fixed field, there is a unique maximal order, called the maximal order, or ring of integers of the number field. It is well known that this is the only order that is a Dedekind domain, hence has a rich ideal structure as well. The maximal order is also the integral closure of mathbfZ in the number field and can also be interpreted as a normalization of any other order.","category":"page"},{"location":"Hecke/orders/orders/#Creation-and-basic-properties","page":"Orders","title":"Creation and basic properties","text":"","category":"section"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"Order(::AnticNumberField, ::Vector{nf_elem})\nOrder(::AnticNumberField, ::FakeFmpqMat)\nOrder(::NfOrdFracIdl)\nEquationOrder(::AnticNumberField)\nMaximalOrder(::AnticNumberField)\nMaximalOrder(::NfOrd)\nlll(::NfOrd)\nany_order(K::AnticNumberField)","category":"page"},{"location":"Hecke/orders/orders/#Order-Tuple{AnticNumberField, Vector{nf_elem}}","page":"Orders","title":"Order","text":"Order(B::Vector{nf_elem}; check::Bool = true, cached::Bool = true, isbasis::Bool = false) -> NfOrd\nOrder(K::AnticNumberField, B::Vector{nf_elem}; check::Bool = true, cached::Bool = true, isbasis::Bool = false) -> NfOrd\n\nReturns the order generated by B. If check is set, it is checked whether B defines an order. If isbasis is set, then elements are assumed to form a mathbfZ-basis.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#Order-Tuple{AnticNumberField, FakeFmpqMat}","page":"Orders","title":"Order","text":"Order(K::AnticNumberField, A::FakeFmpqMat; check::Bool = true) -> NfOrd\n\nReturns the order which has basis matrix A with respect to the power basis of K. If check is set, it is checked whether A defines an order.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#Order-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}","page":"Orders","title":"Order","text":"Order(K::AnticNumberField, A::fmpz_mat, check::Bool = true) -> NfOrd\n\nReturns the order which has basis matrix A with respect to the power basis of K. If check is set, it is checked whether A defines an order.\n\n\n\nOrder(A::AbsAlgAss{<: NumFieldElem}, M::PMat{<: NumFieldElem, T})\n  -> AlgAssRelOrd\n\nReturns the order of A with basis pseudo-matrix M.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#EquationOrder-Tuple{AnticNumberField}","page":"Orders","title":"EquationOrder","text":"EquationOrder(K::NumberField) -> NumFieldOrd\nequation_order(K::NumberField) -> NumFieldOrd\n\nReturns the equation order of the number field K.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#MaximalOrder-Tuple{AnticNumberField}","page":"Orders","title":"MaximalOrder","text":"MaximalOrder(K::NumField{fmpq}; discriminant::fmpz, ramified_primes::Vector{fmpz}) -> NfAbsOrd\n\nReturns the maximal order of K. Additional information can be supplied if they are already known, as the ramified primes or the discriminant of the maximal order.\n\nExample\n\njulia> Qx, x = FlintQQ[\"x\"];\njulia> K, a = NumberField(x^3 + 2, \"a\");\njulia> O = MaximalOrder(K);\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#MaximalOrder-Tuple{NfOrd}","page":"Orders","title":"MaximalOrder","text":"MaximalOrder(O::NfAbsOrd; index_divisors::Vector{fmpz}, discriminant::fmpz, ramified_primes::Vector{fmpz}) -> NfAbsOrd\n\nReturns the maximal order of the number field that contains O. Additional information can be supplied if they are already known, as the ramified primes, the discriminant of the maximal order or a set of integers dividing the index of O in the maximal order.\n\n\n\nMaximalOrder(O::AlgAssAbsOrd)\n\nGiven an order O, this function returns a maximal order containing O.\n\n\n\nMaximalOrder(A::AbsAlgAss{fmpq}) -> AlgAssAbsOrd\n\nReturns a maximal order of A.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#lll-Tuple{NfOrd}","page":"Orders","title":"lll","text":"lll(M::NfAbsOrd) -> NfAbsOrd\n\nThe same order, but with the basis now being LLL reduced wrt. the Minkowski metric.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#any_order-Tuple{AnticNumberField}","page":"Orders","title":"any_order","text":"any_order(K::NumberField)\n\nReturn some order in K. In case the defining polynomial for K is monic and integral, this just returns the equation order. In the other case mathbb Zalphacap mathbb Z1alpha is returned.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#Example","page":"Orders","title":"Example","text":"","category":"section"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"using Hecke; # hide\nQx, x = PolynomialRing(FlintQQ, \"x\");\nK, a = NumberField(x^2 - 2, \"a\");\nO = EquationOrder(K)","category":"page"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"parent(::NfOrd)\nsignature(::NfOrd)\nnf(::NfOrd)\nbasis(::NfOrd)\nlll_basis(::NfOrd)\nbasis(::NfOrd, ::AnticNumberField)\npseudo_basis(::NfRelOrd)\nbasis_pmatrix(::NfRelOrd)\nbasis_nf(::NfRelOrd)\ninv_coeff_ideals(::NfRelOrd)\nbasis_matrix(::NfAbsOrd)\nbasis_mat_inv(::NfOrd)\ngen_index(::NfOrd)\nisindex_divisor(::NfOrd, ::fmpz)\nminkowski_matrix(::NfOrd, ::Int)\nin(::nf_elem, ::NfOrd)\nnorm_change_const(::NfOrd)\ntrace_matrix(::NfOrd)\n+(::NfAbsOrd, ::NfAbsOrd)\npoverorder(::NfOrd, ::fmpz)\npoverorders(::NfOrd, ::fmpz)\npmaximal_overorder(::NfOrd, ::fmpz)\npradical(::NfAbsOrd, ::Union{Integer, fmpz})\npradical(::NfRelOrd, ::Union{Hecke.NfRelOrdIdl, NfOrdIdl})\nring_of_multipliers(::NfAbsOrdIdl)\n","category":"page"},{"location":"Hecke/orders/orders/#parent-Tuple{NfOrd}","page":"Orders","title":"parent","text":"parent(O::NfAbsOrd) -> NfOrdSet\n\nReturns the parent of mathcal O, that is, the set of orders of the ambient number field.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#signature-Tuple{NfOrd}","page":"Orders","title":"signature","text":"signature(O::NumFieldOrd) -> Tuple{Int, Int}\n\nReturns the signature of the ambient number field of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#nf-Tuple{NfOrd}","page":"Orders","title":"nf","text":"nf(O::NumFieldOrd) -> NumField\n\nReturns the ambient number field of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#basis-Tuple{NfOrd}","page":"Orders","title":"basis","text":"basis(O::NfAbsOrd) -> Vector{NfAbsOrdElem}\n\nReturns the mathbf Z-basis of mathcal O.\n\n\n\nbasis(I::NfAbsOrdFracIdl) -> Vector{nf_elem}\n\nReturns the mathbf Z-basis of I.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#lll_basis-Tuple{NfOrd}","page":"Orders","title":"lll_basis","text":"lll_basis(M::NumFieldOrd) -> Vector{NumFieldElem}\n\nA basis for M that is reduced using the LLL algorithm for the Minkowski metric.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#basis-Tuple{NfOrd, AnticNumberField}","page":"Orders","title":"basis","text":"basis(O::NfOrd, K::AnticNumberField) -> Vector{nf_elem}\n\nReturns the mathbf Z-basis elements of mathcal O as elements of the ambient number field.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#pseudo_basis-Tuple{Hecke.NfRelOrd}","page":"Orders","title":"pseudo_basis","text":"  pseudo_basis(O::NfRelOrd{T, S}) -> Vector{Tuple{NumFieldElem{T}, S}}\n\nReturns the pseudo-basis of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#basis_pmatrix-Tuple{Hecke.NfRelOrd}","page":"Orders","title":"basis_pmatrix","text":"  basis_pmatrix(O::NfRelOrd) -> PMat\n\nReturns the basis pseudo-matrix of mathcal O with respect to the power basis of the ambient number field.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#basis_nf-Tuple{Hecke.NfRelOrd}","page":"Orders","title":"basis_nf","text":"  basis_nf(O::NfRelOrd) -> Vector{NumFieldElem}\n\nReturns the elements of the pseudo-basis of mathcal O as elements of the ambient number field.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#inv_coeff_ideals-Tuple{Hecke.NfRelOrd}","page":"Orders","title":"inv_coeff_ideals","text":"  inv_coeff_ideals(O::NfRelOrd{T, S}) -> Vector{S}\n\nReturns the inverses of the coefficient ideals of the pseudo basis of O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#basis_matrix-Tuple{NfAbsOrd}","page":"Orders","title":"basis_matrix","text":"basis_matrix(O::NfAbsOrd) -> FakeFmpqMat\n\nReturns the basis matrix of mathcal O with respect to the basis of the ambient number field.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#basis_mat_inv-Tuple{NfOrd}","page":"Orders","title":"basis_mat_inv","text":"basis_mat_inv(O::NfAbsOrd) -> FakeFmpqMat\n\nReturns the inverse of the basis matrix of mathcal O.\n\n\n\nbasis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat\n\nReturns the inverse basis matrix of A.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#gen_index-Tuple{NfOrd}","page":"Orders","title":"gen_index","text":"gen_index(O::NfOrd) -> fmpq\n\nReturns the generalized index of mathcal O with respect to the equation order of the ambient number field.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#isindex_divisor-Tuple{NfOrd, fmpz}","page":"Orders","title":"isindex_divisor","text":"isindex_divisor(O::NfOrd, d::fmpz) -> Bool\nisindex_divisor(O::NfOrd, d::Int) -> Bool\n\nReturns whether d is a divisor of the index of mathcal O. It is assumed that mathcal O contains the equation order of the ambient number field.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#minkowski_matrix-Tuple{NfOrd, Int64}","page":"Orders","title":"minkowski_matrix","text":"minkowski_matrix(O::NfAbsOrd, abs_tol::Int = 64) -> arb_mat\n\nReturns the Minkowski matrix of mathcal O.  Thus if mathcal O has degree d, then the result is a matrix in operatornameMat_dtimes d(mathbf R). The entries of the matrix are real balls of type arb with radius less then 2^-abs_tol.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#in-Tuple{nf_elem, NfOrd}","page":"Orders","title":"in","text":"in(a::NumFieldElem, O::NumFieldOrd) -> Bool\n\nChecks whether a lies in mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#norm_change_const-Tuple{NfOrd}","page":"Orders","title":"norm_change_const","text":"norm_change_const(O::NfOrd) -> (Float64, Float64)\n\nReturns (c_1 c_2) in mathbf R_0^2 such that for all x = sum_i=1^d x_i omega_i in mathcal O we have T_2(x) leq c_1 cdot sum_i^d x_i^2 and sum_i^d x_i^2 leq c_2 cdot T_2(x), where (omega_i)_i is the mathbf Z-basis of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#trace_matrix-Tuple{NfOrd}","page":"Orders","title":"trace_matrix","text":"trace_matrix(O::NfAbsOrd) -> fmpz_mat\n\nReturns the trace matrix of mathcal O, that is, the matrix (operatornametr_Kmathbf Q(b_i cdot b_j))_1 leq i j leq d.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#+-Tuple{NfAbsOrd, NfAbsOrd}","page":"Orders","title":"+","text":"+(R::NfOrd, S::NfOrd) -> NfOrd\n\nGiven two orders R, S of K, this function returns the smallest order containing both R and S. It is assumed that R, S contain the ambient equation order and have coprime index.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#poverorder-Tuple{NfOrd, fmpz}","page":"Orders","title":"poverorder","text":"poverorder(O::NfOrd, p::fmpz) -> NfOrd\npoverorder(O::NfOrd, p::Integer) -> NfOrd\n\nThis function tries to find an order that is locally larger than mathcal O at the prime p: If p divides the index  mathcal O_K  mathcal O, this function will return an order R such that v_p( mathcal O_K  R)  v_p( mathcal O_K  mathcal O). Otherwise mathcal O is returned.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#poverorders-Tuple{NfOrd, fmpz}","page":"Orders","title":"poverorders","text":"poverorders(O, p) -> Vector{Ord}\n\nReturns all p-overorders of O, that is all overorders M, such that the index of O in M is a p-power.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#pmaximal_overorder-Tuple{NfOrd, fmpz}","page":"Orders","title":"pmaximal_overorder","text":"pmaximal_overorder(O::NfOrd, p::fmpz) -> NfOrd\npmaximal_overorder(O::NfOrd, p::Integer) -> NfOrd\n\nThis function finds a p-maximal order R containing mathcal O. That is, the index  mathcal O_K  R is not divisible by p.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#pradical-Tuple{NfAbsOrd, Union{Integer, fmpz}}","page":"Orders","title":"pradical","text":"pradical(O::NfOrd, p::{fmpz|Integer}) -> NfAbsOrdIdl\n\nGiven a prime number p, this function returns the p-radical sqrtpmathcal O of mathcal O, which is just  x in mathcal O mid exists k in mathbf Z_geq 0 colon x^k in pmathcal O . It is not checked that p is prime.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#pradical-Tuple{Hecke.NfRelOrd, Union{Hecke.NfRelOrdIdl, NfOrdIdl}}","page":"Orders","title":"pradical","text":"  pradical(O::NfRelOrd, P::NfOrdIdl) -> NfRelOrdIdl\n\nGiven a prime ideal P, this function returns the P-radical sqrtPmathcal O of mathcal O, which is just  x in mathcal O mid exists k in mathbf Z_geq 0 colon x^k in Pmathcal O . It is not checked that P is prime.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#ring_of_multipliers-Tuple{NfAbsOrdIdl}","page":"Orders","title":"ring_of_multipliers","text":"ring_of_multipliers(I::NfAbsOrdIdl) -> NfAbsOrd\n\nComputes the order (I  I), which is the set of all x in K with xI subseteq I.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#Invariants","page":"Orders","title":"Invariants","text":"","category":"section"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"discriminant(::NfOrd)\ndiscriminant(::NfAbsOrd)\nreduced_discriminant(::NfOrd)\ndegree(::NfOrd)\nindex(::NfOrd)\ndifferent(::NfOrd)\ncodifferent(::NfOrd)\nisgorenstein(::NfOrd)\nisbass(::NfOrd)\nisequation_order(::NfOrd)\nzeta_log_residue(::NfOrd, ::Float64)\nramified_primes(::NfOrd)","category":"page"},{"location":"Hecke/orders/orders/#discriminant-Tuple{NfOrd}","page":"Orders","title":"discriminant","text":"discriminant(O::NfOrd) -> fmpz\n\nReturns the discriminant of mathcal O.\n\n\n\ndiscriminant(E::EllCrv{T}) -> T\n\nComputes the discriminant of E.\n\n\n\ndiscriminant(O::AlgssRelOrd)\n\nReturns the discriminant of O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#discriminant-Tuple{NfAbsOrd}","page":"Orders","title":"discriminant","text":"discriminant(O::NfOrd) -> fmpz\n\nReturns the discriminant of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#reduced_discriminant-Tuple{NfOrd}","page":"Orders","title":"reduced_discriminant","text":"reduced_discriminant(O::NfOrd) -> fmpz\n\nReturns the reduced discriminant, that is, the largest elementary divisor of the trace matrix of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#degree-Tuple{NfOrd}","page":"Orders","title":"degree","text":"degree(O::NumFieldOrd) -> Int\n\nReturns the degree of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#index-Tuple{NfOrd}","page":"Orders","title":"index","text":"index(O::NfOrd) -> fmpz\n\nAssuming that the order mathcal O contains the equation order mathbf Zalpha of the ambient number field, this function returns the index  mathcal O  mathbf Z.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#different-Tuple{NfOrd}","page":"Orders","title":"different","text":"different(R::NfAbsOrd) -> NfAbsOrdIdl\n\nThe differnt ideal of R, that is, the ideal generated by all differents of elements in R. For Gorenstein orders, this is also the inverse ideal of the co-different.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#codifferent-Tuple{NfOrd}","page":"Orders","title":"codifferent","text":"codifferent(R::NfAbsOrd) -> NfOrdIdl\n\nThe codiffernt ideal of R, i.e. the trace-dual of R.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#isgorenstein-Tuple{NfOrd}","page":"Orders","title":"isgorenstein","text":"isgorenstein(O::NfOrd) -> Bool\n\nReturn whether the order \\mathcal{O} is Gorenstein.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#isbass-Tuple{NfOrd}","page":"Orders","title":"isbass","text":"isbass(O::NfOrd) -> Bool\n\nReturn whether the order \\mathcal{O} is Bass.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#isequation_order-Tuple{NfOrd}","page":"Orders","title":"isequation_order","text":"isequation_order(O::NumFieldOrd) -> Bool\n\nReturns whether mathcal O is the equation order of the ambient number field K.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#zeta_log_residue-Tuple{NfOrd, Float64}","page":"Orders","title":"zeta_log_residue","text":"zeta_log_residue(O::NfOrd, error::Float64) -> arb\n\nComputes the residue of the zeta function of mathcal O at 1. The output will be an element of type arb with radius less then error.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#ramified_primes-Tuple{NfOrd}","page":"Orders","title":"ramified_primes","text":"ramified_primes(O::NfAbsOrd) -> Vector{fmpz}\n\nReturns the list of prime numbers that divide operatornamedisc(mathcal O).\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#Arithmetic","page":"Orders","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"Progress and intermediate results of the functions mentioned here can be obtained via verbose_level, supported are","category":"page"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"ClassGroup\nUnitGroup","category":"page"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"All of the functions have a very similar interface: they return an abelian group and a map converting elements of the group into the objects required. The maps also allow a point-wise inverse to server as the discrete logarithm map. For more information on abelian group, see here, for ideals, here.","category":"page"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"torsion_unit_group(::NfOrd)\nunit_group(::NfOrd)\nunit_group_fac_elem(::NfOrd)\nsunit_group(::Vector{NfOrdIdl})\nsunit_group_fac_elem(::Vector{NfOrdIdl})\nsunit_mod_units_group_fac_elem(::Vector{NfOrdIdl})\nclass_group(::NfOrd)\npicard_group(::NfOrd)\nnarrow_class_group(::NfOrd)","category":"page"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"For the processing of units, there are a couple of helper functions also available:","category":"page"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"isindependent","category":"page"},{"location":"Hecke/orders/orders/#isindependent","page":"Orders","title":"isindependent","text":"isindependent{T}(x::Vector{T})\n\nGiven an array of non-zero units in a number field, returns whether they are multiplicatively independent.\n\n\n\n","category":"function"},{"location":"Hecke/orders/orders/#Predicates","page":"Orders","title":"Predicates","text":"","category":"section"},{"location":"Hecke/orders/orders/","page":"Orders","title":"Orders","text":"Hecke.iscontained(::NfAbsOrd, ::NfAbsOrd)\nismaximal(::NfAbsOrd)","category":"page"},{"location":"Hecke/orders/orders/#iscontained-Tuple{NfAbsOrd, NfAbsOrd}","page":"Orders","title":"iscontained","text":"iscontained(R::NfAbsOrd, S::NfAbsOrd) -> Bool\n\nChecks if R is contained in S.\n\n\n\n","category":"method"},{"location":"Hecke/orders/orders/#ismaximal-Tuple{NfAbsOrd}","page":"Orders","title":"ismaximal","text":"ismaximal(R::NfAbsOrd) -> Bool\n\nTests if the order R is maximal. This might trigger the computation of the maximal order.\n\n\n\n","category":"method"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"using Oscar","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"Pages = [\"permgroup.md\"]","category":"page"},{"location":"Groups/permgroup/#Permutation-groups","page":"Permutation groups","title":"Permutation groups","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"Permutation groups can be defined as symmetric groups, alternating groups or their subgroups.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"PermGroup\nPermGroupElem\nsymmetric_group\nisnatural_symmetric_group(G::GAPGroup)\nisisomorphic_with_symmetric_group(G::GAPGroup)\nalternating_group\nisnatural_alternating_group(G::GAPGroup)\nisisomorphic_with_alternating_group(G::GAPGroup)","category":"page"},{"location":"Groups/permgroup/#PermGroup","page":"Permutation groups","title":"PermGroup","text":"PermGroup\n\nGroups of permutations. Every group of this type is the subgroup of Sym(n) for some n.\n\nExamples\n\nsymmetric_group(n::Int): the symmetric group Sym(n)\nalternating_group(n::Int): the alternating group Alt(n)\nsubgroups of Sym(n)\ndihedral_group(PermGroup, n::Int): the dihedral group of order n as a group of permutations. Same holds replacing dihedral_group by quaternion_group\n\n\n\n\n\n","category":"type"},{"location":"Groups/permgroup/#PermGroupElem","page":"Permutation groups","title":"PermGroupElem","text":"PermGroupElem\n\nElement of a group of permutations. It is displayed as product of disjoint cycles.\n\nAssumptions:\n\nfor x,y in Sym(n), the product xy is read from left to right;\nfor x in Sym(n) and i in {1,...,n}, i^x and x(i) return the image of i under the action of x.\n\n\n\n\n\n","category":"type"},{"location":"Groups/permgroup/#symmetric_group","page":"Permutation groups","title":"symmetric_group","text":"symmetric_group(::Type{T} = PermGroup, n::Int)\n\nReturn the full symmetric group on the set {1, 2, ..., n}, as an instance of T, where T is in {PermGroup, PcGroup}.\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#isnatural_symmetric_group-Tuple{Oscar.GAPGroup}","page":"Permutation groups","title":"isnatural_symmetric_group","text":"isnatural_symmetric_group(G::GAPGroup)\n\nReturn true if G is a permutation group acting as the symmetric group on its moved points, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#isisomorphic_with_symmetric_group-Tuple{Oscar.GAPGroup}","page":"Permutation groups","title":"isisomorphic_with_symmetric_group","text":"isisomorphic_with_symmetric_group(G::GAPGroup)\n\nReturn true if G is isomorphic with a symmetric group, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#alternating_group","page":"Permutation groups","title":"alternating_group","text":"alternating_group(::Type{T} = PermGroup, n::Int)\n\nReturn the full alternating group on the set {1, 2, ..., n}, as an instance of T, where T is in {PermGroup, PcGroup}.\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#isnatural_alternating_group-Tuple{Oscar.GAPGroup}","page":"Permutation groups","title":"isnatural_alternating_group","text":"isnatural_alternating_group(G::GAPGroup)\n\nReturn true if G is a permutation group acting as the alternating group on its moved points, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#isisomorphic_with_alternating_group-Tuple{Oscar.GAPGroup}","page":"Permutation groups","title":"isisomorphic_with_alternating_group","text":"isisomorphic_with_alternating_group(G::GAPGroup)\n\nReturn true if G is isomorphic with an alternating group, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"In Oscar, every permutation group has a degree n, that corresponds to the size of the set on which G acts.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"degree(x::PermGroup)","category":"page"},{"location":"Groups/permgroup/#degree-Tuple{PermGroup}","page":"Permutation groups","title":"degree","text":"degree(G::PermGroup) -> Int\n\nReturn the degree of G as a permutation group, that is, an integer n that is stored in G, with the following meaning.\n\nG embeds into symmetric_group(n).\nTwo permutation groups of different degrees are regarded as not equal, even if they contain the same permutations.\nSubgroups constructed with derived_subgroup, sylow_subgroup, etc., get the same degree as the given group.\nThe range 1:degree(G) is used as the default set of points on which G and its element acts.\n\nnote: Note\nThe degree of a group of permutations is not necessarily equal to the largest moved point of the group G. For example, the trivial subgroup of symmetric_group(n) has degree n even though it fixes n.\n\nExamples\n\njulia> degree(symmetric_group(4))\n4\n\njulia> t4 = trivial_subgroup(symmetric_group(4))[1];\n\njulia> degree(t4)\n4\n\njulia> t4 == trivial_subgroup(symmetric_group(5))[1]\nfalse\n\njulia> show(Vector(gen(symmetric_group(4), 2)))\n[2, 1, 3, 4]\njulia> show(Vector(gen(symmetric_group(5), 2)))\n[2, 1, 3, 4, 5]\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#Permutations","page":"Permutation groups","title":"Permutations","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"Permutations in Oscar are displayed as products of disjoint cycles, as in GAP. An explicit permutation can be built using the functions perm, gap_perm and cperm.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"perm\ngap_perm\ncperm","category":"page"},{"location":"Groups/permgroup/#perm","page":"Permutation groups","title":"perm","text":"perm(G::PermGroup, L::AbstractVector{<:IntegerUnion})\n(G::PermGroup)(L::AbstractVector{<:IntegerUnion})\n\nReturn the permutation x which maps every i from 1 to n= length(L) to Li. The parent of x is G. An exception is thrown if x is not contained in G or L does not contain every integer from 1 to n exactly once.\n\nFor gap_perm, the parent group of x is set to symmetric_group(n).\n\nExamples\n\njulia> perm(symmetric_group(6),[2,4,6,1,3,5])\n(1,2,4)(3,6,5)\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#gap_perm","page":"Permutation groups","title":"gap_perm","text":"gap_perm(L::AbstractVector{<:IntegerUnion})\n\nReturn the permutation x which maps every i from 1 to n= length(L) to Li. The parent of x is set to symmetric_group(n). An exception is thrown if L does not contain every integer from 1 to n exactly once.\n\nExamples\n\njulia> gap_perm([2,4,6,1,3,5])\n(1,2,4)(3,6,5)\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#cperm","page":"Permutation groups","title":"cperm","text":"cperm(L::AbstractVector{<:T}...) where T <: IntegerUnion\ncperm(G::PermGroup, L::AbstractVector{<:T}...)\n\nFor given lists a_1 a_2 ldots a_n b_1 b_2 ldots  b_m ldots of positive integers, return the permutation x = (a_1 a_2 ldots a_n) * (b_1 b_2 ldots b_m) * ldots. Arrays of the form [n, n+1, ..., n+k] can be replaced by n:n+k.\n\nThe parent of x is G. If G is not specified then the parent of x is set to symmetric_group(n), where n is the largest integer that occurs in an entry of L.\n\nAn exception is thrown if x is not contained in G or one of the given vectors is empty or contains duplicates.\n\nExamples\n\njulia> cperm([1,2,3],4:7)\n(1,2,3)(4,5,6,7)\n\njulia> cperm([1,2],[2,3])\n(1,3,2)\n\njulia> p = cperm([1,2,3],[7])\n(1,2,3)\n\njulia> degree(parent(p))\n7\n\n\nAt the moment, the input vectors of the function cperm need not be disjoint.\n\nwarning: Warning\nIf the function perm is evaluated in a vector of integers without specifying the group G, then the returned value is an element of the AbstractAlgebra.jl type Perm{Int}. For this reason, if one wants a permutation of type GAPGroupElem{PermGroup} without specifying a parent, one has to use the function gap_perm.\n\n\n\n","category":"function"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"Every permutation has always a permutation group as a parent. Two permutations coincide if, and only if, they move the same points and their parent groups have the same degree.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"julia> G=symmetric_group(5);\n\njulia> A=alternating_group(5);\n\njulia> x=cperm(G,[1,2,3]);\n\njulia> y=cperm(A,[1,2,3]);\n\njulia> z=cperm([1,2,3]); parent(z)\nSym( [ 1 .. 3 ] )\n\njulia> x==y\ntrue\n\njulia> x==z\nfalse","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"In the example above, x and y are equal because both act on a set of cardinality 5, while x and z are different because x belongs to Sym(5) and z belongs to Sym(3).","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"If G is a group and x is a permutation, G(x) returns a permutation x with parent G; an exception is thrown if x does not embed into G.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"G=symmetric_group(5);\nx=cperm([1,2,3]);\ny=G(x);\nparent(x)\nparent(y)","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"The function Vector{T} works in the opposite way with respect to perm:","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"Vector(x::PermGroupElem, n::Int = x.parent.deg)","category":"page"},{"location":"Groups/permgroup/#Vector","page":"Permutation groups","title":"Vector","text":"Vector{T}(x::PermGroupElem, n::Int = x.parent.deg) where T <: IntegerUnion\nVector(x::PermGroupElem, n::Int = x.parent.deg)\n\nReturn the list of length n that contains x(i) at position i. If not specified, T is set as Int.\n\nExamples\n\njulia> pi = cperm(1:3)\n(1,2,3)\njulia> Vector(pi)\n3-element Vector{Int64}:\n 2\n 3\n 1\njulia> Vector(pi, 2)\n2-element Vector{Int64}:\n 2\n 3\njulia> Vector(pi, 4)\n4-element Vector{Int64}:\n 2\n 3\n 1\n 4\njulia> Vector{fmpz}(pi, 2)\n2-element Vector{fmpz}:\n 2\n 3\n\n\n\n\n\n\n","category":"type"},{"location":"Groups/permgroup/#Operations-on-permutations","page":"Permutation groups","title":"Operations on permutations","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"sign(g::PermGroupElem)\nisodd(g::PermGroupElem)\niseven(g::PermGroupElem)\ncycle_structure(g::PermGroupElem)","category":"page"},{"location":"Groups/permgroup/#sign-Tuple{PermGroupElem}","page":"Permutation groups","title":"sign","text":"sign(g::PermGroupElem)\n\nReturn the sign of the permutation g.\n\nThe sign of a permutation g is defined as (-1)^k where k is the number of cycles of g of even length.\n\nExamples\n\njulia> sign(cperm(1:2))\n-1\n\njulia> sign(cperm(1:3))\n1\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#isodd-Tuple{PermGroupElem}","page":"Permutation groups","title":"isodd","text":"isodd(g::PermGroupElem)\n\nReturn true if the permutation g is odd, false otherwise.\n\nA permutation is odd if it has an odd number of cycles of even length. Equivalently, a permutation is odd if it has sign -1.\n\nExamples\n\njulia> isodd(cperm(1:2))\ntrue\n\njulia> isodd(cperm(1:3))\nfalse\n\njulia> isodd(cperm(1:2,3:4))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#iseven-Tuple{PermGroupElem}","page":"Permutation groups","title":"iseven","text":"iseven(g::PermGroupElem)\n\nReturn true if the permutation g is even, false otherwise.\n\nA permutation is even if it has an even number of cycles of even length. Equivalently, a permutation is even if it has sign +1.\n\nExamples\n\njulia> iseven(cperm(1:2))\nfalse\n\njulia> iseven(cperm(1:3))\ntrue\n\njulia> iseven(cperm(1:2,3:4))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#cycle_structure-Tuple{PermGroupElem}","page":"Permutation groups","title":"cycle_structure","text":"cycle_structure(g::PermGroupElem)\n\nReturn the cycle structure of the permutation g as a cycle type. A cycle type behaves similar to a vector of pairs k => n indicating that there are n cycles of length k.\n\nExamples\n\njulia> g = cperm(1:3, 4:5, 6:7, 8:10, 11:15)\n(1,2,3)(4,5)(6,7)(8,9,10)(11,12,13,14,15)\n\njulia> cycle_structure(g)\n3-element Oscar.CycleType:\n 2 => 2\n 3 => 2\n 5 => 1\n\njulia> cperm()\n()\n\njulia> cycle_structure(ans)\n1-element Oscar.CycleType:\n 1 => 1\n\n\n\n\n\n","category":"method"},{"location":"Groups/permgroup/#Permutations-as-functions","page":"Permutation groups","title":"Permutations as functions","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"A permutation can be viewed as a function on the set {1,...,n}, hence it can be evaluated on integers.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"note: Note\nThe multiplication between permutations works from the left to the right. So, if x and y are permutations and n is an integer, then (x*y)(n) = (y(x(n)), NOT x(y(n)). This works also if the argument is not in the range 1:n; in such a case, the output coincides with the input.","category":"page"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"julia> x = cperm([1,2,3,4,5]);\n\njulia> x(2)\n3\n\njulia> x(6)\n6","category":"page"},{"location":"Groups/permgroup/#Operations-for-permutation-groups","page":"Permutation groups","title":"Operations for permutation groups","text":"","category":"section"},{"location":"Groups/permgroup/","page":"Permutation groups","title":"Permutation groups","text":"istransitive(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\ntransitivity(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\nisprimitive(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\nisregular(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\nissemiregular(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\nblocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\nmaximal_blocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\nrepresentatives_minimal_blocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\nall_blocks(G::PermGroup)","category":"page"},{"location":"Groups/permgroup/#istransitive","page":"Permutation groups","title":"istransitive","text":"istransitive(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn whether the action of G on L is transitive.\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#transitivity","page":"Permutation groups","title":"transitivity","text":"transitivity(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn the maximum k such that the action of G on L is k-transitive. The output is 0 if G is not transitive on L.\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#isprimitive","page":"Permutation groups","title":"isprimitive","text":"isprimitive(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn whether the action of G on L is primitive, that is, the action is transitive and the point stabilizers are maximal in G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#isregular","page":"Permutation groups","title":"isregular","text":"isregular(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn whether the action of G on L is regular (i.e., transitive and semiregular).\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#issemiregular","page":"Permutation groups","title":"issemiregular","text":"issemiregular(G::PermGroup, L::AbstractVector{Int} = 1:degree(G))\n\nReturn whether the action of G on L is semiregular (i.e., the stabilizer of each point is the identity).\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#blocks","page":"Permutation groups","title":"blocks","text":"blocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\n\nReturn a block system for the action of G on L, i.e., a non-trivial partition of L preserved by the action of G.\n\nHere, L must be a subvector of 1:degree(G) on which G acts transitively. G may move points outside L, in this case the restriction of the action of the set stabilizer of L in G to L is considered.\n\nAn exception is thrown if this action is not transitive.\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#maximal_blocks","page":"Permutation groups","title":"maximal_blocks","text":"maximal_blocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\n\nReturn a maximal block system for the action of G on L, i.e., a maximal non-trivial partition of L preserved by the action of G.\n\nHere, L must be a subvector of 1:degree(G) on which G acts transitively. G may move points outside L, in this case the restriction of the action of the set stabilizer of L in G to L is considered.\n\nAn exception is thrown if this action is not transitive.\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#representatives_minimal_blocks","page":"Permutation groups","title":"representatives_minimal_blocks","text":"representatives_minimal_blocks(G::PermGroup, L::AbstractVector{Int} = moved_points(G))\n\nReturn a list of block representatives for all minimal non-trivial block systems for the action of G on L.\n\nHere, L must be a subvector of 1:degree(G) on which G acts transitively. G may move points outside L, in this case the restriction of the action of the set stabilizer of L in G to L is considered.\n\nAn exception is thrown if this action is not transitive.\n\n\n\n\n\n","category":"function"},{"location":"Groups/permgroup/#all_blocks-Tuple{PermGroup}","page":"Permutation groups","title":"all_blocks","text":"all_blocks(G::PermGroup)\n\nReturn a list of representatives of all block systems for the action of G on the set of moved points of G.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/fraction/#Fraction-fields","page":"Fraction fields","title":"Fraction fields","text":"","category":"section"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Nemo allows the creation of fraction fields over any ring R. We don't require R to be an integral domain, however no attempt is made to deal with the general case. Two fractions ab and cd are equal in Nemo iff ad = bc. Thus, in practice, a greatest common divisor function is currently required for the ring R.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"In order to make the representation ab unique for printing, we have a notion of canonical unit for elements of a ring R. When canonicalising ab, each of the elements a and b is first divided by the canonical unit of b.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"The canonical_unit function is defined for elements of every Nemo ring. It must have the properties","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"canonical_unit(u) == u\ncanonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"for any unit u of the ring in question, and a and b arbitrary elements of the ring.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"For example, the canonical unit of an integer is its sign. Thus a fraction of integers always has positive denominator after canonicalisation.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"The canonical unit of a polynomial is the canonical unit of its leading coefficient, etc.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"There are two different kinds of implementation of fraction fields in Nemo: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of fractions over specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"The following table shows each of the fraction types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of fraction (the type information is mainly of concern to developers).","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.Frac{T} Generic.FracField{T}\nmathbbZ Flint fmpq FlintRationalField","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"All fraction element types belong to the abstract type FracElem and all of the fraction field types belong to the abstract type FracField. This enables one to write generic functions that can accept any Nemo fraction type.","category":"page"},{"location":"Nemo/fraction/#Fraction-functionality","page":"Fraction fields","title":"Fraction functionality","text":"","category":"section"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"All fraction types in Nemo provide funtionality for fields described in AbstractAlgebra.jl:","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"In addition all the fraction field functionality of AbstractAlgebra.jl is provided, along with generic fractions fields as described here:","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/fraction","category":"page"},{"location":"Nemo/fraction/#Basic-manipulation","page":"Fraction fields","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"sign(::fmpq)","category":"page"},{"location":"Nemo/fraction/#sign-Tuple{fmpq}","page":"Fraction fields","title":"sign","text":"sign(a::fmpq)\n\nReturn the sign of a (-1, 0 or 1) as a fraction.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"height(::fmpq)","category":"page"},{"location":"Nemo/fraction/#height-Tuple{fmpq}","page":"Fraction fields","title":"height","text":"height(a::fmpq)\n\nReturn the height of the fraction a, namely the largest of the absolute values of the numerator and denominator.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"height_bits(::fmpq)","category":"page"},{"location":"Nemo/fraction/#height_bits-Tuple{fmpq}","page":"Fraction fields","title":"height_bits","text":"height_bits(a::fmpq)\n\nReturn the number of bits of the height of the fraction a.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"<<(::fmpq, ::Int)","category":"page"},{"location":"Nemo/fraction/#<<-Tuple{fmpq, Int64}","page":"Fraction fields","title":"<<","text":"<<(a::fmpq, b::Int)\n\nReturn a times 2^b.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":">>(::fmpq, ::Int)","category":"page"},{"location":"Nemo/fraction/#>>-Tuple{fmpq, Int64}","page":"Fraction fields","title":">>","text":">>(a::fmpq, b::Int)\n\nReturn a2^b.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"floor(::fmpq)\nceil(::fmpq)","category":"page"},{"location":"Nemo/fraction/#floor-Tuple{fmpq}","page":"Fraction fields","title":"floor","text":"floor(a::fmpq)\n\nReturn the greatest integer that is less than or equal to a. The result is returned as a rational with denominator 1.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/#ceil-Tuple{fmpq}","page":"Fraction fields","title":"ceil","text":"ceil(a::fmpq)\n\nReturn the least integer that is greater than or equal to a. The result is returned as a rational with denominator 1.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"d = abs(ZZ(11)//3)\n4 <= ZZ(7)//ZZ(3)","category":"page"},{"location":"Nemo/fraction/#Modular-arithmetic","page":"Fraction fields","title":"Modular arithmetic","text":"","category":"section"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"The following functions are available for rationals.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"mod(a::fmpq, b::fmpz)","category":"page"},{"location":"Nemo/fraction/#mod-Tuple{fmpq, fmpz}","page":"Fraction fields","title":"mod","text":"mod(a::fmpq, b::fmpz)\n\nReturn a pmodb where b is an integer coprime to the denominator of a.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"mod(a::fmpq, b::Integer)","category":"page"},{"location":"Nemo/fraction/#mod-Tuple{fmpq, Integer}","page":"Fraction fields","title":"mod","text":"mod(a::fmpq, b::Integer)\n\nReturn a pmodb where b is an integer coprime to the denominator of a.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"a = -fmpz(2)//3\nb = fmpz(1)//2\n\nc = mod(a, 7)\nd = mod(b, fmpz(5))","category":"page"},{"location":"Nemo/fraction/#Rational-Reconstruction","page":"Fraction fields","title":"Rational Reconstruction","text":"","category":"section"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Rational reconstruction is available for rational numbers.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"reconstruct(::fmpz, ::fmpz)\nreconstruct(::fmpz, ::Integer)\nreconstruct(::Integer, ::fmpz)\nreconstruct(::Integer, ::Integer)","category":"page"},{"location":"Nemo/fraction/#reconstruct-Tuple{fmpz, fmpz}","page":"Fraction fields","title":"reconstruct","text":"reconstruct(a::fmpz, b::fmpz)\n\nAttempt to return a rational number nd such that 0 leq n leq lfloorsqrtm2rfloor and 0  d leq lfloorsqrtm2rfloor such that gcd(n d) = 1 and a equiv nd^-1 pmodm. If no solution exists, an exception is thrown.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/#reconstruct-Tuple{fmpz, Integer}","page":"Fraction fields","title":"reconstruct","text":"reconstruct(a::fmpz, b::Integer)\n\nAttempt to return a rational number nd such that 0 leq n leq lfloorsqrtm2rfloor and 0  d leq lfloorsqrtm2rfloor such that gcd(n d) = 1 and a equiv nd^-1 pmodm. If no solution exists, an exception is thrown.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/#reconstruct-Tuple{Integer, fmpz}","page":"Fraction fields","title":"reconstruct","text":"reconstruct(a::Integer, b::fmpz)\n\nAttempt to find a rational number nd such that 0 leq n leq lfloorsqrtm2rfloor and 0  d leq lfloorsqrtm2rfloor such that gcd(n d) = 1 and a equiv nd^-1 pmodm. If no solution exists, an exception is thrown.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/#reconstruct-Tuple{Integer, Integer}","page":"Fraction fields","title":"reconstruct","text":"reconstruct(a::Integer, b::Integer)\n\nAttempt to return a rational number nd such that 0 leq n leq lfloorsqrtm2rfloor and 0  d leq lfloorsqrtm2rfloor such that gcd(n d) = 1 and a equiv nd^-1 pmodm. If no solution exists, an exception is thrown.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"a = reconstruct(7, 13)\nb = reconstruct(fmpz(15), 31)\nc = reconstruct(fmpz(123), fmpz(237))","category":"page"},{"location":"Nemo/fraction/#Rational-enumeration","page":"Fraction fields","title":"Rational enumeration","text":"","category":"section"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Various methods exist to enumerate rationals.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_minimal(::fmpq)","category":"page"},{"location":"Nemo/fraction/#next_minimal-Tuple{fmpq}","page":"Fraction fields","title":"next_minimal","text":"next_minimal(a::fmpq)\n\nGiven a, return the next rational number in the sequence obtained by enumerating all positive denominators q, and for each q enumerating the numerators 1 le p  q in order and generating both pq and qp, but skipping all gcd(pq) neq 1. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being 0 1 12 2 13 3 23 32 14 4 34 43 ldots. This enumeration produces the rational numbers in order of minimal height. It has the disadvantage of being somewhat slower to compute than the Calkin-Wilf enumeration. If a  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_signed_minimal(::fmpq)","category":"page"},{"location":"Nemo/fraction/#next_signed_minimal-Tuple{fmpq}","page":"Fraction fields","title":"next_signed_minimal","text":"next_signed_minimal(a::fmpq)\n\nGiven a signed rational number a assumed to be in canonical form, return the next element in the minimal-height sequence generated by next_minimal but with negative numbers interleaved. The sequence begins 0 1 -1 12 -12 2 -2 13 -13 ldots. Starting with zero, this generates every rational number once and only once, in order of minimal height.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_calkin_wilf(::fmpq)","category":"page"},{"location":"Nemo/fraction/#next_calkin_wilf-Tuple{fmpq}","page":"Fraction fields","title":"next_calkin_wilf","text":"next_calkin_wilf(a::fmpq)\n\nReturn the next number after a in the breadth-first traversal of the Calkin-Wilf tree. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being 0 1 12 2 13 32 23 3 14 43 35 52 25 ldots. Despite the appearance of the initial entries, the Calkin-Wilf enumeration does not produce the rational numbers in order of height: some small fractions will appear late in the sequence. This order has the advantage of being faster to produce than the minimal-height order.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_signed_calkin_wilf(::fmpq)","category":"page"},{"location":"Nemo/fraction/#next_signed_calkin_wilf-Tuple{fmpq}","page":"Fraction fields","title":"next_signed_calkin_wilf","text":"next_signed_calkin_wilf(a::fmpq)\n\nGiven a signed rational number a returns the next element in the Calkin-Wilf sequence with negative numbers interleaved. The sequence begins 0 1 -1 12 -12 2 -2 13 -13 ldots. Starting with zero, this generates every rational number once and only once, but not in order of minimal height.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"next_minimal(fmpz(2)//3)\nnext_signed_minimal(-fmpz(21)//31)\nnext_calkin_wilf(fmpz(321)//113)\nnext_signed_calkin_wilf(-fmpz(51)//(17))","category":"page"},{"location":"Nemo/fraction/#Random-generation","page":"Fraction fields","title":"Random generation","text":"","category":"section"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"rand_bits(::FlintRationalField, b::Int)","category":"page"},{"location":"Nemo/fraction/#rand_bits-Tuple{FlintRationalField, Int64}","page":"Fraction fields","title":"rand_bits","text":"rand_bits(::FlintRationalField, b::Int)\n\nReturn a random signed rational whose numerator and denominator both have b bits before canonicalisation. Note that the resulting numerator and denominator can be smaller than b bits.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/#Special-functions","page":"Fraction fields","title":"Special functions","text":"","category":"section"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"The following special functions are available for specific rings in Nemo.","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"harmonic(::Int)","category":"page"},{"location":"Nemo/fraction/#harmonic-Tuple{Int64}","page":"Fraction fields","title":"harmonic","text":"harmonic(n::Int)\n\nReturn the harmonic number H_n = 1 + 12 + 13 + cdots + 1n. Table lookup is used for H_n whose numerator and denominator fit in a single limb. For larger n, a divide and conquer strategy is used.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"bernoulli(::Int)","category":"page"},{"location":"Nemo/fraction/#bernoulli-Tuple{Int64}","page":"Fraction fields","title":"bernoulli","text":"bernoulli(n::Int)\n\nReturn the Bernoulli number B_n for nonnegative n.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"bernoulli_cache(::Int)","category":"page"},{"location":"Nemo/fraction/#bernoulli_cache-Tuple{Int64}","page":"Fraction fields","title":"bernoulli_cache","text":"bernoulli_cache(n::Int)\n\nPrecomputes and caches all the Bernoulli numbers up to B_n. This is much faster than repeatedly calling bernoulli(k). Once cached, subsequent calls to bernoulli(k) for any k le n will read from the cache, making them virtually free.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"dedekind_sum(::fmpz, ::fmpz)","category":"page"},{"location":"Nemo/fraction/#dedekind_sum-Tuple{fmpz, fmpz}","page":"Fraction fields","title":"dedekind_sum","text":"dedekind_sum(h::fmpz, k::fmpz)\n\nReturn the Dedekind sum s(hk) for arbitrary h and k.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"a = harmonic(12)\n\nb = dedekind_sum(12, 13)\nc = dedekind_sum(-120, fmpz(1305))\n\nd = bernoulli(12)\n\nbernoulli_cache(100)\ne = bernoulli(100)","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"simplest_between(::fmpq, ::fmpq)","category":"page"},{"location":"Nemo/fraction/#simplest_between-Tuple{fmpq, fmpq}","page":"Fraction fields","title":"simplest_between","text":"  simplest_between(l::fmpq, r::fmpq)\n\nReturn the simplest fraction in the closed interval l r. A canonical fraction a_1  b_1 is defined to be simpler than a_2  b_2 if and only if b_1  b_2 or b_1 = b_2 and a_1  a_2.\n\n\n\n","category":"method"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"Examples","category":"page"},{"location":"Nemo/fraction/","page":"Fraction fields","title":"Fraction fields","text":"simplest_between(fmpq(1//10), fmpq(3//10))","category":"page"},{"location":"General/other/#Notes-for-users-of-other-computer-algebra-systems","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"","category":"section"},{"location":"General/other/#General-differences","page":"Notes for users of other computer algebra systems","title":"General differences","text":"","category":"section"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"TODO: 2^100 is evaluated to 0; write fmpz(2)^100 to get a long","category":"page"},{"location":"General/other/#Notes-for-GAP-users","page":"Notes for users of other computer algebra systems","title":"Notes for GAP users","text":"","category":"section"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"TODO\nTODO: also talk about how to use it from Oscar?","category":"page"},{"location":"General/other/#Notes-for-Singular-users","page":"Notes for users of other computer algebra systems","title":"Notes for Singular users","text":"","category":"section"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"TODO\nTODO: also talk about how to use it from Oscar?","category":"page"},{"location":"General/other/#Notes-for-Polymake-users","page":"Notes for users of other computer algebra systems","title":"Notes for Polymake users","text":"","category":"section"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"OSCAR (and Julia) is 1-based, meaning that it counts from 1, rather than from 0 like polymake. For most properties we have taken care of the translation but be aware that it might pop up at some point and generate confusion.\nPolyhedra and polyhedral complexes in OSCAR are represented inhomogeneously, i.e. without the leading 1 for vertices or 0 for rays. Hence constructors take points, rays, and lineality generators separately.\nTODO: also talk about how to use it from Oscar?","category":"page"},{"location":"General/other/#Notes-for-Magma-users","page":"Notes for users of other computer algebra systems","title":"Notes for Magma users","text":"","category":"section"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"TODO","category":"page"},{"location":"General/other/#Notes-for-SageMath-users","page":"Notes for users of other computer algebra systems","title":"Notes for SageMath users","text":"","category":"section"},{"location":"General/other/","page":"Notes for users of other computer algebra systems","title":"Notes for users of other computer algebra systems","text":"TODO","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"StraightLinePrograms/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"This is the documentation of the straight-line programs (SLP) implementation by Rafael Fourquet. Originally this was supposed to become a separate Julia module, however it has now been incorporated into the Oscar core.","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"The main SLP type is SLProgram, to which other types can \"compile\" (or \"transpile\"). The easiest way to create an SLProgram is to combine \"generators\":","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> using Oscar;\n\njulia> using Oscar.StraightLinePrograms; const SLP = Oscar.StraightLinePrograms;\n\njulia> x, y, z = SLP.gens(SLProgram, 3)\n3-element Vector{SLProgram{Union{}}}:\n x\n y\n z\n\njulia> p = (x*y^2 + 1.3*z)^-1\n#1 = ^   y  2  ==>  y^2\n#2 = *   x #1  ==>  (x*y^2)\n#3 = * 1.3  z  ==>  (1.3*z)\n#4 = +  #2 #3  ==>  ((x*y^2) + (1.3*z))\n#5 = ^  #4 -1  ==>  ((x*y^2) + (1.3*z))^-1\nreturn: #5","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"On the right side of the above output is the representation of the computation so far. It's done via another SLP type (tentatively) called Lazy which represent \"formulas\" as trees:","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> using Oscar;\n\njulia> using Oscar.StraightLinePrograms; const SLP = Oscar.StraightLinePrograms;\n\njulia> x, y, z = SLP.gens(SLProgram, 3);\n\njulia> p = (x*y^2 + 1.3*z)^-1;\n\njulia> X, Y, Z = SLP.gens(Lazy, 3)\n3-element Vector{Lazy}:\n x\n y\n z\n\njulia> q = (X*Y^2 + 1.3*Z)^-1\n((x*y^2) + (1.3*z))^-1\n\njulia> f = SLP.evaluate(p, [X, Y, Z])\n((x*y^2) + (1.3*z))^-1\n\njulia> SLP.evaluate(f, [X, Y, Z]) == f\ntrue\n\njulia> SLP.evaluate(p, Any[x, y, z]) == p\ntrue\n\njulia> dump(q) # q::Lazy is a tree\nOscar.StraightLinePrograms.Lazy\n  x: Oscar.StraightLinePrograms.Exp\n    p: Oscar.StraightLinePrograms.Plus\n      xs: Array{Oscar.StraightLinePrograms.LazyRec}((2,))\n        1: Oscar.StraightLinePrograms.Times\n          xs: Array{Oscar.StraightLinePrograms.LazyRec}((2,))\n            1: Oscar.StraightLinePrograms.Input\n              n: Int64 1\n            2: Oscar.StraightLinePrograms.Exp\n              p: Oscar.StraightLinePrograms.Input\n                n: Int64 2\n              e: Int64 2\n        2: Oscar.StraightLinePrograms.Times\n          xs: Array{Oscar.StraightLinePrograms.LazyRec}((2,))\n            1: Oscar.StraightLinePrograms.Const{Float64}\n              c: Float64 1.3\n            2: Oscar.StraightLinePrograms.Input\n              n: Int64 3\n    e: Int64 -1\n  gens: Array{Symbol}((3,))\n    1: Symbol x\n    2: Symbol y\n    3: Symbol z","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"Evaluation of SLPs is done via evaluate, which can take a vector of anything which supports the operations used in the SLP (e.g. *, + and ^ in this example; - is also supported but division not yet). Note that currently, the eltype of the input vector for SLProgram must be a supertype of any intermediate computation (so it's always safe to pass a Vector{Any}).","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> using Oscar;\n\njulia> using Oscar.StraightLinePrograms; const SLP = Oscar.StraightLinePrograms;\n\njulia> x, y, z = SLP.gens(SLProgram, 3);\n\njulia> p = (x*y^2 + 1.3*z)^-1;\n\njulia> X, Y, Z = SLP.gens(Lazy, 3);\n\n\njulia> SLP.evaluate(p, [2.0, 3.0, 5.0])\n0.04081632653061224\n\njulia> SLP.evaluate(X*Y^2, ['a', 'b'])\n\"abb\"","category":"page"},{"location":"StraightLinePrograms/intro/#Returning-multiple-values","page":"Introduction","title":"Returning multiple values","text":"","category":"section"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"There is a low-level interface to return multiple values from an SLProgram; for example, to return the second and last intermediate values from p above, we would \"assign\" these values to positions #1 and #2, delete all other positions (via the \"keep\" operation), and return the resulting array (the one used for intermediate computations):","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> using Oscar;\n\njulia> using Oscar.StraightLinePrograms; const SLP = Oscar.StraightLinePrograms;\n\njulia> x, y, z = SLP.gens(SLProgram, 3);\n\njulia> p = (x*y^2 + 1.3*z)^-1;\n\njulia> X, Y, Z = SLP.gens(Lazy, 3);\n\n\njulia> SLP.pushop!(p, SLP.assign, SLP.Arg(2), SLP.Arg(1))\n       SLP.pushop!(p, SLP.assign, SLP.Arg(5), SLP.Arg(2))\n       SLP.pushop!(p, SLP.keep, SLP.Arg(2))\n       SLP.setmultireturn!(p)\n#1 = ^   y  2  ==>  y^2\n#2 = *   x #1  ==>  (x*y^2)\n#3 = * 1.3  z  ==>  (1.3*z)\n#4 = +  #2 #3  ==>  ((x*y^2) + (1.3*z))\n#5 = ^  #4 -1  ==>  ((x*y^2) + (1.3*z))^-1\n#1 =    #2     ==>  (x*y^2)\n#2 =    #5     ==>  ((x*y^2) + (1.3*z))^-1\nkeep: #1..#2\nreturn: [#1, #2]\n\njulia> SLP.evaluate(p, [X, Y, Z])\nlist([(x*y^2), ((x*y^2) + (1.3*z))^-1])","category":"page"},{"location":"StraightLinePrograms/intro/#Straight-line-decisions","page":"Introduction","title":"Straight line decisions","text":"","category":"section"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"A \"decision\" is a special operation which allows to stop prematurely the execution of the program if a condition is false, and the program returns true if no condition failed. Currently, the interface is modeled after GAP's SLPs and defaults to testing the AbstractAlgebra.order of an element. More specifically, test(prg, n::Integer) tests whether the order of the result of prg is equal to n, and dec1 & dec2 chains two programs with a short-circuiting behavior:","category":"page"},{"location":"StraightLinePrograms/intro/","page":"Introduction","title":"Introduction","text":"julia> p1 = SLP.test(x*y^2, 2)\n#1 = ^ y  2  ==>  y^2\n#2 = * x #1  ==>  (xy^2)\ntest: order(#2) == 2 || return false\nreturn: true\n\njulia> p2 = SLP.test(y, 4)\ntest: order(y) == 4 || return false\nreturn: true\n\njulia> p1 & p2\n#1 = ^ y  2  ==>  y^2\n#2 = * x #1  ==>  (xy^2)\ntest: order(#2) == 2 || return false\ntest: order(y) == 4 || return false\nreturn: true\n\njulia> SLP.evaluate(p1 & p2, [X, Y])\ntest((xy^2), 2) & test(y, 4)\n\njulia> using AbstractAlgebra; perm1, perm2 = perm\"(1, 4)\", perm\"(1, 3, 4, 2)\";\n\njulia> SLP.evaluate(p1 & p2, [perm1, perm2])\ntrue\n\njulia> SLP.evaluate(p1 & p2, [perm2, perm1])\nfalse","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"using Oscar","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"Pages = [\"grouplib.md\"]","category":"page"},{"location":"Groups/grouplib/#Group-libraries","page":"Group libraries","title":"Group libraries","text":"","category":"section"},{"location":"Groups/grouplib/#Transitive-permutation-groups-of-small-degree","page":"Group libraries","title":"Transitive permutation groups of small degree","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"TODO: explain about the scope of this.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"TODO: give proper attribution to the transgrp package (in particular, cite it)","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The arrangement and the names of the groups of degree up to 15 is the same as given in John H. Conway, Alexander Hulpke, John McKay (1998). With the exception of the symmetric and alternating group (which are represented as symmetric_group and alternating_group) the generators for these groups also conform to this paper with the only difference that 0 (which is not permitted in GAP for permutations to act on) is always replaced by the degree.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The arrangement for all degrees is intended to be equal to the arangement within the systems GAP and Magma, thus it should be safe to refer to particular (classes of) groups by their index numbers.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"all_transitive_groups\nhas_number_transitive_groups\nhas_transitive_group_identification\nhas_transitive_groups\nnumber_transitive_groups\ntransitive_group\ntransitive_group_identification","category":"page"},{"location":"Groups/grouplib/#all_transitive_groups","page":"Group libraries","title":"all_transitive_groups","text":"all_transitive_groups(L...)\n\nReturn the list of all transitive groups (up to permutation isomorphism) satisfying the conditions described by the arguments. These conditions may be of one of the following forms:\n\nfunc => intval selects groups for which the function func returns intval\nfunc => list selects groups for which the function func returns any element inside list\nfunc selects groups for which the function func returns true\n!func selects groups for which the function func returns false\n\nThe following functions are currently supported as values for func:\n\ndegree\nisabelian\nisalmostsimple\niscyclic\nisnilpotent\nisperfect\nisprimitive\nis_quasisimple\nissimple\nis_sporadic_simple\nissolvable\nissupersolvable\nistransitive\nnumber_conjugacy_classes\nnumber_moved_points\norder\ntransitivity\n\nThe type of the returned groups is PermGroup.\n\nExamples\n\njulia> all_transitive_groups(degree => 3:5, isabelian)\n4-element Vector{PermGroup}:\n A3\n C(4) = 4\n E(4) = 2[x]2\n C(5) = 5\n\nreturns the list of all abelian transitive groups acting on 3, 4 or 5 points.\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_number_transitive_groups","page":"Group libraries","title":"has_number_transitive_groups","text":"has_number_transitive_groups(deg::Int)\n\nReturn whether the number transitive groups groups of degree deg are available for use via number_transitive_groups.\n\nExamples\n\njulia> has_number_transitive_groups(30)\ntrue\n\njulia> has_number_transitive_groups(64)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_transitive_group_identification","page":"Group libraries","title":"has_transitive_group_identification","text":"has_transitive_group_identification(deg::Int)\n\nReturn whether identification of transitive groups groups of degree deg is available via transitive_group_identification.\n\nExamples\n\njulia> has_transitive_group_identification(30)\ntrue\n\njulia> has_transitive_group_identification(64)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_transitive_groups","page":"Group libraries","title":"has_transitive_groups","text":"has_transitive_groups(deg::Int)\n\nReturn whether the transitive groups groups of degree deg are available for use. This function should be used to test for the scope of the library available.\n\nExamples\n\njulia> has_transitive_groups(30)\ntrue\n\njulia> has_transitive_groups(64)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#number_transitive_groups","page":"Group libraries","title":"number_transitive_groups","text":"number_transitive_groups(deg::Int)\n\nReturn the number of transitive groups of degree deg, up to permutation isomorphism.\n\nExamples\n\njulia> number_transitive_groups(30)\n5712\n\njulia> number_transitive_groups(64)\nERROR: ArgumentError: the number of transitive groups of degree 64 is not available\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#transitive_group","page":"Group libraries","title":"transitive_group","text":"transitive_group(deg::Int, i::Int)\n\nReturn the i-th group in the catalogue of transitive groups over the set {1, ..., deg} in GAP's Transitive Groups Library. The output is a group of type PermGroup.\n\nExamples\n\njulia> transitive_group(5,4)\nA5\n\njulia> transitive_group(5,6)\nERROR: ArgumentError: there are only 5 transitive groups of degree 5, not 6\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#transitive_group_identification","page":"Group libraries","title":"transitive_group_identification","text":"transitive_group_identification(G::PermGroup)\n\nReturn a pair (d,n) such that G is permutation isomorphic with transitive_group(d,n), where G acts transitively on d points.\n\nIf G is not transitive on its moved points, or if the transitive groups of degree d are not available, an exception is thrown.\n\nExamples\n\njulia> G = symmetric_group(7);  m = transitive_group_identification(G)\n(7, 7)\n\njulia> order(transitive_group(m...)) == order(G)\ntrue\n\njulia> S = sub(G, [gap_perm([1, 3, 4, 5, 2])])[1]\nGroup([ (2,3,4,5) ])\n\njulia> istransitive(S)\nfalse\n\njulia> istransitive(S, moved_points(S))\ntrue\n\njulia> m = transitive_group_identification(S)\n(4, 1)\n\njulia> order(transitive_group(m...)) == order(S)\ntrue\n\njulia> transitive_group_identification(symmetric_group(64))\nERROR: identification of transitive groups of degree 64 are not available\n\njulia> S = sub(G, [gap_perm([1,3,4,5,2,7,6])])[1];\n\njulia> transitive_group_identification(S)\nERROR: group is not transitive on its moved points\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#Primitive-permutation-groups-of-small-degree","page":"Group libraries","title":"Primitive permutation groups of small degree","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"TODO: explain about the scope of this.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"TODO: give proper attribution to the primitive groups library (in particular, cite it)","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"all_primitive_groups\nhas_number_primitive_groups\nhas_primitive_group_identification\nhas_primitive_groups\nnumber_primitive_groups\nprimitive_group\nprimitive_group_identification","category":"page"},{"location":"Groups/grouplib/#all_primitive_groups","page":"Group libraries","title":"all_primitive_groups","text":"all_primitive_groups(L...)\n\nReturn the list of all primitive permutation groups (up to permutation isomorphism) satisfying the conditions described by the arguments. These conditions may be of one of the following forms:\n\nfunc => intval selects groups for which the function func returns intval\nfunc => list selects groups for which the function func returns any element inside list\nfunc selects groups for which the function func returns true\n!func selects groups for which the function func returns false\n\nThe following functions are currently supported as values for func:\n\ndegree\nisabelian\nisalmostsimple\niscyclic\nisnilpotent\nisperfect\nisprimitive\nis_quasisimple\nissimple\nis_sporadic_simple\nissolvable\nissupersolvable\nistransitive\nnumber_conjugacy_classes\nnumber_moved_points\norder\ntransitivity\n\nThe type of the returned groups is PermGroup.\n\nExamples\n\njulia> all_primitive_groups(degree => 3:5, isabelian)\n2-element Vector{PermGroup}:\n A(3)\n C(5)\n\nreturns the list of all abelian primitive permutation groups acting on 3, 4 or 5 points.\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_number_primitive_groups","page":"Group libraries","title":"has_number_primitive_groups","text":"has_number_primitive_groups(deg::Int)\n\nReturn true if the number of primitive permutation groups of degree deg is available via number_primitive_groups, otherwise false.\n\nCurrently the number of primitive permutation groups is available up to degree 4095.\n\nExamples\n\njulia> has_number_primitive_groups(50)\ntrue\n\njulia> has_number_primitive_groups(5000)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_primitive_group_identification","page":"Group libraries","title":"has_primitive_group_identification","text":"has_primitive_group_identification(deg::Int)\n\nReturn true if identification is supported for the primitive permutation groups of degree deg via primitive_group_identification, otherwise false.\n\nCurrently identification is available for all primitive permutation groups up to degree 4095.\n\nExamples\n\njulia> has_primitive_group_identification(50)\ntrue\n\njulia> has_primitive_group_identification(5000)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_primitive_groups","page":"Group libraries","title":"has_primitive_groups","text":"has_primitive_groups(deg::Int)\n\nReturn true if the primitive permutation groups of degree deg are available via primitive_group and all_primitive_groups, otherwise false.\n\nCurrently all primitive permutation groups up to degree 4095 are available.\n\nExamples\n\njulia> has_primitive_groups(50)\ntrue\n\njulia> has_primitive_groups(5000)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#number_primitive_groups","page":"Group libraries","title":"number_primitive_groups","text":"number_primitive_groups(deg::Int)\n\nReturn the number of primitive permutation groups of degree deg, up to permutation isomorphism.\n\nExamples\n\njulia> number_primitive_groups(10)\n9\n\njulia> number_primitive_groups(4096)\nERROR: ArgumentError: the number of primitive permutation groups of degree 4096 is not available\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#primitive_group","page":"Group libraries","title":"primitive_group","text":"primitive_group(deg::Int, i::Int)\n\nReturn the i-th group in the catalogue of primitive permutation groups over the set {1, ..., deg} in GAP's library of primitive permutation groups. The output is a group of type PermGroup.\n\nExamples\n\njulia> primitive_group(10,1)\nA(5)\n\njulia> primitive_group(10,10)\nERROR: ArgumentError: there are only 9 primitive permutation groups of degree 10, not 10\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#primitive_group_identification","page":"Group libraries","title":"primitive_group_identification","text":"primitive_group_identification(G::PermGroup)\n\nReturn a pair (d,n) such that G is permutation isomorphic with primitive_group(d,n), where G acts primitively on d points.\n\nIf G is not primitive on its moved points, or if the primitive permutation groups of degree d are not available, an exception is thrown.\n\nExamples\n\njulia> G = symmetric_group(7);  m = primitive_group_identification(G)\n(7, 7)\n\njulia> order(primitive_group(m...)) == order(G)\ntrue\n\njulia> S = stabilizer(G, 1)[1]\nGroup([ (2,7,6,5,4,3), (6,7) ])\n\njulia> isprimitive(S)\nfalse\n\njulia> isprimitive(S, moved_points(S))\ntrue\n\njulia> m = primitive_group_identification(S)\n(6, 4)\n\njulia> order(primitive_group(m...)) == order(S)\ntrue\n\njulia> primitive_group_identification(symmetric_group(4096))\nERROR: identification of primitive permutation groups of degree 4096 is not available\n\njulia> S = sub(G, [gap_perm([1,3,4,5,2,7,6])])[1];\n\njulia> primitive_group_identification(S)\nERROR: group is not primitive on its moved points\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#Perfect-groups-of-small-order","page":"Group libraries","title":"Perfect groups of small order","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The functions in this section are wrappers for the GAP library of finite perfect groups which provides, up to isomorphism, a list of all perfect groups whose sizes are less than 2cdot 10^6. The groups of most orders up to 10^6 have been enumerated by Derek Holt and Wilhelm Plesken, see Derek F. Holt, W. Plesken (1989). For orders n = 86016, 368640, or 737280 this work only counted the groups (but did not explicitly list them), the groups of orders n = 61440, 122880, 172032, 245760, 344064, 491520, 688128, or 983040 were omitted.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"Several additional groups omitted from the book Derek F. Holt, W. Plesken (1989) have also been included. Two groups – one of order 450000 with a factor group of type A_6 and the one of order 962280 – were found by Jack Schmidt in","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"Two groups of order 243000 and one each of orders 729000, 871200, 878460","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"were found in 2020 by Alexander Hulpke.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The perfect groups of size less than 2cdot 10^6 which had not been classified in the work of Holt and Plesken have been enumerated by Alexander Hulpke. They are stored directly and provide less construction information in their names.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"As all groups are stored by presentations, a permutation representation is obtained by coset enumeration. Note that some of the library groups do not have a faithful permutation representation of small degree. Computations in these groups may be rather time consuming.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"has_number_perfect_groups\nhas_perfect_group_identification\nhas_perfect_groups\nnumber_perfect_groups\norders_perfect_groups\nperfect_group\nperfect_group_identification","category":"page"},{"location":"Groups/grouplib/#has_number_perfect_groups","page":"Group libraries","title":"has_number_perfect_groups","text":"has_number_perfect_groups(n::Int)\n\nReturn true if the number of perfect groups of order n are available via number_perfect_groups, otherwise false.\n\nCurrently the number of perfect groups is available up to order 2 cdot 10^6.\n\nExamples\n\njulia> has_number_perfect_groups(7200)\ntrue\n\njulia> has_number_perfect_groups(2*10^6+1)\nfalse\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_perfect_group_identification","page":"Group libraries","title":"has_perfect_group_identification","text":"has_perfect_group_identification(n::Int)\n\nReturn true if identification is supported for the perfect groups of order n via perfect_group_identification, otherwise false.\n\nCurrently identification is available for all perfect groups up to order 2 cdot 10^6.\n\nExamples\n\njulia> has_perfect_group_identification(7200)\ntrue\n\njulia> has_perfect_group_identification(2*10^6+1)\nfalse\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_perfect_groups","page":"Group libraries","title":"has_perfect_groups","text":"has_perfect_groups(deg::Int)\n\nReturn true if the perfect groups of order n are available via perfect_group and all_perfect_groups, otherwise false.\n\nCurrently all perfect groups up to order 2 cdot 10^6 are available.\n\nExamples\n\njulia> has_perfect_groups(7200)\ntrue\n\njulia> has_perfect_groups(2*10^6+1)\nfalse\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#number_perfect_groups","page":"Group libraries","title":"number_perfect_groups","text":"number_perfect_groups(n::IntegerUnion)\n\nReturn the number of perfect groups of order n, up to isomorphism.\n\nExamples\n\njulia> number_perfect_groups(60)\n1\n\njulia> number_perfect_groups(1966080)\n7344\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#orders_perfect_groups","page":"Group libraries","title":"orders_perfect_groups","text":"orders_perfect_groups()\n\nReturns a sorted vector of all numbers to 2 cdot 10^6 that occur as orders of perfect groups.\n\nExamples\n\njulia> orders_perfect_groups()[1:10]\n10-element Vector{Int64}:\n   1\n  60\n 120\n 168\n 336\n 360\n 504\n 660\n 720\n 960\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#perfect_group","page":"Group libraries","title":"perfect_group","text":"perfect_group(::Type{T} = PermGroup, n::IntegerUnion, k::IntegerUnion)\n\nReturn the k-th group of order n and type T in the catalogue of perfect groups in GAP's Perfect Groups Library. The type T can be either PermGroup or FPGroup.\n\nExamples\n\njulia> perfect_group(60, 1)\nA5\n\njulia> gens(ans)\n2-element Vector{PermGroupElem}:\n (1,2)(4,5)\n (2,3,4)\n\njulia> perfect_group(FPGroup, 60, 1)\nA5\n\njulia> gens(ans)\n2-element Vector{FPGroupElem}:\n a\n b\n\njulia> perfect_group(60, 2)\nERROR: ArgumentError: there are only 1 perfect groups of order 60\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#perfect_group_identification","page":"Group libraries","title":"perfect_group_identification","text":"perfect_group_identification(G::GAPGroup)\n\nReturn (n, m) such that G is isomorphic with perfect_group(n, m). If G is not perfect, an exception is thrown.\n\nExamples\n\njulia> perfect_group_identification(alternating_group(5))\n(60, 1)\n\njulia> perfect_group_identification(SL(2,7))\n(336, 1)\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#Groups-of-small-order","page":"Group libraries","title":"Groups of small order","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"TODO: explain about the scope of this.","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"TODO: give proper attribution to the smallgrp package and other things used (in particular, cite it)","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"all_small_groups\nhas_number_small_groups\nhas_small_group_identification\nhas_small_groups\nnumber_small_groups\nsmall_group\nsmall_group_identification","category":"page"},{"location":"Groups/grouplib/#all_small_groups","page":"Group libraries","title":"all_small_groups","text":"all_small_groups(L...)\n\nReturn the list of all groups (up to isomorphism) satisfying the conditions described by the arguments. These conditions may be of one of the following forms:\n\nfunc => intval selects groups for which the function func returns intval\nfunc => list selects groups for which the function func returns any element inside list\nfunc selects groups for which the function func returns true\n!func selects groups for which the function func returns false\n\nAs a special case, the first argument may also be one of the following:\n\nintval selects groups whose order equals intval; this is equivalent to order => intval\nintlist selects groups whose order is in intlist; this is equivalent to order => intlist\n\nNote that at least one of the conditions must impose a limit on the group order, otherwise an exception is thrown.\n\nThe following functions are currently supported as values for func:\n\nisabelian\nisalmostsimple\niscyclic\nisnilpotent\nisperfect\nis_quasisimple\nissimple\nis_sporadic_simple\nissolvable\nissupersolvable\nnumber_conjugacy_classes\norder\n\nThe type of the returned groups is PcGroup if the group is solvable, PermGroup otherwise.\n\nExamples\n\nList all abelian non-cyclic groups of order 12:\n\njulia> all_small_groups(12, !iscyclic, isabelian)\n1-element Vector{PcGroup}:\n <pc group of size 12 with 3 generators>\n\nList groups of order 1 to 10 which are not abelian:\n\njulia> all_small_groups(1:10, !isabelian)\n4-element Vector{PcGroup}:\n <pc group of size 6 with 2 generators>\n <pc group of size 8 with 3 generators>\n <pc group of size 8 with 3 generators>\n <pc group of size 10 with 2 generators>\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_number_small_groups","page":"Group libraries","title":"has_number_small_groups","text":"has_number_small_groups(n::IntegerUnion)\n\nReturn true if the number of groups of order n is known, otherwise false.\n\nExamples\n\njulia> has_number_small_groups(1024)\ntrue\n\njulia> has_number_small_groups(2048)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_small_group_identification","page":"Group libraries","title":"has_small_group_identification","text":"has_small_group_identification(n::IntegerUnion)\n\nReturn true if identification for groups of order n is available via small_group_identification, otherwise false.\n\nExamples\n\njulia> has_small_group_identification(256)\ntrue\n\njulia> has_small_group_identification(512)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#has_small_groups","page":"Group libraries","title":"has_small_groups","text":"has_small_groups(n::IntegerUnion)\n\nReturn true if the groups of order n are available via small_group and all_small_groups, otherwise false.\n\nExamples\n\njulia> has_small_groups(512)\ntrue\n\njulia> has_small_groups(1024)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#number_small_groups","page":"Group libraries","title":"number_small_groups","text":"number_small_groups(n::IntegerUnion)\n\nReturn the number of groups of order n, up to isomorphism.\n\nExamples\n\njulia> number_small_groups(8)\n5\n\njulia> number_small_groups(4096)\nERROR: the number of groups of order 4096 is not available\n\njulia> number_small_groups(next_prime(fmpz(2)^64))\n1\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#small_group","page":"Group libraries","title":"small_group","text":"small_group(::Type{T}, n::IntegerUnion, i::IntegerUnion) where T\nsmall_group(n::IntegerUnion, i::IntegerUnion)\n\nReturn the i-th group of order n in the Small Groups Library. If a type T is specified then an attempt is made to return the result with that type. If T is omitted then the resulting group will have type PcGroup if it is solvable, otherwise it will be of type PermGroup.\n\nExamples\n\njulia> small_group(60, 4)\n<pc group of size 60 with 4 generators>\n\njulia> small_group(60, 5)\nGroup([ (1,2,3,4,5), (1,2,3) ])\n\njulia> small_group(PcGroup, 60, 4)\n<pc group of size 60 with 4 generators>\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#small_group_identification","page":"Group libraries","title":"small_group_identification","text":"small_group_identification(G::Group)\n\nReturn a pair of integer (n, m), where G is isomorphic with small_group(n, m).\n\nExamples\n\njulia> small_group_identification(alternating_group(5))\n(60, 5)\n\njulia> small_group_identification(symmetric_group(20))\nERROR: identification is not available for groups of order 2432902008176640000\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#Atlas-of-Group-Representations","page":"Group libraries","title":"Atlas of Group Representations","text":"","category":"section"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"The functions in this section give access to data in the Atlas of Group Representations R. A. Wilson, P. Walsh, J. Tripp, I. Suleiman, R. A. Parker, S. P. Norton, S. Nickerson, S. Linton, J. Bray, R. Abbott (). The isomorphism types of the groups in question are specified via names for the groups, which coincide with the names of the corresponding character tables in the library of character tables, see character_table(id::String, p::Int = 0).","category":"page"},{"location":"Groups/grouplib/","page":"Group libraries","title":"Group libraries","text":"number_atlas_groups\natlas_group","category":"page"},{"location":"Groups/grouplib/#number_atlas_groups","page":"Group libraries","title":"number_atlas_groups","text":"number_atlas_groups([::Type{T}, ]name::String) where T <: Union{PermGroup, MatrixGroup}\n\nReturn the number of groups from the Atlas of Group Representations whose isomorphism type is given by name and have the type T.\n\nExamples\n\njulia> number_atlas_groups(\"A5\")\n18\n\njulia> number_atlas_groups(PermGroup, \"A5\")\n3\n\njulia> number_atlas_groups(MatrixGroup, \"A5\")\n15\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouplib/#atlas_group","page":"Group libraries","title":"atlas_group","text":"atlas_group([::Type{T}, ]name::String) where T <: Union{PermGroup, MatrixGroup}\n\nReturn a group from the Atlas of Group Representations whose isomorphism type is given by name and have the type T.\n\nExamples\n\njulia> atlas_group(\"A5\")  # alternating group A5\nGroup([ (1,2)(3,4), (1,3,5) ])\n\njulia> atlas_group(MatrixGroup, \"A5\")\nMatrix group of degree 4 over Galois field with characteristic 2\n\njulia> atlas_group(\"M11\")  # Mathieu group M11\nGroup([ (2,10)(4,11)(5,7)(8,9), (1,4,3,8)(2,5,6,9) ])\n\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/mseries/#Multivariate-series","page":"Multivariate series","title":"Multivariate series","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"AbstractAlgebra.jl provide multivariate series over a commutative ring.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Currently only series with capped absolute precision are provided. The precision in each variable can be set, but is capped at some maximum precision which is set when defining the ring.","category":"page"},{"location":"AbstractAlgebra/mseries/#Generic-multivariate-series","page":"Multivariate series","title":"Generic multivariate series","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Generic multivariate series over a commutative ring, AbsMSeries{T} is implemented in src/generic/AbsMSeries.jl.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Such series are capped absolute series and have type Generic.AbsMSeries{T} where T is the type of elements of the coefficient ring.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Internally they consist of a multivariate polynomial and a vector of precisions, one for each variable. See the file src/generic/GenericTypes.jl for details of the type.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"The series are implemented in terms of multivariate polynomials which are used internally to keep track of the coefficients of the series.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Only lex ordering is provided at present, though series print in reverse order to what multivariate polynomials would print, i.e. least significant term first, as would be expected for series.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Parent objects of such series have type Generic.AbsMSeriesRing{T}.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"The symbol representation of the variables and the multivariate polynomial ring is stored in the parent object.","category":"page"},{"location":"AbstractAlgebra/mseries/#Abstract-types","page":"Multivariate series","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Multivariate series element types belong to the abstract type MSeriesElem{T} and the multivariate series ring types belong to the abstract type MSeriesRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra multivariate series type.","category":"page"},{"location":"AbstractAlgebra/mseries/#Multivariate-series-ring-constructors","page":"Multivariate series","title":"Multivariate series ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"In order to construct multivariate series in AbstractAlgebra.jl, one must first construct the series ring itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"PowerSeriesRing(R::Ring, prec::Vector{Int}, s::Vector{U}; cached::Bool = true) where U <: AbstractString","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Given a base ring R and vector of strings s specifying how the generators (variables) should be printed, along with a vector of precisions, one for each variable, return a tuple U, (x, y, ...) representing the new series ring S and the generators x y ldots of the ring as a tuple. By default the parent object S will depend only on R and the variable names x, y, ... and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Here are some examples of creating multivariate series rings and making use of the resulting parent objects to coerce various elements into the series ring.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Note that one can also use the function call O(x^n) to specify the precision in the variable x of a given series expression should be precision n.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"note: Note\nIt is not possible to use x^0 in the O() function, since there is no distinction between x^0 and y^0 as far as the system is concerned. If one wishes to set the precision of a variable to precision 0, one must use the set_precision! function described below.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"If one wants a series with the same precision in all variables, one can use O(R, n) where R is the series ring and n is the desired precision.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"If all the precisions are to be the same, the vector of integers for the precisions can be replaced by a single integer.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"julia> R, (x, y) = PowerSeriesRing(ZZ, [2, 3], [\"x\", \"y\"])\n(Multivariate power series ring in x, y over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^2), y + O(y^3) + O(x^2)])\n\njulia> f = R()\nO(y^3) + O(x^2)\n\njulia> g = R(123)\n123 + O(y^3) + O(x^2)\n\njulia> h = R(BigInt(1234))\n1234 + O(y^3) + O(x^2)\n\njulia> k = R(x + 1)\n1 + x + O(y^3) + O(x^2)\n\njulia> m = x + y + O(y^2)\ny + x + O(y^2) + O(x^2)\n\njulia> R, (x, y) = PowerSeriesRing(ZZ, 3, [\"x\", \"y\"])\n(Multivariate power series ring in x, y over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(y^3) + O(x^3), y + O(y^3) + O(x^3)])\n\njulia> n = x + y + O(R, 2)\ny + x + O(y^2) + O(x^2)","category":"page"},{"location":"AbstractAlgebra/mseries/#Basic-ring-functionality","page":"Multivariate series","title":"Basic ring functionality","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Once a multivariate series ring is constructed, there are various ways to construct series in that ring.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"The easiest way is simply using the generators returned by the PowerSeriesRing constructor and build up the power series using basic arithmetic, as described in the Ring interface.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"The power series rings in AbstractAlgebra.jl implement the full Ring interface.","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"We give some examples of such functionality. ","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"note: Note\nThe divexact function can currently only divide by unit series (i.e. whose constant coefficient is invertible).","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"julia> R, (x,) = PowerSeriesRing(ZZ, [5], [\"x\"])\n(Multivariate power series ring in x over Integers, AbstractAlgebra.Generic.AbsMSeries{BigInt, AbstractAlgebra.Generic.MPoly{BigInt}}[x + O(x^5)])\n\njulia> f = x^3 + 3x + 21\n21 + 3*x + x^3 + O(x^5)\n\njulia> h = zero(R)\nO(x^5)\n\njulia> k = one(R)\n1 + O(x^5)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = length(f)\n3\n\njulia> U = base_ring(R)\nIntegers\n\njulia> v = symbols(R)\n1-element Vector{Symbol}:\n :x\n\njulia> T = parent(x + 1)\nMultivariate power series ring in x over Integers\n\njulia> f == deepcopy(f)\ntrue\n\njulia> t = divexact(f*x, 1 + x)\n21*x - 18*x^2 + 18*x^3 - 17*x^4 + O(x^5)","category":"page"},{"location":"AbstractAlgebra/mseries/#Power-series-functionality-provided-by-AbstractAlgebra.jl","page":"Multivariate series","title":"Power series functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"The functionality listed below is automatically provided by AbstractAlgebra.jl for absolute series over any commutative ring.","category":"page"},{"location":"AbstractAlgebra/mseries/#Basic-functionality","page":"Multivariate series","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"nvars(::Generic.AbsMSeriesRing)","category":"page"},{"location":"AbstractAlgebra/mseries/#nvars-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}","page":"Multivariate series","title":"nvars","text":"nvars(R::AbsMSeriesRing)\n\nReturn the number of variables in the series ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"symbols(::MSeriesRing)","category":"page"},{"location":"AbstractAlgebra/mseries/#symbols-Tuple{AbstractAlgebra.MSeriesRing}","page":"Multivariate series","title":"symbols","text":"symbols(R::MSeriesRing)\n\nReturn a vector of symbols, one for each of the variables of the series ring R.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"precision(::Generic.AbsMSeries)","category":"page"},{"location":"AbstractAlgebra/mseries/#precision-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"precision","text":"precision(a::AbsMSeries)\n\nReturn a vector of precisions, one for each variable in the series ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"max_precision(::Generic.AbsMSeriesRing)","category":"page"},{"location":"AbstractAlgebra/mseries/#max_precision-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}","page":"Multivariate series","title":"max_precision","text":"max_precision(R::AbsMSeriesRing)\n\nReturn a vector of precision caps, one for each variable in the ring. Arithmetic operations will be performed to precisions not exceeding these values.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"valuation(::Generic.AbsMSeries)","category":"page"},{"location":"AbstractAlgebra/mseries/#valuation-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"valuation","text":"valuation(a::AbsMSeries)\n\nReturn the valuation of a as a vector of integers, one for each variable.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"coeff(::Generic.AbsMSeries, ::Int)","category":"page"},{"location":"AbstractAlgebra/mseries/#coeff-Tuple{AbstractAlgebra.Generic.AbsMSeries, Int64}","page":"Multivariate series","title":"coeff","text":"coeff(a::AbsMSeries, n::Int)\n\nReturn the coefficient of the n-th nonzero term of the series (or zero if there are fewer than n nonzero terms). Terms are numbered from the least significant term, i.e. the first term displayed when the series is printed.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"characteristic(::Generic.AbsMSeries)","category":"page"},{"location":"AbstractAlgebra/mseries/#characteristic-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"characteristic","text":"characteristic(R::FracField{T}) where T <: RingElem\n\nReturn the characteristic of the given field.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"gen(::Generic.AbsMSeriesRing, ::Int)","category":"page"},{"location":"AbstractAlgebra/mseries/#gen-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing, Int64}","page":"Multivariate series","title":"gen","text":"gen(R::AbsMSeriesRing, i::Int)\n\nReturn the i-th generator (variable) of the series ring R. Numbering starts from 1 for the most significant variable.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"gens(::Generic.AbsMSeriesRing)","category":"page"},{"location":"AbstractAlgebra/mseries/#gens-Tuple{AbstractAlgebra.Generic.AbsMSeriesRing}","page":"Multivariate series","title":"gens","text":"gens(R::AbsMSeriesRing)\n\nReturn a vector of the generators (variables) of the series ring R, starting with the most significant.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"isgen(::Generic.AbsMSeries)","category":"page"},{"location":"AbstractAlgebra/mseries/#isgen-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"isgen","text":"isgen(a::AbsMSeries)\n\nReturn true if the series a is a generator of its parent series ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"isunit(::Generic.AbsMSeries)","category":"page"},{"location":"AbstractAlgebra/mseries/#isunit-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"isunit","text":"isunit(a::AbsMSeries)\n\nReturn true if the series is a unit in its series ring, i.e. if its constant term is a unit in the base ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"length(::Generic.AbsMSeries)","category":"page"},{"location":"AbstractAlgebra/mseries/#length-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"length","text":"length(a::AbsMSeries)\n\nReturn the number of nonzero terms in the series a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/#Iteration","page":"Multivariate series","title":"Iteration","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"coefficients(::Generic.AbsMSeries)","category":"page"},{"location":"AbstractAlgebra/mseries/#coefficients-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"coefficients","text":"coefficients(a::AbsMSeries)\n\nReturn an array of the nonzero coefficients of the series, in the order they would be displayed, i.e. least significant term first.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"exponent_vectors(::Generic.AbsMSeries)","category":"page"},{"location":"AbstractAlgebra/mseries/#exponent_vectors-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"exponent_vectors","text":"exponent_vectors(a::AbsMSeries)\n\nReturn an array of the exponent vectors of the nonzero terms of the series, in the order they would be displayed, i.e. least significant term first.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/#Truncation","page":"Multivariate series","title":"Truncation","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"truncate(::Generic.AbsMSeries, ::Vector{Int})","category":"page"},{"location":"AbstractAlgebra/mseries/#truncate-Tuple{AbstractAlgebra.Generic.AbsMSeries, Vector{Int64}}","page":"Multivariate series","title":"truncate","text":"truncate(a::AbstractAlgebra.AbsMSeries, prec::Vector{Int})\n\nReturn a truncated to (absolute) precisions given by the vector prec.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/#Inversion","page":"Multivariate series","title":"Inversion","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"Base.inv(::Generic.AbsMSeries)","category":"page"},{"location":"AbstractAlgebra/mseries/#inv-Tuple{AbstractAlgebra.Generic.AbsMSeries}","page":"Multivariate series","title":"inv","text":"Base.inv(x::AbsMSeries)\n\nReturn the inverse of the series x. An exception is raised if the series is not a unit.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/#Exact-division","page":"Multivariate series","title":"Exact division","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"divexact(::Generic.AbsMSeries{T}, ::Generic.AbsMSeries{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mseries/#divexact-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.AbsMSeries{T, S} where S, AbstractAlgebra.Generic.AbsMSeries{T, S} where S}} where T<:RingElem","page":"Multivariate series","title":"divexact","text":"divexact(x::AbsMSeries{T}, y::AbsMSeries{T}; check::Bool=true) where T <: RingElement\n\nReturn the exact quotient of the series x by the series y. This function currently assumes y is an invertible series.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/#Evaluation","page":"Multivariate series","title":"Evaluation","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"evaluate(::U, ::Vector{Int}, ::Vector{U}) where {T <: RingElement, U <: Generic.AbsMSeries{T}}","category":"page"},{"location":"AbstractAlgebra/mseries/#evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{Int64}, Vector{U}}} where {T<:RingElement, U<:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S)}","page":"Multivariate series","title":"evaluate","text":"evaluate(a::U, vars::Vector{Int}, vals::Vector{U}) where {T <: RingElement, U <: AbsMSeries{T}}\n\nEvaluate the series expression by substituting in the supplied values in the array vals for the corresponding variables with indices given by the array vars. The values must be in the same ring as a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"evaluate(::U, ::Vector{U}, ::Vector{U}) where {T <: RingElement, U <: Generic.AbsMSeries{T}}","category":"page"},{"location":"AbstractAlgebra/mseries/#evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}, Vector{U}}} where {T<:RingElement, U<:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S)}","page":"Multivariate series","title":"evaluate","text":"evaluate(a::U, vars::Vector{U}, vals::Vector{U}) where {T <: RingElement, U <: AbsMSeries{T}}\n\nEvaluate the series expression by substituting in the supplied values in the array vals for the corresponding variables given by the array vars. The values must be in the same ring as a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"evaluate(::U, ::Vector{U}) where {T <: RingElement, U <: Generic.AbsMSeries{T}}","category":"page"},{"location":"AbstractAlgebra/mseries/#evaluate-Union{Tuple{U}, Tuple{T}, Tuple{U, Vector{U}}} where {T<:RingElement, U<:(AbstractAlgebra.Generic.AbsMSeries{T, S} where S)}","page":"Multivariate series","title":"evaluate","text":"evaluate(a::U, vals::Vector{U}) where {T <: RingElement, U <: AbsMSeries{T}}\n\nEvaluate the series expression by substituting in the supplied values in the array vals for the variables the series ring to which a belongs. The values must be in the same ring as a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mseries/#Random-generation","page":"Multivariate series","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/mseries/","page":"Multivariate series","title":"Multivariate series","text":"rand(::MSeriesRing, term_range, v...)","category":"page"},{"location":"AbstractAlgebra/mseries/#rand-Tuple{AbstractAlgebra.MSeriesRing, Any, Vararg{Any, N} where N}","page":"Multivariate series","title":"rand","text":"rand(S::MSeriesRing, term_range, v...)\n\nReturn a random element of the series ring S with number of terms in the range given by term_range and where coefficients of the series are randomly generated in the base ring using the data given by v. The exponents of the variable in the terms will be less than the precision caps for the Ring S when it was created.\n\n\n\n","category":"method"},{"location":"Hecke/function_fields/basics/#Creation-of-number-fields","page":"-","title":"Creation of number fields","text":"","category":"section"},{"location":"Hecke/function_fields/basics/","page":"-","title":"-","text":"CurrentModule = Hecke\nDocTestSetup = quote\n  using Hecke\nend","category":"page"},{"location":"Hecke/function_fields/basics/","page":"-","title":"-","text":"For details on creation of rational function fields and extensions thereof, refer to the AbstractAlgebra documentation which can be found here https://nemocas.github.io/AbstractAlgebra.jl/stable/function_field/.","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/mpolynomial/#Multivariate-polynomials","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"","category":"section"},{"location":"Nemo/mpolynomial/#Introduction","page":"Multivariate polynomials","title":"Introduction","text":"","category":"section"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Nemo allow the creation of sparse, distributed multivariate polynomials over any computable ring R. There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The following table shows each of the polynomial types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.MPoly{T} Generic.MPolyRing{T}\nmathbbZ Flint fmpz_mpoly FmpzMPolyRing\nmathbbZnmathbbZ (small n) Flint nmod_mpoly NmodMPolyRing\nmathbbQ Flint fmpq_mpoly FmpqMPolyRing","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The following are not implemented yet, but will be available soon:","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Base ring Library Element type Parent type\nmathbbZpmathbbZ (small prime p) Flint gfp_mpoly GFPMPolyRing\nmathbbF_p^n (small p) Flint fq_nmod_mpoly FqNmodMPolyRing","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"The string representation of the variables and the base ring R of a generic polynomial is stored in its parent object. ","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"All polynomial element types belong to the abstract type MPolyElem and all of the polynomial ring types belong to the abstract type MPolyRing. This enables one to write generic functions that can accept any Nemo multivariate polynomial type.","category":"page"},{"location":"Nemo/mpolynomial/#Polynomial-functionality","page":"Multivariate polynomials","title":"Polynomial functionality","text":"","category":"section"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"All multivariate polynomial types in Nemo provide the multivariate polynomial functionality described by AbstractAlgebra:","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/mpolynomial","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"Generic multivariate polynomials are also available.","category":"page"},{"location":"Nemo/mpolynomial/","page":"Multivariate polynomials","title":"Multivariate polynomials","text":"We describe here only functions that are in addition to that guaranteed by AbstractAlgebra.jl, for specific coefficient rings.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"Pages = [\"auxiliary.md\"]","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#Auxiliary-functions","page":"Auxiliary functions","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#Geometric-data","page":"Auxiliary functions","title":"Geometric data","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"facets(P::Polyhedron)\nvertices(P::Polyhedron)\nrays(P::Polyhedron)\naffine_hull(P::Polyhedron{T}) where T<:scalar_types\nambient_dim(P::Polyhedron)\ndim(P::Polyhedron)\ncodim(P::Polyhedron)\nisbounded(P::Polyhedron)\nisfeasible(P::Polyhedron)\nisfulldimensional(P::Polyhedron)\nlineality_dim(P::Polyhedron)\nlineality_space(P::Polyhedron{T}) where T<:scalar_types\nrecession_cone(P::Polyhedron{T}) where T<:scalar_types\nrelative_interior_point(P::Polyhedron{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#facets-Tuple{Polyhedron}","page":"Auxiliary functions","title":"facets","text":"facets(as::Type{T} = AffineHalfspace, P::Polyhedron)\n\nReturn the facets of P in the format defined by as.\n\nThe allowed values for as are\n\nHalfspace,\nPolyhedron,\nPair.\n\nExamples\n\nWe can retrieve the six facets of the 3-dimensional cube this way:\n\njulia> C = cube(3);\n\njulia> facets(Polyhedron, C)\n6-element SubObjectIterator{Polyhedron{fmpq}}:\n A polyhedron in ambient dimension 3\n A polyhedron in ambient dimension 3\n A polyhedron in ambient dimension 3\n A polyhedron in ambient dimension 3\n A polyhedron in ambient dimension 3\n A polyhedron in ambient dimension 3\n\njulia> facets(Halfspace, C)\n6-element SubObjectIterator{AffineHalfspace{fmpq}} over the Halfspaces of R^3 described by:\n-x₁ ≦ 1\nx₁ ≦ 1\n-x₂ ≦ 1\nx₂ ≦ 1\n-x₃ ≦ 1\nx₃ ≦ 1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#vertices-Tuple{Polyhedron}","page":"Auxiliary functions","title":"vertices","text":"vertices(P::Polyhedron)\n\nReturn an iterator over the vertices of a polyhedron P as points.\n\nExamples\n\nThe following code computes the vertices of the Minkowski sum of a triangle and a square:\n\njulia> P = simplex(2) + cube(2);\n\njulia> vertices(P)\n5-element SubObjectIterator{PointVector{fmpq}}:\n [-1, -1]\n [2, -1]\n [2, 1]\n [-1, 2]\n [1, 2]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#rays-Tuple{Polyhedron}","page":"Auxiliary functions","title":"rays","text":"rays(P::Polyhedron)\n\nReturn minimal set of generators of the cone of unbounded directions of P (i.e. its rays) as points.\n\nExamples\n\nWe can verify that the positive orthant of the plane is generated by the two rays in positive unit direction:\n\njulia> PO = convex_hull([0 0], [1 0; 0 1]);\n\njulia> rays(PO)\n2-element SubObjectIterator{RayVector{fmpq}}:\n [1, 0]\n [0, 1]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#affine_hull-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Auxiliary functions","title":"affine_hull","text":"affine_hull(P::Polytope)\n\nReturn the (affine) hyperplanes generating the affine hull of P.\n\nExamples\n\nThis triangle in mathbbR^4 is contained in the plane defined by P =  (x_1 x_2 x_3 x_4)  x_3 = 2  x_4 = 5 .\n\njulia> t = convex_hull([0 0 2 5; 1 0 2 5; 0 1 2 5]);\n\njulia> affine_hull(t)\n2-element SubObjectIterator{AffineHyperplane{fmpq}} over the Hyperplanes of R^4 described by:\nx₃ = 2\nx₄ = 5\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#ambient_dim-Tuple{Polyhedron}","page":"Auxiliary functions","title":"ambient_dim","text":"ambient_dim(P::Polyhedron)\n\nReturn the ambient dimension of P.\n\nExamples\n\njulia> V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];\n\njulia> P = convex_hull(V);\n\njulia> ambient_dim(P)\n3\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#dim-Tuple{Polyhedron}","page":"Auxiliary functions","title":"dim","text":"dim(P::Polyhedron)\n\nReturn the dimension of P.\n\nExamples\n\njulia> V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];\n\njulia> P = convex_hull(V);\n\njulia> dim(P)\n2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#codim-Tuple{Polyhedron}","page":"Auxiliary functions","title":"codim","text":"codim(P::Polyhedron)\n\nReturn the codimension of P.\n\nExamples\n\njulia> V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];\n\njulia> P = convex_hull(V);\n\njulia> codim(P)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#isbounded-Tuple{Polyhedron}","page":"Auxiliary functions","title":"isbounded","text":"isbounded(P::Polyhedron)\n\nCheck whether P is bounded.\n\nExamples\n\njulia> P = Polyhedron([1 -3; -1 1; -1 0; 0 -1],[1,1,1,1]);\n\njulia> isbounded(P)\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#isfeasible-Tuple{Polyhedron}","page":"Auxiliary functions","title":"isfeasible","text":"isfeasible(P::Polyhedron)\n\nCheck whether P is feasible, i.e. non-empty.\n\nExamples\n\njulia> P = Polyhedron([1 -1; -1 1; -1 0; 0 -1],[-1,-1,1,1]);\n\njulia> isfeasible(P)\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#isfulldimensional-Tuple{Polyhedron}","page":"Auxiliary functions","title":"isfulldimensional","text":"isfulldimensional(P::Polyhedron)\n\nCheck whether P is full-dimensional.\n\nExamples\n\njulia> V = [1 2 3; 1 3 2; 2 1 3; 2 3 1; 3 1 2; 3 2 1];\n\njulia> isfulldimensional(convex_hull(V))\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#lineality_dim-Tuple{Polyhedron}","page":"Auxiliary functions","title":"lineality_dim","text":"lineality_dim(P::Polyhedron)\n\nReturn the dimension of the lineality space, i.e. the dimension of the largest affine subspace contained in P.\n\nExamples\n\nPolyhedron with one lineality direction.\n\njulia> C = convex_hull([0 0], [1 0], [1 1])\nA polyhedron in ambient dimension 2\n\njulia> lineality_dim(C)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#lineality_space-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Auxiliary functions","title":"lineality_space","text":"lineality_space(P::Polyhedron)\n\nReturn a matrix whose row span is the lineality space of P.\n\nExamples\n\nDespite not being reflected in this construction of the upper half-plane, its lineality in x-direction is recognized:\n\njulia> UH = convex_hull([0 0],[0 1; 1 0; -1 0]);\n\njulia> lineality_space(UH)\n1-element SubObjectIterator{RayVector{fmpq}}:\n [1, 0]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#recession_cone-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Auxiliary functions","title":"recession_cone","text":"recession_cone(P::Polyhedron)\n\nReturn the recession cone of P.\n\nExamples\n\njulia> P = Polyhedron([1 -2; -1 1; -1 0; 0 -1],[2,1,1,1]);\n\njulia> vertices(P)\n3-element SubObjectIterator{PointVector{fmpq}}:\n [0, -1]\n [-1, 0]\n [-1, -1]\n\njulia> recession_cone(P)\nA polyhedral cone in ambient dimension 2\n\njulia> rays(recession_cone(P))\n2-element SubObjectIterator{RayVector{fmpq}}:\n [1, 1//2]\n [1, 1]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#relative_interior_point-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Auxiliary functions","title":"relative_interior_point","text":"relative_interior_point(P::Polyhedron)\n\nCompute a point in the relative interior point of P, i.e. a point in P not contained in any facet.\n\nExamples\n\nThe square -11^3 has the origin as a relative interior point.\n\njulia> square = cube(2)\nA polyhedron in ambient dimension 2\n\njulia> relative_interior_point(square)\n2-element PointVector{fmpq}:\n 0\n 0\n\njulia> vertices(square)\n4-element SubObjectIterator{PointVector{fmpq}}:\n [-1, -1]\n [1, -1]\n [-1, 1]\n [1, 1]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#Combinatorial-data","page":"Auxiliary functions","title":"Combinatorial data","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"nfacets(P::Polyhedron)\nnvertices(P::Polyhedron)\nf_vector(P::Polyhedron)\ng_vector(P::Polyhedron)\nh_vector(P::Polyhedron)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#nfacets-Tuple{Polyhedron}","page":"Auxiliary functions","title":"nfacets","text":"nfacets(P::Polyhedron)\n\nReturn the number of facets of P.\n\nExamples\n\nThe number of facets of the 5-dimensional cross polytope can be retrieved via the following line:\n\njulia> nfacets(cross(5))\n32\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#nvertices-Tuple{Polyhedron}","page":"Auxiliary functions","title":"nvertices","text":"nvertices(P::Polyhedron)\n\nReturn the number of vertices of P.\n\nExamples\n\nThe 3-cube's number of vertices can be obtained with this input:\n\njulia> C = cube(3);\n\njulia> nvertices(C)\n8\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#f_vector-Tuple{Polyhedron}","page":"Auxiliary functions","title":"f_vector","text":"f_vector(P::Polyhedron)\n\nReturn the vector (f₀f₁f₂f_(dim(P)-1))` where f_i is the number of faces of P of dimension i.\n\nExamples\n\nHere we compute the f-vector of the 5-cube:\n\njulia> f_vector(cube(5))\n5-element Vector{fmpz}:\n 32\n 80\n 80\n 40\n 10\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#g_vector-Tuple{Polyhedron}","page":"Auxiliary functions","title":"g_vector","text":"g_vector(P::Polyhedron)\n\nReturn the (toric) g-vector of a polytope. Defined by g_0 = 1  and g_k = h_k - h_k-1, for 1 leq k leq lceil (d+1)2rceil where h is the h-vector and d=dim(P). Undefined for unbounded polyhedra.\n\nExamples\n\njulia> g_vector(cross(3))\n2-element Vector{fmpz}:\n 1\n 2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#h_vector-Tuple{Polyhedron}","page":"Auxiliary functions","title":"h_vector","text":"h_vector(P::Polyhedron)\n\nReturn the (toric) h-vector of a polytope. For simplicial polytopes this is a linear transformation of the f-vector. Undefined for unbounded polyhedra.\n\nExamples\n\njulia> h_vector(cross(3))\n4-element Vector{fmpz}:\n 1\n 3\n 3\n 1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#Other","page":"Auxiliary functions","title":"Other","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/","page":"Auxiliary functions","title":"Auxiliary functions","text":"all_triangulations\nboundary_lattice_points(P::Polyhedron{fmpq})\ncontains(P::Polyhedron, v::AbstractVector)\nehrhart_polynomial(P::Polyhedron{fmpq})\nehrhart_polynomial(R::FmpqPolyRing, P::Polyhedron{fmpq})\nh_star_polynomial(P::Polyhedron{fmpq})\nh_star_polynomial(R::FmpqPolyRing, P::Polyhedron{fmpq})\ninterior_lattice_points(P::Polyhedron{fmpq})\nisnormal(P::Polyhedron{fmpq})\nissimple(P::Polyhedron)\nissmooth(P::Polyhedron{fmpq})\nis_very_ample(P::Polyhedron{fmpq})\nlattice_points(P::Polyhedron{fmpq})\nlattice_volume(P::Polyhedron{fmpq})\nnormalized_volume(P::Polyhedron{T}) where T<:scalar_types\npolarize(P::Polyhedron{T}) where T<:scalar_types\nproject_full(P::Polyhedron{T}) where T<:scalar_types\nprint_constraints(A::AnyVecOrMat, b::AbstractVector; trivial::Bool = false)\nprint_constraints(P::Polyhedron; trivial::Bool = false)\nregular_triangulations\nregular_triangulation\nsecondary_polytope\nsolve_ineq(A::fmpz_mat, b::fmpz_mat)\nsolve_mixed(A::fmpz_mat, b::fmpz_mat, C::fmpz_mat, d::fmpz_mat)\nsolve_mixed(A::fmpz_mat, b::fmpz_mat, C::fmpz_mat)\nsolve_non_negative(A::fmpz_mat, b::fmpz_mat)\nsupport_function(P::Polyhedron{T}; convention::Symbol = :max) where T<:scalar_types\nvolume(P::Polyhedron{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#all_triangulations","page":"Auxiliary functions","title":"all_triangulations","text":"all_triangulations(pts::AnyVecOrMat; full=false)\n\nCompute all triangulations on the points given as the rows of pts. Optionally select full=true to output full triangulations only, i.e. those that use all given points.\n\nThe return type is a Vector{Vector{Vector{Int}}} where each Vector{Vector{Int}} encodes a triangulation, in which a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nA polyhedron in ambient dimension 2\n\njulia> V = vertices(c)\n4-element SubObjectIterator{PointVector{fmpq}}:\n [0, 0]\n [1, 0]\n [0, 1]\n [1, 1]\n\njulia> all_triangulations(V)\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n [[1, 2, 4], [1, 3, 4]]\n\n\n\nall_triangulations(P::Polyhedron)\n\nCompute all triangulations that can be formed using the vertices of the given bounded and full-dimensional polytope P.\n\nThe return type is a Vector{Vector{Vector{Int}}} where each Vector{Vector{Int}} encodes a triangulation, in which a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nA polyhedron in ambient dimension 2\n\njulia> all_triangulations(c)\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n [[1, 2, 4], [1, 3, 4]]\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#boundary_lattice_points-Tuple{Polyhedron{fmpq}}","page":"Auxiliary functions","title":"boundary_lattice_points","text":"boundary_lattice_points(P::Polyhedron{fmpq})\n\nReturn the integer points contained in the boundary of the bounded polyhedron P.\n\nExamples\n\njulia> c = polarize(cube(3))\nA polyhedron in ambient dimension 3\n\njulia> boundary_lattice_points(c)\n6-element SubObjectIterator{PointVector{fmpz}}:\n [-1, 0, 0]\n [0, -1, 0]\n [0, 0, -1]\n [0, 0, 1]\n [0, 1, 0]\n [1, 0, 0]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#contains-Tuple{Polyhedron, AbstractVector{T} where T}","page":"Auxiliary functions","title":"contains","text":"contains(P::Polyhedron, v::AbstractVector)\n\nCheck whether P contains v.\n\nExamples\n\nThe positive orthant only contains vectors with non-negative entries:\n\njulia> PO = Polyhedron([-1 0; 0 -1], [0, 0]);\n\njulia> contains(PO, [1, 2])\ntrue\n\njulia> contains(PO, [1, -2])\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#ehrhart_polynomial-Tuple{Polyhedron{fmpq}}","page":"Auxiliary functions","title":"ehrhart_polynomial","text":"ehrhart_polynomial(P::Polyhedron{fmpq})\n\nCompute the Ehrhart polynomial of P.\n\nExamples\n\n```jldoctest julia> c = cube(3) A polyhedron in ambient dimension 3\n\njulia> ehrhart_polynomial(c) 8x^3 + 12x^2 + 6*x + 1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#ehrhart_polynomial-Tuple{FmpqPolyRing, Polyhedron{fmpq}}","page":"Auxiliary functions","title":"ehrhart_polynomial","text":"ehrhart_polynomial(R::FmpqMPolyRing, P::Polyhedron{fmpq})\n\nCompute the Ehrhart polynomial of P and return it as a polynomial in R.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rational Field, x)\n\njulia> c = cube(3)\nA polyhedron in ambient dimension 3\n\njulia> ehrhart_polynomial(R, c)\n8*x^3 + 12*x^2 + 6*x + 1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#h_star_polynomial-Tuple{Polyhedron{fmpq}}","page":"Auxiliary functions","title":"h_star_polynomial","text":"h_star_polynomial(P::Polyhedron)\n\nCompute the h^* polynomial of P.\n\nExamples\n\n```jldoctest julia> c = cube(3) A polyhedron in ambient dimension 3\n\njulia> hstarpolynomial(c) x^3 + 23x^2 + 23x + 1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#h_star_polynomial-Tuple{FmpqPolyRing, Polyhedron{fmpq}}","page":"Auxiliary functions","title":"h_star_polynomial","text":"h_star_polynomial(R::FmpqMPolyRing, P::Polyhedron)\n\nCompute the h^* polynomial of P and return it as a polynomial in R.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rational Field, x)\n\njulia> c = cube(3)\nA polyhedron in ambient dimension 3\n\njulia> h_star_polynomial(R, c)\nx^3 + 23*x^2 + 23*x + 1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#interior_lattice_points-Tuple{Polyhedron{fmpq}}","page":"Auxiliary functions","title":"interior_lattice_points","text":"interior_lattice_points(P::Polyhedron{fmpq})\n\nReturn the integer points contained in the interior of the bounded polyhedron P.\n\nExamples\n\njulia> c = cube(3)\nA polyhedron in ambient dimension 3\n\njulia> interior_lattice_points(c)\n1-element SubObjectIterator{PointVector{fmpz}}:\n [0, 0, 0]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#isnormal-Tuple{Polyhedron{fmpq}}","page":"Auxiliary functions","title":"isnormal","text":"isnormal(P::Polyhedron{fmpq})\n\nCheck whether P is normal.\n\nExamples\n\nThe 3-cube is normal.\n\njulia> C = cube(3)\nA polyhedron in ambient dimension 3\n\njulia> isnormal(C)\ntrue\n\nBut this pyramid is not:\n\njulia> P = convex_hull([0 0 0; 0 1 1; 1 1 0; 1 0 1]);\n\njulia> isnormal(P)\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#issimple-Tuple{Polyhedron}","page":"Auxiliary functions","title":"issimple","text":"issimple(P::Polyhedron)\n\nCheck whether P is simple.\n\nExamples\n\njulia> c = cube(2,0,1)\nA polyhedron in ambient dimension 2\n\njulia> issimple(c)\ntrue\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#issmooth-Tuple{Polyhedron{fmpq}}","page":"Auxiliary functions","title":"issmooth","text":"issmooth(P::Polyhedron{fmpq})\n\nCheck whether P is smooth.\n\nExamples\n\nA cube is always smooth.\n\njulia> C = cube(8);\n\njulia> issmooth(C)\ntrue\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#is_very_ample-Tuple{Polyhedron{fmpq}}","page":"Auxiliary functions","title":"is_very_ample","text":"is_very_ample(P::Polyhedron{fmpq})\n\nCheck whether P is very ample.\n\nExamples\n\njulia> c = cube(3)\nA polyhedron in ambient dimension 3\n\njulia> is_very_ample(c)\ntrue\n\njulia> P = convex_hull([0 0 0; 1 1 0; 1 0 1; 0 1 1])\nA polyhedron in ambient dimension 3\n\njulia> is_very_ample(P)\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#lattice_points-Tuple{Polyhedron{fmpq}}","page":"Auxiliary functions","title":"lattice_points","text":"lattice_points(P::Polyhedron{fmpq})\n\nReturn the integer points contained in the bounded polyhedron P.\n\nExamples\n\njulia> S = 2 * simplex(2);\n\njulia> lattice_points(S)\n6-element SubObjectIterator{PointVector{fmpz}}:\n [0, 0]\n [0, 1]\n [0, 2]\n [1, 0]\n [1, 1]\n [2, 0]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#lattice_volume-Tuple{Polyhedron{fmpq}}","page":"Auxiliary functions","title":"lattice_volume","text":"lattice_volume(P::Polyhedron{fmpq})\n\nReturn the lattice volume of P.\n\nExamples\n\njulia> C = cube(2);\n\njulia> lattice_volume(C)\n8\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#normalized_volume-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Auxiliary functions","title":"normalized_volume","text":"normalized_volume(P::Polyhedron)\n\nReturn the (normalized) volume of P.\n\nExamples\n\njulia> C = cube(2);\n\njulia> normalized_volume(C)\n8\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#polarize-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Auxiliary functions","title":"polarize","text":"polarize(P::Polyhedron)\n\nReturn the polar dual of the polyhedron P, consisting of all linear functions whose evaluation on P does not exceed 1.\n\nExamples\n\njulia> square = cube(2)\nA polyhedron in ambient dimension 2\n\njulia> P = polarize(square)\nA polyhedron in ambient dimension 2\n\njulia> vertices(P)\n4-element SubObjectIterator{PointVector{fmpq}}:\n [1, 0]\n [-1, 0]\n [0, 1]\n [0, -1]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#project_full-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Auxiliary functions","title":"project_full","text":"project_full(P::Polyhedron)\n\nProject the polyhedron down such that it becomes full dimensional in the new ambient space.\n\njulia> P = convex_hull([1 0 0; 0 0 0])\nA polyhedron in ambient dimension 3\n\njulia> isfulldimensional(P)\nfalse\n\njulia> p = project_full(P)\nA polyhedron in ambient dimension 1\n\njulia> isfulldimensional(p)\ntrue\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#print_constraints-Tuple{Union{MatElem, AbstractVecOrMat{T} where T}, AbstractVector{T} where T}","page":"Auxiliary functions","title":"print_constraints","text":"print_constraints(A::AnyVecOrMat, b::AbstractVector; trivial::Bool = false, numbered::Bool = false)\n\nPretty print the constraints given by P(Ab) =  x   Ax  b .\n\nTrivial inequalities are counted but omitted. They are included if trivial is set to true.\n\nExamples\n\njulia> print_constraints([-1 0 4 5; 4 4 4 3; 1 0 0 0; 0 0 0 0; 0 0 0 0; 9 9 9 9], [0, 1, 2, 3, -4, 5]; numbered = true)\n1: -x₁ + 4*x₃ + 5*x₄ ≦ 0\n2: 4*x₁ + 4*x₂ + 4*x₃ + 3*x₄ ≦ 1\n3: x₁ ≦ 2\n5: 0 ≦ -4\n6: 9*x₁ + 9*x₂ + 9*x₃ + 9*x₄ ≦ 5\n\njulia> print_constraints([-1 0 4 5; 4 4 4 3; 1 0 0 0; 0 0 0 0; 0 0 0 0; 9 9 9 9], [0, 1, 2, 3, -4, 5]; trivial = true)\n-x₁ + 4*x₃ + 5*x₄ ≦ 0\n4*x₁ + 4*x₂ + 4*x₃ + 3*x₄ ≦ 1\nx₁ ≦ 2\n0 ≦ 3\n0 ≦ -4\n9*x₁ + 9*x₂ + 9*x₃ + 9*x₄ ≦ 5\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#print_constraints-Tuple{Polyhedron}","page":"Auxiliary functions","title":"print_constraints","text":"print_constraints(P::Polyhedron; trivial::Bool = false, numbered::Bool = false)\n\nPretty print the constraints given by P(Ab) =  x   Ax  b .\n\nTrivial inequalities are counted but omitted. They are included if trivial is set to true.\n\nExamples\n\nThe 3-cube is given by -1  x_i  1  i  1 2 3.\n\njulia> print_constraints(cube(3))\n-x₁ ≦ 1\nx₁ ≦ 1\n-x₂ ≦ 1\nx₂ ≦ 1\n-x₃ ≦ 1\nx₃ ≦ 1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#regular_triangulations","page":"Auxiliary functions","title":"regular_triangulations","text":"regular_triangulations(pts::AnyVecOrMat; full=false)\n\nCompute all regular triangulations on the points given as the rows of pts.\n\nA triangulation is regular if it can be induced by weights, i.e. attach a weight to every point, take the convex hull of these new vectors and then take the subdivision corresponding to the facets visible from below (lower envelope). Optionally specify full, i.e. that every triangulation must use all points.\n\nThe return type is a Vector{Vector{Vector{Int}}} where each Vector{Vector{Int}} encodes a triangulation, in which a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nA polyhedron in ambient dimension 2\n\njulia> V = vertices(c)\n4-element SubObjectIterator{PointVector{fmpq}}:\n [0, 0]\n [1, 0]\n [0, 1]\n [1, 1]\n\njulia> regular_triangulations(V)\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n [[1, 3, 4], [1, 2, 4]]\n\n\n\nregular_triangulations(P::Polyhedron)\n\nCompute all regular triangulations that can be formed using the vertices of the given bounded and full-dimensional polytope P.\n\nA triangulation is regular if it can be induced by weights, i.e. attach a weight to every point, take the convex hull of these new vectors and then take the subdivision corresponding to the facets visible from below (lower envelope).\n\nThe return type is a Vector{Vector{Vector{Int}}} where each Vector{Vector{Int}} encodes a triangulation, in which a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nA polyhedron in ambient dimension 2\n\njulia> regular_triangulations(c)\n2-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n [[1, 3, 4], [1, 2, 4]]\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#regular_triangulation","page":"Auxiliary functions","title":"regular_triangulation","text":"regular_triangulation(pts::AnyVecOrMat; full=false)\n\nComputes ONE regular triangulations on the points given as the rows of pts.\n\nA triangulation is regular if it can be induced by weights, i.e. attach a weight to every point, take the convex hull of these new vectors and then take the subdivision corresponding to the facets visible from below (lower envelope). Optionally specify full, i.e. that every triangulation must use all points.\n\nAs for regular_triangulation(pts::AnyVecOrMat; full=false) the return type is Vector{Vector{Vector{Int}}}. Here, only one triangulation is computed, so the outer vector is of length one. Its entry of type Vector{Vector{Int}} encodes the triangulation in question. Recall that a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nA polyhedron in ambient dimension 2\n\njulia> V = vertices(c)\n4-element SubObjectIterator{PointVector{fmpq}}:\n [0, 0]\n [1, 0]\n [0, 1]\n [1, 1]\n\njulia> regular_triangulation(V)\n1-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n\n\n\nregular_triangulation(P::Polyhedron)\n\nComputes ONE regular triangulations that can be formed using the vertices of the given bounded and full-dimensional polytope P.\n\nA triangulation is regular if it can be induced by weights, i.e. attach a weight to every point, take the convex hull of these new vectors and then take the subdivision corresponding to the facets visible from below (lower envelope).\n\nAs for regular_triangulations(P::Polyhedron) the return type is Vector{Vector{Vector{Int}}}. Here, only one triangulation is computed, so the outer vector is of length one. Its entry of type Vector{Vector{Int}} encodes the triangulation in question. Recall that a Vector{Int} encodes a simplex as the set of indices of the vertices of the simplex. I.e. the Vector{Int} [1,2,4] corresponds to the simplex that is the convex hull of the first, second, and fourth input point.\n\nExamples\n\njulia> c = cube(2,0,1)\nA polyhedron in ambient dimension 2\n\njulia> regular_triangulation(c)\n1-element Vector{Vector{Vector{Int64}}}:\n [[1, 2, 3], [2, 3, 4]]\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#secondary_polytope","page":"Auxiliary functions","title":"secondary_polytope","text":"secondary_polytope(P::Polyhedron)\n\nCompute the secondary polytope of a polyhedron, i.e. the convex hull of all the gkz vectors of all its (regular) triangulations. A triangulation here means only using the vertices of P.\n\nExamples\n\nCompute the secondary polytope of the cube.\n\njulia> c = cube(3)\nA polyhedron in ambient dimension 3\n\njulia> sc = secondary_polytope(c)\nA polyhedron in ambient dimension 8\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#solve_ineq-Tuple{fmpz_mat, fmpz_mat}","page":"Auxiliary functions","title":"solve_ineq","text":"solve_ineq(A::fmpz_mat, b::fmpz_mat)\n\nSolve Ax=b, assumes finite set of solutions.\n\nExamples\n\nThe following gives the vertices of the square. The solutions are the rows of the output. Note that the output can be permuted, hence we sort it.\n\njulia> A = fmpz_mat([1 0; 0 1; -1 0; 0 -1]);\n\njulia> b = zero_matrix(FlintZZ, 4,1); b[1,1]=1; b[2,1]=1; b[3,1]=0; b[4,1]=0;\n\njulia> sortslices(Matrix{BigInt}(solve_ineq(A, b)), dims=1)\n4×2 Matrix{BigInt}:\n 0  0\n 0  1\n 1  0\n 1  1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#solve_mixed-NTuple{4, fmpz_mat}","page":"Auxiliary functions","title":"solve_mixed","text":"solve_mixed(A::fmpz_mat, b::fmpz_mat, C::fmpz_mat, d::fmpz_mat)\n\nSolve Ax = b under Cx = d, assumes a finite solution set.\n\nExamples\n\nFind all (x_1 x_2)inmathbbZ^2 such that x_1+x_2=7, x_1ge 2, and x_2ge 3. The solutions are the rows of the output. Note that the output can be permuted, hence we sort it.\n\njulia> A = fmpz_mat([1 1]);\n\njulia> b = zero_matrix(FlintZZ, 1,1); b[1,1]=7;\n\njulia> C = fmpz_mat([1 0; 0 1]);\n\njulia> d = zero_matrix(FlintZZ,2,1); d[1,1]=2; d[2,1]=3;\n\njulia> sortslices(Matrix{BigInt}(solve_mixed(A, b, C, d)), dims=1)\n3×2 Matrix{BigInt}:\n 2  5\n 3  4\n 4  3\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#solve_mixed-Tuple{fmpz_mat, fmpz_mat, fmpz_mat}","page":"Auxiliary functions","title":"solve_mixed","text":"solve_mixed(A::fmpz_mat, b::fmpz_mat, C::fmpz_mat)\n\nSolve Ax = b under Cx = 0, assumes a finite solution set.\n\nExamples\n\nFind all (x_1 x_2)inmathbbZ^2_ge 0 such that x_1+x_2=3. The solutions are the rows of the output. Note that the output can be permuted, hence we sort it.\n\njulia> A = fmpz_mat([1 1]);\n\njulia> b = zero_matrix(FlintZZ, 1,1); b[1,1]=3;\n\njulia> C = fmpz_mat([1 0; 0 1]);\n\njulia> sortslices(Matrix{BigInt}(solve_mixed(A, b, C)), dims=1)\n4×2 Matrix{BigInt}:\n 0  3\n 1  2\n 2  1\n 3  0\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#solve_non_negative-Tuple{fmpz_mat, fmpz_mat}","page":"Auxiliary functions","title":"solve_non_negative","text":"solve_non_negative(A::fmpz_mat, b::fmpz_mat)\n\nFind all solutions to Ax = b, x=0. Assumes a finite set of solutions.\n\nExamples\n\nFind all (x_1 x_2)inmathbbZ^2_ge 0 such that x_1+x_2=3. The solutions are the rows of the output. Note that the output can be permuted, hence we sort it.\n\njulia> A = fmpz_mat([1 1]);\n\njulia> b = zero_matrix(FlintZZ, 1,1); b[1,1]=3;\n\njulia> sortslices(Matrix{BigInt}(solve_non_negative(A, b)), dims=1)\n4×2 Matrix{BigInt}:\n 0  3\n 1  2\n 2  1\n 3  0\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#support_function-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Auxiliary functions","title":"support_function","text":"support_function(P::Polyhedron; convention::Symbol = :max)\n\nProduce a function h(ω) = maxdot(xω)  x in P. max may be changed to min by setting convention = :min.\n\nExamples\n\njulia> P = cube(3) + simplex(3);\n\njulia> φ = support_function(P);\n\njulia> φ([1,2,3])\n9\n\njulia> ψ = support_function(P, convention = :min);\n\njulia> ψ([1,2,3])\n-6\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/auxiliary/#volume-Union{Tuple{Polyhedron{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Auxiliary functions","title":"volume","text":"volume(P::Polyhedron)\n\nReturn the (Euclidean) volume of P.\n\nExamples\n\njulia> C = cube(2);\n\njulia> volume(C)\n4\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"CurrentModule = Oscar","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"using Oscar","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"Pages = [\"abelian_closure.md\"]","category":"page"},{"location":"NumberTheory/abelian_closure/#Abelian-closure-of-the-rationals","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"","category":"section"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"The abelian closure mathbfQ^textab is the maximal abelian extension of mathbfQ inside a fixed algebraic closure and can explicitely described as","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"mathbfQ^mathrmab = mathbfQ(zeta_n mid n in mathbfN)","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"the union of all cyclotomic extensions. Here for n in mathbfN we denote by zeta_n a primitve n-th root of unity.","category":"page"},{"location":"NumberTheory/abelian_closure/#Creation-of-the-abelian-closure-and-elements","page":"Abelian closure of the rationals","title":"Creation of the abelian closure and elements","text":"","category":"section"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"abelian_closure(::FlintRationalField)","category":"page"},{"location":"NumberTheory/abelian_closure/#abelian_closure-Tuple{FlintRationalField}","page":"Abelian closure of the rationals","title":"abelian_closure","text":"abelian_closure(QQ::RationalField)\n\nReturn a pair (K, z) consisting of the abelian closure K of the rationals and a generator z that can be used to construct primitive roots of unity in K.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"Given the abelian closure, the generator can be recovered as follows:","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"gen(::QabField)","category":"page"},{"location":"NumberTheory/abelian_closure/#gen-Tuple{QabField}","page":"Abelian closure of the rationals","title":"gen","text":"gen(M::SubQuo{T}, i::Int) where T\n\nReturn the ith generator of M.\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/#Printing","page":"Abelian closure of the rationals","title":"Printing","text":"","category":"section"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"The n-th primitive root of the abelian closure of will by default be printed as z(n). The printing can be manipulated using the following functions:","category":"page"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"gen(::QabField, ::String)\nset_variable!(::QabField, ::String)\nget_variable(::QabField)","category":"page"},{"location":"NumberTheory/abelian_closure/#gen-Tuple{QabField, String}","page":"Abelian closure of the rationals","title":"gen","text":"gen(K::QabField, s::String)\n\nReturn the generator of the abelian closure K that can be used to construct primitive roots of unity. The string s will be used during printing.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/#set_variable!-Tuple{QabField, String}","page":"Abelian closure of the rationals","title":"set_variable!","text":"set_variable!(K::QabField, s::String)\n\nChange the printing of the primitive n-th root of the abelian closure of the rationals to s(n), where s is the supplied string.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/#get_variable-Tuple{QabField}","page":"Abelian closure of the rationals","title":"get_variable","text":"get_variable(K::QabField)\n\nReturn the string used to print the primitive n-th root of the abelian closure of the rationals.\n\n\n\n\n\n","category":"method"},{"location":"NumberTheory/abelian_closure/#Examples","page":"Abelian closure of the rationals","title":"Examples","text":"","category":"section"},{"location":"NumberTheory/abelian_closure/","page":"Abelian closure of the rationals","title":"Abelian closure of the rationals","text":"julia> K, z = abelian_closure(QQ);\n\njulia> z(4)\nz(4)\n\njulia> ζ = gen(K, \"ζ\")\nGenerator of abelian closure of Q\n\njulia> ζ(5) + ζ(3)\nζ(15)^5 + ζ(15)^3","category":"page"},{"location":"TropicalGeometry/curve/","page":"Curves","title":"Curves","text":"CurrentModule = Oscar","category":"page"},{"location":"TropicalGeometry/curve/","page":"Curves","title":"Curves","text":"using Oscar","category":"page"},{"location":"TropicalGeometry/curve/","page":"Curves","title":"Curves","text":"Pages = [\"curve.md\"]","category":"page"},{"location":"TropicalGeometry/curve/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"TropicalGeometry/curve/#Introduction","page":"Curves","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/curve/","page":"Curves","title":"Curves","text":"An abstract tropical curve is a finite, loopless, mulitgraph. It is defined by an incidence matrix with vertices as columns and edges as rows.","category":"page"},{"location":"TropicalGeometry/curve/","page":"Curves","title":"Curves","text":"A divisor on an abstract tropical curve is a formal linear combination of the vertices with integer coefficients. The degree of a divisor is the sum of its coefficients. A divisor is effective if all its coefficients are nonnegative.","category":"page"},{"location":"TropicalGeometry/curve/","page":"Curves","title":"Curves","text":"For more definitions on the theory of divisors and linear sisyems on abstract tropical curve, we refer to Matthew Baker, Serguei Norine (2007).","category":"page"},{"location":"TropicalGeometry/curve/","page":"Curves","title":"Curves","text":"The tropical Jacobian of an abstract tropical curve is the group of divisors of degree zero modulo the subgroup of principal divisors. Here a principal divisor is the divisor associated to a piecewise-linear function on the vertices by the Laplacian operator. The tropical Jacobian is a finite abelian group, with order equal to the number of maximal spanning trees in the graph. It is isomorphic to prodmathbbZn_imathbbZ, where the n_i are the nonzero elementary divisors of the Laplacian matrix. For more details, see Matthew Baker, Serguei Norine (2007).","category":"page"},{"location":"TropicalGeometry/curve/#Construction","page":"Curves","title":"Construction","text":"","category":"section"},{"location":"TropicalGeometry/curve/","page":"Curves","title":"Curves","text":"TropicalCurve(PC::PolyhedralComplex)\nDivisorOnTropicalCurve(tc::TropicalCurve, coeffs::Vector{Int})","category":"page"},{"location":"TropicalGeometry/curve/#TropicalCurve-Tuple{PolyhedralComplex}","page":"Curves","title":"TropicalCurve","text":"TropicalCurve(PC::PolyhedralComplex)\n\nConstruct a tropical curve from a polyhedral complex. If the curve is embedded, vertices must are points in mathbb R^n. If the curve is abstract, the polyhedral complex is empty, vertices must be 1, ..., n, and the graph is given as attribute.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4]])\n3×4 IncidenceMatrix\n[1, 2]\n[1, 3]\n[1, 4]\n\n\njulia> VR = [0 0; 1 0; -1 0; 0 1]\n4×2 Matrix{Int64}:\n  0  0\n  1  0\n -1  0\n  0  1\n\njulia> PC = PolyhedralComplex{fmpq}(IM, VR)\nA polyhedral complex in ambient dimension 2\n\njulia> TC = TropicalCurve(PC)\nA min tropical curve in 2-dimensional Euclidean space\n\njulia> abs_TC = TropicalCurve(IM)\nAn abstract min tropical curve\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#DivisorOnTropicalCurve-Tuple{TropicalCurve, Vector{Int64}}","page":"Curves","title":"DivisorOnTropicalCurve","text":"DivisorOnTropicalCurve(tc::TropicalCurve, coeffs::Vector{Int})\n\nConstruct a divisor with coefficients coeffs on an abstract tropical curve tc.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]);\n\njulia> tc = TropicalCurve(IM)\nAn abstract min tropical curve\n\njulia> coeffs = [0, 1, 1, 1];\n\njulia> dtc = DivisorOnTropicalCurve(tc,coeffs)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [0, 1, 1, 1])\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#Auxiliary-functions","page":"Curves","title":"Auxiliary functions","text":"","category":"section"},{"location":"TropicalGeometry/curve/","page":"Curves","title":"Curves","text":"graph(tc::TropicalCurve)\nn_nodes(tc::TropicalCurve)\ncoefficients(dtc::DivisorOnTropicalCurve)\ndegree(dtc::DivisorOnTropicalCurve)\nis_effective(dtc::DivisorOnTropicalCurve)\nchip_firing_move(dtc::DivisorOnTropicalCurve, position::Int)\nv_reduced(dtc::DivisorOnTropicalCurve, vertex::Int)\nis_linearly_equivalent(dtc1::DivisorOnTropicalCurve, dtc2::DivisorOnTropicalCurve)\nstructure_tropical_jacobian(tc::TropicalCurve) ","category":"page"},{"location":"TropicalGeometry/curve/#graph-Tuple{TropicalCurve}","page":"Curves","title":"graph","text":"graph(tc::TropicalCurve)\n\nReturn the graph of an abstract tropical curve tc.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]);\n\njulia> tc = TropicalCurve(IM)\nAn abstract min tropical curve\n\njulia> graph(tc)\n6×4 IncidenceMatrix\n[1, 2]\n[1, 3]\n[1, 4]\n[2, 3]\n[2, 4]\n[3, 4]\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#n_nodes-Tuple{TropicalCurve}","page":"Curves","title":"n_nodes","text":"n_nodes(tc::TropicalCurve)\n\nReturn the number of nodes of an abstract tropical curve tc.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]);\n\njulia> tc = TropicalCurve(IM)\nAn abstract min tropical curve\n\njulia> n_nodes(tc)\n4\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#coefficients-Tuple{DivisorOnTropicalCurve}","page":"Curves","title":"coefficients","text":"coefficients(dtc::DivisorOnTropicalCurve)\n\nConstruct a divisor dtc with coefficients coeffs on an abstract tropical curve.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]);\n\njulia> tc = TropicalCurve(IM)\nAn abstract min tropical curve\n\njulia> coeffs = [0, 1, 1, 1];\n\njulia> dtc = DivisorOnTropicalCurve(tc,coeffs)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [0, 1, 1, 1])\n\njulia> coefficients(dtc)\n4-element Vector{Int64}:\n 0\n 1\n 1\n 1\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#degree-Tuple{DivisorOnTropicalCurve}","page":"Curves","title":"degree","text":"degree(dtc::DivisorOnTropicalCurve)\n\nCompute the degree of  a divisor dtc on an abstract tropical curve.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]);\n\njulia> tc = TropicalCurve(IM)\nAn abstract min tropical curve\n\njulia> coeffs = [0, 1, 1, 1];\n\njulia> dtc = DivisorOnTropicalCurve(tc,coeffs)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [0, 1, 1, 1])\n\njulia> degree(dtc)\n3\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#is_effective-Tuple{DivisorOnTropicalCurve}","page":"Curves","title":"is_effective","text":"is_effective(dtc::DivisorOnTropicalCurve)\n\nCheck whether a divisor dtc on an abstract tropical curve is effective.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]);\n\njulia> tc = TropicalCurve(IM)\nAn abstract min tropical curve\n\njulia> coeffs = [0, 1, 1, 1];\n\njulia> dtc = DivisorOnTropicalCurve(tc,coeffs)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [0, 1, 1, 1])\n\njulia> is_effective(dtc)\ntrue\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#chip_firing_move-Tuple{DivisorOnTropicalCurve, Int64}","page":"Curves","title":"chip_firing_move","text":"chipfiringmove(dtc::DivisorOnTropicalCurve, position::Int)\n\nGiven a divisor dtc and vertex labelled position, compute the linearly equivalent divisor obtained by a chip firing move from the given vertex position.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]);\n\njulia> tc = TropicalCurve(IM)\nAn abstract min tropical curve\n\njulia> coeffs = [0, 1, 1, 1];\n\njulia> dtc = DivisorOnTropicalCurve(tc,coeffs)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [0, 1, 1, 1])\n\njulia> chip_firing_move(dtc,1)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [-3, 2, 2, 2])\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#v_reduced-Tuple{DivisorOnTropicalCurve, Int64}","page":"Curves","title":"v_reduced","text":"v_reduced(dtc::DivisorOnTropicalCurve, vertex::Int)\n\nGiven a divisor dtc and vertex labelled vertex, compute the unique divisor reduced with repspect to vertex as defined in Matthew Baker, Serguei Norine (2007). The divisor dtc must have positive coefficients apart from vertex.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]);\n\njulia> tc = TropicalCurve(IM)\nAn abstract min tropical curve\n\njulia> coeffs = [0, 1, 1, 1];\n\njulia> dtc = DivisorOnTropicalCurve(tc,coeffs)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [0, 1, 1, 1])\n\njulia> v_reduced(dtc,1)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [3, 0, 0, 0])\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#is_linearly_equivalent-Tuple{DivisorOnTropicalCurve, DivisorOnTropicalCurve}","page":"Curves","title":"is_linearly_equivalent","text":"islinearlyequivalent(dtc1::DivisorOnTropicalCurve, dtc2::DivisorOnTropicalCurve)\n\nGiven two effective divisors dtc1 and dtc2 on the same tropical curve, check whether they are linearly equivalent.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]);\n\njulia> tc = TropicalCurve(IM)\nAn abstract min tropical curve\n\njulia> coeffs1 = [0, 1, 1, 1];\n\njulia> dtc1 = DivisorOnTropicalCurve(tc,coeffs1)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [0, 1, 1, 1])\n\njulia> coeffs2 = [3,0,0,0];\n\njulia> dtc2 = DivisorOnTropicalCurve(tc,coeffs2)\nDivisorOnTropicalCurve{min, false}(An abstract min tropical curve, [3, 0, 0, 0])\n\njulia> is_linearly_equivalent(dtc1, dtc2)\ntrue\n\n\n\n","category":"method"},{"location":"TropicalGeometry/curve/#structure_tropical_jacobian-Tuple{TropicalCurve}","page":"Curves","title":"structure_tropical_jacobian","text":"structure_tropical_jacobian(TC::TropicalCurve)\n\nCompute the elementary divisors n_i of the Laplacian matrix of the tropical curve TC. The tropical Jacobian is then isomorphic to prod (Z(n_i)Z).\n\nExamples\n\njulia> cg = Oscar.Graphs.complete_graph(5);\n\njulia> IM1=IncidenceMatrix([[Oscar.Graphs.src(e), Oscar.Graphs.dst(e)] for e in Oscar.Graphs.edges(cg)])\n10×5 IncidenceMatrix\n[1, 2]\n[1, 3]\n[2, 3]\n[1, 4]\n[2, 4]\n[3, 4]\n[1, 5]\n[2, 5]\n[3, 5]\n[4, 5]\n\njulia> TC1 = TropicalCurve(IM1)\nAn abstract min tropical curve\n\njulia> structure_tropical_jacobian(TC1)\n(General) abelian group with relation matrix\n[1 0 0 0; 0 5 0 0; 0 0 5 0; 0 0 0 5]\n\njulia> cg2 = Oscar.Graphs.complete_graph(3);\n\njulia> IM2=IncidenceMatrix([[Oscar.Graphs.src(e), Oscar.Graphs.dst(e)] for e in Oscar.Graphs.edges(cg2)])\n3×3 IncidenceMatrix\n[1, 2]\n[1, 3]\n[2, 3]\n\njulia> TC2 = TropicalCurve(IM2)\nAn abstract min tropical curve\n\njulia> structure_tropical_jacobian(TC2)\n(General) abelian group with relation matrix\n[1 0; 0 3]\n\njulia> IM3 = IncidenceMatrix([[1,2],[2,3],[3,4],[4,5],[1,5]])\n5×5 IncidenceMatrix\n[1, 2]\n[2, 3]\n[3, 4]\n[4, 5]\n[1, 5]\n\njulia> TC3=TropicalCurve(IM3)\nAn abstract min tropical curve\n\njulia> G = structure_tropical_jacobian(TC3)\n(General) abelian group with relation matrix\n[1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 5]\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/submodule/#Submodules","page":"Submodules","title":"Submodules","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"AbstractAlgebra allows the construction of submodules/subvector spaces of AbstractAlgebra modules over euclidean domains. These are given as the submodule generated by a finite list of elements in the original module.","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"We define two submodules to be equal if they are (transitively) submodules of the same module M and their generators generate the same set of elements.","category":"page"},{"location":"AbstractAlgebra/submodule/#Generic-submodule-type","page":"Submodules","title":"Generic submodule type","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"AbstractAlgebra implements a generic submodule type Generic.Submodule{T} where T is the element type of the base ring in src/generic/Submodule.jl. See src/generic/GenericTypes.jl for more details of the type definition.","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Elements of a generic submodule have type Generic.SubmoduleElem{T}.","category":"page"},{"location":"AbstractAlgebra/submodule/#Abstract-types","page":"Submodules","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Submodule types belong to the abstract type FPModule{T} and their elements to FPModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/submodule/#Constructors","page":"Submodules","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"sub(::FPModule{T}, ::Vector{FPModuleElem{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#sub-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, Array{AbstractAlgebra.FPModuleElem{T}, 1}}} where T<:RingElement","page":"Submodules","title":"sub","text":"sub(m::AbstractAlgebra.FPModule{T}, gens::Vector{<:AbstractAlgebra.FPModuleElem{T}}) where T <: RingElement\n\nReturn the submodule of the module m generated by the given generators, given as elements of m.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"sub(::FPModule{T}, ::Vector{Generic.Submodule{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#sub-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, Array{AbstractAlgebra.Generic.Submodule{T}, 1}}} where T<:RingElement","page":"Submodules","title":"sub","text":"sub(m::Module{T}, subs::Vector{<:Generic.Submodule{T}}) where T <: RingElement\n\nReturn the submodule S of the module m generated by the union of the given submodules of m, and a map which is the canonical injection from S to m.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Note that the preimage of the canonical injection can be obtained using the preimage function described in the section on module homomorphisms. As the canonical injection is injective, this is unique.","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> n = M([ZZ(2), ZZ(-1)])\n(2, -1)\n\njulia> N, f = sub(M, [m, n])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> v = N([ZZ(3), ZZ(4)])\n(3, 4)\n\njulia> v2 = f(v)\n(3, 26)\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> n = V([QQ(2), QQ(-1)])\n(2//1, -1//1)\n\njulia> N, f = sub(V, [m, n])\n(Subspace over Rationals with 2 generators and no relations\n, Module homomorphism with\nDomain: Subspace over Rationals with 2 generators and no relations\n\nCodomain: Vector space of dimension 2 over Rationals)\n","category":"page"},{"location":"AbstractAlgebra/submodule/#Functionality-for-submodules","page":"Submodules","title":"Functionality for submodules","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"In addition to the Module interface, AbstractAlgebra submodules implement the following functionality.","category":"page"},{"location":"AbstractAlgebra/submodule/#Basic-manipulation","page":"Submodules","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"supermodule(::Generic.Submodule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#supermodule-Union{Tuple{AbstractAlgebra.Generic.Submodule{T}}, Tuple{T}} where T<:RingElement","page":"Submodules","title":"supermodule","text":"supermodule(M::Submodule{T}) where T <: RingElement\n\nReturn the module that this module is a submodule of.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"issubmodule(::FPModule{T}, ::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#issubmodule-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Submodules","title":"issubmodule","text":"issubmodule(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true if N was constructed as a submodule of M. The relation is taken transitively (i.e. subsubmodules are submodules for the purposes of this relation, etc). The module M is also considered a submodule of itself for this relation.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"iscompatible(::FPModule{T}, ::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#iscompatible-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Submodules","title":"iscompatible","text":"iscompatible(M::AbstractAlgebra.FPModule{T}, N::AbstractAlgebra.FPModule{T}) where T <: RingElement\n\nReturn true, P if the given modules are compatible, i.e. that they are (transitively) submodules of the same module, P. Otherwise return false, M.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"dim(N::Generic.Submodule{T}) where T <: FieldElement","category":"page"},{"location":"AbstractAlgebra/submodule/#dim-Union{Tuple{AbstractAlgebra.Generic.Submodule{T}}, Tuple{T}} where T<:FieldElement","page":"Submodules","title":"dim","text":"dim(N::Submodule{T}) where T <: FieldElement\n\nReturn the dimension of the given vector subspace.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> n = M([ZZ(1), ZZ(4)])\n(1, 4)\n\njulia> N1, = sub(M, [m, n])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> N2, = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> supermodule(N1) == M\ntrue\n\njulia> iscompatible(N1, N2)\n(true, Free module of rank 2 over Integers)\n\njulia> issubmodule(N1, M)\nfalse\n\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> m = V([QQ(2), QQ(3)])\n(2//1, 3//1)\n\njulia> N, = sub(V, [m])\n(Subspace over Rationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Subspace over Rationals with 1 generator and no relations\n\nCodomain: Vector space of dimension 2 over Rationals)\n\njulia> dim(V)\n2\n\njulia> dim(N)\n1\n","category":"page"},{"location":"AbstractAlgebra/submodule/#Intersection","page":"Submodules","title":"Intersection","text":"","category":"section"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Base.intersect(M::FPModule{T}, N::FPModule{T}) where\nT <: RingElement","category":"page"},{"location":"AbstractAlgebra/submodule/#intersect-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Submodules","title":"intersect","text":"Base.intersect(M::FPModule{T}, N::FPModule{T}) where T <: RingElement\n\nReturn the intersection of the modules M as a submodule of M. Note that M and N must be (constructed as) submodules (transitively) of some common module P.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/submodule/","page":"Submodules","title":"Submodules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> n = M([ZZ(1), ZZ(4)])\n(1, 4)\n\njulia> N1 = sub(M, [m, n])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> N2 = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> I = intersect(N1, N2)\nUnion{AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}, AbstractAlgebra.Generic.Submodule{BigInt}}[]","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"Pages = [\"linear_programs.md\"]","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#Linear-Programs","page":"Linear Programs","title":"Linear Programs","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/#Introduction","page":"Linear Programs","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"The purpose of a linear program is to optimize a linear function over a polyhedron.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#Constructions","page":"Linear Programs","title":"Constructions","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"Linear programs are constructed from a polyhedron and a linear objective function which is described by a vector and (optionally) a translation. One can select whether the optimization problem is to maximize or to minimize the objective function.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"LinearProgram","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#LinearProgram","page":"Linear Programs","title":"LinearProgram","text":"LinearProgram(P, c; k = 0, convention = :max)\n\nThe linear program on the feasible set P (a Polyhedron) with respect to the function x ↦ dot(c,x)+k.\n\n\n\n","category":"type"},{"location":"PolyhedralGeometry/linear_programs/#Solving-a-linear-program-an-example","page":"Linear Programs","title":"Solving a linear program - an example","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"Let P=-11^3 be the 3-dimensional cube in mathbbR^3, and consider the linear function ell, given by ell(xyz) = 3x-2y+4z+2. Minimizing ell over P can be done by solving the corresponding linear program. Computationally, this means first defining a linear program:","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"P = cube(3)\nLP = LinearProgram(P,[3,-2,4];k=2,convention = :min)","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"The information about the linear program LP can be easily extracted.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"c, k = objective_function(LP)\nP == feasible_region(LP)\nℓ = objective_function(LP; as = :function)","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"To solve the optimization problem call solve_lp, which returns a pair m, v where the optimal value is m, and that value is attained at v.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"m, v = solve_lp(LP)\nℓ(v) == m","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"The optimal value and an optimal vertex may be obtained individually as well.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"M = optimal_value(LP)\nV = optimal_vertex(LP)\nℓ(V) == M","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#Functions","page":"Linear Programs","title":"Functions","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"After constructing a linear program, it is straightforward to extract the feasible region and objective function","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"feasible_region\nobjective_function","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#feasible_region","page":"Linear Programs","title":"feasible_region","text":"feasible_region(lp::LinearProgram)\n\nReturn the feasible region of the linear program lp, which is a Polyhedron.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/linear_programs/#objective_function","page":"Linear Programs","title":"objective_function","text":"objective_function(LP::LinearProgram; as = :pair)\n\nReturn the objective function x ↦ dot(c,x)+k of the linear program LP. The allowed values for as are\n\npair: Return the pair (c,k)\nfunction: Return the objective function as a function.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"Calling solve_lp on a linear program outputs a pair: the optimal value and the vertex at which the optimum is obtained","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"solve_lp","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#solve_lp","page":"Linear Programs","title":"solve_lp","text":"solve_lp(LP::LinearProgram)\n\nReturn a pair (m,v) where the optimal value m of the objective  function of LP is attained at v (if m exists). If the optimum  is not attained, m may be inf or -inf in which case v is  nothing.\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"One can obtain the optimal value of the objective function over the feasible region, if it exists.","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"optimal_value","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#optimal_value","page":"Linear Programs","title":"optimal_value","text":"optimal_value(LP::LinearProgram)\n\nReturn, if it exists, the optimal value of the objective function of LP over the feasible region of LP. Otherwise, return -inf or inf depending on convention.\n\nExamples\n\nThe following example constructs a linear program over the three dimensional cube, and obtains the minimal value of the function (x,y,z) ↦ x+2y-3z over that cube.\n\njulia> C=cube(3)\nA polyhedron in ambient dimension 3\n\njulia> LP=LinearProgram(C,[1,2,-3]; convention = :min)\nThe linear program\n   min{c⋅x + k | x ∈ P}\nwhere P is a Polyhedron{fmpq} and\n   c=Polymake.Rational[1 2 -3]\n   k=0\n\njulia> optimal_value(LP)\n-6\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"One can also obtain an optimal vertex at which the objective function attains its optimal value (respectively).","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"optimal_vertex","category":"page"},{"location":"PolyhedralGeometry/linear_programs/#optimal_vertex","page":"Linear Programs","title":"optimal_vertex","text":"optimal_vertex(LP::LinearProgram)\n\nReturn either a point of the feasible region of LP which optimizes the objective function of LP, or nothing if no such point exists.\n\nExamples\n\nThe following example constructs a linear program over the three dimensional cube, and obtains the vertex of the cube which maximizes the function (x,y,z) ↦ x+2y-3z.\n\njulia> C=cube(3)\nA polyhedron in ambient dimension 3\n\njulia> LP=LinearProgram(C,[1,2,-3])\nThe linear program\n   max{c⋅x + k | x ∈ P}\nwhere P is a Polyhedron{fmpq} and\n   c=Polymake.Rational[1 2 -3]\n   k=0\n\njulia> optimal_vertex(LP)\n3-element PointVector{fmpq}:\n 1\n 1\n -1\n\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/linear_programs/#Saving-and-loading","page":"Linear Programs","title":"Saving and loading","text":"","category":"section"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"Objects of type LinearProgram can be saved to a file and loaded from a file in the following way:","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"C = cube(3)\nLP=LinearProgram(C, [1,2,-3], convention=:min)\nsave(LP, \"lp.poly\")\nLP0 = load(\"lp.poly\")\nsolve_lp(LP0)\nsolve_lp(LP)","category":"page"},{"location":"PolyhedralGeometry/linear_programs/","page":"Linear Programs","title":"Linear Programs","text":"The file is in JSON format and contains all previously gathered data belonging to the underlying polymake object. In particular, this file can now be read by both polymake and Oscar.","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"AlgebraicGeometry/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"In this chapter, we introduce structures and functionality for dealing with varieties, sheaves, and schemes.","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"This part of Oscar is at the very beginning of its development.","category":"page"},{"location":"AlgebraicGeometry/intro/","page":"Introduction","title":"Introduction","text":"We refer to the individual sections for references which provide details on theory and algorithms.","category":"page"},{"location":"Hecke/orders/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"This chapter deals with number fields and orders there of. We follow the common terminology and conventions as e.g. used in Henri Cohen (1993), Henri Cohen (2000), M. Pohst, H. Zassenhaus (1997) or Daniel A. Marcus (2018).","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"If K is a number field, then an order mathcal O of K is a subring of the ring of integers mathcal O_K of K, which is free of rank K  mathbf Q as a mathbf Z-module. Depending on whether K is an absolute field or relative field, orders are treated differently. As far as possible, the interaction and the interface for orders of absolute number fields and of relative number fields is the same.","category":"page"},{"location":"Hecke/orders/introduction/#Orders-of-absolute-number-fields","page":"Introduction","title":"Orders of absolute number fields","text":"","category":"section"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"Assume that K is defined as an absolute field. An order mathcal O of such a field are constructed (implicitely) by specifying a mathbf Z-basis, which is refered to as the basis of mathcal O. If (omega_1dotscomega_d) is the basis of mathcal O and (alpha_1dotscalpha_d) the basis of K, then the matrix B in operatornameMat_d times d(mathbf Q) with","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"beginpmatrix omega_1  vdots  omega_d endpmatrix = B beginpmatrix alpha_1  vdots  alpha_d endpmatrix","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"is the basis matrix of K. If K = mathbfQ(alpha) = mathbfQx(f) is simple with f in mathbfZx, then natural order mathbf Zalpha = mathbfZx(f) is called the equation order of K.","category":"page"},{"location":"Hecke/orders/introduction/#Orders-of-relative-number-fields","page":"Introduction","title":"Orders of relative number fields","text":"","category":"section"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"Orders in non-absolute number fields, that is, relative extensions, are represented differently. Let LK be a finite extension of number fields, then currently we require any order in L to contain mathcal O_K, the ring of integers of K. In this case, an order mathcal O in L is a finitly generated torsion-free module over the Dedekind domain mathcal O_K. As a ring, the order mathcal O is unitary and has L as a fraction field. Due to mathcal O_K in general not being a principal ideal domain, the module structure is more complicated and requires so called pseudo-matrices. See here for details on pseudo-matrices, or Henri Cohen (2000), Chapter 1 for an introduction.","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"In short, mathcal O is represented as sum mathfrak a_i omega_i with fractional mathcal O_K ideals mathfrak a_isubset K and K-linear independent elements omega_iin L. In general it is impossible to have both mathfrak a_i integral and omega_i in mathcal O, thus coefficients will not be integral and/or generators not in the structure.","category":"page"},{"location":"Hecke/orders/introduction/#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"Usually, to create an order, one starts with a field (or a polynomial):","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"using Hecke; # hide\nQx, x = PolynomialRing(QQ, \"x\");\nK, a = NumberField(x^2 - 10, \"a\");\nE = EquationOrder(K)\nZ_K = MaximalOrder(K)\nconductor(E)\nE == Z_K","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"Once orders are created, we can play with elements and ideals:","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"lp = prime_decomposition(Z_K, 2)\np = lp[1][1]\nisprincipal(p)\nfl, alpha = isprincipal(p^2)\nnorm(alpha)","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"It is possible to work with residue fields as well:","category":"page"},{"location":"Hecke/orders/introduction/","page":"Introduction","title":"Introduction","text":"Fp, mFp = ResidueField(Z_K, p)\n[ mFp(x) for x = basis(Z_K)]","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"Pages = [\"cones.md\"]","category":"page"},{"location":"PolyhedralGeometry/cones/#Cones","page":"Cones","title":"Cones","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/#Introduction","page":"Cones","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers and other fields are not yet supported everywhere in the implementation.","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"A set C subseteq mathbbF^n is called a (polyhedral) cone if it can be written as the set of nonnegative linear combinations of finitely many vectors in mathbbF^n.  Equivalently, cones can be written as the intersection of finitely many homogeneous linear inequalities.","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"Any cone is a special case of a polyhedron.  Conversely, intersecting a cone with a suitable affine hyperplane yields a polyhedron whose faces are in bijection with the faces of the cone.  Going back and forth between polyhedra and their homogenizations, the cones, is a frequent operation.  This is one reason for keeping cones as a distinct type.","category":"page"},{"location":"PolyhedralGeometry/cones/#Construction","page":"Cones","title":"Construction","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"positive_hull(::Type{T}, ::Union{Oscar.MatElem, AbstractMatrix}) where T<:scalar_types\nsecondary_cone(SOP::SubdivisionOfPoints{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/cones/#positive_hull-Union{Tuple{T}, Tuple{Type{T}, Union{MatElem, AbstractMatrix{T} where T}}} where T<:Union{Float64, fmpq, nf_elem}","page":"Cones","title":"positive_hull","text":"positive_hull([::Type{T} = fmpq,] R::Union{Oscar.MatElem, AbstractMatrix, SubObjectIterator})\n\nA polyhedral cone, not necessarily pointed, defined by the positive hull of the rows of the matrix R. This means the cone consists of all positive linear combinations of the rows of R. This is an interior description, analogous to the V-representation of a polytope.\n\nRedundant rays are allowed.\n\nExamples\n\njulia> R = [1 0; 0 1];\n\njulia> PO = positive_hull(R)\nA polyhedral cone in ambient dimension 2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#secondary_cone-Union{Tuple{SubdivisionOfPoints{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Cones","title":"secondary_cone","text":"secondary_cone(SOP::SubdivisionOfPoints)\n\nReturn the secondary cone of a subdivision of points, the closure of all the weight vectors inducing the given subdivision of points.\n\nExamples\n\nFor a non-regular subdivision, the secondary cone can still contain non-trivial weights, but it will not be full-dimensional.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = IncidenceMatrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = SubdivisionOfPoints(moaepts, moaeimnonreg0)\nA subdivision of points in ambient dimension 3\n\njulia> C = secondary_cone(MOAE)\nA polyhedral cone in ambient dimension 6\n\njulia> dim(C)\n4\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#Saving-and-loading","page":"Cones","title":"Saving and loading","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"Objects of type Cone can be saved to a file and loaded from a file in the following way:","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"C = positive_hull([1 0; 0 1])\nsave(C, \"C.cone\")\nCC = load(\"C.cone\")\ncollect(rays(CC))","category":"page"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"The file is in JSON format and contains all previously gathered data belonging to the underlying polymake object. In particular, this file can now be read by both polymake and Oscar.","category":"page"},{"location":"PolyhedralGeometry/cones/#Auxiliary-functions","page":"Cones","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"ambient_dim(C::Cone)\ncontains(C::Cone, v::AbstractVector)\nf_vector(C::Cone)\nhilbert_basis(C::Cone{fmpq})\ncodim(C::Cone)\ndim(C::Cone)\npolarize(C::Cone{T}) where T<:scalar_types\nintersect(C0::Cone{T}, C1::Cone{T}) where T<:scalar_types\nispointed(C::Cone)\nisfulldimensional(C::Cone)\nlineality_dim(C::Cone)\nlineality_space(C::Cone{T}) where T<:scalar_types\nnfacets(C::Cone)\nnrays(C::Cone)\nrays(C::Cone)","category":"page"},{"location":"PolyhedralGeometry/cones/#ambient_dim-Tuple{Cone}","page":"Cones","title":"ambient_dim","text":"ambient_dim(C::Cone)\n\nReturn the ambient dimension of C.\n\nExamples\n\nThe cone C in this example is 2-dimensional within a 3-dimensional ambient space.\n\njulia> C = Cone([1 0 0; 1 1 0; 0 1 0]);\n\njulia> ambient_dim(C)\n3\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#contains-Tuple{Cone, AbstractVector{T} where T}","page":"Cones","title":"contains","text":"contains(C::Cone, v::AbstractVector)\n\nCheck whether C contains v.\n\nExamples\n\nThe positive orthant only contains vectors with non-negative entries:\n\njulia> C = positive_hull([1 0; 0 1]);\n\njulia> contains(C, [1, 2])\ntrue\n\njulia> contains(C, [1, -2])\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#f_vector-Tuple{Cone}","page":"Cones","title":"f_vector","text":"f_vector(C::Cone)\n\nCompute the vector (f₁f₂f_(dim(C)-1))` where f_i is the number of faces of C of dimension i.\n\nExamples\n\nTake the cone over a square, then the f-vector of the cone is the same as of the square.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 1 1; 1 0 1])\nA polyhedral cone in ambient dimension 3\n\njulia> f_vector(C)\n2-element Vector{fmpz}:\n 4\n 4\n\njulia> square = cube(2)\nA polyhedron in ambient dimension 2\n\njulia> f_vector(square)\n2-element Vector{fmpz}:\n 4\n 4\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#hilbert_basis-Tuple{Cone{fmpq}}","page":"Cones","title":"hilbert_basis","text":"hilbert_basis(C::Cone{fmpq})\n\nReturn the Hilbert basis of a pointed cone C as the rows of a matrix.\n\nExamples\n\nThis (non-smooth) cone in the plane has a hilbert basis with three elements.\n\njulia> C = Cone([1 0; 1 2])\nA polyhedral cone in ambient dimension 2\n\njulia> matrix(ZZ, hilbert_basis(C))\n[1   0]\n[1   2]\n[1   1]\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#codim-Tuple{Cone}","page":"Cones","title":"codim","text":"codim(C::Cone)\n\nReturn the codimension of C.\n\nExamples\n\nThe cone C in this example is 2-dimensional within a 3-dimensional ambient space.\n\njulia> C = Cone([1 0 0; 1 1 0; 0 1 0]);\n\njulia> codim(C)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#dim-Tuple{Cone}","page":"Cones","title":"dim","text":"dim(C::Cone)\n\nReturn the dimension of C.\n\nExamples\n\nThe cone C in this example is 2-dimensional within a 3-dimensional ambient space.\n\njulia> C = Cone([1 0 0; 1 1 0; 0 1 0]);\n\njulia> dim(C)\n2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#polarize-Union{Tuple{Cone{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Cones","title":"polarize","text":"polarize(C::Cone)\n\nReturn the dual cone of C consisting of all those linear functions that evaluate positively on all of C.\n\nExamples\n\njulia> C = positive_hull([1 0; -1 2])\nA polyhedral cone in ambient dimension 2\n\njulia> Cv = polarize(C)\nA polyhedral cone in ambient dimension 2\n\njulia> rays(Cv)\n2-element SubObjectIterator{RayVector{fmpq}}:\n [1, 1//2]\n [0, 1]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#intersect-Union{Tuple{T}, Tuple{Cone{T}, Cone{T}}} where T<:Union{Float64, fmpq, nf_elem}","page":"Cones","title":"intersect","text":"intersect(C0::Cone{T}, C1::Cone{T}) where T<:scalar_types\n\nReturn the intersection C0 cap C1 of C0 and C1.\n\nExamples\n\njulia> C0 = positive_hull([1 0])\nA polyhedral cone in ambient dimension 2\n\njulia> C1 = positive_hull([0 1])\nA polyhedral cone in ambient dimension 2\n\njulia> C01 = intersect(C0, C1)\nA polyhedral cone in ambient dimension 2\n\njulia> rays(C01)\n0-element SubObjectIterator{RayVector{fmpq}}\n\njulia> dim(C01)\n0\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#ispointed-Tuple{Cone}","page":"Cones","title":"ispointed","text":"ispointed(C::Cone)\n\nDetermine whether C is pointed, i.e. whether the origin is a face of C.\n\nExamples\n\nA cone with lineality is not pointed, but a cone only consisting of a single ray is.\n\njulia> C = Cone([1 0], [0 1]);\n\njulia> ispointed(C)\nfalse\n\njulia> C = Cone([1 0]);\n\njulia> ispointed(C)\ntrue\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#isfulldimensional-Tuple{Cone}","page":"Cones","title":"isfulldimensional","text":"isfulldimensional(C::Cone)\n\nDetermine whether C is full-dimensional.\n\nExamples\n\nThe cone C in this example is 2-dimensional within a 3-dimensional ambient space.\n\njulia> C = Cone([1 0 0; 1 1 0; 0 1 0]);\n\njulia> isfulldimensional(C)\nfalse\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#lineality_dim-Tuple{Cone}","page":"Cones","title":"lineality_dim","text":"lineality_dim(C::Cone)\n\nCompute the dimension of the lineality space of C, i.e. the largest linear subspace contained in C.\n\nExamples\n\nA cone is pointed if and only if the dimension of its lineality space is zero.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 1 1; 1 0 1])\nA polyhedral cone in ambient dimension 3\n\njulia> ispointed(C)\ntrue\n\njulia> lineality_dim(C)\n0\n\njulia> C1 = Cone([1 0],[0 1; 0 -1])\nA polyhedral cone in ambient dimension 2\n\njulia> ispointed(C1)\nfalse\n\njulia> lineality_dim(C1)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#lineality_space-Union{Tuple{Cone{T}}, Tuple{T}} where T<:Union{Float64, fmpq, nf_elem}","page":"Cones","title":"lineality_space","text":"lineality_space(C::Cone)\n\nReturn a basis of the lineality space of C.\n\nExamples\n\nThree rays are used here to construct the upper half-plane. Actually, two of these rays point in opposite directions. This gives us a 1-dimensional lineality.\n\njulia> UH = Cone([1 0; 0 1; -1 0]);\n\njulia> lineality_space(UH)\n1-element SubObjectIterator{RayVector{fmpq}}:\n [1, 0]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#nfacets-Tuple{Cone}","page":"Cones","title":"nfacets","text":"nfacets(C::Cone)\n\nReturn the number of facets of a cone C.\n\nExamples\n\nThe cone over a square at height one has four facets.\n\njulia> C = positive_hull([1 0 0; 1 1 0; 1 1 1; 1 0 1])\nA polyhedral cone in ambient dimension 3\n\njulia> nfacets(C)\n4\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#nrays-Tuple{Cone}","page":"Cones","title":"nrays","text":"nrays(C::Cone)\n\nReturn the number of rays of C.\n\nExamples\n\nHere a cone is constructed from three rays. Calling nrays reveals that one of these was redundant:\n\njulia> R = [1 0; 0 1; 0 2];\n\njulia> PO = positive_hull(R);\n\njulia> nrays(PO)\n2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#rays-Tuple{Cone}","page":"Cones","title":"rays","text":"rays(as::Type{T} = RayVector, P::Polyhedron)\n\nReturn a minimal set of generators of the cone of unbounded directions of P (i.e. its rays) in the format defined by as.\n\nOptional arguments for as include\n\nRayVector.\n\nExamples\n\nWe can verify that the positive orthant of the plane is generated by the two rays in positive unit direction:\n\njulia> PO = convex_hull([0 0], [1 0; 0 1]);\n\njulia> rays(RayVector, PO)\n2-element SubObjectIterator{RayVector{fmpq}}:\n [1, 0]\n [0, 1]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/cones/#Visualization","page":"Cones","title":"Visualization","text":"","category":"section"},{"location":"PolyhedralGeometry/cones/","page":"Cones","title":"Cones","text":"visualize(C::Cone)","category":"page"},{"location":"PolyhedralGeometry/cones/#visualize-Tuple{Cone}","page":"Cones","title":"visualize","text":"visualize(C::Cone)\n\nVisualize a cone.\n\n\n\n","category":"method"},{"location":"Nemo/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"Nemo is a computer algebra package for the Julia programming language, maintained by William Hart,  Tommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak, Marek Kaluba and other contributors.","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"https://nemocas.org (Website)\nhttps://github.com/Nemocas/Nemo.jl (Source code)\nhttps://nemocas.github.io/Nemo.jl/stable/ (Online documentation)","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"The features of Nemo so far include:","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"Multiprecision integers and rationals\nIntegers modulo n\np-adic numbers\nFinite fields (prime and non-prime order)\nNumber field arithmetic\nAlgebraic numbers\nExact real and complex numbers\nArbitrary precision real and complex balls\nUnivariate and multivariate polynomials and matrices over the above","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"Nemo depends on AbstractAlgebra.jl which provides Nemo with generic routines for:","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"Univariate and multivariate polynomials\nAbsolute and relative power series\nLaurent series\nFraction fields\nResidue rings\nMatrices and linear algebra\nYoung Tableaux\nPermutation groups\nCharacters","category":"page"},{"location":"Nemo/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"To use Nemo we require Julia 1.6 or higher. Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system.","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"At the Julia prompt simply type","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg; Pkg.add(\"Nemo\")","category":"page"},{"location":"Nemo/#Quick-start","page":"Getting Started","title":"Quick start","text":"","category":"section"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"Here are some examples of using Nemo.","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"This example computes recursive univariate polynomials.","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"julia> using Nemo\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia> T, z = PolynomialRing(S, \"z\")\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia> f = x + y + z + 1\nz+(y+(x+1))\n\njulia> p = f^30; # semicolon supresses output\n\njulia> @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"Here is an example using generic recursive ring constructions.","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"julia> using Nemo\n\njulia> R, x = FiniteField(7, 11, \"x\")\n(Finite field of degree 11 over F_7,x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia> T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia> U, z = PolynomialRing(T, \"z\")\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia> f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia> g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia> s = f^12;\n\njulia> t = (s + g)^12;\n\njulia> @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"Here is an example using matrices.","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"julia> using Nemo\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia> S = MatrixSpace(R, 40, 40)\nMatrix Space of 40 rows and 40 columns over Univariate Polynomial Ring in x over Integer Ring\n\njulia> M = rand(S, 2:2, -20:20)\n\njulia> @time det(M);\n  0.131212 seconds (1.12 M allocations: 39.331 MiB, 4.77% gc time)","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"And here is an example with power series.","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"julia> using Nemo\n\njulia> R, x = QQ[\"x\"]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia> S, t = PowerSeriesRing(R, 100, \"t\")\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia> u = t + O(t^100)\nt+O(t^100)\n\njulia> @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)","category":"page"},{"location":"Nemo/#Building-dependencies-from-source","page":"Getting Started","title":"Building dependencies from source","text":"","category":"section"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"Nemo depends on various C libraries which are installed using binaries by default. With julia version >= 1.3, the use of these binaries can be overridden by putting the following into the file ~/.julia/artifacts/Overrides.toml:","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"[e134572f-a0d5-539d-bddf-3cad8db41a82]\nFLINT = \"/prefix/for/libflint\"\n\n[d9960996-1013-53c9-9ba4-74a4155039c3]\nArb = \"/prefix/for/libarb\"\n\n[e21ec000-9f72-519e-ba6d-10061e575a27]\nAntic = \"/prefix/for/libantic\"","category":"page"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"(If only a specific library should be overridden, only the specific entry should be added.)","category":"page"},{"location":"Nemo/#Experimental-threading-support-for-flint","page":"Getting Started","title":"Experimental threading support for flint","text":"","category":"section"},{"location":"Nemo/","page":"Getting Started","title":"Getting Started","text":"Enabling a threaded version of flint can be done by setting the evironment variable NEMO_THREADED=1. To set the actual number of threads, use Nemo.flint_set_num_threads($numberofthreads).","category":"page"},{"location":"Hecke/orders/elements/#Elements","page":"Elements","title":"Elements","text":"","category":"section"},{"location":"Hecke/orders/elements/","page":"Elements","title":"Elements","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/orders/elements/","page":"Elements","title":"Elements","text":"Elements in orders have two representations: they can be viewed as  elements in the mathbf Z^n giving the coefficients wrt to the order basis where they are elements in. On the other hand, as every order is in a field, they also have a representation as number field elements. Since, asymptotically, operations are more efficient in the field (due to fast polynomial arithmetic) than in the order, the primary representation is that as a field element.","category":"page"},{"location":"Hecke/orders/elements/#Creation","page":"Elements","title":"Creation","text":"","category":"section"},{"location":"Hecke/orders/elements/","page":"Elements","title":"Elements","text":"Elements are constructed either as linear combinations of basis elements or via explicit coercion. Elements will be of type NfAbsOrdElem,  the type if actually parametrized by the type of the surrounding field and the type of the field elements. E.g. the type of any element in any order of an absolute simple field will be NfAbsOrdElem{AnticNumberField,nf_elem}","category":"page"},{"location":"Hecke/orders/elements/","page":"Elements","title":"Elements","text":"NfAbsOrd","category":"page"},{"location":"Hecke/orders/elements/#NfAbsOrd","page":"Elements","title":"NfAbsOrd","text":"  (O::NumFieldOrd)(a::IntegerUnion) -> NumFieldOrdElem\n\nGiven an element a of type fmpz or Integer, this function coerces the element into mathcal O.\n\n\n\n  (O::NfAbsOrd)(arr::Vector{fmpz})\n\nReturns the element of mathcal O with coefficient vector arr.\n\n\n\n","category":"type"},{"location":"Hecke/orders/elements/#Basic-properties","page":"Elements","title":"Basic properties","text":"","category":"section"},{"location":"Hecke/orders/elements/","page":"Elements","title":"Elements","text":"parent(::NfOrdElem)\nelem_in_nf(::NfOrdElem)\ncoordinates(::NfOrdElem)\ndiscriminant(::Vector{NfOrdElem})\n==(::NfOrdElem, ::NfOrdElem)","category":"page"},{"location":"Hecke/orders/elements/#parent-Tuple{NfOrdElem}","page":"Elements","title":"parent","text":"parent(a::NumFieldOrdElem) -> NumFieldOrd\n\nReturns the order of which a is an element.\n\n\n\nparent(a::AbstractAlgebra.MatElem{T}, cached::Bool = true) where T <: RingElement\n\nReturn the parent object of the given matrix.\n\n\n\nparent(a::MatAlgElem{T}, cached::Bool = true) where T <: RingElement\n\nReturn the parent object of the given matrix.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#elem_in_nf-Tuple{NfOrdElem}","page":"Elements","title":"elem_in_nf","text":"elem_in_nf(a::NumFieldOrdElem) -> NumFieldElem\n\nReturns the element a considered as an element of the ambient number field.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#coordinates-Tuple{NfOrdElem}","page":"Elements","title":"coordinates","text":"coordinates(a::NfAbsOrdElem) -> Vector{fmpz}\n\nReturns the coefficient vector of a with respect to the basis of the order.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#discriminant-Tuple{Vector{NfOrdElem}}","page":"Elements","title":"discriminant","text":"discriminant(B::Vector{NumFieldOrdElem})\n\nReturns the discriminant of the family B of algebraic numbers, i.e. det((tr(Bi*Bj))_i j)^2.\n\n\n\ndiscriminant(E::EllCrv{T}) -> T\n\nComputes the discriminant of E.\n\n\n\ndiscriminant(O::AlgssRelOrd)\n\nReturns the discriminant of O.\n\n\n\ndiscriminant(g::Vector)\n\nCompute the product of all differences of distinct elements in the array.    \n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#==-Tuple{NfOrdElem, NfOrdElem}","page":"Elements","title":"==","text":"==(x::NumFieldOrdElem, y::NumFieldOrdElem) -> Bool\n\nReturns whether x and y are equal.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#Arithmetic","page":"Elements","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/orders/elements/","page":"Elements","title":"Elements","text":"All the usual arithmetic operatinos are defined:","category":"page"},{"location":"Hecke/orders/elements/","page":"Elements","title":"Elements","text":"-(::NUmFieldOrdElem)\n+(::NumFieldOrdElem, ::NumFieldOrdElem)\n-(::NumFieldOrdElem, ::NumFieldOrdElem)\n*(::NumFieldOrdElem, ::NumFieldOrdElem)\n^(::NumFieldOrdElem, ::Int)\nmod(::NfAbsOrdElem, ::Int)\nmod_sym(::NumFieldOrdElem, ::fmpz)\npowermod(::NfAbsOrdElem, ::fmpz, ::Int)","category":"page"},{"location":"Hecke/orders/elements/#Miscellaneous","page":"Elements","title":"Miscellaneous","text":"","category":"section"},{"location":"Hecke/orders/elements/","page":"Elements","title":"Elements","text":"representation_matrix(::NfAbsOrdElem)\nrepresentation_matrix(::NfOrdElem, ::AnticNumberField)\ntr(::NumFieldOrdElem)\nnorm(::NumFieldOrdElem)\nabsolute_norm(::NfAbsOrdElem)\nabsolute_tr(::NfAbsOrdElem)\nrand(::NfOrd, ::Int)\nminkowski_map(::NfOrdElem, ::Int)\nconjugates_arb(::NfOrdElem, ::Int)\nconjugates_arb_log(::NfOrdElem, ::Int)\nt2(::NfOrdElem, ::Int)\nminpoly(::NfOrdElem)\ncharpoly(::NfOrdElem)\nfactor(::NfOrdElem)\ndenominator(a::NumFieldElem, O::NfRelOrd)\ndiscriminant(::Vector{NfAbsOrdElem})","category":"page"},{"location":"Hecke/orders/elements/#representation_matrix-Tuple{NfAbsOrdElem}","page":"Elements","title":"representation_matrix","text":"representation_matrix(a::NfAbsOrdElem) -> fmpz_mat\n\nReturns the representation matrix of the element a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#representation_matrix-Tuple{NfOrdElem, AnticNumberField}","page":"Elements","title":"representation_matrix","text":"representation_matrix(a::NfAbsOrdElem, K::AnticNumberField) -> FakeFmpqMat\n\nReturns the representation matrix of the element a considered as an element of the ambient number field K. It is assumed that K is the ambient number field of the order of a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#tr-Tuple{NumFieldOrdElem}","page":"Elements","title":"tr","text":"tr(a::NumFieldOrdElem)\n\nReturns the trace of a as an element of the base ring.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#norm-Tuple{NumFieldOrdElem}","page":"Elements","title":"norm","text":"norm(a::NumFieldOrdElem)\n\nReturns the norm of a as an element in the base ring.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#absolute_norm-Tuple{NfAbsOrdElem}","page":"Elements","title":"absolute_norm","text":"absolute_norm(a::NumFieldOrdElem) -> fmpz\n\nReturn the absolute norm as an integer.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#absolute_tr-Tuple{NfAbsOrdElem}","page":"Elements","title":"absolute_tr","text":"absolute_tr(a::NumFieldOrdElem) -> fmpz\n\nReturn the absolute trace as an integer.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#rand-Tuple{NfOrd, Int64}","page":"Elements","title":"rand","text":"rand(O::NfOrd, n::IntegerUnion) -> NfAbsOrdElem\n\nComputes a coefficient vector with entries uniformly distributed in -ndotsc-101dotscn and returns the corresponding element of the order mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#minkowski_map-Tuple{NfOrdElem, Int64}","page":"Elements","title":"minkowski_map","text":"minkowski_map(a::NumFieldOrdElem, abs_tol::Int) -> Vector{arb}\n\nReturns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^-abs_tol.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#conjugates_arb-Tuple{NfOrdElem, Int64}","page":"Elements","title":"conjugates_arb","text":"conjugates_arb(x::NumFieldOrdElem, abs_tol::Int) -> Vector{acb}\n\nCompute the conjugates of x as elements of type acb. Recall that we order the complex conjugates sigma_r+1(x)sigma_r+2s(x) such that sigma_i(x) = overlinesigma_i + s(x) for r + 2 leq i leq r + s.\n\nEvery entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol, radius(imag(y)) < 2^-abs_tol respectively.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#conjugates_arb_log-Tuple{NfOrdElem, Int64}","page":"Elements","title":"conjugates_arb_log","text":"conjugates_arb_log(x::NumFieldOrdElem, abs_tol::Int) -> Vector{arb}\n\nReturns the elements (log(lvert sigma_1(x) rvert)dotsclog(lvertsigma_r(x) rvert) dotsc2log(lvert sigma_r+1(x) rvert)dotsc 2log(lvert sigma_r+s(x)rvert)) as elements of type arb radius less then 2^-abs_tol.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#t2-Tuple{NfOrdElem, Int64}","page":"Elements","title":"t2","text":"t2(x::NumFieldOrdElem, abs_tol::Int = 32) -> arb\n\nReturn the T_2-norm of x. The radius of the result will be less than 2^-abs_tol.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#minpoly-Tuple{NfOrdElem}","page":"Elements","title":"minpoly","text":"minpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\n\nReturn the minimal polynomial p of the matrix M. The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\nminpoly(a::NfAbsOrdElem) -> fmpz_poly\n\nThe minimal polynomial of a.\n\n\n\nminpoly(S::Ring, M::MatAlgElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\n\nReturn the minimal polynomial p of the matrix M. The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#charpoly-Tuple{NfOrdElem}","page":"Elements","title":"charpoly","text":"charpoly(V::Ring, Y::MatrixElem{T}) where {T <: RingElement}\n\nReturn the characteristic polynomial p of the matrix M. The polynomial ring R of the resulting polynomial must be supplied and the matrix is assumed to be square.\n\n\n\ncharpoly(a::NfAbsOrdElem) -> fmpz_poly\ncharpoly(a::NfAbsOrdElem, FlintZZ) -> fmpz_poly\n\nThe characteristic polynomial of a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#factor-Tuple{NfOrdElem}","page":"Elements","title":"factor","text":"factor(a::NfOrdElem) -> Fac{NfOrdElem}\n\nComputes a factorization of a into irreducible elements. The return value is a factorization fac, which satisfies a = unit(fac) * prod(p^e for (p, e) in fac).\n\nThe function requires that a is non-zero and that all prime ideals containing a are principal, which is for example satisfied if class group of the order of a is trivial.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#denominator-Tuple{NumFieldElem, Hecke.NfRelOrd}","page":"Elements","title":"denominator","text":"denominator(a::NumFieldElem, O::NfOrd) -> fmpz\n\nReturns the smallest positive integer k such that k cdot a is contained in mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/elements/#discriminant-Tuple{Vector{NfAbsOrdElem}}","page":"Elements","title":"discriminant","text":"discriminant(B::Vector{NumFieldOrdElem})\n\nReturns the discriminant of the family B of algebraic numbers, i.e. det((tr(Bi*Bj))_i j)^2.\n\n\n\ndiscriminant(E::EllCrv{T}) -> T\n\nComputes the discriminant of E.\n\n\n\ndiscriminant(O::AlgssRelOrd)\n\nReturns the discriminant of O.\n\n\n\ndiscriminant(g::Vector)\n\nCompute the product of all differences of distinct elements in the array.    \n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/integer/#Integer-ring","page":"Integer ring","title":"Integer ring","text":"","category":"section"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/Integer.jl for making Julia BigInts conform to the AbstractAlgebra.jl Ring interface.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"In addition to providing a parent object ZZ for Julia BigInts, we implement any additional functionality required by AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"Because BigInt cannot be directly included in the AbstractAlgebra.jl abstract type hierarchy, we achieve integration of Julia BigInts by introducing a type union, called RingElement, which is a union of RingElem and a number of Julia types, including BigInt. Everywhere that RingElem is notionally used in AbstractAlgebra.jl, we are in fact using RingElement, with additional care being taken to avoid ambiguities.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"The details of how this is done are technical, and we refer the reader to the implementation for details. For most intents and purposes, one can think of the Julia BigInt type as belonging to RingElem.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"One other technicality is that Julia defines certain functions for BigInt, such as sqrt and exp differently to what AbstractAlgebra.jl requires. To get around this, we redefine these functions internally to AbstractAlgebra.jl, without redefining them for users of AbstractAlgebra.jl. This allows the internals of AbstractAlgebra.jl to function correctly, without broadcasting pirate definitions of already defined Julia functions to the world.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"To access the internal definitions, one can use AbstractAlgebra.sqrt and AbstractAlgebra.exp, etc.","category":"page"},{"location":"AbstractAlgebra/integer/#Types-and-parent-objects","page":"Integer ring","title":"Types and parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"Integers have type BigInt, as in Julia itself. We simply supplement the functionality for this type as required for computer algebra.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"The parent objects of such integers has type Integers{BigInt}.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"For convenience, we also make Int a part of the AbstractAlgebra.jl type hierarchy and its parent object (accessible as zz) has type Integers{Int}. But we caution that this type is not particularly useful as a model of the integers and may not function as expected within AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/integer/#Integer-constructors","page":"Integer ring","title":"Integer constructors","text":"","category":"section"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"In order to construct integers in AbstractAlgebra.jl, one can first construct the integer ring itself. This is accomplished using the following constructor.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"Integers{BigInt}()","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"This gives the unique object of type Integers{BigInt} representing the ring of integers in AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"In practice, one simply uses ZZ which is assigned to be the return value of the above constructor. There is no need to call the constructor in practice.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"Here are some examples of creating the integer ring and making use of the resulting parent object to coerce various elements into the ring.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"julia> f = ZZ()\n0\n\njulia> g = ZZ(123)\n123\n\njulia> h = ZZ(BigInt(1234))\n1234\n","category":"page"},{"location":"AbstractAlgebra/integer/#Basic-ring-functionality","page":"Integer ring","title":"Basic ring functionality","text":"","category":"section"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"The integer ring in AbstractAlgebra.jl implements the full Ring interface and the  Euclidean Ring interface.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"We give some examples of such functionality.","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"julia> f = ZZ(12)\n12\n\njulia> h = zero(ZZ)\n0\n\njulia> k = one(ZZ)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> T = parent(f)\nIntegers\n\njulia> f == deepcopy(f)\ntrue\n\njulia> g = f + 12\n24\n\njulia> h = powermod(f, 12, ZZ(17))\n4\n\njulia> flag, q = divides(f, ZZ(3))\n(true, 4)\n","category":"page"},{"location":"AbstractAlgebra/integer/#Integer-functionality-provided-by-AbstractAlgebra.jl","page":"Integer ring","title":"Integer functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"The functionality below supplements that provided by Julia itself for its BigInt type.","category":"page"},{"location":"AbstractAlgebra/integer/#Basic-functionality","page":"Integer ring","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"julia> r = ZZ(-1)\n-1\n\njulia> isunit(r)\ntrue\n","category":"page"},{"location":"AbstractAlgebra/integer/#Divisibility-testing","page":"Integer ring","title":"Divisibility testing","text":"","category":"section"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"isdivisible_by(a::BigInt, b::BigInt)","category":"page"},{"location":"AbstractAlgebra/integer/#isdivisible_by-Tuple{BigInt, BigInt}","page":"Integer ring","title":"isdivisible_by","text":"isdivisible_by(a::Integer, b::Integer)\n\nReturn true if a is divisible by b, i.e. if there exists c such that a = bc.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"** Examples **","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"julia> r = ZZ(6)\n6\n\njulia> s = ZZ(3)\n3\n\njulia> isdivisible_by(r, s)\ntrue","category":"page"},{"location":"AbstractAlgebra/integer/#Square-root","page":"Integer ring","title":"Square root","text":"","category":"section"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"AbstractAlgebra.sqrt(a::BigInt)","category":"page"},{"location":"AbstractAlgebra/integer/#sqrt-Tuple{BigInt}","page":"Integer ring","title":"sqrt","text":"sqrt(a::T; check::Bool=true) where T <: Integer\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"issquare(a::BigInt)\nissquare_with_sqrt(a::BigInt)","category":"page"},{"location":"AbstractAlgebra/integer/#issquare-Tuple{BigInt}","page":"Integer ring","title":"issquare","text":"issquare(f::PolyElem{T}) where T <: RingElement\n\nReturn true if f is a perfect square.\n\n\n\nissquare(a::ResFieldElem{T}) where T <: Integer\n\nReturn true if a is a square.\n\n\n\nissquare(a::T) where T <: Integer\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/#issquare_with_sqrt-Tuple{BigInt}","page":"Integer ring","title":"issquare_with_sqrt","text":"issquare_with_sqrt(a::T) where T <: Integer\n\nReturn (true, s) if a is a perfect square, where s^2 = a. Otherwise return (false, 0).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"root(a::BigInt)\niroot(a::BigInt)","category":"page"},{"location":"AbstractAlgebra/integer/#root-Tuple{BigInt}","page":"Integer ring","title":"root","text":"root(a::T, n::Int; check::Bool=true) where T <: Integer\n\nReturn the n-th root of a. If check=true the function will test if the input was a perfect n-th power, otherwise an exception will be raised. We require n  0.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/#iroot-Tuple{BigInt}","page":"Integer ring","title":"iroot","text":"iroot(a::T, n::Int) where T <: Integer\n\nReturn the truncated integer part of the n-th root of a (round towards zero). We require n  0 and also a geq 0 if n is even.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"ispower(a::BigInt)\nispower_with_root(a::BigInt)","category":"page"},{"location":"AbstractAlgebra/integer/#ispower-Tuple{BigInt}","page":"Integer ring","title":"ispower","text":"ispower(a::T, n::Int) where T <: Integer\n\nReturn true if a is a perfect n-th power, i.e. if there is a b such that a = b^n. We require n  0.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/#ispower_with_root-Tuple{BigInt}","page":"Integer ring","title":"ispower_with_root","text":"ispower_with_root(a::T, n::Int) where T <: Integer\n\nReturn true, q if a is a perfect n-th power with a = q^n. Otherwise return false, 0. We require n  0.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"AbstractAlgebra.exp(a::BigInt)","category":"page"},{"location":"AbstractAlgebra/integer/#exp-Tuple{BigInt}","page":"Integer ring","title":"exp","text":"exp(a::T) where T <: Integer\n\nReturn 1 if a = 0, otherwise throw an exception. This function is not generally of use to the user, but is used internally in AbstractAlgebra.jl.\n\n\n\nexp(a::Rational{T}) where T <: Integer\n\nReturn 1 if a = 0, otherwise throw an exception.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"julia> d = AbstractAlgebra.sqrt(ZZ(36))\n6\n\njulia> issquare(ZZ(9))\ntrue\n\njulia> m = AbstractAlgebra.exp(ZZ(0))\n1","category":"page"},{"location":"AbstractAlgebra/integer/#Coprime-bases","page":"Integer ring","title":"Coprime bases","text":"","category":"section"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"ppio(a::BigInt, b::BigInt)","category":"page"},{"location":"AbstractAlgebra/integer/#ppio-Tuple{BigInt, BigInt}","page":"Integer ring","title":"ppio","text":"ppio(a::T, b::T)\n\nSplit a into c*d where c = gcd(a b^infty).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"Examples","category":"page"},{"location":"AbstractAlgebra/integer/","page":"Integer ring","title":"Integer ring","text":"julia> c, n = ppio(ZZ(12), ZZ(26))\n(4, 3)\n","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"CurrentModule = Oscar","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"using Oscar","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"Pages = [\"it_lrg.md\"]","category":"page"},{"location":"InvariantTheory/reductive_groups/#Invariants-of-Linearly-Reductive-Groups","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"In this section, with notation as in the introduction to this chapter, G will be a linearly algebraic group over an algebraically closed field K, and rho G to textGL(V)cong textGL_n(K) will be a rational representation of G. As in the previous sections, G will act on KVcong Kx_1 dots x_n by linear substitution:","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"(f      pi)  (x_1 dots x_n)  = f((x_1 dots x_n) cdot rho(pi)) text for all  piin G","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"note: Note\nThe definition of linear reductivity guarantees the existence of a Reynolds operator mathcal R KV to KV. \nBy Hilbert's celebrated finiteness theorem, KV^G is finitely generated as a K-algebra.\nBy a result of Hochster and Roberts, KV^G is Cohen-Macaulay. ","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"In cases where the Reynold's operator can be explicitly handled, generators of invariant rings of linearly reductive groups can be found in two steps using Derksen's algorithm, see Harm Derksen (1999) :","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"First, compute generators of Hilbert's null-cone ideal.\nThen, apply the Reynold's operator to these generators.","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"See also Harm Derksen, Gregor Kemper (2015) and Wolfram Decker, Theo de Jong (1998).","category":"page"},{"location":"InvariantTheory/reductive_groups/#Creating-Invariant-Rings","page":"Invariants of Linearly Reductive Groups","title":"Creating Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"There are no exact means to handle algebraically closed fields on the computer. For the computation of invariant rings in the above setting, on the other hand, there is no need to deal with explicit elements of G or with its group structure. The implementation of Derksen's algorithm in OSCAR can  handle situations where both G and the representation rho are defined over an exact subfield k of K which is supported by OSCAR: ","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"G is  specified as an affine algebraic variety by polynomials with coefficients in k;\nrho G to textGL(V) cong textGL_n(K) is specified by an ntimes n matrix whose entries are polynomials in the same variables as those specifying G, with coefficients in k.","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"All computations are then performed over k.","category":"page"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"warning: Warning\nOSCAR does neither check whether the affine variety defined by the given equations carries a group structure which makes it a linearly reductive group nor does it check whether the given ntimes n matrix really defines a representation.","category":"page"},{"location":"InvariantTheory/reductive_groups/#Basic-Data-Associated-to-Invariant-Rings","page":"Invariants of Linearly Reductive Groups","title":"Basic Data Associated to Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/#The-Reynolds-Operator","page":"Invariants of Linearly Reductive Groups","title":"The Reynolds Operator","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/","page":"Invariants of Linearly Reductive Groups","title":"Invariants of Linearly Reductive Groups","text":"Omega-process","category":"page"},{"location":"InvariantTheory/reductive_groups/#Generators-of-Hilbert's-Null-Cone-Ideal","page":"Invariants of Linearly Reductive Groups","title":"Generators of Hilbert's Null-Cone Ideal","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/#Generators-of-the-Invariant-Ring","page":"Invariants of Linearly Reductive Groups","title":"Generators of the Invariant Ring","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/#Fundamental-Systems-of-Invariants","page":"Invariants of Linearly Reductive Groups","title":"Fundamental Systems of Invariants","text":"","category":"section"},{"location":"InvariantTheory/reductive_groups/#Invariant-Rings-as-Affine-Algebras","page":"Invariants of Linearly Reductive Groups","title":"Invariant Rings as Affine Algebras","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<style>\ndl {\ndisplay: grid;\ngrid-template-columns: max-content auto;\n}\ndt {\ngrid-column-start: 1;\n}\ndd {\ngrid-column-start: 2;\nmargin-bottom: 0.75em;\n}\n</style>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"Hecke/number_fields/fields/#Number-field-operations","page":"Number field operations","title":"Number field operations","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"CurrentModule = Hecke\nDocTestSetup = quote\n  using Hecke\nend","category":"page"},{"location":"Hecke/number_fields/fields/#Creation-of-number-fields","page":"Number field operations","title":"Creation of number fields","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"General number fields can be created using the function NumberField, of which number_field is an alias. To create a simple number field given by a defining polynomial or a non-simple number field given by defining polynomials, the following functions can be used.","category":"page"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"NumberField(::DocuDummy)\nNumberField(::DocuDummy2)","category":"page"},{"location":"Hecke/number_fields/fields/#NumberField-Tuple{Hecke.DocuDummy}","page":"Number field operations","title":"NumberField","text":"NumberField(f::Poly{NumFieldElem}, s::String;\n            cached::Bool = false, check::Bool = false) -> NumField, NumFieldElem\n\nGiven an irreducible polynomial f in Kx over some number field K, this function creates the simple number field L = Kx(f) and returns (L b), where b is the class of x in L. The string s is used only for printing the primitive element b.\n\ncheck: Controls whether irreducibility of f is checked.\ncached: Controls whether the result is cached.\n\nExamples\n\njulia> K, a = quadratic_field(5);\n\njulia> Kt, t = K[\"t\"];\n\njulia> L, b = NumberField(t^3 - 3, \"b\");\n\n\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#NumberField-Tuple{Hecke.DocuDummy2}","page":"Number field operations","title":"NumberField","text":"NumberField(f::Vector{PolyElem{<:NumFieldElem}}, s::String=\"_\\$\", check = true)\n                                          -> NumField, Vector{NumFieldElem}\n\nGiven a list f_1 ldots f_n of univariate polynomials in Kx over some number field K, constructs the extension Kx_1 ldots x_n(f_1(x_1) ldots f_n(x_n)).\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = NumberField([x^2 - 2, x^2 - 3], \"a\")\n(Non-simple number field with defining polynomials fmpq_mpoly[x1^2 - 2, x2^2 - 3], NfAbsNSElem[a1, a2])\n\n\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"tip: Tip\nMany of the constructors have arguments of type Symbol or AbstractString.  If used, they define the appearance in printing, and printing only.  The named parameter check can be true or false, the default being true.  This parameter controls whether the polynomials defining the number field are tested for irreducibility or not. Given that this can be potentially very time consuming if the degree if large, one can disable this test. Note however, that the behaviour of Hecke is undefined if a reducible polynomial is used to define a field.The named boolean parameter cached can be used to disable caching. Two number fields defined using the same polynomial from the identical polynomial ring and the same (identical) symbol/string will be identical if cached == true and different if cached == false.","category":"page"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"For frequently used number fields like quadratic fields, cyclotomic fields or radical extensions, the following functions are provided:","category":"page"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"cyclotomic_field(n::Int)\nquadratic_field(d::fmpz)\nwildanger_field(n::Int, B::fmpz)\nradical_extension(n::Int, a::NumFieldElem)\nrationals_as_number_field()","category":"page"},{"location":"Hecke/number_fields/fields/#cyclotomic_field-Tuple{Int64}","page":"Number field operations","title":"cyclotomic_field","text":"cyclotomic_field(n::Int) -> AnticNumberField, nf_elem\n\nThe cyclotomic field defined by the n-th cyclotomic polynomial.\n\nExamples\n\njulia> cyclotomic_field(10)\n(Cyclotomic field of order 10, z_10)\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#quadratic_field-Tuple{fmpz}","page":"Number field operations","title":"quadratic_field","text":"quadratic_field(d::IntegerUnion) -> AnticNumberField, nf_elem\n\nReturns the field with defining polynomial x^2 - d.\n\nExamples\n\njulia> quadratic_field(5)\n(Real quadratic field defined by x^2 - 5, sqrt(5))\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#wildanger_field-Tuple{Int64, fmpz}","page":"Number field operations","title":"wildanger_field","text":"wildanger_field(n::Int, B::fmpz) -> AnticNumberField, nf_elem\n\nReturns the field with defining polynomial x^n + sum_i=0^n-1 (-1)^n-iBx^i. These fields tend to have non-trivial class groups.\n\nExamples\n\njulia> wildanger_field(3, ZZ(10), \"a\")\n(Number field over Rational Field with defining polynomial x^3 - 10*x^2 + 10*x - 10, a)\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#radical_extension-Tuple{Int64, NumFieldElem}","page":"Number field operations","title":"radical_extension","text":"radical_extension(n::Int, a::NumFieldElem, s = \"_$\";\n               check = true, cached = true) -> NumField, NumFieldElem\n\nGiven an element a of a number field K and an integer n, create the simple extension of K with the defining polynomial x^n - a.\n\nExamples\n\njulia> radical_extension(5, QQ(2), \"a\")\n(Number field over Rational Field with defining polynomial x^5 - 2, a)\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#rationals_as_number_field-Tuple{}","page":"Number field operations","title":"rationals_as_number_field","text":"rationals_as_number_field() -> AnticNumberField, nf_elem\n\nReturns the rational numbers as the number field defined by x - 1.\n\nExamples\n\njulia> rationals_as_number_field()\n(Number field over Rational Field with defining polynomial x - 1, 1)\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#Basic-properties","page":"Number field operations","title":"Basic properties","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"basis(::SimpleNumField)\nbasis(::NonSimpleNumField)\nabsolute_basis(::NumField)\ndefining_polynomial(::SimpleNumField)\ndefining_polynomials(::NonSimpleNumField)\nabsolute_primitive_element(::NumField)\ncomponent(::NonSimpleNumField, ::Int)\nbase_field(::NumField)","category":"page"},{"location":"Hecke/number_fields/fields/#basis-Tuple{SimpleNumField}","page":"Number field operations","title":"basis","text":"basis(L::SimpleNumField) -> Vector{NumFieldElem}\n\nReturns the canonical basis of a simple extension LK, that is, the elements 1adotsca^d - 1, where d is the degree of K and a the primitive element.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = NumberField(x^2 - 2, \"a\");\n\njulia> basis(K)\n2-element Vector{nf_elem}:\n 1\n a\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#basis-Tuple{NonSimpleNumField}","page":"Number field operations","title":"basis","text":"basis(L::NonSimpleNumField) -> Vector{NumFieldElem}\n\nReturns the canonical basis of a non-simple extension LK. If L = K(a_1dotsca_n) where each a_i has degree d_i, then the basis will be a_1^i_1dotsm a_d^i_d with 0 leq i_j leq d_j - 1 for 1 leq j leq n.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, (a1, a2) = NumberField([x^2 - 2, x^2 - 3], \"a\");\n\njulia> basis(K)\n4-element Vector{NfAbsNSElem}:\n 1\n a1\n a2\n a1*a2\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#absolute_basis-Tuple{NumField}","page":"Number field operations","title":"absolute_basis","text":"absolute_basis(K::NumField) -> Vector{NumFieldElem}\n\nReturns an array of elements that form a basis of K (as a vector space) over the rationals.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#defining_polynomial-Tuple{SimpleNumField}","page":"Number field operations","title":"defining_polynomial","text":"defining_polynomial(L::SimpleNumField) -> PolyElem\n\nGiven a simple number field LK, constructed as L = Kx(f), this function returns f.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#defining_polynomials-Tuple{NonSimpleNumField}","page":"Number field operations","title":"defining_polynomials","text":"defining_polynomials(L::NonSimpleNumField) -> Vector{PolyElem}\n\nGiven a non-simple number field LK, constructed as L = Kx(f_1dotscf_r), return the vector containing the f_i's.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#absolute_primitive_element-Tuple{NumField}","page":"Number field operations","title":"absolute_primitive_element","text":"absolute_primitive_element(K::NumField) -> NumFieldElem\n\nGiven a number field K, this function returns an element gamma in K such that K = mathbfQ(gamma).\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#component-Tuple{NonSimpleNumField, Int64}","page":"Number field operations","title":"component","text":"component(L::NonSimpleNumField, i::Int) -> SimpleNumField, Map\n\nGiven a non-simple extension LK, this function returns the simple number field corresponding to the i-th component of L together with its embedding.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#base_field-Tuple{NumField}","page":"Number field operations","title":"base_field","text":"base_field(L::NumField) -> NumField\n\nGiven a number field LK this function returns the base field K. For absolute extensions this returns mathbfQ.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#Invariants","page":"Number field operations","title":"Invariants","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"degree(::NumField)\nabsolute_degree(::NumField)\nsignature(::NumField)\nunit_group_rank(::NumField)\nclass_number(::AnticNumberField)\nrelative_class_number(::AnticNumberField)\nregulator(::AnticNumberField)\ndiscriminant(::SimpleNumField)\nabsolute_discriminant(::SimpleNumField)","category":"page"},{"location":"Hecke/number_fields/fields/#degree-Tuple{NumField}","page":"Number field operations","title":"degree","text":"degree(L::NumField) -> Int\n\nGiven a number field LK, this function returns the degree of L over K.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = NumberField(x^2 - 2, \"a\");\n\njulia> degree(K)\n2\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#absolute_degree-Tuple{NumField}","page":"Number field operations","title":"absolute_degree","text":"absolute_degree(L::NumField) -> Int\n\nGiven a number field LK, this function returns the degree of L over mathbf Q.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#signature-Tuple{NumField}","page":"Number field operations","title":"signature","text":"signature(K::NumField)\n\nReturn the signature of the number field of K.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = NumberField(x^2 - 2, \"a\");\n\njulia> signature(K)\n(2, 0)\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#unit_group_rank-Tuple{NumField}","page":"Number field operations","title":"unit_group_rank","text":"unit_group_rank(K::NumField) -> Int\n\nReturn the rank of the unit group of any order of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#class_number-Tuple{AnticNumberField}","page":"Number field operations","title":"class_number","text":"class_number(K::AnticNumberField) -> fmpz\n\nReturns the class number of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#relative_class_number-Tuple{AnticNumberField}","page":"Number field operations","title":"relative_class_number","text":"relative_class_number(K::AnticNumberField) -> fmpz\n\nReturns the relative class number of K. The field must be a CM-field.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#regulator-Tuple{AnticNumberField}","page":"Number field operations","title":"regulator","text":"regulator(K::AnticNumberField)\n\nComputes the regulator of K, i.e. the discriminant of the unit lattice for the maximal order of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#discriminant-Tuple{SimpleNumField}","page":"Number field operations","title":"discriminant","text":"discriminant(L::SimpleNumField) -> NumFieldElem\n\nThe discriminant of the defining polynomial of L, not the discriminant of the maximal order of L.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#absolute_discriminant-Tuple{SimpleNumField}","page":"Number field operations","title":"absolute_discriminant","text":"absolute_discriminant(L::SimpleNumField, QQ) -> fmpq\n\nThe absolute discriminant of the defining polynomial of L, not the discriminant of the maximal order of L. This is the norm of the discriminant times the d-th power of the discriminant of the base field, where d is the degree of L.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#Predicates","page":"Number field operations","title":"Predicates","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"issimple(::NumField)\nisabsolute(::NumField)\nistotally_real(::NumField)\nistotally_complex(::NumField)\niscm_field(::NumField)\niskummer_extension(::SimpleNumField)\nisradical_extension(::SimpleNumField)\nislinearly_disjoint(::SimpleNumField, ::SimpleNumField)\nisweakly_ramified(::AnticNumberField, ::NfOrdIdl)\nistamely_ramified(::AnticNumberField)\nistamely_ramified(::AnticNumberField, p::Int)\nisabelian(::NumField)","category":"page"},{"location":"Hecke/number_fields/fields/#issimple-Tuple{NumField}","page":"Number field operations","title":"issimple","text":"issimple(L::NumField) -> Bool\n\nGiven a number field LK this function returns whether L is simple, that is, whether LK is defined by a univariate polynomial.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#isabsolute-Tuple{NumField}","page":"Number field operations","title":"isabsolute","text":"isabsolute(L::NumField) -> Bool\n\nReturns whether L is an absolute extension, that is, whether the base field of L is mathbfQ.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#istotally_real-Tuple{NumField}","page":"Number field operations","title":"istotally_real","text":"istotally_real(K::NumberField) -> Bool\n\nReturns true if and only if K is totally real, that is, if all roots of the defining polynomial are real.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#istotally_complex-Tuple{NumField}","page":"Number field operations","title":"istotally_complex","text":"istotally_complex(K::AnticNumberField) -> Bool\n\nReturns true if and only if K is totally complex, that is, if all roots of the defining polynomial are not real.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#iscm_field-Tuple{NumField}","page":"Number field operations","title":"iscm_field","text":"iscm_field(K::AnticNumberField) -> Bool, NfToNfMor\n\nGiven a number field K, this function returns true and the complex conjugation if the field is CM, false and the identity otherwise.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#iskummer_extension-Tuple{SimpleNumField}","page":"Number field operations","title":"iskummer_extension","text":"iskummer_extension(L::SimpleNumField) -> Bool\n\nTests if LK is a Kummer extension, that is, if the defining polynomial is of the form x^n - b for some b in K and if K contains the n-th roots of unity.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#isradical_extension-Tuple{SimpleNumField}","page":"Number field operations","title":"isradical_extension","text":"isradical_extension(L::SimpleNumField) -> Bool\n\nTests if LK is pure, that is, if the defining polynomial is of the form x^n - b for some b in K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#islinearly_disjoint-Tuple{SimpleNumField, SimpleNumField}","page":"Number field operations","title":"islinearly_disjoint","text":"islinearly_disjoint(K::SimpleNumField, L::SimpleNumField) -> Bool\n\nGiven two number fields K and L with the same base field k, this function returns whether K and L are linear disjoint over k.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#isweakly_ramified-Tuple{AnticNumberField, NfOrdIdl}","page":"Number field operations","title":"isweakly_ramified","text":"isweakly_ramified(K::AnticNumberField, P::NfOrdIdl) -> Bool\n\nGiven a prime ideal P of a number field K, return whether P is weakly ramified, that is, whether the second ramification group is trivial.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#istamely_ramified-Tuple{AnticNumberField}","page":"Number field operations","title":"istamely_ramified","text":"istamely_ramified(K::AnticNumberField) -> Bool\n\nReturns whether the number field K is tamely ramified.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#istamely_ramified-Tuple{AnticNumberField, Int64}","page":"Number field operations","title":"istamely_ramified","text":"istamely_ramified(O::NfOrd, p::Union{Int, fmpz}) -> Bool\n\nReturns whether the integer p is tamely ramified in mathcal O. It is assumed that p is prime.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#isabelian-Tuple{NumField}","page":"Number field operations","title":"isabelian","text":"isabelian(L::NumField) -> Bool\n\nCheck if the number field LK is abelian over K.  The function is probabilistic and assumes GRH.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#Subfields","page":"Number field operations","title":"Subfields","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"issubfield(::SimpleNumField, ::SimpleNumField)\nsubfields(::SimpleNumField)\nprincipal_subfields(::SimpleNumField)\ncompositum(::AnticNumberField, ::AnticNumberField)\nembedding(::NumField, ::NumField)\nnormal_closure(::AnticNumberField)\nrelative_simple_extension(::NumField, ::NumField)\nissubfield_normal(::AnticNumberField, ::AnticNumberField)","category":"page"},{"location":"Hecke/number_fields/fields/#issubfield-Tuple{SimpleNumField, SimpleNumField}","page":"Number field operations","title":"issubfield","text":"issubfield(K::SimpleNumField, L::SimpleNumField) -> Bool, Map\n\nReturns true and an injection from K to L if K is a subfield of L. Otherwise the function returns false and a morphism mapping everything to 0.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#subfields-Tuple{SimpleNumField}","page":"Number field operations","title":"subfields","text":"subfields(L::SimpleNumField) -> Vector{Tuple{NumField, Map}}\n\nGiven a simple extension LK, returns all subfields of L containing K as tuples (k iota) consisting of a simple extension k and an embedding iota k to K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#principal_subfields-Tuple{SimpleNumField}","page":"Number field operations","title":"principal_subfields","text":"principal_subfields(L::SimpleNumField) -> Vector{Tuple{NumField, Map}}\n\nReturn the principal subfields of L as pairs consisting of a subfield k and an embedding k to L.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#compositum-Tuple{AnticNumberField, AnticNumberField}","page":"Number field operations","title":"compositum","text":"compositum(K::AnticNumberField, L::AnticNumberField) -> AnticNumberField, Map, Map\n\nAssuming L is normal (which is not checked), compute the compositum C of the 2 fields together with the embedding of K to C and L to C.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#embedding-Tuple{NumField, NumField}","page":"Number field operations","title":"embedding","text":"embedding(k::NumField, K::NumField) -> Map\n\nAssuming k is known to be a subfield of K, return the embedding map.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#normal_closure-Tuple{AnticNumberField}","page":"Number field operations","title":"normal_closure","text":"normal_closure(K::AnticNumberField) -> AnticNumberField, NfToNfMor\n\nThe normal closure of K together with the embedding map.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#relative_simple_extension-Tuple{NumField, NumField}","page":"Number field operations","title":"relative_simple_extension","text":"relative_simple_extension(K::NumField, k::NumField) -> NfRel\n\nGiven two fields Ksupset k, it returns K as a simple relative extension L of k and an isomorphism L to K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#issubfield_normal-Tuple{AnticNumberField, AnticNumberField}","page":"Number field operations","title":"issubfield_normal","text":"  issubfield_normal(K::AnticNumberField, L::AnticNumberField) -> Bool, NfToNfMor\n\nReturns true and an injection from K to L if K is a subfield of L. Otherwise the function returns \"false\" and a morphism mapping everything to 0.\n\nThis function assumes that K is normal.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#Conversion","page":"Number field operations","title":"Conversion","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"simplify(::AnticNumberField)\nabsolute_simple_field(K::NumField)\nsimple_extension(::NonSimpleNumField)\nsimplified_simple_extension(::NonSimpleNumField)","category":"page"},{"location":"Hecke/number_fields/fields/#simplify-Tuple{AnticNumberField}","page":"Number field operations","title":"simplify","text":"simplify(K::AnticNumberField; canonical::Bool = false) -> AnticNumberField, NfToNfMor\n\nTries to find an isomorphic field L given by a \"simpler\" defining polynomial. By default, \"simple\" is defined to be of smaller index, testing is done only using a LLL-basis of the maximal order.\n\nIf canonical is set to true, then a canonical defining polynomial is found, where canonical is using the definition of PARI's polredabs, which is described in http://beta.lmfdb.org/knowledge/show/nf.polredabs.\n\nBoth versions require a LLL reduced basis for the maximal order.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#absolute_simple_field-Tuple{NumField}","page":"Number field operations","title":"absolute_simple_field","text":"absolute_simple_field(K::NumField) -> NumField, Map\n\nGiven a number field K, this function returns an absolute simple number field MmathbfQ together with a mathbfQ-linear isomorphism M to K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#simple_extension-Tuple{NonSimpleNumField}","page":"Number field operations","title":"simple_extension","text":"simple_extension(L::NonSimpleNumField) -> SimpleNumField, Map\n\nGiven a non-simple extension LK, this function computes a simple extension MK and a K-linear isomorphism M to L.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#simplified_simple_extension-Tuple{NonSimpleNumField}","page":"Number field operations","title":"simplified_simple_extension","text":"simplified_simple_extension(L::NonSimpleNumField) -> SimpleNumField, Map\n\nGiven a non-simple extension LK, this function returns an isomorphic simple number field with a \"small\" defining equation together with the isomorphism.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#Morphisms","page":"Number field operations","title":"Morphisms","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"isisomorphic(::SimpleNumField, ::SimpleNumField)\nisinvolution(::NfToNfMor)\nfixed_field(::NumFieldMor)\nautomorphisms(::NumField)\nautomorphism_group(::AnticNumberField)\ncomplex_conjugation(::AnticNumberField)","category":"page"},{"location":"Hecke/number_fields/fields/#isisomorphic-Tuple{SimpleNumField, SimpleNumField}","page":"Number field operations","title":"isisomorphic","text":"isisomorphic(K::SimpleNumField, L::SimpleNumField) -> Bool, Map\n\nReturns true and an isomorphism from K to L if K and L are isomorphic. Otherwise the function returns false and a morphism mapping everything to 0.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#isinvolution-Tuple{NfToNfMor}","page":"Number field operations","title":"isinvolution","text":"isinvolution(f::NfToNfMor) -> Bool\n\nReturns true if f is an involution, i.e. if f^2 is the identity, false otherwise.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#fixed_field-Tuple{Hecke.NumFieldMor}","page":"Number field operations","title":"fixed_field","text":"fixed_field(K::SimpleNumField,\n            sigma::Map;\n            simplify::Bool = true) -> NumberField, NfToNfMor\n\nGiven a number field K and an automorphism sigma of K, this function returns the fixed field of sigma as a pair (L i) consisting of a number field L and an embedding of L into K.\n\nBy default, the function tries to find a small defining polynomial of L. This can be disabled by setting simplify = false.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#automorphisms-Tuple{NumField}","page":"Number field operations","title":"automorphisms","text":"automorphisms(L::NumField) -> Vector{NumFieldMor}\n\nGiven a number field LK, return a list of all K-automorphisms of L.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#automorphism_group-Tuple{AnticNumberField}","page":"Number field operations","title":"automorphism_group","text":"automorphism_group(K::NumField) -> GenGrp, GrpGenToNfMorSet\n\nGiven a number field K, this function returns a group G and a map from G to the automorphisms of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#complex_conjugation-Tuple{AnticNumberField}","page":"Number field operations","title":"complex_conjugation","text":"complex_conjugation(K::AnticNumberField)\n\nGiven a totally complex normal number field, this function returns an automorphism which is the restriction of complex conjugation at one embedding.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#Galois-theory","page":"Number field operations","title":"Galois theory","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"normal_basis(::NumField)\ndecomposition_group(::AnticNumberField, ::NfOrdIdl, ::Map)\nramification_group(::AnticNumberField, ::NfOrdIdl, ::Int, ::Map)\ninertia_subgroup(::AnticNumberField, ::NfOrdIdl, ::Map)","category":"page"},{"location":"Hecke/number_fields/fields/#normal_basis-Tuple{NumField}","page":"Number field operations","title":"normal_basis","text":"normal_basis(L::NumField) -> NumFieldElem\n\nGiven a normal number field LK, this function returns an element a of L, such that the orbit of a under the Galois group of LK is an K-basis of L.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#decomposition_group-Tuple{AnticNumberField, NfOrdIdl, Map}","page":"Number field operations","title":"decomposition_group","text":"decomposition_group(K::AnticNumberField, P::NfOrdIdl, m::Map)\n                                              -> Grp, GrpToGrp\n\nGiven a prime ideal P of a number field K and a map m return from automorphism_group(K), return the decompositon group of P as a subgroup of the domain of m.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#ramification_group-Tuple{AnticNumberField, NfOrdIdl, Int64, Map}","page":"Number field operations","title":"ramification_group","text":"ramification_group(K::AnticNumberField, P::NfOrdIdl, m::Map) -> Grp, GrpToGrp\n\nGiven a prime ideal P of a number field K and a map m return from automorphism_group(K), return the ramification group of P as a subgroup of the domain of m.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#inertia_subgroup-Tuple{AnticNumberField, NfOrdIdl, Map}","page":"Number field operations","title":"inertia_subgroup","text":"inertia_subgroup(K::AnticNumberField, P::NfOrdIdl, m::Map) -> Grp, GrpToGrp\n\nGiven a prime ideal P of a number field K and a map m return from automorphism_group(K), return the intertia subgroup of P as a subgroup of the domain of m.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#Infinite-places","page":"Number field operations","title":"Infinite places","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"infinite_places(K::NumField)\nreal_places(K::AnticNumberField)\ncomplex_places(K::AnticNumberField)\nisreal(::Plc)\niscomplex(::Plc)\ninfinite_places_uniformizers(::AnticNumberField)","category":"page"},{"location":"Hecke/number_fields/fields/#infinite_places-Tuple{NumField}","page":"Number field operations","title":"infinite_places","text":"infinite_places(K::NumField) -> Vector{Plc}\n\nThis function returns all infinite places of K.\n\nExamples\n\njulia> Qx, x = QQ[\"x\"];\n\njulia> K, a = NumberField(x^2 - 2, \"a\");\n\njulia> infinite_places(K)\n2-element Vector{InfPlc}:\n Real place of\nNumber field over Rational Field with defining polynomial x^2 - 2\ncorresponding to the root [-1.414213562373095049 +/- 3.90e-19]\n Real place of\nNumber field over Rational Field with defining polynomial x^2 - 2\ncorresponding to the root [1.414213562373095049 +/- 3.90e-19]\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#real_places-Tuple{AnticNumberField}","page":"Number field operations","title":"real_places","text":"real_places(K::AnticNumberField) -> Vector{InfPlc}\n\nThis function returns all infinite real places of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#complex_places-Tuple{AnticNumberField}","page":"Number field operations","title":"complex_places","text":"complex_places(K::AnticNumberField) -> Vector{InfPlc}\n\nThis function returns all infinite complex places of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#isreal-Tuple{Plc}","page":"Number field operations","title":"isreal","text":"isreal(P::Plc)\n\nReturn whether the embedding into mathbfC defined by P is real or not.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#iscomplex-Tuple{Plc}","page":"Number field operations","title":"iscomplex","text":"iscomplex(P::Plc) -> Bool\n\nReturn whether the embedding into mathbfC defined by P is complex or not.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#infinite_places_uniformizers-Tuple{AnticNumberField}","page":"Number field operations","title":"infinite_places_uniformizers","text":"infinite_places_uniformizers(K::AnticNumberField)\n\nReturns a dictionary having as keys the real places of K and the values are uniformizers for the corresponding real place. A uniformizer of a real place P is an element of the field which is negative at P and positive at all the other real places.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#Miscellaneous","page":"Number field operations","title":"Miscellaneous","text":"","category":"section"},{"location":"Hecke/number_fields/fields/","page":"Number field operations","title":"Number field operations","text":"norm_equation(::AnticNumberField, ::Any)\nlorenz_module(::AnticNumberField, ::Int)\nkummer_failure(::nf_elem, ::Int, ::Int)\nisdefining_polynomial_nice(::AnticNumberField)","category":"page"},{"location":"Hecke/number_fields/fields/#norm_equation-Tuple{AnticNumberField, Any}","page":"Number field operations","title":"norm_equation","text":"norm_equation(K::AnticNumerField, a) -> nf_elem\n\nFor a an integer or rational, try to find T in K s.th. N(T) = a. Raises an error if unsuccessful.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#lorenz_module-Tuple{AnticNumberField, Int64}","page":"Number field operations","title":"lorenz_module","text":"lorenz_module(k::AnticNumberField, n::Int) -> NfOrdIdl\n\nFinds an ideal A s.th. for all positive units e = 1 bmod A we have that e is an n-th power. Uses Lorenz, number theory, 9.3.1. If containing is set, it has to be an integral ideal. The resulting ideal will be a multiple of this.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#kummer_failure-Tuple{nf_elem, Int64, Int64}","page":"Number field operations","title":"kummer_failure","text":"kummer_failure(x::nf_elem, M::Int, N::Int) -> Int\n\nComputes the quotient of N and K(zeta_M sqrtN(x))colon K(zeta_M), where K is the field containing x and N divides M.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/fields/#isdefining_polynomial_nice-Tuple{AnticNumberField}","page":"Number field operations","title":"isdefining_polynomial_nice","text":"isdefining_polynomial_nice(K::AnticNumberField)\n\nTests if the defining polynomial of K is integral and monic.\n\n\n\n","category":"method"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Pages = [\"faq.md\"]","category":"page"},{"location":"General/faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"General/faq/#General-questions","page":"Frequently Asked Questions","title":"General questions","text":"","category":"section"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: How do I install Oscar?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can find our installation instructions here.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why do some of your types have funny names like fmpz or fmpq_mat?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This has historical reasons. We plan to rename these types before Oscar 1.0 (the old names will still work indefinitely, though)","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why do you have your own matrix types, and why do they not support the exact same commands as Julia matrices?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Unfortunately, Julia's matrices and linear algebra cannot be made to work in our context due to two independent problems:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"in empty matrices (0 rows or columns) all that is known is the type of the matrix entries, however for the complex types used in Oscar, this information is not sufficient to create elements, hence zero(T) or friends cannot work.\nmany functions (e.g. det) assume that all types used embed into the real or complex numbers, in Julia det(ones(Int, (1,1))) == 1.0, so the fact that this is exactly the integer 1  is lost. Furthermore, more general rings cannot be embedded into the reals at all.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why can zero(T) for a type T not work?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"At least two reasons:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"the type depends on data that is not a bit-type\neven if it could, it is not desireable. Typical example: computations in ZnZ, so modular arithmetic. If n is small, then it is tempting to define a type T depending on n. We actually did this, and tried to use this. It did not work well, for various reasons. E.g.:\nA generic algorithmic pattern for problems over the integers is to solve them by solving them modulo n for many n, e.g. chosen as prime numbers, and then to combine them. If the type depends on n, then for every prime the code gets compiled, thus negating any advantages from the use of modular techniqes.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Of course, one could make the n an additional parameter to all functions needing it, but then e.g. addition of matrices would have to be implemented specifically for this case, negating the advantages of generic implementations.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In Oscar, the role of the type is split between the actual Julia type and the parent.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: What is a parent?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Almost all element-like objects in Oscar have a parent, i.e., they belong to some larger structure. For example algebraic numbers belong to a number field, modular integers belong to a ring ZnZ, permutations are elements of permutation groups and so on. The data common to all such elements is out-sourced to the parent. For a number field for example, the parent contains the polynomial used to define the field (plus other information).","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Given that a type alone is not large enough to contain the data, the parent is  used. Roughly, outside a function signature, a parent replaces the role of the  type. For example, for a ring element elm in Oscar zero(parent(elm)) works, even if zero(typeof(elm)) may not.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: How can I install or access custom GAP packages (e.g. unpublished ones)?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"TODO","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/#Windows-specific","page":"Frequently Asked Questions","title":"Windows specific","text":"","category":"section"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: How can I install Oscar on Windows?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Please follow the install instructions on our website.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why does OSCAR require WSL on Windows?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Several of the OSCAR corner stones originate from Unix-like operating systems and have no or only limited native support for Windows.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: How can I access Linux files from the Explorer?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Type \\\\wsl$ into the Explorer address bar, then press the Enter key.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/#Linux-specific","page":"Frequently Asked Questions","title":"Linux specific","text":"","category":"section"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: Why can't I install Oscar using the Julia version installed by my package manager?","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Some Linux distributions unfortunately ship crippled versions of Julia by default, which prevent Oscar from working. For example the Debian and Ubuntu Julia packages are missing some files required by Oscar. In this case, this can be resolved by also installing the libjulia-dev package.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For this reason, we recommend always using the official Julia binaries available form the Julia website.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Q: What to do if I get an error similar to libstdc++.so.6: version `GLIBCXX_3.4.26'","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Sometimes installing or updating Oscar gives the error libstdc++.so.6: version `GLIBCXX_3.4.26' or a similar one.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This typically happens when manually installing Julia using the official Julia binaries from their website. These bundle their own copy of the C++ standard library, which can lead to trouble if its version differs from the system's C++ library.","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"As a workaround, you can rename the copy of the C++ library bundled with Julia, so that the system copy is used. This can be achieved by executing the following Julia code:","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"  path = Libdl.dlpath(\"libstdc++\")\n  mv(path,\"$path.bak\")","category":"page"},{"location":"General/faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If for some reason you need to restore the C++ library bundled with Julia, you can simply rename it back.","category":"page"},{"location":"Hecke/function_fields/intro/#Function-Fields","page":"Function Fields","title":"Function Fields","text":"","category":"section"},{"location":"Hecke/function_fields/intro/","page":"Function Fields","title":"Function Fields","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/function_fields/intro/#FunctionFieldsLink","page":"Function Fields","title":"Introduction","text":"","category":"section"},{"location":"Hecke/function_fields/intro/","page":"Function Fields","title":"Function Fields","text":"By definition, a (univariate) function field can be written as a finite extension of a rational function field k(x) for a field k (commonly k = mathbbQ or k = mathbbF_p). In Hecke, a function field L is currently defined as being a (univariate) rational function field k(x) or a finite extension thereof. In other words, the extension is defined in the the following way:","category":"page"},{"location":"Hecke/function_fields/intro/","page":"Function Fields","title":"Function Fields","text":"We have L = k(x)(f), where f in k(x)y is an irreducible polynomial (simple extension)","category":"page"},{"location":"Hecke/function_fields/intro/","page":"Function Fields","title":"Function Fields","text":"We refer to k(x) as the base field of the function field L. We call L an absolute function field if the base field is equal to the rational function field k(x).","category":"page"},{"location":"Hecke/quad_forms/basics/#Quadratic-and-hermitian-spaces","page":"Quadratic and hermitian spaces","title":"Quadratic and hermitian spaces","text":"","category":"section"},{"location":"Hecke/quad_forms/basics/","page":"Quadratic and hermitian spaces","title":"Quadratic and hermitian spaces","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/quad_forms/basics/#Creation-of-spaces","page":"Quadratic and hermitian spaces","title":"Creation of spaces","text":"","category":"section"},{"location":"Hecke/quad_forms/basics/","page":"Quadratic and hermitian spaces","title":"Quadratic and hermitian spaces","text":"quadratic_space(::NumField, ::Int)\nquadratic_space(::NumField, ::MatElem)","category":"page"},{"location":"Hecke/quad_forms/basics/#quadratic_space-Tuple{NumField, Int64}","page":"Quadratic and hermitian spaces","title":"quadratic_space","text":"quadratic_space(K::NumField, n::Int; cached = true) -> QuadSpace\n\nCreate the quadratic space over K with dimension n and Gram matrix equals to the identity matrix.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#quadratic_space-Tuple{NumField, MatElem}","page":"Quadratic and hermitian spaces","title":"quadratic_space","text":"quadratic_space(K::NumField, G::MatElem; cached = true) -> QuadSpace\n\nCreate the quadratic space over K with Gram matrix G. The matrix G must be square and symmetric.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#Attributes","page":"Quadratic and hermitian spaces","title":"Attributes","text":"","category":"section"},{"location":"Hecke/quad_forms/basics/","page":"Quadratic and hermitian spaces","title":"Quadratic and hermitian spaces","text":"rank(::AbsSpace)\ndim(::AbsSpace)\ngram_matrix(::AbsSpace)\ninvolution(::AbsSpace)\nisregular(::AbsSpace)\ndet(::AbsSpace)\ndiscriminant(::AbsSpace)","category":"page"},{"location":"Hecke/quad_forms/basics/#rank-Tuple{Hecke.AbsSpace}","page":"Quadratic and hermitian spaces","title":"rank","text":"rank(V::AbsSpace) -> Int\n\nReturn the rank of the space V.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#dim-Tuple{Hecke.AbsSpace}","page":"Quadratic and hermitian spaces","title":"dim","text":"dim(V::AbsSpace) -> Int\n\nReturn the dimension of the space V.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#gram_matrix-Tuple{Hecke.AbsSpace}","page":"Quadratic and hermitian spaces","title":"gram_matrix","text":"gram_matrix(V::AbsSpace) -> MatElem\n\nReturn the Gram matrix of the space V.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#involution-Tuple{Hecke.AbsSpace}","page":"Quadratic and hermitian spaces","title":"involution","text":"involution(V::AbsSpace) -> NumField\n\nReturn the involution of the space V.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#isregular-Tuple{Hecke.AbsSpace}","page":"Quadratic and hermitian spaces","title":"isregular","text":"isregular(V::AbsSpace) -> Bool\n\nReturn whether the space V is regular, that is, if the Gram matrix has full rank.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#det-Tuple{Hecke.AbsSpace}","page":"Quadratic and hermitian spaces","title":"det","text":"det(V::AbsSpace) -> FieldElem\n\nReturn the determinant of the space V as an element of its fixed field.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#discriminant-Tuple{Hecke.AbsSpace}","page":"Quadratic and hermitian spaces","title":"discriminant","text":"discriminant(V::AbsSpace) -> FieldElem\n\nReturn the discriminant of the space V as an element of its fixed field.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#Inner-products-and-diagonalization","page":"Quadratic and hermitian spaces","title":"Inner products and diagonalization","text":"","category":"section"},{"location":"Hecke/quad_forms/basics/","page":"Quadratic and hermitian spaces","title":"Quadratic and hermitian spaces","text":"gram_matrix(::AbsSpace{T}, ::MatElem{S}) where {S, T}\ngram_matrix(::AbsSpace{T}, ::Vector{Vector{U}}) where {T, U}\ninner_product(::AbsSpace, ::Vector, ::Vector)\northogonal_basis(::AbsSpace)\ndiagonal(::AbsSpace)","category":"page"},{"location":"Hecke/quad_forms/basics/#gram_matrix-Union{Tuple{T}, Tuple{S}, Tuple{Hecke.AbsSpace{T}, MatElem{S}}} where {S, T}","page":"Quadratic and hermitian spaces","title":"gram_matrix","text":"gram_matrix(V::AbsSpace, M::MatElem) -> MatElem\n\nReturn the Gram matrix of the rows of M with respect to the Gram matrix of the space V.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#gram_matrix-Union{Tuple{U}, Tuple{T}, Tuple{Hecke.AbsSpace{T}, Array{Vector{U}, 1}}} where {T, U}","page":"Quadratic and hermitian spaces","title":"gram_matrix","text":"gram_matrix(V::AbsSpace, S::Vector{Vector}) -> MatElem\n\nReturn the Gram matrix of the sequence S with respect to the Gram matrix of the space V.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#inner_product-Tuple{Hecke.AbsSpace, Vector{T} where T, Vector{T} where T}","page":"Quadratic and hermitian spaces","title":"inner_product","text":"inner_product(V::AbsSpace, v::Vector, w::Vector) -> FieldElem\n\nReturn the inner product of v and w with respect to the bilinear form of the space V.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#orthogonal_basis-Tuple{Hecke.AbsSpace}","page":"Quadratic and hermitian spaces","title":"orthogonal_basis","text":"orthogonal_basis(V::AbsSpace) -> MatElem\n\nReturn a matrix M, such that the rows of M form an orthgonal basis of the space V.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#diagonal-Tuple{Hecke.AbsSpace}","page":"Quadratic and hermitian spaces","title":"diagonal","text":"diagonal(V::AbsSpace) -> Vector{FieldElem}\n\nReturn a vector of elements a_1dotsca_n such that the space V is isometric to the diagonal space langle a_1dotsca_n rangle.\n\nThe elements are contained in the fixed field of V.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#Equivalence","page":"Quadratic and hermitian spaces","title":"Equivalence","text":"","category":"section"},{"location":"Hecke/quad_forms/basics/","page":"Quadratic and hermitian spaces","title":"Quadratic and hermitian spaces","text":"hasse_invariant(::QuadSpace, p)\nwitt_invariant(::QuadSpace, p)\nisisometric(::AbsSpace, ::AbsSpace, p)\ninvariants(::QuadSpace)\nisisometric(::QuadSpace, ::QuadSpace)","category":"page"},{"location":"Hecke/quad_forms/basics/#hasse_invariant-Tuple{Hecke.QuadSpace, Any}","page":"Quadratic and hermitian spaces","title":"hasse_invariant","text":"hasse_invariant(V::QuadSpace, p::Union{InfPlc, NfOrdIdl}) -> Int\n\nReturns the Hasse invariant of the quadratic space V at p. This is equal to the product of local Hilbert symbols (a_i a_j)_p, i  j, where V is isometric to langle a_1 dotsc a_nrangle. If V is degenerate return the hasse invariant of V/radical(V).\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#witt_invariant-Tuple{Hecke.QuadSpace, Any}","page":"Quadratic and hermitian spaces","title":"witt_invariant","text":"witt_invariant(V::QuadSpace, p::Union{InfPlc, NfOrdIdl}) -> Int\n\nReturns the Witt invariant of the quadratic space V at p.\n\nSee [Definition 3.2.1, Kir16].\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#isisometric-Tuple{Hecke.AbsSpace, Hecke.AbsSpace, Any}","page":"Quadratic and hermitian spaces","title":"isisometric","text":"isisometric(L::AbsSpace, M::AbsSpace, p::Union{InfPlc, NfOrdIdl}) -> Bool\n\nReturn whether the spaces L and M are isometric over the completion at p.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#invariants-Tuple{Hecke.QuadSpace}","page":"Quadratic and hermitian spaces","title":"invariants","text":"invariants(M::QuadSpace)\n      -> FieldElem, Dict{NfOrdIdl, Int}, Vector{Tuple{InfPlc, Int}}\n\nReturns a tuple (n, k, d, H, I) of invariants of M, which determine the isometry class completely. Here n is the dimension. The dimension of the kernel is k. The element d is the determinant of a Gram matrix of the non-degenerate part, H contains the non-trivial Hasse invariants and I contains for each real place the negative index of inertia.\n\nNote that d is determined only modulo squares.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/basics/#isisometric-Tuple{Hecke.QuadSpace, Hecke.QuadSpace}","page":"Quadratic and hermitian spaces","title":"isisometric","text":"isisometric(L::AbsSpace, M::AbsSpace) -> Bool\n\nReturn whether the spaces L and M are isometric.\n\n\n\n","category":"method"},{"location":"Experimental/non_plane_curves/","page":"Projective Curves","title":"Projective Curves","text":"CurrentModule = Oscar","category":"page"},{"location":"Experimental/non_plane_curves/","page":"Projective Curves","title":"Projective Curves","text":"using Oscar","category":"page"},{"location":"Experimental/non_plane_curves/","page":"Projective Curves","title":"Projective Curves","text":"Pages = [\"plane_curves.md\"]","category":"page"},{"location":"Experimental/non_plane_curves/#Projective-Curves","page":"Projective Curves","title":"Projective Curves","text":"","category":"section"},{"location":"Experimental/non_plane_curves/","page":"Projective Curves","title":"Projective Curves","text":"We consider projective curves in projective spaces of arbitrary dimension.","category":"page"},{"location":"Experimental/non_plane_curves/#Constructors","page":"Projective Curves","title":"Constructors","text":"","category":"section"},{"location":"Experimental/non_plane_curves/","page":"Projective Curves","title":"Projective Curves","text":"We define a projective curve by an ideal of homogenous polynomials.","category":"page"},{"location":"Experimental/non_plane_curves/","page":"Projective Curves","title":"Projective Curves","text":"ProjCurve","category":"page"},{"location":"Experimental/non_plane_curves/#ProjCurve","page":"Projective Curves","title":"ProjCurve","text":"ProjCurve(I::MPolyIdeal)\n\nGiven a homogeneous ideal I of Krull dimension 2, return the projective curve defined by I.\n\nExamples\n\njulia> R, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"]);\n\njulia> M = matrix(R, 2, 3, [w x y; x y z])\n[w   x   y]\n[x   y   z]\n\njulia> V = minors(M, 2)\n3-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n w*y - x^2\n w*z - x*y\n x*z - y^2\n\njulia> I = ideal(R, V);\n\njulia> TC = ProjCurve(I)\nProjective curve defined by the ideal(w*y - x^2, w*z - x*y, x*z - y^2)\n\n\n\n","category":"type"},{"location":"Experimental/non_plane_curves/#General-functions-for-curves","page":"Projective Curves","title":"General functions for curves","text":"","category":"section"},{"location":"Experimental/non_plane_curves/","page":"Projective Curves","title":"Projective Curves","text":"defining_ideal(C::ProjCurve)\nin(P::Oscar.Geometry.ProjSpcElem, C::ProjCurve)\ncurve_components(C::ProjCurve)\nisirreducible(C::ProjCurve)\nreduction(C::ProjCurve)\njacobi_ideal(C::ProjCurve)\ninvert_birational_map(phi::Vector{T}, C::ProjCurve) where {T <: MPolyElem}","category":"page"},{"location":"Experimental/non_plane_curves/#defining_ideal-Tuple{ProjCurve}","page":"Projective Curves","title":"defining_ideal","text":"defining_ideal(C::ProjCurve)\n\nReturn the defining ideal of the projective curve C.\n\n\n\n","category":"method"},{"location":"Experimental/non_plane_curves/#in-Tuple{Oscar.Geometry.ProjSpcElem, ProjCurve}","page":"Projective Curves","title":"in","text":"in(P::Oscar.Geometry.ProjSpcElem, C::ProjCurve)\n\nReturn true if the point P is on the curve C, and false otherwise.\n\nExamples\n\njulia> S, (x, y, z, t) = PolynomialRing(QQ, [\"x\", \"y\", \"z\", \"t\"])\n(Multivariate Polynomial Ring in x, y, z, t over Rational Field, fmpq_mpoly[x, y, z, t])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z, t over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1]\n  t -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z, t])\n\njulia> I = ideal(T, [x^2, y^2*z, z^2])\nideal(x^2, y^2*z, z^2)\n\njulia> C = Oscar.ProjCurve(I)\nProjective curve defined by the ideal(x^2, y^2*z, z^2)\n\n\njulia> PP = proj_space(QQ, 3)\n(Projective space of dim 3 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2], x[3]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(2), QQ(0), QQ(5)])\n(0 : 2 : 0 : 5)\n\njulia> P in C\ntrue\n\n\n\n","category":"method"},{"location":"Experimental/non_plane_curves/#curve_components-Tuple{ProjCurve}","page":"Projective Curves","title":"curve_components","text":"curve_components(C::ProjCurve)\n\nReturn a dictionary containing the irreducible components of C and the corresponding reduced curve.\n\n\n\n","category":"method"},{"location":"Experimental/non_plane_curves/#isirreducible-Tuple{ProjCurve}","page":"Projective Curves","title":"isirreducible","text":"isirreducible(C::ProjCurve)\n\nReturn true if C is irreducible, and false otherwise.\n\nExamples\n\njulia> S, (x, y, z, t) = PolynomialRing(QQ, [\"x\", \"y\", \"z\", \"t\"])\n(Multivariate Polynomial Ring in x, y, z, t over Rational Field, fmpq_mpoly[x, y, z, t])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z, t over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1]\n  t -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z, t])\n\njulia> I = ideal(T, [x^2, y^2*z, z^2])\nideal(x^2, y^2*z, z^2)\n\njulia> C = Oscar.ProjCurve(I)\nProjective curve defined by the ideal(x^2, y^2*z, z^2)\n\njulia> Oscar.isirreducible(C)\ntrue\n\n\n\n","category":"method"},{"location":"Experimental/non_plane_curves/#reduction-Tuple{ProjCurve}","page":"Projective Curves","title":"reduction","text":"reduction(C::ProjCurve)\n\nReturn the projective curve defined by the radical of the defining ideal of C.\n\nExamples\n\njulia> S, (x, y, z, t) = PolynomialRing(QQ, [\"x\", \"y\", \"z\", \"t\"])\n(Multivariate Polynomial Ring in x, y, z, t over Rational Field, fmpq_mpoly[x, y, z, t])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z, t over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1]\n  t -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z, t])\n\njulia> I = ideal(T, [x^2, y^2*z, z^2])\nideal(x^2, y^2*z, z^2)\n\njulia> C = Oscar.ProjCurve(I)\nProjective curve defined by the ideal(x^2, y^2*z, z^2)\n\njulia> Oscar.reduction(C)\nProjective curve defined by the ideal(z, x)\n\n\n\n","category":"method"},{"location":"Experimental/non_plane_curves/#jacobi_ideal-Tuple{ProjCurve}","page":"Projective Curves","title":"jacobi_ideal","text":"jacobi_ideal(C::ProjCurve)\n\nReturn the Jacobian ideal of the defining ideal of C.\n\nExamples\n\njulia> S, (x, y, z, t) = PolynomialRing(QQ, [\"x\", \"y\", \"z\", \"t\"])\n(Multivariate Polynomial Ring in x, y, z, t over Rational Field, fmpq_mpoly[x, y, z, t])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z, t over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1]\n  t -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z, t])\n\njulia> I = ideal(T, [x^2, y^2*z, z^2])\nideal(x^2, y^2*z, z^2)\n\njulia> C = Oscar.ProjCurve(I)\nProjective curve defined by the ideal(x^2, y^2*z, z^2)\n\njulia> Oscar.jacobi_ideal(C)\nideal(4*x*y*z, 2*x*y^2, 4*x*z, 4*y*z^2)\n\n\n\n","category":"method"},{"location":"Experimental/non_plane_curves/#invert_birational_map-Union{Tuple{T}, Tuple{Vector{T}, ProjCurve}} where T<:MPolyElem","page":"Projective Curves","title":"invert_birational_map","text":"invert_birational_map(phi::Vector{T}, C::ProjCurve) where {T <: MPolyElem}\n\nReturn a dictionary where image represents the image of the birational map given by phi, and inverse represents its inverse, where phi is a birational map of the projective curve C to its image in the projective space of dimension size(phi) - 1. Note that the entries of inverse should be considered as representatives of elements in R/image, where R is the basering.\n\n\n\n","category":"method"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/developer/future/#Future-plans","page":"Future plans","title":"Future plans","text":"","category":"section"},{"location":"Nemo/developer/future/#Ring-and-CommRing","page":"Future plans","title":"Ring and CommRing","text":"","category":"section"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"Currently all commutative ring types belong to Ring and their elements to RingElem (and RingElement) and we have separate types for noncommutative rings and elements thereof, i.e. NCRing and NCRingElem etc.","category":"page"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"However, it would be more logical to use Ring for not necessarily commutative rings and CommRing, CRing or CommutativeRing (the name has not been decided on yet) for commutative rings.","category":"page"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"This is a big change and should happen with plenty of warning for the community. It would be convenient if a script could be made available to automate this.","category":"page"},{"location":"Nemo/developer/future/#Mono-repository","page":"Future plans","title":"Mono repository","text":"","category":"section"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"There is currently a proposal to place all Oscar related repositories, or some subset of them in a single repository called OscarMono.jl. The details are not finalised and it is not known what impact this will have on Nemo. However, Nemo developers should be aware that this may happen at some point in the fairly near future.","category":"page"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"Users of Nemo should be unaffected, as Nemo will continue to exist as a separate package in the OscarMono.jl repository, even if it does become part of this repository. Julia supports multiple packages in the same repository nowadays.","category":"page"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"The possibility will always exist to separate the repositories again if the experiment is unsuccessful or serves its purpose and is no longer needed.","category":"page"},{"location":"Nemo/developer/future/#Moving-implementations-from-Hecke","page":"Future plans","title":"Moving implementations from Hecke","text":"","category":"section"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"In the Hecke.jl project there are a vast number of implementations that were intended for AbstractAlgebra.jl and Nemo.jl. They exist in the src/Misc directory of that project.","category":"page"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"These implementations will eventually all be moved over to the correct repositories. Code, documentation and performance improvements will be added.","category":"page"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"A number of things must be taken into account when making such moves:","category":"page"},{"location":"Nemo/developer/future/","page":"Future plans","title":"Future plans","text":"Substantial chunks of code should be moved at a time. The code can be initially placed in a src/Misc directory in AbstractAlgebra or Nemo until it can finally be integrated fully into the correct place in those projects.\nSome of the code calls full parent object constructors in generic code. Such calls should be removed where possible.\nSome functions such as exp and the like require Base to be prepended, as we do not import these functions from Base into Generic.\nSome of the code calls back into convenience functions found only in Hecke. These have to be rewritten in terms of AbstractAlgebra/Nemo functions.\nSome of the code relies on fmpz being available, but would otherwise be suitable for AbstractAlgebra. This code can hopefully be rewritten to be agnostic about the integer type.\nTodos, questions and so on should be moved to tickets.\nSometimes exception types differ between Hecke and Nemo, meaning that tests will fail due to the wrong type of exception being raised. Either the tests will have to be adjusted, or the Nemo exception types changed.\nRingElem is often used where RingElement is intended, etc. Also types are often unconstrained where Nemo would constrain them to RingElement.\nSome Hecke functions try to support generic types and specific concrete Nemo types in the same implementation. These will unfortunately have to either be split between AbstractAlgebra and Nemo or a completely generic implementation for abstract types will have to be made.\nSome Hecke implementations assume sub! and friends are available in generic code. These will have to be rewritten, usually by adding a single unary minus outside of a loop and switching to add! and friends inside the loops.\nTest code, docstrings and documentation will have to be added where they do not already exist.\nExports of the new functionality will have to be added.\nSome functions should be accompanied by similar functions that don't yet exist. For example if there is a blah_rows there probably should be a blah_cols function as well, etc.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/fraction/#Generic-fraction-fields","page":"Generic fraction fields","title":"Generic fraction fields","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"AbstractAlgebra.jl provides a module, implemented in src/Fraction.jl for fraction fields over any gcd domain belonging to the AbstractAlgebra.jl abstract type hierarchy.","category":"page"},{"location":"AbstractAlgebra/fraction/#Generic-fraction-types","page":"Generic fraction fields","title":"Generic fraction types","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"AbstractAlgebra.jl implements a generic fraction type Generic.Frac{T} where T is the type of elements of the base ring. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Parent objects of such fraction elements have type Generic.FracField{T}.","category":"page"},{"location":"AbstractAlgebra/fraction/#Factored-fraction-types","page":"Generic fraction fields","title":"Factored fraction types","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"AbstractAlgebra.jl also implements a fraction type Generic.FactoredFrac{T} with parent objects of such fractions having type Generic.FactoredFracField{T}. As opposed to the fractions of type Generic.Frac{T}, which are just a numerator and denominator, these fractions are maintained in factored form as much as possible.","category":"page"},{"location":"AbstractAlgebra/fraction/#Abstract-types","page":"Generic fraction fields","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"All fraction element types belong to the abstract type FracElem{T} and the fraction field types belong to the abstract type FracField{T}. This enables one to write generic functions that can accept any AbstractAlgebra fraction type.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"note: Note\nBoth the generic fraction field type Generic.FracField{T} and the abstract type it belongs to, FracField{T} are both called FracField. The former is a (parameterised) concrete type for a fraction field over a given base ring whose elements have type T. The latter is an abstract type representing all fraction field types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"AbstractAlgebra/fraction/#Fraction-field-constructors","page":"Generic fraction fields","title":"Fraction field constructors","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"In order to construct fractions in AbstractAlgebra.jl, one can first construct the fraction field itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"FractionField(R::Ring; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Given a base ring R return the parent object of the fraction field of R. By default the parent object S will depend only on R and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Here are some examples of creating fraction fields and making use of the resulting parent objects to coerce various elements into the fraction field.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = FractionField(R)\nFraction field of Univariate Polynomial Ring in x over Integers\n\njulia> f = S()\n0\n\njulia> g = S(123)\n123\n\njulia> h = S(BigInt(1234))\n1234\n\njulia> k = S(x + 1)\nx + 1","category":"page"},{"location":"AbstractAlgebra/fraction/#Factored-Fraction-field-constructors","page":"Generic fraction fields","title":"Factored Fraction field constructors","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"The corresponding factored field uses the following constructor.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"FactoredFractionField(R::Ring; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S = FactoredFractionField(R)\nFactored fraction field of Multivariate Polynomial Ring in x, y over Integers\n\njulia> (X, Y) = (S(x), S(y))\n(x, y)\n\njulia> f = X^6*(X+Y)^2*(X^2+Y)^3*(X+2*Y)^-3*(X+3*Y)^-4\nx^6*(x + y)^2*(x^2 + y)^3/((x + 2*y)^3*(x + 3*y)^4)\n\njulia> numerator(f)\nx^14 + 2*x^13*y + x^12*y^2 + 3*x^12*y + 6*x^11*y^2 + 3*x^10*y^3 + 3*x^10*y^2 + 6*x^9*y^3 + 3*x^8*y^4 + x^8*y^3 + 2*x^7*y^4 + x^6*y^5\n\njulia> denominator(f)\nx^7 + 18*x^6*y + 138*x^5*y^2 + 584*x^4*y^3 + 1473*x^3*y^4 + 2214*x^2*y^5 + 1836*x*y^6 + 648*y^7\n\njulia> derivative(f, x)\nx^5*(x + y)*(x^2 + y)^2*(7*x^5 + 58*x^4*y + 127*x^3*y^2 + x^3*y + 72*x^2*y^3 + 22*x^2*y^2 + 61*x*y^3 + 36*y^4)/((x + 2*y)^4*(x + 3*y)^5)","category":"page"},{"location":"AbstractAlgebra/fraction/#Fraction-constructors","page":"Generic fraction fields","title":"Fraction constructors","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"One can construct fractions using the fraction field parent object, as for any ring or field.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"(R::FracField)() # constructs zero\n(R::FracField)(c::Integer)\n(R::FracField)(c::elem_type(R))\n(R::FracField{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"One may also use the Julia double slash operator to construct elements of the fraction field without constructing the fraction field parent first.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"//(x::T, y::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = FractionField(R)\nFraction field of Univariate Polynomial Ring in x over Rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> x//f\nx//(x + 1)\n\njulia> f//x\n(x + 1)//x","category":"page"},{"location":"AbstractAlgebra/fraction/#Functions-for-types-and-parents-of-fraction-fields","page":"Generic fraction fields","title":"Functions for types and parents of fraction fields","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Fraction fields in AbstractAlgebra.jl implement the Ring interface.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"base_ring(R::FracField)\nbase_ring(a::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Return the base ring of which the fraction field was constructed.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"parent(a::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Return the fraction field of the given fraction.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"characteristic(R::FracField)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Return the characteristic of the base ring of the fraction field. If the characteristic is not known an exception is raised.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = FractionField(R)\nFraction field of Univariate Polynomial Ring in x over Rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> U = base_ring(S)\nUnivariate Polynomial Ring in x over Rationals\n\njulia> V = base_ring(f)\nUnivariate Polynomial Ring in x over Rationals\n\njulia> T = parent(f)\nFraction field of Univariate Polynomial Ring in x over Rationals\n\njulia> m = characteristic(S)\n0","category":"page"},{"location":"AbstractAlgebra/fraction/#Fraction-field-functions","page":"Generic fraction fields","title":"Fraction field functions","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/#Basic-functions","page":"Generic fraction fields","title":"Basic functions","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Fraction fields implement the Ring interface.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"zero(R::FracField)\none(R::FracField)\niszero(a::FracElem)\nisone(a::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"inv(a::T) where T <: FracElem","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"They also implement the field interface.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"isunit(f::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"And they implement the fraction field interface.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"numerator(a::FracElem)\ndenominator(a::FracElem)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = FractionField(R)\nFraction field of Univariate Polynomial Ring in x over Rationals\n\njulia> f = S(x + 1)\nx + 1\n\njulia> g = (x^2 + x + 1)//(x^3 + 3x + 1)\n(x^2 + x + 1)//(x^3 + 3*x + 1)\n\njulia> h = zero(S)\n0\n\njulia> k = one(S)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> r = deepcopy(f)\nx + 1\n\njulia> n = numerator(g)\nx^2 + x + 1\n\njulia> d = denominator(g)\nx^3 + 3*x + 1","category":"page"},{"location":"AbstractAlgebra/fraction/#Greatest-common-divisor","page":"Generic fraction fields","title":"Greatest common divisor","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"gcd{T <: RingElem}(::FracElem{T}, ::FracElem{T})","category":"page"},{"location":"AbstractAlgebra/fraction/#gcd-Union{Tuple{T}, Tuple{FracElem{T}, FracElem{T}}} where T<:RingElem","page":"Generic fraction fields","title":"gcd","text":"gcd(a::FracElem{T}, b::FracElem{T}) where {T <: RingElem}\n\nReturn a greatest common divisor of a and b if one exists. N.B: we define the GCD of ab and cd to be gcd(ad bc)bd, reduced to lowest terms. This requires the existence of a greatest common divisor function for the base ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 2x + 1)//(x^2 + x + 1)\n(x^2 + 2*x + 1)//(x^2 + x + 1)\n\njulia> h = gcd(f, g)\n(x + 1)//(x^5 + x^4 + 4*x^3 + 4*x^2 + 4*x + 1)\n","category":"page"},{"location":"AbstractAlgebra/fraction/#Square-root","page":"Generic fraction fields","title":"Square root","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"issquare{T <: RingElem}(::FracElem{T})","category":"page"},{"location":"AbstractAlgebra/fraction/#issquare-Union{Tuple{FracElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic fraction fields","title":"issquare","text":"issquare(a::FracElem{T}) where T <: RingElem\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Base.sqrt(::FracElem{T}) where {T <: RingElem}","category":"page"},{"location":"AbstractAlgebra/fraction/#sqrt-Union{Tuple{FracElem{T}}, Tuple{T}} where T<:RingElem","page":"Generic fraction fields","title":"sqrt","text":"Base.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = FractionField(R)\nFraction field of Univariate Polynomial Ring in x over Rationals\n\njulia> a = (21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> sqrt(a^2)\n(21//4*x^6 - 15*x^5 + 27//14*x^4 + 9//20*x^3 + 3//7*x + 9//10)//(x + 3)\n\njulia> issquare(a^2)\ntrue","category":"page"},{"location":"AbstractAlgebra/fraction/#Remove-and-valuation","page":"Generic fraction fields","title":"Remove and valuation","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"When working over a Euclidean domain, it is convenient to extend valuations to the fraction field. To facilitate this, we define the following functions.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"remove{T <: RingElem}(::FracElem{T}, ::T)","category":"page"},{"location":"AbstractAlgebra/fraction/#remove-Union{Tuple{T}, Tuple{FracElem{T}, T}} where T<:RingElem","page":"Generic fraction fields","title":"remove","text":"remove(z::FracElem{T}, p::T) where {T <: RingElem}\n\nReturn the tuple n x such that z = p^nx where x has valuation 0 at p.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"valuation{T <: RingElem}(::FracElem{T}, ::T)","category":"page"},{"location":"AbstractAlgebra/fraction/#valuation-Union{Tuple{T}, Tuple{FracElem{T}, T}} where T<:RingElem","page":"Generic fraction fields","title":"valuation","text":"valuation(z::FracElem{T}, p::T) where {T <: RingElem}\n\nReturn the valuation of z at p.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> f = (x + 1)//(x^3 + 3x + 1)\n(x + 1)//(x^3 + 3*x + 1)\n\njulia> g = (x^2 + 1)//(x^2 + x + 1)\n(x^2 + 1)//(x^2 + x + 1)\n\njulia> v, q = remove(f^3*g, x + 1)\n(3, (x^2 + 1)//(x^11 + x^10 + 10*x^9 + 12*x^8 + 39*x^7 + 48*x^6 + 75*x^5 + 75*x^4 + 66*x^3 + 37*x^2 + 10*x + 1))\n\njulia> v = valuation(f^3*g, x + 1)\n3\n","category":"page"},{"location":"AbstractAlgebra/fraction/#Random-generation","page":"Generic fraction fields","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Random fractions can be generated using rand. The parameters passed after the fraction field tell rand how to generate random elements of the base ring.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"rand(R::FracField, v...)","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"using AbstractAlgebra # hide\nK = FractionField(ZZ)\nf = rand(K, -10:10)\n\nR, x = PolynomialRing(ZZ, \"x\")\nS = FractionField(R)\ng = rand(S, -1:3, -10:10)","category":"page"},{"location":"AbstractAlgebra/fraction/#Extra-functionality-for-factored-fractions","page":"Generic fraction fields","title":"Extra functionality for factored fractions","text":"","category":"section"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"The Generic.FactoredFrac{T} type implements an interface similar to that of the Fac{T} type for iterating over the terms in the factorisation. There is also the function push_term!(a, b, e) for efficiently performing a *= b^e, and the function normalise returns relatively prime terms.","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/fraction/","page":"Generic fraction fields","title":"Generic fraction fields","text":"julia> F = FactoredFractionField(ZZ)\nFactored fraction field of Integers\n\njulia> f = F(-1)\n-1\n\njulia> push_term!(f, 10, 10)\n-10^10\n\njulia> push_term!(f, 42, -8)\n-10^10/42^8\n\njulia> normalise(f)\n-5^10*2^2/21^8\n\njulia> unit(f)\n-1\n\njulia> collect(f)\n2-element Vector{Tuple{BigInt, Int64}}:\n (10, 10)\n (42, -8)","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"CurrentModule = Oscar","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"using Oscar","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"Pages = [\"plane_curves.md\"]","category":"page"},{"location":"Experimental/plane_curves/#Affine-and-Projective-Plane-Curves","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"We consider two kinds of plane curves: affine and projective. An affine plane curve is defined by a polynomial in two variables, whereas a projective plane curve is defined by a homogeneous polynomial belonging to a graded polynomial ring in three variables.","category":"page"},{"location":"Experimental/plane_curves/#Affine-Plane-Curves","page":"Affine and Projective Plane Curves","title":"Affine Plane Curves","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"An affine plane curve is defined as the class of a two-variables polynomial F over a field K, modulo the equivalence relation F sim G iff exists lambda in Kbackslash 0 F = lambda cdot G.","category":"page"},{"location":"Experimental/plane_curves/#Example","page":"Affine and Projective Plane Curves","title":"Example","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"AffinePlaneCurve","category":"page"},{"location":"Experimental/plane_curves/#AffinePlaneCurve","page":"Affine and Projective Plane Curves","title":"AffinePlaneCurve","text":"AffinePlaneCurve{S}(eq::Oscar.MPolyElem{S}) where S <: FieldElem\n\nReturn the Affine Plane Curve defined by the polynomial in two variables eq.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> F = y^3*x^6 - y^6*x^2\nx^6*y^3 - x^2*y^6\n\njulia> C = Oscar.AffinePlaneCurve(F)\nAffine plane curve defined by x^6*y^3 - x^2*y^6\n\n\n\n","category":"type"},{"location":"Experimental/plane_curves/#Projective-Plane-Curves","page":"Affine and Projective Plane Curves","title":"Projective Plane Curves","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"Similarly, a projective plane curve is defined as the class of a three-variables homogeneous polynomial F over a field K, modulo the equivalence relation Fsim G iff exists lambda in Kbackslash 0 F = lambda cdot G. The defining equation is supposed to belong to a graded ring.","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"ProjPlaneCurve","category":"page"},{"location":"Experimental/plane_curves/#ProjPlaneCurve","page":"Affine and Projective Plane Curves","title":"ProjPlaneCurve","text":"ProjPlaneCurve{S}(eq::Oscar.MPolyElem_dec{S}) where {S <: FieldElem}\n\nReturn the Projective Plane Curve defined by the homogeneous polynomial in three variables eq.\n\nExamples\n\njulia> R, (x,y,z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(R)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> F = T(y^3*x^6 - y^6*x^2*z)\nx^6*y^3 - x^2*y^6*z\n\njulia> Oscar.ProjPlaneCurve(F)\nProjective plane curve defined by x^6*y^3 - x^2*y^6*z\n\n\n\n","category":"type"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"A particular kind of projective curves is the case of elliptic curves, see the corresponding section for more information. The types ProjPlaneCurve and ProjEllipticCurve are subtypes of the abstract type ProjectivePlaneCurve. In addition, the types AffinePlaneCurve and ProjectivePlaneCurve are subtypes of the abstract type PlaneCurve.","category":"page"},{"location":"Experimental/plane_curves/#Points","page":"Affine and Projective Plane Curves","title":"Points","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"When considering curves, it is natural to have a look at points on the curve. We describe in this section how to deal with points, both in the affine and projective settings.","category":"page"},{"location":"Experimental/plane_curves/#Point-in-the-affine-space","page":"Affine and Projective Plane Curves","title":"Point in the affine space","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"A point in the affine space can be defined as follows:","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"Point","category":"page"},{"location":"Experimental/plane_curves/#Point","page":"Affine and Projective Plane Curves","title":"Point","text":"Point(coordinates::Vector{S}) where {S <: FieldElem}\n\nReturn the point with the given coordinates.\n\nExamples\n\njulia> P = Oscar.Point([QQ(1), QQ(2), QQ(2)])\nPoint with coordinates fmpq[1, 2, 2]\n\n\n\n","category":"type"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"We consider also the following function for points.","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"ideal_point(R::MPolyRing{S}, P::Point{S}) where S <: FieldElem","category":"page"},{"location":"Experimental/plane_curves/#ideal_point-Union{Tuple{S}, Tuple{MPolyRing{S}, Point{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"ideal_point","text":"ideal_point(R::MPolyRing{S}, P::Point{S}) where S <: FieldElem\n\nReturn the maximal ideal associated to the point P in the ring R.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> P = Oscar.Point([QQ(2), QQ(1)])\nPoint with coordinates fmpq[2, 1]\n\njulia> Oscar.ideal_point(R, P)\nideal(x - 2, y - 1)\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"The following function checks if a given point is on a curve:","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"in(P::Point{S}, C::AffinePlaneCurve{S}) where S <: FieldElem","category":"page"},{"location":"Experimental/plane_curves/#in-Union{Tuple{S}, Tuple{Point{S}, AffinePlaneCurve{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"in","text":"in(P::Point{S}, C::AffinePlaneCurve{S}) where S <: FieldElem\n\nReturn true if the point P is on the curve C, and false otherwise.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#Point-in-the-projective-space","page":"Affine and Projective Plane Curves","title":"Point in the projective space","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"In order to define a point in the projective plane, one needs first to define the projective plane as follows, where K is the base ring:","category":"page"},{"location":"Experimental/plane_curves/#Example-2","page":"Affine and Projective Plane Curves","title":"Example","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"K = QQ\nPP = proj_space(K, 2)","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"Then, one can define a projective point as follows:","category":"page"},{"location":"Experimental/plane_curves/#Example-3","page":"Affine and Projective Plane Curves","title":"Example","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(1), QQ(2), QQ(-5)])","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"The following function checks if a given point is on a curve:","category":"page"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"in(P::Oscar.Geometry.ProjSpcElem{S}, C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}) where S <: FieldElem","category":"page"},{"location":"Experimental/plane_curves/#in-Union{Tuple{S}, Tuple{Oscar.Geometry.ProjSpcElem{S}, ProjectivePlaneCurve{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"in","text":"in(P::Oscar.Geometry.ProjSpcElem{S}, C::ProjectivePlaneCurve{S}) where S <: FieldElem\n\nReturn true if the point P is on the curve C, and false otherwise.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#General-functions-for-curves","page":"Affine and Projective Plane Curves","title":"General functions for curves","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"degree(C::Oscar.PlaneCurveModule.PlaneCurve)\nring(C::Oscar.PlaneCurveModule.PlaneCurve)\ncurve_components(C::Oscar.PlaneCurveModule.PlaneCurve{S}) where S <: FieldElem\nreduction(C::AffinePlaneCurve{S}) where S <: FieldElem\nisirreducible(C::Oscar.PlaneCurveModule.PlaneCurve{S}) where S <: FieldElem\nisreduced(C::Oscar.PlaneCurveModule.PlaneCurve{S}) where S <: FieldElem\nunion(C::T, D::T) where T <: Oscar.PlaneCurveModule.PlaneCurve\narithmetic_genus(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve)\narithmetic_genus(C::AffinePlaneCurve)\ngeometric_genus(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}) where S <: FieldElem\ngeometric_genus(C::AffinePlaneCurve)","category":"page"},{"location":"Experimental/plane_curves/#degree-Tuple{Oscar.PlaneCurveModule.PlaneCurve}","page":"Affine and Projective Plane Curves","title":"degree","text":"degree(C::PlaneCurve)\n\nReturn the degree of the defining polynomial of C.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#ring-Tuple{Oscar.PlaneCurveModule.PlaneCurve}","page":"Affine and Projective Plane Curves","title":"ring","text":"ring(C::PlaneCurve)\n\nReturn the coordinate ring of the curve C.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^2+x-x^3)\nAffine plane curve defined by -x^3 + x + y^2\n\njulia> Oscar.ring(C)\n(Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal(-x^3 + x + y^2), Map from\nMultivariate Polynomial Ring in x, y over Rational Field to Quotient of Multivariate Polynomial Ring in x, y over Rational Field by ideal(-x^3 + x + y^2) defined by a julia-function with inverse)\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#curve_components-Union{Tuple{Oscar.PlaneCurveModule.PlaneCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"curve_components","text":"curve_components(C::PlaneCurve{S}) where S <: FieldElem\n\nReturn a dictionary containing the irreducible components of C and their multiplicity.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^3*x^6 - y^6*x^2)\nAffine plane curve defined by x^6*y^3 - x^2*y^6\n\njulia> Oscar.curve_components(C)\nDict{AffinePlaneCurve{fmpq}, Int64} with 3 entries:\n  y         => 3\n  x         => 2\n  x^4 - y^3 => 1\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#reduction-Union{Tuple{AffinePlaneCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"reduction","text":"reduction(C::AffinePlaneCurve{S}) where S <: FieldElem\nreduction(C::ProjPlaneCurve{S}) where S <: FieldElem\n\nReturn the plane curve defined by the squarefree part of the equation of C.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^3*x^6 - y^6*x^2)\nAffine plane curve defined by x^6*y^3 - x^2*y^6\n\njulia> Oscar.reduction(C)\nAffine plane curve defined by x^5*y - x*y^4\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#isirreducible-Union{Tuple{Oscar.PlaneCurveModule.PlaneCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"isirreducible","text":"isirreducible(C::PlaneCurve{S}) where S <: FieldElem\n\nReturn true if C is irreducible, and false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^2+x-x^3)\nAffine plane curve defined by -x^3 + x + y^2\n\njulia> Oscar.isirreducible(C)\ntrue\n\njulia> D = Oscar.AffinePlaneCurve(y^3*x^6 - y^6*x^2)\nAffine plane curve defined by x^6*y^3 - x^2*y^6\n\njulia> Oscar.isirreducible(D)\nfalse\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#isreduced-Union{Tuple{Oscar.PlaneCurveModule.PlaneCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"isreduced","text":"isreduced(C::PlaneCurve{S}) where S <: FieldElem\n\nReturn true if C is reduced, and false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^2+x-x^3)\nAffine plane curve defined by -x^3 + x + y^2\n\njulia> Oscar.isreduced(C)\ntrue\n\njulia> D = Oscar.AffinePlaneCurve(y^3*x^6 - y^6*x^2)\nAffine plane curve defined by x^6*y^3 - x^2*y^6\n\njulia> Oscar.isreduced(D)\nfalse\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#union-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.PlaneCurveModule.PlaneCurve","page":"Affine and Projective Plane Curves","title":"union","text":"union(C::T, D::T) where T <: PlaneCurve\n\nReturn the union of C and D (with multiplicity).\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^2+x-x^3)\nAffine plane curve defined by -x^3 + x + y^2\n\njulia> D = Oscar.AffinePlaneCurve(y^3*x^6 - y^6*x^2)\nAffine plane curve defined by x^6*y^3 - x^2*y^6\n\njulia> union(C, D)\nAffine plane curve defined by -x^9*y^3 + x^7*y^3 + x^6*y^5 + x^5*y^6 - x^3*y^6 - x^2*y^8\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#arithmetic_genus-Tuple{ProjectivePlaneCurve}","page":"Affine and Projective Plane Curves","title":"arithmetic_genus","text":"arithmetic_genus(C::ProjectivePlaneCurve)\n\nReturn the arithmetic genus of C.\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by \n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = Oscar.ProjPlaneCurve(T(y^2 * z - x^3 - x * z^2))\nProjective plane curve defined by -x^3 - x*z^2 + y^2*z\n\njulia> Oscar.arithmetic_genus(C)\n1\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#arithmetic_genus-Tuple{AffinePlaneCurve}","page":"Affine and Projective Plane Curves","title":"arithmetic_genus","text":"arithmetic_genus(C::AffinePlaneCurve)\n\nReturn the arithmetic genus of the projective closure of C.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#geometric_genus-Union{Tuple{ProjectivePlaneCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"geometric_genus","text":"geometric_genus(C::ProjectivePlaneCurve{T}) where T <: FieldElem\n\nReturn the geometric genus of C.\n\nExamples\n\njulia> R, (x,y,z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> C = ProjPlaneCurve(z*x^2-y^3)\nProjective plane curve defined by x^2*z - y^3\n\njulia> geometric_genus(C)\n0\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#geometric_genus-Tuple{AffinePlaneCurve}","page":"Affine and Projective Plane Curves","title":"geometric_genus","text":"geometric_genus(C::AffinePlaneCurve)\n\nReturn the geometric genus of the projective closure of C.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(GF(7), [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Galois field with characteristic 7, gfp_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^9 - x^2*(x-1)^9)\nAffine plane curve defined by 6*x^11 + 2*x^10 + 6*x^9 + x^4 + 5*x^3 + x^2 + y^9\n\njulia> Oscar.geometric_genus(C)\n0\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#Smoothness,-tangents-and-singularity-related-functions","page":"Affine and Projective Plane Curves","title":"Smoothness, tangents and singularity related functions","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"jacobi_ideal(C::Oscar.PlaneCurveModule.PlaneCurve)\nissmooth(C::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\nissmooth(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\ntangent(C::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\ntangent(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\ncurve_singular_locus(C::AffinePlaneCurve)\ncurve_singular_locus([PP::Oscar.Geometry.ProjSpc{S}], C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}) where S <: FieldElem\nmultiplicity(C::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\nmultiplicity(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\ntangent_lines(C::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\ntangent_lines(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\nissmooth_curve(C::AffinePlaneCurve)\nissmooth_curve(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve)","category":"page"},{"location":"Experimental/plane_curves/#jacobi_ideal-Tuple{Oscar.PlaneCurveModule.PlaneCurve}","page":"Affine and Projective Plane Curves","title":"jacobi_ideal","text":"jacobi_ideal(C::PlaneCurve)\n\nReturn the Jacobian ideal of the defining polynomial of C.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(y^3*x^6 - y^6*x^2)\nAffine plane curve defined by x^6*y^3 - x^2*y^6\n\njulia> Oscar.jacobi_ideal(C)\nideal(6*x^5*y^3 - 2*x*y^6, 3*x^6*y^2 - 6*x^2*y^5)\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#issmooth-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, Point{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"issmooth","text":"issmooth(C::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\n\nThrow an error if P is not a point of C, return false if P is a singular point of C, and true if P is a smooth point of C.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(x^2*(x+y)*(y^3-x^2))\nAffine plane curve defined by -x^5 - x^4*y + x^3*y^3 + x^2*y^4\n\njulia> P = Oscar.Point([QQ(0), QQ(0)])\nPoint with coordinates fmpq[0, 0]\n\njulia> Oscar.issmooth(C, P)\nfalse\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#issmooth-Union{Tuple{S}, Tuple{ProjectivePlaneCurve{S}, Oscar.Geometry.ProjSpcElem{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"issmooth","text":"issmooth(C::ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\n\nThrow an error if P is not a point of C, return false if P is a singular point of C, and true if P is a smooth point of C.\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = Oscar.ProjPlaneCurve(x^2*(x+y)*(y^3-x^2*z))\nProjective plane curve defined by -x^5*z - x^4*y*z + x^3*y^3 + x^2*y^4\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(0), QQ(0), QQ(1)])\n(0 : 0 : 1)\n\njulia> Oscar.issmooth(C, P)\nfalse\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#tangent-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, Point{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"tangent","text":"tangent(C::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\n\nReturn the tangent of C at P when P is a smooth point of C, and throw an error otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(x^2*(x+y)*(y^3-x^2))\nAffine plane curve defined by -x^5 - x^4*y + x^3*y^3 + x^2*y^4\n\njulia> P2 = Oscar.Point([QQ(2), QQ(-2)])\nPoint with coordinates fmpq[2, -2]\n\njulia> Oscar.tangent(C, P2)\nAffine plane curve defined by -48*x - 48*y\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#tangent-Union{Tuple{S}, Tuple{ProjectivePlaneCurve{S}, Oscar.Geometry.ProjSpcElem{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"tangent","text":"tangent(C::ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\n\nReturn the tangent of C at P when P is a smooth point of C, and throw an error otherwise.\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\",\"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> C = Oscar.ProjPlaneCurve(x^2*(x+y)*(y^3-x^2*z))\nProjective plane curve defined by -x^5*z - x^4*y*z + x^3*y^3 + x^2*y^4\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(2), QQ(-2), QQ(1)])\n(2 : -2 : 1)\n\njulia> Oscar.tangent(C, P)\nProjective plane curve defined by -48*x - 48*y\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#curve_singular_locus-Tuple{AffinePlaneCurve}","page":"Affine and Projective Plane Curves","title":"curve_singular_locus","text":"curve_singular_locus(C::AffinePlaneCurve)\n\nReturn the reduced singular locus of C as a list whose first element is the affine plane curve consisting of the singular components of C (if any), and the second element is the list of the isolated singular points (which may be contained in the singular component). The singular component might not contain any point over the considered field.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(x^2*(x+y)*(y^3-x^2))\nAffine plane curve defined by -x^5 - x^4*y + x^3*y^3 + x^2*y^4\n\njulia> Oscar.curve_singular_locus(C)\n2-element Vector{Vector{T} where T}:\n AffinePlaneCurve[Affine plane curve defined by x]\n Point[Point with coordinates fmpq[-1, 1], Point with coordinates fmpq[0, 0]]\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#curve_singular_locus-Union{Tuple{S}, Tuple{Oscar.Geometry.ProjSpc{S}, ProjectivePlaneCurve{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"curve_singular_locus","text":"curve_singular_locus([PP::Oscar.Geometry.ProjSpc{S}], C::ProjectivePlaneCurve{S}) where S <: FieldElem\n\nReturn the reduced singular locus of C as a list whose first element is the projective plane curve consisting of the singular components of C (if any), and the second element is the list of the singular points of the reduction of C (the points are in PP if specified, or in a new projective space otherwise). The singular component might not contain any point over the considered field.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#multiplicity-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, Point{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"multiplicity","text":"multiplicity(C::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\n\nReturn the multiplicity of C at P.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(x^2*(x+y)*(y^3-x^2))\nAffine plane curve defined by -x^5 - x^4*y + x^3*y^3 + x^2*y^4\n\njulia> P = Oscar.Point([QQ(2), QQ(-2)])\nPoint with coordinates fmpq[2, -2]\n\njulia> Oscar.multiplicity(C, P)\n1\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#multiplicity-Union{Tuple{S}, Tuple{ProjectivePlaneCurve{S}, Oscar.Geometry.ProjSpcElem{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"multiplicity","text":" multiplicity(C::ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\n\nReturn the multiplicity of C at P.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#tangent_lines-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, Point{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"tangent_lines","text":"tangent_lines(C::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\n\nReturn the tangent lines at P to C with their multiplicity.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(x^2*(x+y)*(y^3-x^2))\nAffine plane curve defined by -x^5 - x^4*y + x^3*y^3 + x^2*y^4\n\njulia> P = Oscar.Point([QQ(0), QQ(0)])\nPoint with coordinates fmpq[0, 0]\n\njulia> Oscar.tangent_lines(C, P)\nDict{AffinePlaneCurve{fmpq}, Int64} with 2 entries:\n  x     => 4\n  x + y => 1\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#tangent_lines-Union{Tuple{S}, Tuple{ProjectivePlaneCurve{S}, Oscar.Geometry.ProjSpcElem{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"tangent_lines","text":"  tangent_lines(C::ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\n\nReturn the tangent lines at P to C with their multiplicity.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#issmooth_curve-Tuple{AffinePlaneCurve}","page":"Affine and Projective Plane Curves","title":"issmooth_curve","text":"issmooth_curve(C::AffinePlaneCurve)\n\nReturn true if C has no singular point, and false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(x*(x+y))\nAffine plane curve defined by x^2 + x*y\n\njulia> Oscar.issmooth_curve(C)\nfalse\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#issmooth_curve-Tuple{ProjectivePlaneCurve}","page":"Affine and Projective Plane Curves","title":"issmooth_curve","text":"issmooth_curve(C::ProjectivePlaneCurve)\n\nReturn true if C has no singular point, and false otherwise.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#Intersection-of-curves","page":"Affine and Projective Plane Curves","title":"Intersection of curves","text":"","category":"section"},{"location":"Experimental/plane_curves/","page":"Affine and Projective Plane Curves","title":"Affine and Projective Plane Curves","text":"common_components(C::AffinePlaneCurve{S}, D::AffinePlaneCurve{S}) where S <: FieldElem\ncommon_components(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, D::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}) where S <: FieldElem\ncurve_intersect(C::AffinePlaneCurve{S}, D::AffinePlaneCurve{S}) where S <: FieldElem\ncurve_intersect([PP::Oscar.Geometry.ProjSpc{S}], C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, D::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}) where S <: FieldElem\nintersection_multiplicity(C::AffinePlaneCurve{S}, D::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\nintersection_multiplicity(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, D::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\naretransverse(C::AffinePlaneCurve{S}, D::AffinePlaneCurve{S}, P::Point{S}) where S<:FieldElem\naretransverse(C::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, D::Oscar.PlaneCurveModule.ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S<:FieldElem","category":"page"},{"location":"Experimental/plane_curves/#common_components-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, AffinePlaneCurve{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"common_components","text":"common_components(C::AffinePlaneCurve{S}, D::AffinePlaneCurve{S}) where S <: FieldElem\n\nReturn the affine plane curve consisting of the common component of C and D, or an empty vector if they do not have a common component.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(x*(x+y)*(x^2 + x + 1))\nAffine plane curve defined by x^4 + x^3*y + x^3 + x^2*y + x^2 + x*y\n\njulia> D = Oscar.AffinePlaneCurve(x*(x+y)*(x-y))\nAffine plane curve defined by x^3 - x*y^2\n\njulia> Oscar.common_components(C, D)\n1-element Vector{AffinePlaneCurve{fmpq}}:\n Affine plane curve defined by x^2 + x*y\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#common_components-Union{Tuple{S}, Tuple{ProjectivePlaneCurve{S}, ProjectivePlaneCurve{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"common_components","text":"common_components(C::ProjectivePlaneCurve{S}, D::ProjectivePlaneCurve{S}) where S <: FieldElem\n\nReturn the projective plane curve consisting of the common component of C and D, or an empty vector if they do not have a common component.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#curve_intersect-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, AffinePlaneCurve{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"curve_intersect","text":"curve_intersect(C::AffinePlaneCurve{S}, D::AffinePlaneCurve{S}) where S <: FieldElem\n\nReturn a list whose first element is the affine plane curve defined by the gcd of C.eq and D.eq, the second element is the list of the remaining intersection points when the common components are removed from C and D.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(x*(x+y))\nAffine plane curve defined by x^2 + x*y\n\njulia> D = Oscar.AffinePlaneCurve((x-y)*(x-2))\nAffine plane curve defined by x^2 - x*y - 2*x + 2*y\n\njulia> Oscar.curve_intersect(C, D)\n2-element Vector{Vector{T} where T}:\n AffinePlaneCurve[]\n Point{fmpq}[Point with coordinates fmpq[0, 0], Point with coordinates fmpq[2, -2]]\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#curve_intersect-Union{Tuple{S}, Tuple{Oscar.Geometry.ProjSpc{S}, ProjectivePlaneCurve{S}, ProjectivePlaneCurve{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"curve_intersect","text":"curve_intersect([PP::Oscar.Geometry.ProjSpc{S}], C::ProjectivePlaneCurve{S}, D::ProjectivePlaneCurve{S}) where S <: FieldElem\n\nReturn a list whose first element is the projective plane curve defined by the gcd of C.eq and D.eq, the second element is the list of the remaining intersection points when the common components are removed from C and D (the points are in PP if specified, or in a new projective space otherwise).\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\",\"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> C = Oscar.ProjPlaneCurve(T(x+y+z))\nProjective plane curve defined by x + y + z\n\njulia> D = Oscar.ProjPlaneCurve(T(z))\nProjective plane curve defined by z\n\njulia> Oscar.curve_intersect(PP[1], C, D)\n2-element Vector{Vector{Any}}:\n []\n [(-1 : 1 : 0)]\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#intersection_multiplicity-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, AffinePlaneCurve{S}, Point{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"intersection_multiplicity","text":"intersection_multiplicity(C::AffinePlaneCurve{S}, D::AffinePlaneCurve{S}, P::Point{S}) where S <: FieldElem\n\nReturn the intersection multiplicity of C and D at P.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve((x^2+y^2)*(x^2 + y^2 + 2*y))\nAffine plane curve defined by x^4 + 2*x^2*y^2 + 2*x^2*y + y^4 + 2*y^3\n\njulia> D = Oscar.AffinePlaneCurve((x^2+y^2)*(y^3*x^6 - y^6*x^2))\nAffine plane curve defined by x^8*y^3 + x^6*y^5 - x^4*y^6 - x^2*y^8\n\njulia> Q = Oscar.Point([QQ(0), QQ(-2)])\nPoint with coordinates fmpq[0, -2]\n\njulia> Oscar.intersection_multiplicity(C, D, Q)\n2\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#intersection_multiplicity-Union{Tuple{S}, Tuple{ProjectivePlaneCurve{S}, ProjectivePlaneCurve{S}, Oscar.Geometry.ProjSpcElem{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"intersection_multiplicity","text":" intersection_multiplicity(C::ProjectivePlaneCurve{S}, D::ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\n\nReturn the intersection multiplicity of C and D at P.\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#aretransverse-Union{Tuple{S}, Tuple{AffinePlaneCurve{S}, AffinePlaneCurve{S}, Point{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"aretransverse","text":"aretransverse(C::AffinePlaneCurve{S}, D::AffinePlaneCurve{S}, P::Point{S}) where S<:FieldElem\n\nReturn true if C and D intersect transversally at P and false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> C = Oscar.AffinePlaneCurve(x*(x+y))\nAffine plane curve defined by x^2 + x*y\n\njulia> D = Oscar.AffinePlaneCurve((x-y)*(x-2))\nAffine plane curve defined by x^2 - x*y - 2*x + 2*y\n\njulia> P = Oscar.Point([QQ(0), QQ(0)])\nPoint with coordinates fmpq[0, 0]\n\njulia> Q = Oscar.Point([QQ(2), QQ(-2)])\nPoint with coordinates fmpq[2, -2]\n\njulia> Oscar.aretransverse(C, D, P)\nfalse\n\njulia> Oscar.aretransverse(C, D, Q)\ntrue\n\n\n\n","category":"method"},{"location":"Experimental/plane_curves/#aretransverse-Union{Tuple{S}, Tuple{ProjectivePlaneCurve{S}, ProjectivePlaneCurve{S}, Oscar.Geometry.ProjSpcElem{S}}} where S<:FieldElem","page":"Affine and Projective Plane Curves","title":"aretransverse","text":" aretransverse(C::ProjectivePlaneCurve{S}, D::ProjectivePlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S<:FieldElem\n\nReturn true if C and D intersect transversally at P and false otherwise.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"CurrentModule = Oscar","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"using Oscar","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"Pages = [\"divisors.md\"]","category":"page"},{"location":"Experimental/elliptic_curves/#Elliptic-Curves","page":"Elliptic Curves","title":"Elliptic Curves","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"An elliptic plane curve is a projective plane curve of degree 3 together with a point of the curve, called the base point. An operation of addition of points can be defined on elliptic curves.","category":"page"},{"location":"Experimental/elliptic_curves/#Constructor","page":"Elliptic Curves","title":"Constructor","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"An elliptic curve is a subtype of the abstract type ProjectivePlaneCurve. To define an elliptic curve over a field, one can either give as input an equation and the point at infinity, or just an equation in Weierstrass form. In the latter case, the point at infinity is (0  1  0).","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"Considering elliptic curves over a ring is helpful in some primality proving test. We introduce here a structure of elliptic curve over a ring. In that case, we always assume the equation to be in Weierstrass form, with infinity point (0  1  0).","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"ProjEllipticCurve","category":"page"},{"location":"Experimental/elliptic_curves/#ProjEllipticCurve","page":"Elliptic Curves","title":"ProjEllipticCurve","text":"ProjEllipticCurve{S}(eq::Oscar.MPolyElem_dec{S}) where {S <: FieldElem}\nProjEllipticCurve(eq::Oscar.MPolyElem_dec{S}, P::Oscar.Geometry.ProjSpcElem{S}) where {S <: FieldElem}\nProjEllipticCurve(eq::Oscar.MPolyElem_dec{S}) where {S <: Nemo.fmpz_mod}\n\nReturn the Projective Elliptic Curve defined by the equation eq, with P as infinity point. If no point is specified it is expected that eq is in Weierstrass form, and the infinity point is (0:1:0).\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> F = T(-x^3 - 3*x^2*y - 3*x*y^2 - x*z^2 - y^3 + y^2*z - y*z^2 - 4*z^3)\n-x^3 - 3*x^2*y - 3*x*y^2 - x*z^2 - y^3 + y^2*z - y*z^2 - 4*z^3\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(-1), QQ(1), QQ(0)])\n(-1 : 1 : 0)\n\njulia> E1 = Oscar.ProjEllipticCurve(F, P)\nProjective elliptic curve defined by -x^3 - 3*x^2*y - 3*x*y^2 - x*z^2 - y^3 + y^2*z - y*z^2 - 4*z^3\n\njulia> E2 = Oscar.ProjEllipticCurve(T(y^2*z - x^3 - x*z^2))\nProjective elliptic curve defined by -x^3 - x*z^2 + y^2*z\n\n\n\n","category":"type"},{"location":"Experimental/elliptic_curves/#Points-on-Elliptic-Curves","page":"Elliptic Curves","title":"Points on Elliptic Curves","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"We define a specific structure for the points on an elliptic curve, on which the operation of addition and multiplication by an integer are defined.","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"Point_EllCurve","category":"page"},{"location":"Experimental/elliptic_curves/#Point_EllCurve","page":"Elliptic Curves","title":"Point_EllCurve","text":"Point_EllCurve(E::ProjEllipticCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where {S <: FieldElem}\nPoint_EllCurve(E::ProjEllipticCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where {S <: Nemo.fmpz_mod}\n\nCreate the point P on the elliptic curve E.\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> E = Oscar.ProjEllipticCurve(T(y^2*z - x^3 + 2*x*z^2))\nProjective elliptic curve defined by -x^3 + 2*x*z^2 + y^2*z\n\njulia> PP = Oscar.proj_space(E)\nProjective space of dim 2 over Rational Field\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP, [QQ(2), QQ(2), QQ(1)])\n(2 : 2 : 1)\n\njulia> Q = Oscar.Point_EllCurve(E, P)\n(2 : 2 : 1)\n\n\n\n","category":"type"},{"location":"Experimental/elliptic_curves/#Methods","page":"Elliptic Curves","title":"Methods","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"Most of the functions described for projective plane curves are also available for elliptic curves over a field. We describe here the functions which are specific to elliptic curves.","category":"page"},{"location":"Experimental/elliptic_curves/#Basic-functions","page":"Elliptic Curves","title":"Basic functions","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"proj_space(E::ProjEllipticCurve{S}) where S <: FieldElem\nproj_space(P::Point_EllCurve{S}) where S <: FieldElem\ncurve(P::Point_EllCurve{S}) where S <: FieldElem","category":"page"},{"location":"Experimental/elliptic_curves/#proj_space-Union{Tuple{Oscar.PlaneCurveModule.ProjEllipticCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Elliptic Curves","title":"proj_space","text":"proj_space(E::ProjEllipticCurve{S}) where S <: FieldElem\n\nReturn the projective space to which the base point of the elliptic curve E belongs.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#proj_space-Union{Tuple{Oscar.PlaneCurveModule.Point_EllCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Elliptic Curves","title":"proj_space","text":"proj_space(P::Point_EllCurve{S}) where S <: FieldElem\n\nReturn the projective space to which the point P belongs.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#curve-Union{Tuple{Oscar.PlaneCurveModule.Point_EllCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Elliptic Curves","title":"curve","text":"curve(P::Point_EllCurve{S}) where S <: FieldElem\n\nReturn the curve on which the point P is considered.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"Addition and multiplication by an integer of a point on an elliptic curve can be performed using the usual symbols + and *.","category":"page"},{"location":"Experimental/elliptic_curves/#Example","page":"Elliptic Curves","title":"Example","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\nT, _ = grade(S)\nE = Oscar.ProjEllipticCurve(T(y^2*z - x^3 + 2*x*z^2))\nPP = Oscar.proj_space(E)\nP = Oscar.Geometry.ProjSpcElem(PP, [QQ(2), QQ(2), QQ(1)])\nQ = Oscar.Point_EllCurve(E, P)\nQ+Q\n3*Q","category":"page"},{"location":"Experimental/elliptic_curves/#Weierstrass-form","page":"Elliptic Curves","title":"Weierstrass form","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"weierstrass_form(E::ProjEllipticCurve{S}) where {S <: FieldElem}\ntoweierstrass(C::ProjPlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem","category":"page"},{"location":"Experimental/elliptic_curves/#weierstrass_form-Union{Tuple{Oscar.PlaneCurveModule.ProjEllipticCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Elliptic Curves","title":"weierstrass_form","text":"weierstrass_form(E::ProjEllipticCurve{S}) where {S <: FieldElem}\n\nReturn the equation of a projective elliptic curve defined by an equation in Weierstrass form and which is linearly equivalent to E.\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> F = T(-x^3 - 3*x^2*y - 3*x*y^2 - x*z^2 - y^3 + y^2*z - y*z^2 - 4*z^3)\n-x^3 - 3*x^2*y - 3*x*y^2 - x*z^2 - y^3 + y^2*z - y*z^2 - 4*z^3\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> P = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(-1), QQ(1), QQ(0)])\n(-1 : 1 : 0)\n\njulia> E = Oscar.ProjEllipticCurve(F, P)\nProjective elliptic curve defined by -x^3 - 3*x^2*y - 3*x*y^2 - x*z^2 - y^3 + y^2*z - y*z^2 - 4*z^3\n\njulia> Oscar.weierstrass_form(E)\n-x^3 - x*z^2 + y^2*z - 4*z^3\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#toweierstrass-Union{Tuple{S}, Tuple{ProjPlaneCurve{S}, Oscar.Geometry.ProjSpcElem{S}}} where S<:FieldElem","page":"Elliptic Curves","title":"toweierstrass","text":"toweierstrass(C::ProjPlaneCurve{S}, P::Oscar.Geometry.ProjSpcElem{S}) where S <: FieldElem\n\nGiven a smooth plane cubic projective curve C and a point P on the curve, return an elliptic curve birationally equivalent to C given by an equation in long Weierstrass form.\n\nExamples\n\njulia> S, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> T, _ = grade(S)\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> PP = proj_space(QQ, 2)\n(Projective space of dim 2 over Rational Field\n, MPolyElem_dec{fmpq, fmpq_mpoly}[x[0], x[1], x[2]])\n\njulia> Q = Oscar.Geometry.ProjSpcElem(PP[1], [QQ(-1), QQ(1), QQ(0)])\n(-1 : 1 : 0)\n\njulia> D = Oscar.ProjPlaneCurve(T(-x^3 - 3*x^2*y + 2*x^2*z - 3*x*y^2 + 3*x*y*z - 4*x*z^2 - y^3 - y*z^2 + 6*z^3))\nProjective plane curve defined by -x^3 - 3*x^2*y + 2*x^2*z - 3*x*y^2 + 3*x*y*z - 4*x*z^2 - y^3 - y*z^2 + 6*z^3\n\njulia> Oscar.toweierstrass(D, Q)\n-x^3 - 2*x^2*z + x*y*z - 4*x*z^2 + y^2*z + 3*y*z^2 - 6*z^3\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#Invariant-of-Elliptic-Curves,-torsion-points...","page":"Elliptic Curves","title":"Invariant of Elliptic Curves, torsion points...","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"discriminant(E::ProjEllipticCurve{S}) where S <: FieldElem\nj_invariant(E::ProjEllipticCurve{S}) where S <: FieldElem\nistorsion_point(P::Point_EllCurve{fmpq})\ntorsion_points_lutz_nagell(E::ProjEllipticCurve{fmpq})\ntorsion_points_division_poly(E::ProjEllipticCurve{fmpq})\norder(P::Point_EllCurve{fmpq})","category":"page"},{"location":"Experimental/elliptic_curves/#discriminant-Union{Tuple{Oscar.PlaneCurveModule.ProjEllipticCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Elliptic Curves","title":"discriminant","text":"discriminant(E::ProjEllipticCurve{S}) where S <: FieldElem\n\nReturn the discriminant of the projective elliptic curve E.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#j_invariant-Union{Tuple{Oscar.PlaneCurveModule.ProjEllipticCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Elliptic Curves","title":"j_invariant","text":"j_invariant(E::ProjEllipticCurve{S}) where S <: FieldElem\n\nReturn the j-invariant of the projective elliptic curve E.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#istorsion_point-Tuple{Oscar.PlaneCurveModule.Point_EllCurve{fmpq}}","page":"Elliptic Curves","title":"istorsion_point","text":"istorsion_point(P::Point_EllCurve{fmpq})\n\nReturn whether the point P is a torsion point.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#torsion_points_lutz_nagell-Tuple{Oscar.PlaneCurveModule.ProjEllipticCurve{fmpq}}","page":"Elliptic Curves","title":"torsion_points_lutz_nagell","text":"torsion_points_lutz_nagell(E::ProjEllipticCurve{fmpq})\n\nReturn the rational torsion points of the elliptic curve E using the Lutz-Nagell theorem.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#torsion_points_division_poly-Tuple{Oscar.PlaneCurveModule.ProjEllipticCurve{fmpq}}","page":"Elliptic Curves","title":"torsion_points_division_poly","text":"torsion_points_division_poly(E::ProjEllipticCurve{fmpq})\n\nReturn the rational torsion points of a rational elliptic curve E using division polynomials.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#order-Tuple{Oscar.PlaneCurveModule.Point_EllCurve{fmpq}}","page":"Elliptic Curves","title":"order","text":"order(P::Point_EllCurve{fmpq})\n\nReturn the order of the point P or 0 if the order is infinite.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"The following functions are implemented for elliptic curves over finite fields:","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"rand(E::ProjEllipticCurve{S}) where S <: FieldElem\nlist_rand(E::ProjEllipticCurve, N::Int)\norder(E::ProjEllipticCurve{S}) where S <: FieldElem","category":"page"},{"location":"Experimental/elliptic_curves/#rand-Union{Tuple{Oscar.PlaneCurveModule.ProjEllipticCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Elliptic Curves","title":"rand","text":"rand(E::ProjEllipticCurve{S}) where S <: FieldElem\n\nReturn a random point on the elliptic curve E defined over a finite field.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#list_rand-Tuple{Oscar.PlaneCurveModule.ProjEllipticCurve, Int64}","page":"Elliptic Curves","title":"list_rand","text":"list_rand(E::ProjEllipticCurve, N::Int)\n\nReturn a list of N random points on the elliptic curve E defined over a finite field.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#order-Union{Tuple{Oscar.PlaneCurveModule.ProjEllipticCurve{S}}, Tuple{S}} where S<:FieldElem","page":"Elliptic Curves","title":"order","text":"order(E::ProjEllipticCurve{S}) where S <: FieldElem\n\nGiven an elliptic curve E over a finite field mathbf F, computes E(mathbf F).\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"The addition of points is not well defined for projective elliptic curves over a ring, that's why this case has to be considered separately. The following methods can for example be used for teaching purposes to show the steps of the Elliptic Curve Method.","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"sum_Point_EllCurveZnZ(P::Point_EllCurve{S}, Q::Point_EllCurve{S}) where S <: Nemo.fmpz_mod\nIntMult_Point_EllCurveZnZ(m::fmpz, P::Point_EllCurve{S}) where S <: Nemo.fmpz_mod\nrand_pair_EllCurve_Point(R::Oscar.MPolyRing_dec{S}, PP::Oscar.Geometry.ProjSpc{S}) where S <: Nemo.fmpz_mod","category":"page"},{"location":"Experimental/elliptic_curves/#sum_Point_EllCurveZnZ-Union{Tuple{S}, Tuple{Oscar.PlaneCurveModule.Point_EllCurve{S}, Oscar.PlaneCurveModule.Point_EllCurve{S}}} where S<:fmpz_mod","page":"Elliptic Curves","title":"sum_Point_EllCurveZnZ","text":"sum_Point_EllCurveZnZ(P::Point_EllCurve{S}, Q::Point_EllCurve{S}) where S <: Nemo.fmpz_mod\n\nReturn, if possible, the sum of the points P and Q, and an error otherwise.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#IntMult_Point_EllCurveZnZ-Union{Tuple{S}, Tuple{fmpz, Oscar.PlaneCurveModule.Point_EllCurve{S}}} where S<:fmpz_mod","page":"Elliptic Curves","title":"IntMult_Point_EllCurveZnZ","text":"IntMult_Point_EllCurveZnZ(m::fmpz, P::Point_EllCurve{S}) where S <: Nemo.fmpz_mod\n\nReturn, if possible, the point mP, and an error otherwise.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#rand_pair_EllCurve_Point-Union{Tuple{S}, Tuple{MPolyRing_dec{S, S1} where S1, Oscar.Geometry.ProjSpc{S}}} where S<:fmpz_mod","page":"Elliptic Curves","title":"rand_pair_EllCurve_Point","text":"rand_pair_EllCurve_Point(R::Oscar.MPolyRing_dec{S}, PP::Oscar.Geometry.ProjSpc{S}) where S <: Nemo.fmpz_mod\n\nReturn a pair composed of an elliptic plane curve E with equation in R, and a point P on E.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#Primality-proving","page":"Elliptic Curves","title":"Primality proving","text":"","category":"section"},{"location":"Experimental/elliptic_curves/#Elliptic-Curve-Method","page":"Elliptic Curves","title":"Elliptic Curve Method","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"Projective elliptic curves over a ring are for example used in the Elliptic Curve Method. We give here an example (see Example 7.1 of Lawrence C. Washington (2008)) on how to use the previous functions to apply it. ","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"n = 4453\nA = ResidueRing(ZZ, ZZ(n))\nS, (x,y,z) = PolynomialRing(A, [\"x\", \"y\", \"z\"])\nT, _ = grade(S)\nE = Oscar.ProjEllipticCurve(T(y^2*z - x^3 - 10*x*z^2 + 2*z^3))\nPP = proj_space(A, 2)\nQ = Oscar.Geometry.ProjSpcElem(PP[1], [A(1), A(3), A(1)])\nP = Oscar.Point_EllCurve(E, Q)\nP2 = Oscar.IntMult_Point_EllCurveZnZ(ZZ(2), P)\nOscar.sum_Point_EllCurveZnZ(P, P2)","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"The last sum is not defined, and the error which is shown when we ask for the sum gives us a factor of 4453. The Elliptic Curve Method is implemented and can be called using:","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"ECM(n::fmpz; nbcurve::Int = 25000, multfact::fmpz = factorial(ZZ(10^4)))","category":"page"},{"location":"Experimental/elliptic_curves/#ECM-Tuple{fmpz}","page":"Elliptic Curves","title":"ECM","text":"ECM(n::fmpz; nbcurve::Int = 25000, multfact::fmpz = factorial(ZZ(10^4)))\n\nReturn a factor of n, obtained with the Elliptic Curve Method.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#Elliptic-Curve-Primality-Proving","page":"Elliptic Curves","title":"Elliptic Curve Primality Proving","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"Elliptic curves over finite fields or rings are used for the method called \"Elliptic Curve Primality Proving\". We implemented here the version relying on Atkin-Morain's test. The present implementation is not intended to be competitive.","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"ECPP(n::fmpz)","category":"page"},{"location":"Experimental/elliptic_curves/#ECPP-Tuple{fmpz}","page":"Elliptic Curves","title":"ECPP","text":"ECPP(n::fmpz)\n\nThe algorithm returns true if the number is prime, false if not, and an error if it can't decide.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#Other-algorithms","page":"Elliptic Curves","title":"Other algorithms","text":"","category":"section"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"TODO: The following algorithms are not directly related to Plane Curves, they might be moved to another section of the documentation.","category":"page"},{"location":"Experimental/elliptic_curves/","page":"Elliptic Curves","title":"Elliptic Curves","text":"cornacchia_algorithm(d::fmpz, m::fmpz)\nMiller_Rabin_test(N::fmpz, k::Int64 = 20)\nPollard_rho(N::fmpz, bound::Int = 50000)\nPollard_p_1(N::fmpz, B::fmpz = ZZ(10)^5)","category":"page"},{"location":"Experimental/elliptic_curves/#cornacchia_algorithm-Tuple{fmpz, fmpz}","page":"Elliptic Curves","title":"cornacchia_algorithm","text":"cornacchia_algorithm(d::fmpz, m::fmpz)\n\nReturn true and a solution of x^2 + d*y^2 = m if it exists, and false and (0, 0) otherwise.\n\n\n\n","category":"method"},{"location":"Experimental/elliptic_curves/#Miller_Rabin_test","page":"Elliptic Curves","title":"Miller_Rabin_test","text":"Miller_Rabin_test(N::fmpz, k::Int64 = 20)\n\nGiven an odd number N, return false if the number is composite, and true if it is probably prime.\n\n\n\n","category":"function"},{"location":"Experimental/elliptic_curves/#Pollard_rho","page":"Elliptic Curves","title":"Pollard_rho","text":"Pollard_rho(N::fmpz, bound::Int = 50000)\n\nThe algorithm computes a factor of N using the Pollard rho algorithm and returns it.\n\n\n\n","category":"function"},{"location":"Experimental/elliptic_curves/#Pollard_p_1","page":"Elliptic Curves","title":"Pollard_p_1","text":"Pollard_p_1(N::fmpz, B::fmpz = ZZ(10)^5)\n\nThe algorithm computes a factor of N and returns it.\n\n\n\n","category":"function"},{"location":"Hecke/misc/#Miscalleneous","page":"Miscalleneous","title":"Miscalleneous","text":"","category":"section"},{"location":"Hecke/misc/#Integer-related","page":"Miscalleneous","title":"Integer related","text":"","category":"section"},{"location":"Hecke/misc/","page":"Miscalleneous","title":"Miscalleneous","text":"euler_phi_inv\nHecke.modord(::fmpz, ::fmpz)\nHecke.isprime_power(::fmpz)\nHecke.primes_up_to(::Int)","category":"page"},{"location":"Hecke/misc/#euler_phi_inv","page":"Miscalleneous","title":"euler_phi_inv","text":"euler_phi_inv(n::Integer) -> Vector{fmpz}\n\nThe inverse of the Euler totient functions: find all x s.th. phi(x) = n holds.\n\n\n\neuler_phi_inv(n::fmpz) -> Vector{fmpz}\n\nThe inverse of the Euler totient functions: find all x s.th. phi(x) = n holds.\n\n\n\neuler_phi_inv(n::fmpz, zk::NfAbsOrd{AnticNumberField, nf_elem}) -> Vector{NfOrdIdl}\n\nThe inverse of the ideal totient function: all ideals A s.th. the unit group of the residue ring has the required size.\n\n\n\n","category":"function"},{"location":"Hecke/misc/#modord-Tuple{fmpz, fmpz}","page":"Miscalleneous","title":"modord","text":"modord(a::fmpz, m::fmpz) -> Int\nmodord(a::Integer, m::Integer)\n\nThe multiplicative order of a modulo m (not a good algorithm).\n\n\n\n","category":"method"},{"location":"Hecke/misc/#isprime_power-Tuple{fmpz}","page":"Miscalleneous","title":"isprime_power","text":"isprime_power(n::fmpz) -> Bool\nisprime_power(n::Integer) -> Bool\n\nTests if n is the exact power of a prime number.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#primes_up_to-Tuple{Int64}","page":"Miscalleneous","title":"primes_up_to","text":"primes_up_to(n::Int) -> Vector{Int}\n\nReturns a vector containing all the prime numbers up to n.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#Analytic","page":"Miscalleneous","title":"Analytic","text":"","category":"section"},{"location":"Hecke/misc/","page":"Miscalleneous","title":"Miscalleneous","text":"dickman_rho\nHecke.psi_guess\nHecke.psi_lower","category":"page"},{"location":"Hecke/misc/#dickman_rho","page":"Miscalleneous","title":"dickman_rho","text":"dickman_rho(x::Number, prec::Int=55) Number\n\nEvaluates the Dickman-rho function at x.\n\n\n\ndickman_rho(x::Number, e::UnitRange{Int}, prec::Int=55) Number[]\n\nEvaluates the Dickman-rho function at i*x for all iin e.\n\n\n\n","category":"function"},{"location":"Hecke/misc/#psi_guess","page":"Miscalleneous","title":"psi_guess","text":"psi_guess(x::Number, B::Int) Number\n\nUses the dickman_rho function to estimate psi(x B) the number of B-smooth integers bounded by x.\n\n\n\npsi_guess(x::Number, e::UnitRange, B::Int) Number\n\nUses the dickman_rho function to estimate psi(x^i B) the number of B-smooth integers bounded by x^i for i in e.\n\n\n\n","category":"function"},{"location":"Hecke/misc/#psi_lower","page":"Miscalleneous","title":"psi_lower","text":"psi_lower(N::Integer, B::Int, a::Int = 776) -> Vector{Int}, fmpz_abs_series\npsi_lower(N::fmpz, B::Int, a::Int = 776) -> Vector{Int}, fmpz_abs_series\n\nUses Bernstein's ideas: https://cr.yp.to/papers/psi.pdf to compute lower bounds on the psi function counting smooth numbers. An array L is returned s.th. psi(2^i-1 B) ge L_i for 1le ile rceil log_2(B)lceil. The second return value is Bernstein's power series.\n\nThe optional other parameter a controls the precision of the result, it defaults to 776.\n\n\n\npsi_lower(N::Integer, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series\npsi_lower(N::fmpz, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series\n\npsi_upper(N::Integer, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series\npsi_upper(N::fmpz, B::NfFactorBase) -> Vector{Int}, fmpz_abs_series\n\nUses Bernstein's techniques to bound the number of ideals A of norm bounded by N that are smooth over the factor base B.\n\n\n\n","category":"function"},{"location":"Hecke/misc/#Linear-Algebra","page":"Miscalleneous","title":"Linear Algebra","text":"","category":"section"},{"location":"Hecke/misc/","page":"Miscalleneous","title":"Miscalleneous","text":"Hecke.largest_elementary_divisor\nHecke.maximal_elementary_divisor(::fmpz_mat)\nHecke.mod_sym(::fmpz_mat, ::fmpz)\nHecke.mod_sym!(::fmpz_mat, ::fmpz)\nHecke.mod!(::fmpz_mat, ::fmpz)\nHecke.saturate(::fmpz_mat)\nHecke.elementary_divisors(::fmpz_mat)\nHecke.jordan_normal_form\nHecke.divisors(::fmpz_mat, ::fmpz)\nHecke.snf_with_transform(::fmpz_mat)","category":"page"},{"location":"Hecke/misc/#largest_elementary_divisor","page":"Miscalleneous","title":"largest_elementary_divisor","text":"largest_elementary_divisor(A::fmpz_mat) -> fmpz\n\nThe largest elementary divisor of A, that is, the last diagonal entry of the Smith normal form of A.\n\n\n\n","category":"function"},{"location":"Hecke/misc/#maximal_elementary_divisor-Tuple{fmpz_mat}","page":"Miscalleneous","title":"maximal_elementary_divisor","text":"maximal_elementary_divisor(A::fmpz_mat) -> fmpz\n\nThe largest elementary divisor of A, that is, the last diagonal entry of the Smith normal form of A.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#mod_sym-Tuple{fmpz_mat, fmpz}","page":"Miscalleneous","title":"mod_sym","text":"mod_sym(M::fmpz_mat, p::fmpz) -> fmpz_mat\n\nReduces every entry modulo p into the symmetric residue system.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#mod_sym!-Tuple{fmpz_mat, fmpz}","page":"Miscalleneous","title":"mod_sym!","text":"mod_sym!(M::fmpz_mat, p::fmpz)\n\nReduces every entry modulo p in-place, into the symmetric residue system.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#mod!-Tuple{fmpz_mat, fmpz}","page":"Miscalleneous","title":"mod!","text":"mod!(M::fmpz_mat, p::fmpz)\n\nReduces every entry modulo p in-place, i.e. applies the mod function to every entry. Positive residue system.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#saturate-Tuple{fmpz_mat}","page":"Miscalleneous","title":"saturate","text":"saturate(A::fmpz_mat) -> fmpz_mat\n\nComputes the saturation of A, that is, a basis for mathbfQotimes M cap mathbfZ^n, where M is the row span of A and n the number of rows of A.\n\nEquivalently, return TA for an invertible rational matrix T such that TA is integral and the elementary divisors of TA are all trivial.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#elementary_divisors-Tuple{fmpz_mat}","page":"Miscalleneous","title":"elementary_divisors","text":"elementary_divisors(A::fmpz_mat) -> Vector{fmpz}\n\nThe elementary divisors of A, that is, the diagonal entries of the Smith normal form of A.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#jordan_normal_form","page":"Miscalleneous","title":"jordan_normal_form","text":"jordan_normal_form(M::MatElem{T}) where T <: FieldElem -> MatElem{T}, MatElem{T}\n\nReturns matrices J and S such that J = SMS^-1 and J is in Jordan normal form.\n\n\n\n","category":"function"},{"location":"Hecke/misc/#divisors-Tuple{fmpz_mat, fmpz}","page":"Miscalleneous","title":"divisors","text":"divisors(A::fmpz_mat, d::fmpz) -> fmpz\n\nReturns the diagonal entries of a diagonal form of A. We assume that all the elementary divisors are divisors of d.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#snf_with_transform-Tuple{fmpz_mat}","page":"Miscalleneous","title":"snf_with_transform","text":"snf_with_transform(A)\n\nReturn the tuple S T U consisting of the Smith normal form S of A together with invertible matrices T and U such that TAU = S.\n\n\n\nsnf_with_transform(A::fmpz_mat, l::Bool = true, r::Bool = true) -> fmpz_mat, fmpz_mat, fmpz_mat\n\nGiven some integer matrix A, compute the Smith normal form (elementary divisor normal form) of A. If l and/ or r are true, then the corresponding left and/ or right transformation matrices are computed as well.\n\n\n\n","category":"method"},{"location":"Hecke/misc/#Polynomials","page":"Miscalleneous","title":"Polynomials","text":"","category":"section"},{"location":"Hecke/misc/#CRT","page":"Miscalleneous","title":"CRT","text":"","category":"section"},{"location":"Hecke/misc/","page":"Miscalleneous","title":"Miscalleneous","text":"induce_crt\nHecke.induce_rational_reconstruction","category":"page"},{"location":"Hecke/misc/#induce_crt","page":"Miscalleneous","title":"induce_crt","text":"induce_crt(a::fmpz_poly, p::fmpz, b::fmpz_poly, q::fmpz, signed::Bool = false) -> fmpz_poly\n\nGiven integral polynomials a and b as well as coprime integer moduli p and q, find f = a bmod p and f=b bmod q. If signed is set, the symmetric representative is used, the positive one otherwise.\n\n\n\ninduce_crt(L::Vector{PolyElem}, c::crt_env{fmpz}) -> fmpz_poly\n\nGiven fmpz_poly polynomials Li and a crt\\_env, apply the crt function to each coefficient resulting in a polynomial f = Li bmod pi.\n\n\n\ninduce_crt(L::Vector{MatElem}, c::crt_env{fmpz}) -> fmpz_mat\n\nGiven matrices Li and a crt\\_env, apply the crt function to each coefficient resulting in a matrix M = Li bmod pi.\n\n\n\ninduce_crt(a::Generic.Poly{nf_elem}, p::fmpz, b::Generic.Poly{nf_elem}, q::fmpz) -> Generic.Poly{nf_elem}, fmpz\n\nGiven polynomials a defined modulo p and b modulo q, apply the CRT to all coefficients recursively. Implicitly assumes that a and b have integral coefficients (i.e. no denominators).\n\n\n\n","category":"function"},{"location":"Hecke/misc/#induce_rational_reconstruction","page":"Miscalleneous","title":"induce_rational_reconstruction","text":"induce_rational_reconstruction(a::fmpz_poly, M::fmpz) -> fmpq_poly\n\nApply rational_reconstruction to each coefficient of a, resulting in either a fail (return (false, s.th.)) or (true, g) for some rational polynomial g s.th. g equiv a bmod M.\n\n\n\ninduce_rational_reconstruction(a::Generic.Poly{nf_elem}, M::fmpz) -> bool, Generic.Poly{nf_elem}\n\nApply rational reconstruction to the coefficients of a. Implicitly assumes the coefficients to be integral (no checks done) returns true iff this is successful for all coefficients.\n\n\n\n","category":"function"},{"location":"Hecke/number_fields/conventions/#Number-fields","page":"-","title":"Number fields","text":"","category":"section"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"By an absolute number field we mean finite extensions of mathbf Q, which is of type AnticNumberField and whose elements are of type nf_elem. Such an absolute number field K is always given in the form K = mathbf Q(alpha) = mathbf QX(f), where f in mathbf QX is an irreducible polynomial. See here for more information on the different types of fields supported.","category":"page"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"We call (1alphaalpha^2dotscalpha^d-1), where d is the degree K  mathbf Q the power basis of K. If beta is any element of K, then the representation matrix of beta is the matrix representing K to K gamma mapsto beta gamma with respect to the power basis, that is,","category":"page"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"beta cdot (1alphadotscalpha^d-1) = M_alpha (1 alpha dotsc alpha^d-1)","category":"page"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"Let (rs) be the signature of K, that is, K has r real embeddings sigma_i colon K to mathbfR, 1 leq i leq r, and 2s complex embeddings sigma_i colon K to mathbfC, 1 leq i leq 2s. In Hecke the complex embeddings are always ordered such that sigma_i = overlinesigma_i+s for r + 1 leq i leq r + s. The mathbfQ-linear function","category":"page"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"begingather*\n  K longrightarrow mathbf R^d \n  alpha longmapsto Bigl( sigma_1(alpha) dotsc sigma_r(alpha) sqrt2operatornameRebigl(sigma_r+1(alpha)bigr) sqrt2operatornameImbigl(sigma_r+1(alpha)bigr) dotsc sqrt2operatornameRebigl(sigma_r+s(alpha)bigr) sqrt2operatornameImbigl(sigma_r+s(alpha)bigr) Bigr)\nendgather*","category":"page"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"is called the Minkowski map (or Minkowski embedding).","category":"page"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"If K = mathbf Q(alpha) is an absolute number field, then an order mathcal O of K is a subring of the ring of integers mathcal O_K, which is free of rank  K  mathbf Q as a mathbf Z-module. The natural order mathbf Zalpha is called the equation order of K. In Hecke orders of absolute number fields are constructed (implicitely) by specifying a mathbf Z-basis, which is refered to as the basis of mathcal O. If (omega_1dotscomega_d) is the basis of mathcal O, then the matrix B in operatornameMat_d times d(mathbf Q) with","category":"page"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"is called the basis matrix of mathcal O. We call det(B) the generalized index of mathcal O.  In case mathbf Zalpha subseteq mathcal O, the determinant det(B)^-1 is in fact equal to  mathcal O  mathbf Zalpha and is called the index of mathcal O. The matrix","category":"page"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"beginpmatrix\nsigma_1(omega_1)  dotsc  sigma_r(omega_1)  sqrt2operatornameRe(sigma_r+1(omega_1))  sqrt2operatornameIm(sigma_r+1(omega_1))  dotsc  sqrt2operatornameIm(sigma_r+s(omega_1)) \nsigma_1(omega_2)  dotsc  sigma_r(omega_2)  sqrt2operatornameRe(sigma_r+1(omega_2))  sqrt2operatornameIm(sigma_r+1(omega_2))  dotsc   sqrt2operatornameIm(sigma_r+s(omega_2)) \nvdots  ddots  vdots  vdots  vdots  ddots  vdots\nsigma_1(omega_d)  dotsc  sigma_r(omega_d)  sqrt2operatornameRe(sigma_r+1(omega_d))  sqrt2operatornameIm(sigma_r+2(omega_d))  dotsc  sqrt2operatornameIm(sigma_r+s(omega_d))\nendpmatrix\nin operatornameMat_dtimes d(mathbf R)","category":"page"},{"location":"Hecke/number_fields/conventions/","page":"-","title":"-","text":"is called the Minkowski matrix of mathcal O.","category":"page"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"using Oscar","category":"page"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"Pages = [\"action.md\"]","category":"page"},{"location":"Groups/action/#Group-Actions","page":"Group Actions","title":"Group Actions","text":"","category":"section"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"A group action of a group G on a set Ω (from the right) is defined by a map μ: Ω × G → Ω that satisfies the compatibility conditions μ(μ(x, g), h) = μ(x, g*h) and μ(x, one(G)) == x for all x ∈ Ω.","category":"page"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"The maps μ are implemented as functions that take two arguments, an element x of Ω and a group element g, and return the image of x under g.","category":"page"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"In many cases, a natural action is given by the types of the elements in Ω and in G. For example permutation groups act on positive integers by just applying the permutations. In such situations, the function ^ can be used as action function, and ^ is taken as the default whenever no other function is prescribed.","category":"page"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"However, the action is not always determined by the types of the involved objects. For example, permutations can act on vectors of positive integers by applying the permutations pointwise, or by permuting the entries; matrices can act on vectors by multiplying the vector with the matrix, or by multiplying the inverse of the matrix with the vector; and of course one can construct new custom actions in situations where default actions are already available.","category":"page"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"Thus it is in general necessary to specify the action function explicitly, see the following sections.","category":"page"},{"location":"Groups/action/#Common-actions-of-group-elements","page":"Group Actions","title":"Common actions of group elements","text":"","category":"section"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"on_tuples\non_sets\npermuted\non_indeterminates","category":"page"},{"location":"Groups/action/#on_tuples","page":"Group Actions","title":"on_tuples","text":"on_tuples(tuple::GAP.GapObj, x::GAPGroupElem)\non_tuples(tuple::Vector{T}, x::GAPGroupElem) where T\non_tuples(tuple::T, x::GAPGroupElem) where T <: Tuple\n\nReturn the image of tuple under x, where the action is given by applying ^ to the entries of tuple.\n\nFor Vector and Tuple objects, one can also call ^ instead of on_tuples.\n\nExamples\n\njulia> g = symmetric_group(3);  g[1]\n(1,2,3)\n\njulia> l = GAP.GapObj([1, 2, 4])\nGAP: [ 1, 2, 4 ]\n\njulia> on_tuples(l, g[1])\nGAP: [ 2, 3, 4 ]\n\njulia> on_tuples([1, 2, 4], g[1])\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> on_tuples((1, 2, 4), g[1])\n(2, 3, 4)\n\njulia> (1, 2, 4)^g[1]\n(2, 3, 4)\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#on_sets","page":"Group Actions","title":"on_sets","text":"on_sets(set::GAP.GapObj, x::GAPGroupElem)\non_sets(set::Vector, x::GAPGroupElem)\non_sets(set::Tuple, x::GAPGroupElem)\non_sets(set::AbstractSet, x::GAPGroupElem)\n\nReturn the image of set under x, where the action is given by applying ^ to the entries of set, and then turning the result into a sorted vector/tuple or a set, respectively.\n\nFor Set objects, one can also call ^ instead of on_sets.\n\nExamples\n\njulia> g = symmetric_group(3);  g[1]\n(1,2,3)\n\njulia> l = GAP.GapObj([1,3])\nGAP: [ 1, 3 ]\n\njulia> on_sets(l, g[1])\nGAP: [ 1, 2 ]\n\njulia> on_sets([1, 3], g[1])\n2-element Vector{Int64}:\n 1\n 2\n\njulia> on_sets((1, 3), g[1])\n(1, 2)\n\njulia> on_sets(Set([1, 3]), g[1])\nSet{Int64} with 2 elements:\n  2\n  1\n\njulia> BitSet([1, 3])^g[1]\nBitSet with 2 elements:\n  1\n  2\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#permuted","page":"Group Actions","title":"permuted","text":"permuted(pnt::GAP.GapObj, x::PermGroupElem)\npermuted(pnt::Vector, x::PermGroupElem)\npermuted(pnt::Tuple, x::PermGroupElem)\n\nReturn the image of pnt under x, where the action is given by permuting the entries of pnt with x.\n\nExamples\n\njulia> g = symmetric_group(3);  g[1]\n(1,2,3)\n\njulia> a = [\"a\", \"b\", \"c\"]\n3-element Vector{String}:\n \"a\"\n \"b\"\n \"c\"\n\njulia> permuted(a, g[1])\n3-element Vector{String}:\n \"c\"\n \"a\"\n \"b\"\n\njulia> permuted((\"a\", \"b\", \"c\"), g[1])\n(\"c\", \"a\", \"b\")\n\njulia> l = GAP.GapObj(a, recursive = true)\nGAP: [ \"a\", \"b\", \"c\" ]\n\njulia> permuted(l, g[1])\nGAP: [ \"c\", \"a\", \"b\" ]\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#on_indeterminates","page":"Group Actions","title":"on_indeterminates","text":"on_indeterminates(f::GAP.GapObj, p::PermGroupElem)\non_indeterminates(f::Nemo.MPolyElem, p::PermGroupElem)\n\nReturn the image of f under p, w.r.t. permuting the indeterminates with p.\n\nFor Nemo.MPolyElem objects, one can also call ^ instead of on_indeterminates.\n\nExamples\n\njulia> g = symmetric_group(3);  p = g[1]\n(1,2,3)\n\njulia> R, x = PolynomialRing(QQ, [\"x1\", \"x2\", \"x3\"]);\n\njulia> f = x[1]*x[2] + x[2]*x[3]\nx1*x2 + x2*x3\n\njulia> f^p\nx1*x3 + x2*x3\n\njulia> x = [GAP.Globals.X( GAP.Globals.Rationals, i ) for i in 1:3];\n\njulia> f = x[1]*x[2] + x[2]*x[3]\nGAP: x_1*x_2+x_2*x_3\n\njulia> on_indeterminates(f, p)\nGAP: x_1*x_3+x_2*x_3\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/action/#Stabilizers","page":"Group Actions","title":"Stabilizers","text":"","category":"section"},{"location":"Groups/action/","page":"Group Actions","title":"Group Actions","text":"stabilizer(G::Oscar.GAPGroup, pnt::Any, actfun::Function)","category":"page"},{"location":"Groups/action/#stabilizer-Tuple{Oscar.GAPGroup, Any, Function}","page":"Group Actions","title":"stabilizer","text":"stabilizer(G::Oscar.GAPGroup, pnt::Any[, actfun::Function])\n\nReturn the subgroup of G that consists of all those elements g that fix pnt under the action given by actfun, that is, actfun(pnt, g) == pnt holds.\n\nThe default for actfun depends on the types of G and pnt: If G is a PermGroup then the default actions on integers, Vectors of  integers, and Sets of integers are given by ^, on_tuples, and on_sets, respectively. If G is a MatrixGroup then the default actions on FreeModuleElems, Vectors of them, and Sets of them are given by *, on_tuples, and on_sets, respectively.\n\nExamples\n\njulia> G = symmetric_group(5);\n\njulia> S = stabilizer(G, 1);  order(S[1])\n24\n\njulia> S = stabilizer(G, [1, 2]);  order(S[1])\n6\n\njulia> S = stabilizer(G, Set([1, 2]));  order(S[1])\n12\n\njulia> S = stabilizer(G, [1,1,2,2,3], permuted);  order(S[1])\n4\n\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"CurrentModule = Oscar","category":"page"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"Pages = [\"CohomologyClasses.md\"]","category":"page"},{"location":"ToricVarieties/CohomologyClasses/#Cohomology-Classes","page":"Cohomology Classes","title":"Cohomology Classes","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/#Constructors","page":"Cohomology Classes","title":"Constructors","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/#Generic-constructors","page":"Cohomology Classes","title":"Generic constructors","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"CohomologyClass(d::ToricDivisor)\nCohomologyClass(c::ToricDivisorClass)\nCohomologyClass(l::ToricLineBundle)","category":"page"},{"location":"ToricVarieties/CohomologyClasses/#CohomologyClass-Tuple{ToricDivisor}","page":"Cohomology Classes","title":"CohomologyClass","text":"CohomologyClass(d::ToricDivisor)\n\nConstruct the toric cohomology class corresponding to the toric divisor d.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> d = ToricDivisor(P2, [1,2,3])\nA torus-invariant, non-prime divisor on a normal toric variety\n\njulia> CohomologyClass(d)\nA cohomology class on a normal toric variety given by 6*x3\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#CohomologyClass-Tuple{ToricDivisorClass}","page":"Cohomology Classes","title":"CohomologyClass","text":"CohomologyClass(c::ToricDivisorClass)\n\nConstruct the toric cohomology class corresponding to the toric divisor class c.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> tdc = ToricDivisorClass(P2, [2])\nA divisor class on a normal toric variety\n\njulia> CohomologyClass(tdc)\nA cohomology class on a normal toric variety given by 2*x3\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#CohomologyClass-Tuple{ToricLineBundle}","page":"Cohomology Classes","title":"CohomologyClass","text":"CohomologyClass(l::ToricLineBundle)\n\nConstruct the toric cohomology class corresponding to the toric line bundle l.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(P2, [2])\nA toric line bundle on a normal toric variety\n\njulia> polynomial(CohomologyClass(l))\n2*x3\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#Addition,-subtraction-and-scalar-multiplication","page":"Cohomology Classes","title":"Addition, subtraction and scalar multiplication","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"Addition of cohomology classes cc1 and cc2 is implemented by cc1+cc2. Similarly, we can subtract the classes by cc1-cc2. Scalar multiplication with c (this could be an integer, fmpz or even fmpq number) is supported by c*cc1.","category":"page"},{"location":"ToricVarieties/CohomologyClasses/#Wedge-product","page":"Cohomology Classes","title":"Wedge product","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"The wedge product of cohomology classes cc1 and cc2 is computed by cc1*cc2. This makes sense, since cohomology classes on toric varieties are elements of the cohomology ring, which in turn is (a certain) quotient of the Cox ring. Hence, internally, a cohomology class is just a polynomial in this ring and the wedge product corresponds to the product of two (equivalence classes of) polynomials. We also support cc1^n, which corresponds to computing the wedge product of cc1 with itself n-times.","category":"page"},{"location":"ToricVarieties/CohomologyClasses/#Equality","page":"Cohomology Classes","title":"Equality","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"Equality of cohomology classes cc1 and cc2 is implemented by cc1 == cc2.","category":"page"},{"location":"ToricVarieties/CohomologyClasses/#Properties","page":"Cohomology Classes","title":"Properties","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"To check if a cohomology class c is trivial, one can invoke istrivial(c).","category":"page"},{"location":"ToricVarieties/CohomologyClasses/#Attributes","page":"Cohomology Classes","title":"Attributes","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"toric_variety(c::CohomologyClass)\ncoefficients(c::CohomologyClass)\nexponents(c::CohomologyClass)\npolynomial(c::CohomologyClass)\npolynomial(c::CohomologyClass, ring::MPolyQuo)","category":"page"},{"location":"ToricVarieties/CohomologyClasses/#toric_variety-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"toric_variety","text":"toric_variety(c::CohomologyClass)\n\nReturn the normal toric variety of the cohomology class c.\n\nExamples\n\njulia> dP2 = del_pezzo(2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> d = ToricDivisor(dP2, [1,2,3,4,5])\nA torus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = CohomologyClass(d)\nA cohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> toric_variety(cc)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety over QQ without torusfactor\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#coefficients-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"coefficients","text":"coefficients(c::CohomologyClass)\n\nReturn the coefficients of the cohomology class c.\n\nExamples\n\njulia> dP2 = del_pezzo(2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> d = ToricDivisor(dP2, [1,2,3,4,5])\nA torus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = CohomologyClass(d)\nA cohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> coefficients(cc)\n3-element Vector{fmpq}:\n 6\n 1\n 7\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#exponents-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"exponents","text":"exponents(c::CohomologyClass)\n\nReturn the exponents of the cohomology class c.\n\nExamples\n\njulia> dP2 = del_pezzo(2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> d = ToricDivisor(dP2, [1,2,3,4,5])\nA torus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = CohomologyClass(d)\nA cohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> exponents(cc)\n[0   0   1   0   0]\n[0   0   0   1   0]\n[0   0   0   0   1]\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#polynomial-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"polynomial","text":"polynomial(c::CohomologyClass)\n\nReturn the polynomial in the cohomology ring of the normal toric variety toric_variety(c) which corresponds to c.\n\nExamples\n\njulia> dP2 = del_pezzo(2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> d = ToricDivisor(dP2, [1,2,3,4,5])\nA torus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = CohomologyClass(d)\nA cohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> polynomial(cc)\n6*x3 + e1 + 7*e2\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#polynomial-Tuple{CohomologyClass, MPolyQuo}","page":"Cohomology Classes","title":"polynomial","text":"polynomial(c::CohomologyClass, ring::MPolyQuo)\n\nReturns the polynomial in ring corresponding to the cohomology class c.\n\nExamples\n\njulia> dP2 = del_pezzo(2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> d = ToricDivisor(dP2, [1,2,3,4,5])\nA torus-invariant, non-prime divisor on a normal toric variety\n\njulia> cc = CohomologyClass(d)\nA cohomology class on a normal toric variety given by 6*x3 + e1 + 7*e2\n\njulia> R, _ = PolynomialRing(QQ, 5)\n(Multivariate Polynomial Ring in x1, x2, x3, x4, x5 over Rational Field, fmpq_mpoly[x1, x2, x3, x4, x5])\n\njulia> (x1,x2,x3,x4,x5) = gens(R)\n5-element Vector{fmpq_mpoly}:\n x1\n x2\n x3\n x4\n x5\n\njulia> sr_and_linear_relation_ideal = ideal([x1*x3, x1*x5, x2*x4, x2*x5, x3*x4, x1 + x2 - x5, x2 + x3 - x4 - x5])\nideal(x1*x3, x1*x5, x2*x4, x2*x5, x3*x4, x1 + x2 - x5, x2 + x3 - x4 - x5)\n\njulia> R_quo = quo(R, sr_and_linear_relation_ideal)[1]\nQuotient of Multivariate Polynomial Ring in x1, x2, x3, x4, x5 over Rational Field by ideal(x1*x3, x1*x5, x2*x4, x2*x5, x3*x4, x1 + x2 - x5, x2 + x3 - x4 - x5)\n\njulia> polynomial(cc, R_quo)\n6*x3 + x4 + 7*x5\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#Methods","page":"Cohomology Classes","title":"Methods","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"integrate(c::CohomologyClass)","category":"page"},{"location":"ToricVarieties/CohomologyClasses/#integrate-Tuple{CohomologyClass}","page":"Cohomology Classes","title":"integrate","text":"integrate(c::CohomologyClass)\n\nIntegrate the cohomolgy class c over the normal toric variety toric_variety(c).\n\nExamples\n\njulia> dP3 = del_pezzo(3)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> (x1,x2,x3,e1,e2,e3) = gens(cohomology_ring(dP3))\n6-element Vector{MPolyQuoElem{MPolyElem_dec{fmpq, fmpq_mpoly}}}:\n x1\n x2\n x3\n e1\n e2\n e3\n\njulia> c = CohomologyClass(dP3, e3*e3 + e3)\nA cohomology class on a normal toric variety given by e3^2 + e3\n\njulia> integrate(c)\n-1\n\njulia> F3 = hirzebruch_surface(3)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> (x1,x2,x3,x4) = gens(cohomology_ring(F3))\n4-element Vector{MPolyQuoElem{MPolyElem_dec{fmpq, fmpq_mpoly}}}:\n t1\n x1\n t2\n x2\n\njulia> c = CohomologyClass(F3, x1*x2 + x3*x4)\nA cohomology class on a normal toric variety given by 2//3*x2^2\n\njulia> integrate(c)\n2\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#Special-attributes-of-toric-varieties","page":"Cohomology Classes","title":"Special attributes of toric varieties","text":"","category":"section"},{"location":"ToricVarieties/CohomologyClasses/","page":"Cohomology Classes","title":"Cohomology Classes","text":"cohomology_ring(v::AbstractNormalToricVariety)\nvolume_form(v::NormalToricVariety)\nintersection_form(v::NormalToricVariety)","category":"page"},{"location":"ToricVarieties/CohomologyClasses/#cohomology_ring-Tuple{Oscar.AbstractNormalToricVariety}","page":"Cohomology Classes","title":"cohomology_ring","text":"cohomology_ring(v::AbstractNormalToricVariety)\n\nReturn the cohomology ring of the simplicial and complete toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> ngens(cohomology_ring(p2))\n3\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#volume_form-Tuple{NormalToricVariety}","page":"Cohomology Classes","title":"volume_form","text":"volume_form(v::NormalToricVariety)\n\nConstruct the volume form of the normal toric toric variety v.\n\nExamples\n\njulia> polynomial(volume_form(projective_space(NormalToricVariety, 2)))\nx3^2\n\njulia> polynomial(volume_form(del_pezzo(3)))\n-e3^2\n\njulia> polynomial(volume_form(hirzebruch_surface(5)))\n1//5*x2^2\n\n\n\n","category":"method"},{"location":"ToricVarieties/CohomologyClasses/#intersection_form-Tuple{NormalToricVariety}","page":"Cohomology Classes","title":"intersection_form","text":"intersection_form(v::NormalToricVariety)\n\nComputes the intersection numbers among the cohomology classes associated to the torusinvariant prime divisors of the normal toric toric variety v.\n\nExamples\n\njulia> F3 = hirzebruch_surface(3)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> length(intersection_form(F3))\n10\n\n\n\n","category":"method"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"NumberTheory/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"The number theory part of OSCAR provides functionality for algebraic number theory.","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"It is under development with regard to providing both the functionality and the documentation. ","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"NumberTheory/intro/","page":"Introduction","title":"Introduction","text":"Henri Cohen (1993)\nHenri Cohen (2000)\nDaniel A. Marcus (2018)\nM. Pohst, H. Zassenhaus (1997)","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Ring-Interface","page":"Ring Interface","title":"Ring Interface","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"AbstractAlgebra.jl generic code makes use of a standardised set of functions which it expects to be implemented for all rings. Here we document this interface. All libraries which want to make use of the generic capabilities of AbstractAlgebra.jl must supply all of the required functionality for their rings.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"In addition to the required functions, there are also optional functions which can be provided for certain types of rings, e.g. GCD domains or fields, etc. If implemented, these allow the generic code to provide additional functionality for those rings, or in some cases, to select more efficient algorithms.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Types","page":"Ring Interface","title":"Types","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Most rings must supply two types:","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"a type for the parent object (representing the ring itself)\na type for elements of that ring","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For example, the generic univariate polynomial type in AbstractAlgebra.jl provides two types in generic/GenericTypes.jl:","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Generic.PolyRing{T} for the parent objects\nGeneric.Poly{T} for the actual polynomials","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"The parent type must belong to Ring and the element type must belong to RingElem. Of course, the types may belong to these abstract types transitively, e.g. Poly{T} actually belongs to PolyElem{T} which in turn belongs to RingElem.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For parameterised rings, we advise that the types of both the parent objects and element objects to be parameterised by the types of the elements of the base ring (see the function base_ring below for a definition).","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"There can be variations on this theme: e.g. in some areas of mathematics there is a notion of a coefficient domain, in which case it may make sense to parameterise all types by the type of elements of this coefficient domain. But note that this may have implications for the ad hoc operators one might like to explicitly implement.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#RingElement-type-union","page":"Ring Interface","title":"RingElement type union","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Because of its lack of multiple inheritance, Julia does not allow Julia Base types to belong to RingElem. To allow us to work equally with AbstractAlgebra and Julia types that represent elements of rings we define a union type RingElement in src/julia/JuliaTypes.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"So far, in addition to RingElem the  union type RingElement includes the Julia types Integer, Rational and AbstractFloat.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Most of the generic code in AbstractAlgebra makes use of the union type RingElement instead of RingElem so that the generic functions also accept the Julia Base ring types.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"note: Note\nOne must be careful when defining ad hoc binary operations for ring element types. It is often necessary to define separate versions of the functions for RingElem then for each of the Julia types separately in order to avoid ambiguity warnings.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Note that even though RingElement is a union type we still have the following inclusion","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"RingElement <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Parent-object-caches","page":"Ring Interface","title":"Parent object caches","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"In many cases, it is desirable to have only one object in the system to represent each ring. This means that if the same ring is constructed twice, elements of the two rings will be compatible as far as arithmetic is concerned.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"In order to facilitate this, global caches of rings are stored in AbstractAlgebra.jl, usually implemented using dictionaries. For example, the Generic.PolyRing parent objects are looked up in a dictionary PolyID to see if they have been previously defined.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Whether these global caches are provided or not, depends on both mathematical and algorithmic considerations. E.g. in the case of number fields, it isn't desirable to identify all number fields with the same defining polynomial, as they may be considered with distinct embeddings into one another. In other cases, identifying whether two rings are the same may be prohibitively expensive. Generally, it may only make sense algorithmically to identify two rings if they were constructed from identical data.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"If a global cache is provided, it must be optionally possible to construct the parent objects without caching. This is done by passing a boolean value cached to the inner constructor of the parent object. See generic/GenericTypes.jl for examples of how to construct and handle such caches.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Required-functions-for-all-rings","page":"Ring Interface","title":"Required functions for all rings","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"In the following, we list all the functions that are required to be provided for rings in AbstractAlgebra.jl or by external libraries wanting to use AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"We give this interface for fictitious types MyParent for the type of the ring parent object R and MyElem for the type of the elements of the ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"note: Note\nGeneric functions in AbstractAlgebra.jl may not rely on the existence of functions that are not documented here. If they do, those functions will only be available for rings that implement that additional functionality, and should be documented as such.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Data-type-and-parent-object-methods","page":"Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"parent_type(::Type{MyElem})","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return the type of the corresponding parent object for the given element type. For example, parent_type(Generic.Poly{T}) will return Generic.PolyRing{T}.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"elem_type(::Type{MyParent})","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return the type of the elements of the ring whose parent object has the given type. This is the inverse of the parent_type function, i.e. elem_type(Generic.PolyRing{T}) will return Generic.Poly{T}.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"base_ring(R::MyParent)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Given a parent object R, representing a ring, this function returns the parent object of any base ring that parameterises this ring. For example, the base ring of the ring of polynomials over the integers would be the integer ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"If the ring is not parameterised by another ring, this function must return Union{}.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"note: Note\nThere is a distinction between a base ring and other kinds of parameters. For example, in the ring mathbbZnmathbbZ, the modulus n is a parameter, but the only base ring is mathbbZ. We consider the ring mathbbZnmathbbZ to have been constructed from the base ring mathbbZ by taking its quotient by a (principal) ideal.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"parent(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return the parent object of the given element, i.e. return the ring to which the given element belongs.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"This is usually stored in a field parent in each ring element. (If the parent objects have mutable struct types, the internal overhead here is just an additional machine pointer stored in each element of the ring.)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For some element types it isn't necessary to append the parent object as a field of every element. This is the case when the parent object can be reconstructed just given the type of the elements. For example, this is the case for the ring of integers and in fact for any ring element type that isn't parameterised or generic in any way.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"isdomain_type(::Type{MyElem})","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return true if every element of the given element type (which may be parameterised or an abstract type) necessarily has a parent that is an integral domain, otherwise if this cannot be guaranteed, the function returns false.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For example, if MyElem was the type of elements of generic residue rings of a polynomial ring, the answer to the question would depend on the modulus of the residue ring. Therefore isdomain_type would have to return false, since we cannot guarantee that we are dealing with elements of an integral domain in general. But if the given element type was for rational integers, the answer would be true, since every rational integer has as parent the ring of rational integers, which is an integral domain.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Note that this function depends only on the type of an element and cannot access information about the object itself, or its parent.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"isexact_type(::Type{MyElem})","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return true if every element of the given type is represented exactly. For example, p-adic numbers, real and complex floating point numbers and power series are not exact, as we can only represent them in general with finite truncations. Similarly polynomials and matrices over inexact element types are themselves inexact.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Integers, rationals, finite fields and polynomials and matrices over them are always exact.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Note that MyElem may be parameterised or an abstract type, in which case every element of every type represented by MyElem must be exact, otherwise the function must return false.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Base.hash(f::MyElem, h::UInt)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return a hash for the object f of type UInt. This is used as a hopefully cheap way to distinguish objects that differ arithmetically.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"If the object has components, e.g. the coefficients of a polynomial or elements of a matrix, these should be hashed recursively, passing the same parameter h to all levels. Each component should then be xor'd with h before combining the individual component hashes to give the final hash.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"The hash functions in AbstractAlgebra.jl usually start from some fixed 64 bit hexadecimal  value that has been picked at random by the library author for that type. That is then truncated to fit a UInt (in case the latter is not 64 bits). This ensures that objects that are the same arithmetically (or that have the same components), but have different types (or structures), are unlikely to hash to the same value.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"deepcopy_internal(f::MyElem, dict::ObjectIdDict)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return a copy of the given element, recursively copying all components of the object.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Obviously the parent, if it is stored in the element, should not be copied. The new element should have precisely the same parent as the old object.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For types that cannot self-reference themselves anywhere internally, the dict argument may be ignored.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"In the case that internal self-references are possible, please consult the Julia documentation on how to implement deepcopy_internal.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Constructors","page":"Ring Interface","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Outer constructors for most AbstractAlgebra types are provided by overloading the call syntax for parent objects.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"If R is a parent object for a given ring we provide the following constructors.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"(R::MyParent)()","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return the zero object of the given ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"(R::MyParent)(a::Integer)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Coerce the given integer into the given ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"(R::MyParent)(a::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"If a belongs to the given ring, the function returns it (without making a copy). Otherwise an error is thrown.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For parameterised rings we also require a function to coerce from the base ring into the parent ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"(R::MyParent{T})(a::T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Coerce a into the ring R if a belongs to the base ring of R.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Basic-manipulation-of-rings-and-elements","page":"Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"zero(R::MyParent)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return the zero element of the given ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"one(R::MyParent)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return the multiplicative identity of the given ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"iszero(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return true if the given element is the zero element of the ring it belongs to.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"isone(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return true if the given element is the multiplicative identity of the ring it belongs to.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Canonicalisation","page":"Ring Interface","title":"Canonicalisation","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"canonical_unit(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"When fractions are created with two elements of the given type, it is nice to be able to represent them in some kind of canonical form. This is of course not always possible. But for example, fractions of integers can be canonicalised by first removing any common factors of the numerator and denominator, then making the denominator positive.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"In AbstractAlgebra.jl, the denominator would be made positive by dividing both the numerator and denominator by the canonical unit of the denominator. For a negative denominator, this would be -1.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For elements of a field, canonical_unit simply returns the element itself. In general, canonical_unit of an invertible element should be that element. Finally, if a = ub we should have the identity canonical_unit(a) = canonical_unit(u)*canonical_unit(b).","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For some rings, it is completely impractical to implement this function, in which case it may return 1 in the given ring. The function must however always exist, and always return an element of the ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#String-I/O","page":"Ring Interface","title":"String I/O","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"show(io::IO, R::MyParent)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"This should print an English description of the parent ring (to the given IO object). If the ring is parameterised, it can call the corresponding show function for any rings it depends on.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"show(io::IO, f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"This should print a human readable, textual representation of the object (to the given IO object). It can recursively call the corresponding show functions for any of its components.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Expressions","page":"Ring Interface","title":"Expressions","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"To obtain best results when printing composed types derived from other types, e.g., polynomials, the following method should be implemented.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"expressify(f::MyElem; context = nothing)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"which must return either Expr, Symbol, Integer or String.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For a type which implements  expressify, one can automatically derive show methods supporting output as plain text, LaTeX and html by using the following:","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"@enable_all_show_via_expressify MyElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"This defines the following show methods for the specified type MyElem:","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"function Base.show(io::IO, a::MyElem)\n  show_via_expressify(io, a)\nend\n\nfunction Base.show(io::IO, mi::MIME\"text/plain\", a::MyElem)\n  show_via_expressify(io, mi, a)\nend\n\nfunction Base.show(io::IO, mi::MIME\"text/latex\", a::MyElem)\n  show_via_expressify(io, mi, a)\nend\n\nfunction Base.show(io::IO, mi::MIME\"text/html\", a::MyElem)\n  show_via_expressify(io, mi, a)\nend","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"As an example, assume that an object f of type MyElem has two components f.a and f.b of integer type, which should be printed as a^b, this can be implemented as","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"expressify(f::MyElem; context = nothing) = Expr(:call, :^, f.a, f.b)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"If f.a and f.b themselves are objects that can be expressified, this can be implemented as","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"function expressify(f::MyElem; context = nothing)\n  return Expr(:call, :^, expressify(f.a, context = context),\n                         expressify(f.b, context = context))\nend","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"As noted above, expressify should return an Expr, Symbol, Integer or String. The rendering of such expressions with a particular MIME type to an output context is controlled by the following rules which are subject to change slightly in future versions of AbstracAlgebra.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Integer: The printing of integers is straightforward and automatically includes transformations such as 1 + (-2)*x => 1 - 2*x as this is cumbersome to implement per-type.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Symbol: Since variable names are stored as mere symbols in AbstractAlgebra, some transformations related to subscripts are applied to symbols automatically in latex output. The \\operatorname{ in the following table is actually replaced with the more portable \\mathop{\\mathrm{.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"expressify latex output\nSymbol(\"a\") a\nSymbol(\"α\") {\\alpha}\nSymbol(\"x1\") \\operatorname{x1}\nSymbol(\"xy_1\") \\operatorname{xy}_{1}\nSymbol(\"sin\") \\operatorname{sin}\nSymbol(\"sin_cos\") \\operatorname{sin\\_cos}\nSymbol(\"sin_1\") \\operatorname{sin}_{1}\nSymbol(\"sin_cos_1\") \\operatorname{sin\\_cos}_{1}\nSymbol(\"αaβb_1_2\") \\operatorname{{\\alpha}a{\\beta}b}_{1,2}","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Expr: These are the most versatile as the Expr objects themselves contain a symbolic head and any number of arguments. What looks like f(a,b) in textual output is Expr(:call, :f, :a, :b) under the hood. AbstractAlgebra currently contains the following printing rules for such expressions.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"expressify output latex notes\nExpr(:call, :+, a, b) a + b \nExpr(:call, :*, a, b) a*b one space for implied multiplication\nExpr(:call, :cdot, a, b) a * b a real \\cdot is used\nExpr(:call, :^, a, b) a^b may include some courtesy parentheses\nExpr(:call, ://, a, b) a//b will create a fraction box\nExpr(:call, :/, a, b) a/b will not create a fraction box\nExpr(:call, a, b, c) a(b, c) \nExpr(:ref, a, b, c) a[b, c] \nExpr(:vcat, a, b) [a; b] actually vertical\nExpr(:vect, a, b) [a, b] \nExpr(:tuple, a, b) (a, b) \nExpr(:list, a, b) {a, b} \nExpr(:series, a, b) a, b \nExpr(:sequence, a, b) ab \nExpr(:row, a, b) a b combine with :vcat to make matrices\nExpr(:hcat, a, b) a b ","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"String: Strings are printed verbatim and should only be used as a last resort as they provide absolutely no precedence information on their contents.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Unary-operations","page":"Ring Interface","title":"Unary operations","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"-(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return -f.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Binary-operations","page":"Ring Interface","title":"Binary operations","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"+(f::MyElem, g::MyElem)\n-(f::MyElem, g::MyElem)\n*(f::MyElem, g::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return f + g, f - g or fg, respectively.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Comparison","page":"Ring Interface","title":"Comparison","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"==(f::MyElem, g::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return true if f and g are arithmetically equal. In the case where the two elements are inexact, the function returns true if they agree to the minimum precision of the two.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"isequal(f::MyElem, g::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For exact rings, this should return the same thing as == above. For inexact rings, this returns true only if the two elements are arithmetically equal and have the same precision.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Powering","page":"Ring Interface","title":"Powering","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"^(f::MyElem, e::Int)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return f^e. The function should throw a DomainError() if negative exponents don't make sense but are passed to the function.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Exact-division","page":"Ring Interface","title":"Exact division","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"divexact(f::MyElem, g::MyElem; check::Bool=true)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return fg, though note that Julia uses / for floating point division. Here we mean exact division in the ring, i.e. return q such that f = gq. A DivideError() should be thrown if g is zero.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"If check=true the function should check that the division is exact and throw an exception if not.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"If check=false the check may be omitted for performance reasons. The behaviour is then undefined if a division is performed that is not exact. This may include throwing an exception, returning meaningless results, hanging or crashing. The function should only be called with check=false if it is already known that the division will be exact.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Inverse","page":"Ring Interface","title":"Inverse","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"inv(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return the inverse of f, i.e. 1f, though note that Julia uses / for floating point division. Here we mean exact division in the ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"A fallback for this function is provided in terms of divexact so an implementation can be omitted if preferred.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Unsafe-operators","page":"Ring Interface","title":"Unsafe operators","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"To speed up polynomial and matrix arithmetic, it sometimes makes sense to mutate values in place rather than replace them with a newly created object every time they are modified.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For this purpose, certain mutating operators are required. In order to support immutable types (struct in Julia) and systems that don't have in-place operators, all unsafe operators must return the (ostensibly) mutated value. Only the returned value is used in computations, so this lifts the requirement that the unsafe operators actually mutate the value.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Note the exclamation point is a convention, which indicates that the object may be mutated in-place.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"To make use of these functions, one must be certain that no other references are held to the object being mutated, otherwise those values will also be changed!","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"The results of deepcopy and all arithmetic operations, including powering and division can be assumed to be new objects without other references being held, as can objects returned from constructors.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"note: Note\nIt is important to recognise that R(a) where R is the ring a belongs to, does not create a new value. For this case, use deepcopy(a).","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"zero!(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Set the value f to zero in place. Return the mutated value.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"mul!(c::MyElem, a::MyElem, b::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Set c to the value ab in place. Return the mutated value. Aliasing is permitted.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"add!(c::MyElem, a::MyElem, b::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Set c to the value a + b in place. Return the mutated value. Aliasing is permitted.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"addeq!(a::MyElem, b::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Set a to a + b in place. Return the mutated value. Aliasing is permitted.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Random-generation","page":"Ring Interface","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"The random functions are only used for test code to generate test data. They therefore don't need to provide any guarantees on uniformity, and in fact, test values that are known to be a good source of corner cases can be supplied.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"rand(R::MyParent, v...)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return a random element in the given ring of the specified size.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"There can be as many arguments as is necessary to specify the size of the test example which is being produced.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Promotion-rules","page":"Ring Interface","title":"Promotion rules","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"AbstractAlgebra currently has a very simple coercion model. With few exceptions only simple coercions are supported. For example if x in mathbbZ and y in mathbbZx then x + y can be computed by coercing x into the same ring as y and then adding in that ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Complex coercions such as adding elements of mathbbQ and mathbbZx are not supported, as this would require finding and creating a common overring in which the elements could be added.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"AbstractAlgebra supports simple coercions by overloading parent object call syntax R(x) to coerce the object x into the ring R. However, to coerce elements up a tower of rings, one needs to also have a promotion system similar to Julia's type promotion system.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"As for Julia, AbstractAlgebra's promotion system only specifies what happens to types. It is the coercions themselves that must deal with the mathematical situation at the level of rings, including checking that the object can even be coerced into the given ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"We now describe the required AbstractAlgebra type promotion rules.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For every ring, one wants to be able to coerce integers into the ring. And for any ring constructed over a base ring, one would like to be able to coerce from the base ring into the ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"The required promotion rules to support this look a bit different depending on whether the element type is parameterised or not and whether it is built on a base ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For ring element types MyElem that are neither parameterised nor built over a base ring, the promotion rules can be defined as follows:","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"promote_rule(::Type{MyElem}, ::Type{T}) where {T <: Integer} = MyElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For ring element types MyElem that aren't parameterised, but which have a base ring with concrete element type T the promotion rules can be defined as follows:","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"promote_rule(::Type{MyElem}, ::Type{U}) where U <: Integer = MyElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"promote_rule(::Type{MyElem}, ::Type{T}) = MyElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For ring element types MyElem{T} that are parameterised by the type of elements of the base ring, the promotion rules can be defined as follows:","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"promote_rule(::Type{MyElem{T}}, ::Type{MyElem{T}}) where T <: RingElement = MyElem{T}","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"function promote_rule(::Type{MyElem{T}}, ::Type{U}) where {T <: RingElement, U <: RingElement}\n   promote_rule(T, U) == T ? MyElem{T} : Union{}\nend","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Required-functionality-for-inexact-rings","page":"Ring Interface","title":"Required functionality for inexact rings","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/#Approximation-(floating-point-and-ball-arithmetic-only)","page":"Ring Interface","title":"Approximation (floating point and ball arithmetic only)","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"isapprox(f::MyElem, g::MyElem; atol::Real=sqrt(eps()))","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"This is used by test code that uses rings involving floating point or ball arithmetic. The function should return true if all components of f and g are equal to within the square root of the Julia epsilon, since numerical noise may make an exact comparison impossible.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For parameterised rings over an inexact ring, we also require the following ad hoc approximation functionality.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"isapprox(f::MyElem{T}, g::T; atol::Real=sqrt(eps())) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"isapprox(f::T, g::MyElem{T}; atol::Real=sqrt(eps())) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"These notionally coerce the element of the base ring into the parameterised ring and do a full comparison.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Optional-functionality","page":"Ring Interface","title":"Optional functionality","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Some functionality is difficult or impossible to implement for all rings in the system. If it is provided, additional functionality or performance may become available. Here is a list of all functions that are considered optional and can't be relied on by generic functions in the AbstractAlgebra Ring interface.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"It may be that no algorithm, or no efficient algorithm is known to implement these functions. As these functions are optional, they do not need to exist. Julia will already inform the user that the function has not been implemented if it is called but doesn't exist.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Optional-basic-manipulation-functionality","page":"Ring Interface","title":"Optional basic manipulation functionality","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"isunit(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return true if the given element is a unit in the ring it belongs to.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"characteristic(R::MyParent)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Return the characteristic of the ring. The function should not be defined if it is not possible to unconditionally give the characteristic. AbstractAlgebra will raise an exception is such cases.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Optional-binary-ad-hoc-operators","page":"Ring Interface","title":"Optional binary ad hoc operators","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"By default, ad hoc operations are handled by AbstractAlgebra.jl if they are not defined explicitly, by coercing both operands into the same ring and then performing the required operation.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"In some cases, e.g. for matrices, this leads to very inefficient behaviour. In such cases, it is advised to implement some of these operators explicitly.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"It can occasionally be worth adding a separate set of ad hoc binary operators for the type Int, if this can be done more efficiently than for arbitrary Julia Integer types.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"+(f::MyElem, c::Integer)\n-(f::MyElem, c::Integer)\n*(f::MyElem, c::Integer)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"+(c::Integer, f::MyElem)\n-(c::Integer, f::MyElem)\n*(c::Integer, f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"For parameterised types, it is also sometimes more performant to provide explicit ad hoc operators with elements of the base ring.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"+(f::MyElem{T}, c::T) where T <: RingElem\n-(f::MyElem{T}, c::T) where T <: RingElem\n*(f::MyElem{T}, c::T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"+(c::T, f::MyElem{T}) where T <: RingElem\n-(c::T, f::MyElem{T}) where T <: RingElem\n*(c::T, f::MyElem{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Optional-ad-hoc-comparisons","page":"Ring Interface","title":"Optional ad hoc comparisons","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"==(f::MyElem, c::Integer)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"==(c::Integer, f::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"==(f::MyElem{T}, c:T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"==(c::T, f::MyElem{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Optional-ad-hoc-exact-division-functions","page":"Ring Interface","title":"Optional ad hoc exact division functions","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"divexact(a::MyElem{T}, b::T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"divexact(a::MyElem, b::Integer)","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Optional-powering-functions","page":"Ring Interface","title":"Optional powering functions","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"^(f::MyElem, e::BigInt)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"In case f cannot explode in size when powered by a very large integer, and it is practical to do so, one may provide this function to support powering with BigInt exponents (or for external modules, any other big integer type).","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Optional-unsafe-operators","page":"Ring Interface","title":"Optional unsafe operators","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"addmul!(c::MyElem, a::MyElem, b::MyElem, t::MyElem)","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Set c = c + ab in-place. Return the mutated value. The value t should be a temporary of the same type as a, b and c, which can be used arbitrarily by the implementation to speed up the computation. Aliasing between a, b and c is permitted.","category":"page"},{"location":"AbstractAlgebra/ring_interface/#Minimal-example-of-ring-implementation","page":"Ring Interface","title":"Minimal example of ring implementation","text":"","category":"section"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"Here is a minimal example of implementing the Ring Interface for a constant polynomial type (i.e. polynomials of degree less than one).","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"# ConstPoly.jl : Implements constant polynomials\n\nusing AbstractAlgebra\n\nusing Random: Random, SamplerTrivial, GLOBAL_RNG\nusing RandomExtensions: RandomExtensions, Make2, AbstractRNG\n\nimport AbstractAlgebra: parent_type, elem_type, base_ring, parent, isdomain_type,\n       isexact_type, canonical_unit, isequal, divexact, zero!, mul!, add!, addeq!,\n       get_cached!, isunit, characteristic, Ring, RingElem, expressify\n\nimport Base: show, +, -, *, ^, ==, inv, isone, iszero, one, zero, rand,\n             deepcopy_internal, hash\n\nmutable struct ConstPolyRing{T <: RingElement} <: Ring\n   base_ring::Ring\n\n   function ConstPolyRing{T}(R::Ring, cached::Bool) where T <: RingElement\n      return get_cached!(ConstPolyID, R, cached) do\n         new{T}(R)\n      end::ConstPolyRing{T}\n   end\nend\n\nconst ConstPolyID = AbstractAlgebra.CacheDictType{Ring, ConstPolyRing}()\n   \nmutable struct ConstPoly{T <: RingElement} <: RingElem\n   c::T\n   parent::ConstPolyRing{T}\n\n   function ConstPoly{T}(c::T) where T <: RingElement\n      return new(c)\n   end\nend\n\n# Data type and parent object methods\n\nparent_type(::Type{ConstPoly{T}}) where T <: RingElement = ConstPolyRing{T}\n\nelem_type(::Type{ConstPolyRing{T}}) where T <: RingElement = ConstPoly{T}\n\nbase_ring(R::ConstPolyRing) = R.base_ring\n\nparent(f::ConstPoly) = f.parent\n\nisdomain_type(::Type{ConstPoly{T}}) where T <: RingElement = isdomain_type(T)\n\nisexact_type(::Type{ConstPoly{T}}) where T <: RingElement = isexact_type(T)\n\nfunction hash(f::ConstPoly, h::UInt)\n   r = 0x65125ab8e0cd44ca\n   return xor(r, hash(f.c, h))\nend\n\nfunction deepcopy_internal(f::ConstPoly{T}, d::IdDict) where T <: RingElement\n   r = ConstPoly{T}(deepcopy_internal(f.c, d))\n   r.parent = f.parent # parent should not be deepcopied\n   return r\nend\n\n# Basic manipulation\n\nzero(R::ConstPolyRing) = R()\n\none(R::ConstPolyRing) = R(1)\n\niszero(f::ConstPoly) = iszero(f.c)\n\nisone(f::ConstPoly) = isone(f.c)\n\nisunit(f::ConstPoly) = isunit(f.c)\n\ncharacteristic(R::ConstPolyRing) = characteristic(base_ring(R))\n\n# Canonical unit\n\ncanonical_unit(f::ConstPoly) = canonical_unit(f.c)\n\n# String I/O\n\nfunction show(io::IO, R::ConstPolyRing)\n   print(io, \"Constant polynomials over \")\n   show(io, base_ring(R))\nend\n\nfunction show(io::IO, f::ConstPoly)\n   print(io, f.c)\nend\n\n# Expressification (optional)\n\nfunction expressify(R::ConstPolyRing; context = nothing)\n   return Expr(:sequence, Expr(:text, \"Constant polynomials over \"),\n                          expressify(base_ring(R), context = context))\nend\n\nfunction expressify(f::ConstPoly; context = nothing)\n   return expressify(f.c, context = context)\nend\n\n# Unary operations\n\nfunction -(f::ConstPoly)\n   R = parent(f)\n   return R(-f.c)\nend\n\n# Binary operations\n\nfunction +(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   parent(f) != parent(g) && error(\"Incompatible rings\")\n   R = parent(f)\n   return R(f.c + g.c)\nend\n\nfunction -(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   parent(f) != parent(g) && error(\"Incompatible rings\")\n   R = parent(f)\n   return R(f.c - g.c)\nend\n\nfunction *(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   parent(f) != parent(g) && error(\"Incompatible rings\")\n   R = parent(f)\n   return R(f.c*g.c)\nend\n\n# Comparison\n\nfunction ==(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   parent(f) != parent(g) && error(\"Incompatible rings\")\n   return f.c == g.c\nend\n\nfunction isequal(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   parent(f) != parent(g) && error(\"Incompatible rings\")\n   return isequal(f.c, g.c)\nend\n\n# Powering need not be implemented if * is\n\n# Exact division\n\nfunction divexact(f::ConstPoly{T}, g::ConstPoly{T}; check::Bool = true) where T <: RingElement\n   parent(f) != parent(g) && error(\"Incompatible rings\")\n   R = parent(f)\n   return R(divexact(f.c, g.c, check = check))\nend\n\n# Inverse\n\nfunction inv(f::ConstPoly)\n   R = parent(f)\n   return R(AbstractAlgebra.inv(f.c))\nend\n\n# Unsafe operators\n\nfunction zero!(f::ConstPoly)\n   f.c = zero(base_ring(parent(f)))\n   return f\nend\n\nfunction mul!(f::ConstPoly{T}, g::ConstPoly{T}, h::ConstPoly{T}) where T <: RingElement\n   f.c = g.c*h.c\n   return f\nend\n\nfunction add!(f::ConstPoly{T}, g::ConstPoly{T}, h::ConstPoly{T}) where T <: RingElement\n   f.c = g.c + h.c\n   return f\nend\n\nfunction addeq!(f::ConstPoly{T}, g::ConstPoly{T}) where T <: RingElement\n   f.c += g.c\n   return f\nend\n\n# Random generation\n\nRandomExtensions.maketype(R::ConstPolyRing, _) = elem_type(R)\n\nrand(rng::AbstractRNG, sp::SamplerTrivial{<:Make2{ConstPoly,ConstPolyRing}}) =\n        sp[][1](rand(rng, sp[][2]))\n\nrand(rng::AbstractRNG, R::ConstPolyRing, n::UnitRange{Int}) = R(rand(rng, n))\n\nrand(R::ConstPolyRing, n::UnitRange{Int}) = rand(Random.GLOBAL_RNG, R, n)\n\n# Promotion rules\n\npromote_rule(::Type{ConstPoly{T}}, ::Type{ConstPoly{T}}) where T <: RingElement = ConstPoly{T}\n\nfunction promote_rule(::Type{ConstPoly{T}}, ::Type{U}) where {T <: RingElement, U <: RingElement}\n   promote_rule(T, U) == T ? ConstPoly{T} : Union{}\nend\n\n# Constructors\n\nfunction (R::ConstPolyRing{T})() where T <: RingElement\n   r = ConstPoly{T}(base_ring(R)(0))\n   r.parent = R\n   return r\nend\n\nfunction (R::ConstPolyRing{T})(c::Integer) where T <: RingElement\n   r = ConstPoly{T}(base_ring(R)(c))\n   r.parent = R\n   return r\nend\n\n# Needed to prevent ambiguity\nfunction (R::ConstPolyRing{T})(c::T) where T <: Integer\n   r = ConstPoly{T}(base_ring(R)(c))\n   r.parent = R\n   return r\nend\n\nfunction (R::ConstPolyRing{T})(c::T) where T <: RingElement\n   base_ring(R) != parent(c) && error(\"Unable to coerce element\")\n   r = ConstPoly{T}(c)\n   r.parent = R\n   return r\nend\n\nfunction (R::ConstPolyRing{T})(f::ConstPoly{T}) where T <: RingElement\n   R != parent(f) && error(\"Unable to coerce element\")\n   return f\nend\n\n# Parent constructor\n\nfunction ConstantPolynomialRing(R::Ring, cached::Bool=true)\n   T = elem_type(R)\n   return ConstPolyRing{T}(R, cached)\nend","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"The above implementation of ConstantPolynomialRing may be tested as follows.","category":"page"},{"location":"AbstractAlgebra/ring_interface/","page":"Ring Interface","title":"Ring Interface","text":"using Test\ninclude(joinpath(pathof(AbstractAlgebra), \"..\", \"..\", \"test\", \"Rings-conformance-tests.jl\"))\n\nS, _ = PolynomialRing(QQ, \"x\")\n\nfunction test_elem(R::ConstPolyRing{elem_type(S)})\n   return R(rand(base_ring(R), 1:6, -999:999))\nend\n\ntest_Ring_interface(ConstantPolynomialRing(S))","category":"page"},{"location":"Hecke/orders/frac_ideals/#Fractional-ideals","page":"Fractional ideals","title":"Fractional ideals","text":"","category":"section"},{"location":"Hecke/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"A fractional ideal in the number field K is a Z_K-module A such that there exists an integer d0 wich dA is an (integral) ideal in Z_K. Due to the Dedekind property of Z_K, the ideals for a multiplicative group.","category":"page"},{"location":"Hecke/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"Fractional ideals are represented as an integral ideal and an additional denominator. They are of type NfOrdFracIdl.","category":"page"},{"location":"Hecke/orders/frac_ideals/#Creation","page":"Fractional ideals","title":"Creation","text":"","category":"section"},{"location":"Hecke/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"fractional_ideal(::NfOrd, ::fmpz_mat)\nfractional_ideal(::NfOrd, ::fmpz_mat, ::fmpz)\nfractional_ideal(::NfOrd, ::FakeFmpqMat)\nfractional_ideal(::NfOrd, ::NfOrdIdl)\nfractional_ideal(::NfOrd, ::NfOrdIdl, ::fmpz)\nfractional_ideal(::NfOrd, ::nf_elem)\nfractional_ideal(::NfOrd, ::NfOrdElem)\ninv(::NfOrdIdl)","category":"page"},{"location":"Hecke/orders/frac_ideals/#fractional_ideal-Tuple{NfOrd, fmpz_mat}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::NfAbsOrd, A::fmpz_mat, b::fmpz, A_in_hnf::Bool = false) -> NfAbsOrdFracIdl\n\nCreates the fractional ideal of mathcal O with basis matrix Ab. If A_in_hnf is set, then it is assumed that A is already in lower left HNF.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#fractional_ideal-Tuple{NfOrd, fmpz_mat, fmpz}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::NfAbsOrd, A::fmpz_mat, b::fmpz, A_in_hnf::Bool = false) -> NfAbsOrdFracIdl\n\nCreates the fractional ideal of mathcal O with basis matrix Ab. If A_in_hnf is set, then it is assumed that A is already in lower left HNF.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#fractional_ideal-Tuple{NfOrd, FakeFmpqMat}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::NfAbsOrd, A::FakeFmpqMat, A_in_hnf::Bool = false) -> NfAbsOrdFracIdl\n\nCreates the fractional ideal of mathcal O with basis matrix A. If A_in_hnf is set, then it is assumed that the numerator of A is already in lower left HNF.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#fractional_ideal-Tuple{NfOrd, NfOrdIdl}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::NfOrd, I::NfAbsOrdIdl) -> NfOrdFracIdl\n\nThe fractional ideal of O generated by a Z-basis of I.\n\n\n\nfractional_ideal(O::NfAbsOrd, I::NfAbsOrdIdl) -> NfAbsOrdFracIdl\n\nTurns the ideal I into a fractional ideal of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#fractional_ideal-Tuple{NfOrd, NfOrdIdl, fmpz}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::NfAbsOrd, I::NfAbsOrdIdl, b::fmpz) -> NfAbsOrdFracIdl\n\nCreates the fractional ideal Ib of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#fractional_ideal-Tuple{NfOrd, nf_elem}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::NfAbsOrd, a::nf_elem) -> NfAbsOrdFracIdl\n\nCreates the principal fractional ideal (a) of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#fractional_ideal-Tuple{NfOrd, NfOrdElem}","page":"Fractional ideals","title":"fractional_ideal","text":"fractional_ideal(O::NfAbsOrd, a::NfAbsOrdElem) -> NfAbsOrdFracIdl\n\nCreates the principal fractional ideal (a) of mathcal O.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#inv-Tuple{NfOrdIdl}","page":"Fractional ideals","title":"inv","text":"inv(A::NfAbsOrdIdl) -> NfOrdFracIdl\n\nComputes the inverse of A, that is, the fractional ideal B such that AB = mathcal O_K.\n\n\n\n inv(a::LocElem{T}, checked::Bool = true)  where {T <: RingElem}\n\nReturns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#Arithmetic","page":"Fractional ideals","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"All the normal operations are provided as well.","category":"page"},{"location":"Hecke/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"inv(::NfOrdFracIdl)\nintegral_split(::NfOrdFracIdl)\nnumerator(::NfRelOrdFracIdl)\ndenominator(::NfRelOrdFracIdl)","category":"page"},{"location":"Hecke/orders/frac_ideals/#inv-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}","page":"Fractional ideals","title":"inv","text":"inv(A::NfAbsOrdFracIdl) -> NfAbsOrdFracIdl\n\nReturns the fractional ideal B such that AB = mathcal O.\n\n\n\n inv(a::LocElem{T}, checked::Bool = true)  where {T <: RingElem}\n\nReturns the inverse element of a if a is a unit. If 'checked = false' the invertibility of a is not checked and the corresponding inverse element of the Fraction Field is returned.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#integral_split-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}","page":"Fractional ideals","title":"integral_split","text":"integral_split(A::NfAbsOrdFracIdl) -> NfAbsOrdIdl, NfAbsOrdIdl\n\nComputes the unique coprime integral ideals N and D s.th. A = ND^-1\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#numerator-Tuple{Hecke.NfRelOrdFracIdl}","page":"Fractional ideals","title":"numerator","text":"numerator(a::NfRelOrdFracIdl) -> NfRelOrdIdl\n\nReturns the ideal d*a where d is the denominator of a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#denominator-Tuple{Hecke.NfRelOrdFracIdl}","page":"Fractional ideals","title":"denominator","text":"denominator(a::NfRelOrdFracIdl) -> fmpz\n\nReturns the smallest positive integer d such that da is contained in the order of a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#Miscaellenous","page":"Fractional ideals","title":"Miscaellenous","text":"","category":"section"},{"location":"Hecke/orders/frac_ideals/","page":"Fractional ideals","title":"Fractional ideals","text":"order(::NfOrdFracIdl)\nbasis_matrix(::NfOrdFracIdl)\nbasis_mat_inv(::NfOrdFracIdl)\nbasis(::NfOrdFracIdl)\nnorm(::NfOrdFracIdl)","category":"page"},{"location":"Hecke/orders/frac_ideals/#order-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}","page":"Fractional ideals","title":"order","text":"order(a::NfAbsOrdFracIdl) -> NfAbsOrd\n\nThe order that was used to define the ideal a.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#basis_matrix-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}","page":"Fractional ideals","title":"basis_matrix","text":"basis_matrix(I::NfAbsOrdFracIdl) -> FakeFmpqMat\n\nReturns the basis matrix of I with respect to the basis of the order.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#basis_mat_inv-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}","page":"Fractional ideals","title":"basis_mat_inv","text":"basis_mat_inv(O::NfAbsOrd) -> FakeFmpqMat\n\nReturns the inverse of the basis matrix of mathcal O.\n\n\n\nbasis_mat_inv(A::NfAbsOrdIdl) -> fmpz_mat\n\nReturns the inverse basis matrix of A.\n\n\n\nbasis_mat_inv(I::NfAbsOrdFracIdl) -> FakeFmpqMat\n\nReturns the inverse of the basis matrix of I.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#basis-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}","page":"Fractional ideals","title":"basis","text":"basis(I::NfAbsOrdFracIdl) -> Vector{nf_elem}\n\nReturns the mathbf Z-basis of I.\n\n\n\n","category":"method"},{"location":"Hecke/orders/frac_ideals/#norm-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}","page":"Fractional ideals","title":"norm","text":"norm(I::NfAbsOrdFracIdl) -> fmpq\n\nReturns the norm of I.\n\n\n\nnorm(a::NfRelOrdIdl) -> NfOrdIdl\n\nReturns the norm of a.\n\n\n\nnorm(a::NfRelOrdFracIdl{T, S}) -> S\n\nReturns the norm of a.\n\n\n\nnorm(a::AlgAssAbsOrdIdl, O::AlgAssAbsOrd; copy::Bool = true) -> fmpq\n\nReturns the norm of a considered as an (possibly fractional) ideal of O.\n\n\n\nnorm(a::AlgAssRelOrdIdl{S, T, U}, O::AlgAssRelOrd{S, T, U}; copy::Bool = true)\n  where { S, T, U } -> T\n\nReturns the norm of a considered as an (possibly fractional) ideal of O.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#Factored-Elements","page":"Factored Elements","title":"Factored Elements","text":"","category":"section"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in Qsqrt d it is known that the coefficients wrt. the canonical basis 1 sqrt d can have O(exp sqrt d) many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them.","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"Mathematically, one can think of factored elements to formally live in the ring ZK the group ring of the non-zero field elements. Thus elements are of the form $ \\prod ai^{ei}$ where a_i are elements in K, typically small and the e_iin Z are frequently large exponents. We refer to the a_i as the base and the e_i as the exponents of the factored element.","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"Since K is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added.","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"In Hecke, this is caputured more generally by the type FacElem, parametrized by the type of the elements in the base and the type of their parent.","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"Important special cases are","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"FacElem{fmpz, FlintIntegerRing}, factored integers\nFacElem{nf_elem, AnticNumberField}, factored algerbaic numbers\nFacElem{NfAbsOrdIdl, NfAbsOrdIdlSet}, factored ideals","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"It should be noted that an object of type `FacElemfmpz FlintIntegerRing will, in general, not represent an integer as the exponents can be negative.","category":"page"},{"location":"Hecke/FacElem/#Construction","page":"Factored Elements","title":"Construction","text":"","category":"section"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"In general one can define factored elements by giving 2 arrays, the base and the exponent, or a dictionary containing the pairs:","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"FacElem\nFacElem(a::nf_elem)","category":"page"},{"location":"Hecke/FacElem/#FacElem","page":"Factored Elements","title":"FacElem","text":"FacElem{B}(R, base::Vector{B}, exp::Vector{fmpz}) -> FacElem{B}\n\nReturns the element prod b_i^e_i, un-expanded.\n\n\n\nFacElem{B}(base::Vector{B}, exp::Vector{fmpz}) -> FacElem{B}\n\nReturns the element prod b_i^e_i, un-expanded.\n\n\n\nFacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B}\nFacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B}\n\nReturns the element prod b^dp, un-expanded.\n\n\n\nFacElem{B}(d::Dict{B, fmpz}) -> FacElem{B}\nFacElem{B}(d::Dict{B, Integer}) -> FacElem{B}\n\nReturns the element prod b^dp, un-expanded.\n\n\n\n","category":"type"},{"location":"Hecke/FacElem/#FacElem-Tuple{nf_elem}","page":"Factored Elements","title":"FacElem","text":"FacElem{B}(R, base::Vector{B}, exp::Vector{fmpz}) -> FacElem{B}\n\nReturns the element prod b_i^e_i, un-expanded.\n\n\n\nFacElem{B}(base::Vector{B}, exp::Vector{fmpz}) -> FacElem{B}\n\nReturns the element prod b_i^e_i, un-expanded.\n\n\n\nFacElem{B}(R, d::Dict{B, fmpz}) -> FacElem{B}\nFacElem{B}(R, d::Dict{B, Integer}) -> FacElem{B}\n\nReturns the element prod b^dp, un-expanded.\n\n\n\nFacElem{B}(d::Dict{B, fmpz}) -> FacElem{B}\nFacElem{B}(d::Dict{B, Integer}) -> FacElem{B}\n\nReturns the element prod b^dp, un-expanded.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"ideal(::NfOrd, ::FacElem{nf_elem, AnticNumberField})","category":"page"},{"location":"Hecke/FacElem/#ideal-Tuple{NfOrd, FacElem{nf_elem, AnticNumberField}}","page":"Factored Elements","title":"ideal","text":" ideal(O::NfOrd, a::FacElem{nf_elem, AnticNumberField)\n\nThe factored fractional ideal a*O.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#Conversion","page":"Factored Elements","title":"Conversion","text":"","category":"section"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"The process of computing the value defined by a factored element is available as evaluate. Depending on the types involved this can be very efficient.","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"evaluate(::FacElem{fmpz, S}) where S\nevaluate(::FacElem{fmpq, S} where S)\nevaluate(::FacElem{T,S} where S) where T\nevaluate_naive(::FacElem{T,S} where S) where T","category":"page"},{"location":"Hecke/FacElem/#evaluate-Union{Tuple{FacElem{fmpz, S}}, Tuple{S}} where S","page":"Factored Elements","title":"evaluate","text":"evaluate{T}(x::FacElem{T}) -> T\n\nExpands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#evaluate-Tuple{FacElem{fmpq, S} where S}","page":"Factored Elements","title":"evaluate","text":"evaluate(x::FacElem{fmpq}) -> fmpq\nevaluate(x::FacElem{fmpz}) -> fmpz\n\nExpands or evaluates the factored element, i.e. actually computes the the element. Works by first obtaining a simplified version of the power product into coprime base elements.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#evaluate-Union{Tuple{FacElem{T, S} where S}, Tuple{T}} where T","page":"Factored Elements","title":"evaluate","text":"evaluate{T}(x::FacElem{T}) -> T\n\nExpands or evaluates the factored element, i.e. actually computes the value. Does \"square-and-multiply\" on the exponent vectors.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#evaluate_naive-Union{Tuple{FacElem{T, S} where S}, Tuple{T}} where T","page":"Factored Elements","title":"evaluate_naive","text":"evaluate_naive{T}(x::FacElem{T}) -> T\n\nExpands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#Special-functions","page":"Factored Elements","title":"Special functions","text":"","category":"section"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"In the case where the parent of the base allows for efficient gcd computation, power products can be made unique:","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"simplify(x::FacElem{NfOrdIdl, NfOrdIdlSet})\nsimplify(x::FacElem{fmpq,S} where S)","category":"page"},{"location":"Hecke/FacElem/#simplify-Tuple{FacElem{NfOrdIdl, Hecke.NfAbsOrdIdlSet{AnticNumberField, nf_elem}}}","page":"Factored Elements","title":"simplify","text":"simplify(x::FacElem{NfOrdIdl, NfOrdIdlSet}) -> FacElem\nsimplify(x::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}) -> FacElem\n\nUses coprime_base to obtain a simplified version of x, ie. in the simplified version all base ideals will be pariwise coprime but not neccessarily prime!.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#simplify-Tuple{FacElem{fmpq, S} where S}","page":"Factored Elements","title":"simplify","text":"simplify(x::FacElem{fmpq}) -> FacElem{fmpq}\nsimplify(x::FacElem{fmpz}) -> FacElem{fmpz}\n\nSimplfies the factored element, i.e. arranges for the base to be coprime.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"The simplified version can then be used further:","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"isone(x::FacElem{fmpq, S} where S)\nfactor_coprime(::FacElem{fmpz, S} where S)\nfactor_coprime(::FacElem{NfOrdIdl, NfOrdIdlSet})\nfactor_coprime(::FacElem{NfOrdFracIdl, NfOrdFracIdlSet})\nfactor_coprime(::FacElem{nf_elem, AnticNumberField}, ::NfOrdIdlSet)\nfactor(::FacElem{NfOrdFracIdl, NfOrdFracIdlSet})\nfactor(::FacElem{nf_elem, AnticNumberField}, ::NfOrdIdlSet)","category":"page"},{"location":"Hecke/FacElem/#isone-Tuple{FacElem{fmpq, S} where S}","page":"Factored Elements","title":"isone","text":"isone(x::FacElem{fmpq}) -> Bool\nisone(x::FacElem{fmpz}) -> Bool\n\nTests if x represents 1 without an evaluation.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#factor_coprime-Tuple{FacElem{fmpz, S} where S}","page":"Factored Elements","title":"factor_coprime","text":"factor_coprime(x::FacElem{fmpz}) -> Fac{fmpz}\n\nComputed a partial factorisation of x, ie. writes x as a product of pariwise coprime integers.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#factor_coprime-Tuple{FacElem{NfOrdIdl, Hecke.NfAbsOrdIdlSet{AnticNumberField, nf_elem}}}","page":"Factored Elements","title":"factor_coprime","text":"factor_coprime(x::FacElem{NfOrdIdl, NfOrdIdlSet}) -> Dict{NfOrdIdl, Int}\n\nComputed a partial factorisation of x, ie. writes x as a product of pariwise coprime integral ideals.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#factor_coprime-Tuple{FacElem{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}, Hecke.NfAbsOrdFracIdlSet{AnticNumberField, nf_elem}}}","page":"Factored Elements","title":"factor_coprime","text":"factor_coprime(Q::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}) -> Dict{NfOrdIdl, Int}\n\nA coprime factorisation of Q: each ideal in Q is split using \\code{integral_split} and then a coprime basis is computed. This does {\\bf not} use any factorisation.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#factor_coprime-Tuple{FacElem{nf_elem, AnticNumberField}, Hecke.NfAbsOrdIdlSet{AnticNumberField, nf_elem}}","page":"Factored Elements","title":"factor_coprime","text":"factor_coprime(a::FacElem{nf_elem, AnticNumberField}, I::NfOrdIdlSet) -> Dict{NfOrdIdl, fmpz}\n\nFactors the rincipal ideal generated by a into coprimes by computing a coprime basis from the principal ideals in the factorisation of a.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#factor-Tuple{FacElem{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}, Hecke.NfAbsOrdFracIdlSet{AnticNumberField, nf_elem}}}","page":"Factored Elements","title":"factor","text":" factor(Q::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}) -> Dict{NfOrdIdl, Int}\n\nThe factorisation of Q, by refining a coprime factorisation.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#factor-Tuple{FacElem{nf_elem, AnticNumberField}, Hecke.NfAbsOrdIdlSet{AnticNumberField, nf_elem}}","page":"Factored Elements","title":"factor","text":"factor(a::FacElem{nf_elem, AnticNumberField}, I::NfOrdIdlSet) -> Dict{NfOrdIdl, fmpz}\n\nFactors the principal ideal generated by a by refinind a coprime factorisation.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results:","category":"page"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"compact_presentation(a::FacElem{nf_elem, AnticNumberField}, n::Int = 2)","category":"page"},{"location":"Hecke/FacElem/#compact_presentation","page":"Factored Elements","title":"compact_presentation","text":"compact_presentation(a::FacElem{nf_elem, AnticNumberField}, n::Int = 2; decom, arb_prec = 100, short_prec = 1000) -> FacElem\n\nComputes a presentation a = prod a_i^n_i where all the exponents n_i are powers of n and, the elements a_i are \"small\", generically, they have a norm bounded by d^n2 where d is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by a, it can be passed in in \\code{decom}.\n\n\n\n","category":"function"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"signs(::Union{FacElem{nf_elem,AnticNumberField}, nf_elem})\nsigns(::Union{FacElem{nf_elem,AnticNumberField}, nf_elem}, ::Vector{InfPlc})\nsign(::Union{FacElem{nf_elem,AnticNumberField}, nf_elem}, ::InfPlc)\nispositive(::Union{FacElem{nf_elem,AnticNumberField}, nf_elem}, ::InfPlc)\nispositive(::Union{FacElem{nf_elem,AnticNumberField}, nf_elem}, ::Vector{InfPlc})\nistotally_positive(::Union{FacElem{nf_elem,AnticNumberField}, nf_elem})","category":"page"},{"location":"Hecke/FacElem/#signs-Tuple{Union{FacElem{nf_elem, AnticNumberField}, nf_elem}}","page":"Factored Elements","title":"signs","text":"signs(a::nf_elem)          -> Dict{InfPlc, Int}\nsigns(a::FacElem{nf_elem}) -> Dict{InfPlc, Int}\n\nThis function returns a dictionary of the signs of a at all infinite places of the ambient number field. The keys are infinite places of the ambient number field. The value is 1 if the sign is positive and -1 if the sign is negative.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#signs-Tuple{Union{FacElem{nf_elem, AnticNumberField}, nf_elem}, Vector{InfPlc}}","page":"Factored Elements","title":"signs","text":"signs(a::nf_elem, l::Vector{InfPlc})          -> Dict{InfPlc, Int}\nsigns(a::FacElem{nf_elem}, l::Vector{InfPlc}) -> Dict{InfPlc, Int}\n\nThis function returns a dictionary of the signs of a at places in l. The keys are the elements of l. The value is 1 if the sign is positive and -1 if the sign is negative. The result will contain as many signs as there are real places contained in l.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#sign-Tuple{Union{FacElem{nf_elem, AnticNumberField}, nf_elem}, InfPlc}","page":"Factored Elements","title":"sign","text":"sign(a::nf_elem, P::InfPlc)          -> Int\nsign(a::FacElem{nf_elem}, P::InfPlc) -> Int\n\nThis function returns the sign of a at the place P. The value is 1 if the sign is positive and -1 if the sign is negative.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#ispositive-Tuple{Union{FacElem{nf_elem, AnticNumberField}, nf_elem}, InfPlc}","page":"Factored Elements","title":"ispositive","text":"ispositive(a::nf_elem, P::InfPlc)          -> Bool\nispositive(a::FacElem{nf_elem}, P::InfPlc) -> Bool\n\nReturns whether the element a is positive at the embedding corresponding to P. The place P must be real.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#ispositive-Tuple{Union{FacElem{nf_elem, AnticNumberField}, nf_elem}, Vector{InfPlc}}","page":"Factored Elements","title":"ispositive","text":"ispositive(a::nf_elem, l::Vector{InfPlc})          -> Bool\nispositive(a::FacElem{nf_elem}, l::Vector{InfPlc}) -> Bool\n\nReturns whether the element a is positive at the embeddings corresponding to the real places of l.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#istotally_positive-Tuple{Union{FacElem{nf_elem, AnticNumberField}, nf_elem}}","page":"Factored Elements","title":"istotally_positive","text":"istotally_positive(a::nf_elem)          -> Bool\nistotally_positive(a::FacElem{nf_elem}) -> Bool\n\nReturns whether the element a is totally positive, that is, whether it is positive at all places of the ambient number field.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"valuation(::FacElem{nf_elem,AnticNumberField}, ::NfAbsOrdIdl{AnticNumberField,nf_elem})\nvaluation(::FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}, ::NfAbsOrdIdl{AnticNumberField,nf_elem})\nevaluate_mod(::FacElem{nf_elem,AnticNumberField}, ::NfOrdFracIdl)\nreduce_ideal(::FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}})\nmodular_proj(::FacElem{nf_elem,AnticNumberField}, ::Hecke.modular_env)","category":"page"},{"location":"Hecke/FacElem/#valuation-Tuple{FacElem{nf_elem, AnticNumberField}, NfOrdIdl}","page":"Factored Elements","title":"valuation","text":"valuation(a::FacElem{nf_elem, AnticNumberField}, P::NfOrdIdl) -> fmpz\n\nThe valuation of a at P.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#valuation-Tuple{FacElem{NfOrdIdl, Hecke.NfAbsOrdIdlSet{AnticNumberField, nf_elem}}, NfOrdIdl}","page":"Factored Elements","title":"valuation","text":"valuation(A::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}, p::NfOrdIdl)\nvaluation(A::FacElem{NfOrdIdl, NfOrdIdlSet}, p::NfOrdIdl)\n\nThe valuation of A at P.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#evaluate_mod-Tuple{FacElem{nf_elem, AnticNumberField}, Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}}","page":"Factored Elements","title":"evaluate_mod","text":"evaluate_mod(a::FacElem{nf_elem, AnticNumberField}, B::NfOrdFracIdl) -> nf_elem\n\nEvaluates a using CRT and small primes. Assumes that the ideal generated by a is in fact B. Useful in cases where a has huge exponents, but the evaluated element is actually \"small\".\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#reduce_ideal-Tuple{FacElem{NfOrdIdl, Hecke.NfAbsOrdIdlSet{AnticNumberField, nf_elem}}}","page":"Factored Elements","title":"reduce_ideal","text":"reduce_ideal(A::FacElem{NfOrdIdl}) -> NfOrdIdl, FacElem{nf_elem}\n\nComputes B and alpha in factored form, such that alpha B = A.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#modular_proj-Tuple{FacElem{nf_elem, AnticNumberField}, Hecke.modular_env}","page":"Factored Elements","title":"modular_proj","text":"modular_proj(a::FacElem{nf_elem, AnticNumberField}, me::modular_env) -> Vector{fq_nmod}\n\nGiven an algebraic number a in factored form and data \\code{me} as computed by \\code{modular_init}, project a onto the residue class fields.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#Miscellaneous","page":"Factored Elements","title":"Miscellaneous","text":"","category":"section"},{"location":"Hecke/FacElem/","page":"Factored Elements","title":"Factored Elements","text":"max_exp(a::FacElem)\nmin_exp(a::FacElem)\nmaxabs_exp(a::FacElem)","category":"page"},{"location":"Hecke/FacElem/#max_exp-Tuple{FacElem}","page":"Factored Elements","title":"max_exp","text":"max_exp(a::FacElem)\n\nFinds the largest exponent in the factored element a.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#min_exp-Tuple{FacElem}","page":"Factored Elements","title":"min_exp","text":"min_exp(a::FacElem)\n\nFinds the smallest exponent in the factored element a.\n\n\n\n","category":"method"},{"location":"Hecke/FacElem/#maxabs_exp-Tuple{FacElem}","page":"Factored Elements","title":"maxabs_exp","text":"maxabs_exp(a::FacElem)\n\nFinds the largest exponent by absolute value in the factored element a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/#Sparse-distributed-multivariate-Laurent-polynomials","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"","category":"section"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"Every element of the multivariate Laurent polynomial ring Rx_1 x_1^-1 dots x_n x_n^-1 can be presented as a sum of products of powers of the x_i where the power can be any integer. Therefore, the interface for sparse multivarate polynomials carries over with the additional feature that exponents can be negative.","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/#Generic-multivariate-Laurent-polynomial-types","page":"Sparse distributed multivariate Laurent polynomials","title":"Generic multivariate Laurent polynomial types","text":"","category":"section"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"AbstractAlgebra.jl provides a generic implementation of multivariate Laurent polynomials, built in terms of regular multivariate polynomials, in the file src/generic/LaurentMPoly.jl.","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"The type LaurentMPolyWrap{T, ...} <: LaurentMPolyElem{T} implements generic multivariate Laurent polynomials by wrapping regular polynomials: a Laurent polynomial l wraps a polynomial p and a vector of integers n_i such that l = prod_i x_i^n_i * p. The representation is said to be normalized when each n_i is as large as possible (or zero when l is zero), but the representation of a given element is not required to be normalized internally.","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"The corresponding parent type is LaurentMPolyWrapRing{T, ...} <: LaurentMPolyRing{T}.","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/#Abstract-types","page":"Sparse distributed multivariate Laurent polynomials","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"Two abstract types LaurentMPolyElem{T} and LaurentMPolyRing{T} are defined to represent Laurent polynomials and rings thereof, parameterized on a base ring T.","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/#Multivate-Laurent-polynomial-operations","page":"Sparse distributed multivariate Laurent polynomials","title":"Multivate Laurent polynomial operations","text":"","category":"section"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"Since, from the point of view of the interface, Laurent polynomials are simply regular polynomials with possibly negative exponents, the following functions from the polynomial interface are completely analogous. As with regular polynomials, an implementation must provide access to the elements as a sum of individual terms in some order. This order currently cannot be specified in the constructor.","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"LaurentPolynomialRing(R::Ring, S::Vector{String}; cached::Bool = true)\nLaurentPolynomialRing(R::Ring, n::Int, s::String=\"x\"; cached::Bool = false)","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"(S::LaurentMPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}})","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"MPolyBuildCtx(R::LaurentMPolyRing)\npush_term!(M::LaurentMPolyBuildCtx, c::RingElem, v::Vector{Int})\nfinish(M::LaurentMPolyBuildCtx)","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"symbols(S::LaurentMPolyRing)\nnvars(f::LaurentMPolyRing)\ngens(S::LaurentMPolyRing)\ngen(S::LaurentMPolyRing, i::Int)\nisgen(x::LaurentMPolyElem)\nvar_index(p::LaurentMPolyElem)\nlength(f::LaurentMPolyElem)","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"coefficients(p::LaurentMPolyElem)\nmonomials(p::LaurentMPolyElem)\nterms(p::LaurentMPolyElem)\nexponent_vectors(p::LaurentMPolyElem)\nleading_coefficient(p::LaurentMPolyElem)\nleading_monomial(p::LaurentMPolyElem)\nleading_term(p::LaurentMPolyElem)\nleading_exponent_vector(p::LaurentMPolyElem)","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"change_base_ring(::Ring, p::LaurentMPolyElem)\nchange_coefficient_ring(::Ring, p::LaurentMPolyElem)\nmap_coefficients(::Any, p::LaurentMPolyElem)","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"evaluate(p::LaurentMPolyElem, ::Vector)","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"derivative(p::LaurentMPolyElem, x::LaurentMPolyElem)\nderivative(p::LaurentMPolyElem, i::Int)","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"rand(R::LaurentMPolyElem, length_range::UnitRange{Int}, exp_range::UnitRange{Int}, v...)","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"The choice of canonical unit for Laurent polynomials includes the product prod_i x_i^n_i from the normalized representation. In particular, this means that the output of gcd will not have any negative exponents.","category":"page"},{"location":"AbstractAlgebra/laurent_mpolynomial/","page":"Sparse distributed multivariate Laurent polynomials","title":"Sparse distributed multivariate Laurent polynomials","text":"julia> R, (x, y) = LaurentPolynomialRing(ZZ, [\"x\", \"y\"]);\n\njulia> canonical_unit(2*x^-5 - 3*x + 4*y^-4 + 5*y^2)\n-x^-5*y^-4\n\njulia> gcd(x^-3 - y^3, x^-2 - y^2)\nx*y - 1","category":"page"},{"location":"Hecke/dev/test/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"Hecke/dev/test/#Structure","page":"Testing","title":"Structure","text":"","category":"section"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"The Hecke tests can be found in Hecke/test/ and are organized in such a way that the file hierarchy mirrors the source directory Hecke/src/. For example, here is a subset of the src/QuadForm and the test/QuadForm directories:","category":"page"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"├── src\n│   ├── QuadForm\n│   │   ├── Enumeration.jl\n│   │   ├── Herm\n│   │   │   ├── Genus.jl\n│   │   ├── Quad\n│   │   │   ├── Genus.jl\n│   │   │   ├── GenusRep.jl\n│   │   │   ├── NormalForm.jl\n│   │   │   ├── Spaces.jl\n│   │   │   ├── Types.jl\n│   │   │   ├── ZGenus.jl\n│   │   │   └── ZLattices.jl\n│   │   ├── QuadBin.jl\n│   │   ├── Torsion.jl\n│   ├── QuadForm.jl\n│\n│\n│\n├── test\n│   ├── QuadForm\n│   │   ├── Enumeration.jl\n│   │   ├── Herm\n│   │   │   ├── Genus.jl\n│   │   ├── Quad\n│   │   │   ├── Genus.jl\n│   │   │   ├── GenusRep.jl\n│   │   │   ├── NormalForm.jl\n│   │   │   ├── Spaces.jl\n│   │   │   ├── ZGenus.jl\n│   │   │   └── ZLattices.jl\n│   │   ├── QuadBin.jl\n│   │   └── Torsion.jl\n│   ├── QuadForm.jl","category":"page"},{"location":"Hecke/dev/test/#Adding-tests","page":"Testing","title":"Adding tests","text":"","category":"section"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"If one adds functionality to a file, say src/QuadForm/Quad/Genus.jl, a corresponding a test should be added to the corresponding test file. In this case this would be test/QuadForm/Quad/Genus.jl.\nAssume one adds a new file, say src/QuadForm/New.jl, which is included in src/QuadForm.jl. Then a corresponding file test/QuadForm/Test.jl containing the tests must be added. This new file must then also be included in test/QuadForm.jl.\nSimilar to the above, if a new directory in src/ is added, the same must apply in test/.","category":"page"},{"location":"Hecke/dev/test/#Adding-long-tests","page":"Testing","title":"Adding long tests","text":"","category":"section"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"If one knows that running a particular test will take a long time, one can use @long_test instead of @test inside the test suite. When running the test suite, tests annotated with @long_test will not be run, unless specifically asked for (see below). The continuous integration servers will run at least one job including the long tests.","category":"page"},{"location":"Hecke/dev/test/#Running-the-tests","page":"Testing","title":"Running the tests","text":"","category":"section"},{"location":"Hecke/dev/test/#Running-all-tests","page":"Testing","title":"Running all tests","text":"","category":"section"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"All tests can be run as usual with Pkg.test(\"Hecke\"). The whole test suite can be run in parallel using the following options:","category":"page"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"Set the environment variable HECKE_TEST_VARIABLE=n, where n is the number of processes.\nOn julia >= 1.3, run Pkg.test(\"Hecke\", test_args = [\"-j$(n)\"]), where n is the number of processes.","category":"page"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"The tests annotated with @long_test can be invoked by setting HECKE_TESTLONG=1 or adding \"long\" to the test_args keyword argument on julia >= 1.3.","category":"page"},{"location":"Hecke/dev/test/#Running-a-subset-of-tests","page":"Testing","title":"Running a subset of tests","text":"","category":"section"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"Because the test structure mirrors the source directory, it is easy to run only a subset of tests. For example, to run all the tests in test/QuadForm/Quad/Genus.jl, one can invoke:","category":"page"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"julia> Hecke.test_module(\"QuadForm/Quad/Genus\")","category":"page"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"This also works on the directory level. If one wants to add run all tests for quadratic forms, one can just run","category":"page"},{"location":"Hecke/dev/test/","page":"Testing","title":"Testing","text":"julia> Hecke.test_module(\"QuadForm\")","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"Fields/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"The fields part of OSCAR provides functionality for handling various kinds of fields:","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"the field of rationals\nNumber fields\nGeneric fraction fields\nlocal fields (Padics and Qadics)\nfinite fields","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"Fields/intro/","page":"Introduction","title":"Introduction","text":"Henri Cohen (1993)\nHenri Cohen (2000)\nRudolf Lidl, Harald Niederreiter (1997)\nDaniel A. Marcus (2018)\nM. Pohst, H. Zassenhaus (1997)","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/ideal/#Ideal-functionality","page":"Ideal functionality","title":"Ideal functionality","text":"","category":"section"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/Ideal.jl for ideals of a Euclidean domain (assuming the existence of a gcdx function) or of a univariate or multivariate polynomial ring over the integers. Univariate and multivariate polynomial rings over other domains (other than fields) are not supported at this time.","category":"page"},{"location":"AbstractAlgebra/ideal/#Generic-ideal-types","page":"Ideal functionality","title":"Generic ideal types","text":"","category":"section"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"AbstractAlgebra.jl provides a generic ideal type based on Julia arrays which is implemented in src/generic/Ideal.jl.","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"These generic ideals have type Generic.Ideal{T} where T is the type of elements of the ring the ideals belong to. Internally they consist of a Julia array of generators and some additional fields for a parent object, etc. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"Parent objects of ideals have type Generic.IdealSet{T}.","category":"page"},{"location":"AbstractAlgebra/ideal/#Abstract-types","page":"Ideal functionality","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"All ideal types belong to the abstract type Ideal{T} and their parents belong to the abstract type Set. This enables one to write generic functions that can accept any AbstractAlgebra ideal type.","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"note: Note\nBoth the generic ideal type Generic.Ideal{T} and the abstract type it belongs to, Ideal{T}, are called Ideal. The former is a (parameterised) concrete type for an ideal in the ring whose elements have type T. The latter is an abstract type representing all ideal types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"AbstractAlgebra/ideal/#Ideal-constructors","page":"Ideal functionality","title":"Ideal constructors","text":"","category":"section"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"One may construct ideals in AbstractAlgebra.jl with the following constructor.","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"Ideal(R::Ring, V::Vector{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"Given a set of elements V in the ring R, construct the ideal of R generated by the elements V. Note that V may be arbitrary, e.g. it can contain duplicates, zero entries or be empty.","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"]; ordering=:degrevlex)\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> V = [3*x^2*y - 3*y^2, 9*x^2*y + 7*x*y]\n2-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n 3*x^2*y - 3*y^2\n 9*x^2*y + 7*x*y\n\njulia> I = Ideal(R, V)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.MPoly{BigInt}}(AbstractAlgebra.Generic.MPoly{BigInt}[7*x*y + 9*y^2, 243*y^3 - 147*y^2, x*y^2 + 36*y^3 - 21*y^2, x^2*y + 162*y^3 - 99*y^2], Multivariate Polynomial Ring in x, y over Integers)\n\njulia> W = map(ZZ, [2, 5, 7])\n3-element Vector{BigInt}:\n 2\n 5\n 7\n\njulia> J = Ideal(ZZ, W)\nAbstractAlgebra.Generic.Ideal{BigInt}(BigInt[1], Integers)","category":"page"},{"location":"AbstractAlgebra/ideal/#Ideal-functions","page":"Ideal functionality","title":"Ideal functions","text":"","category":"section"},{"location":"AbstractAlgebra/ideal/#Basic-functionality","page":"Ideal functionality","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"gens(::Generic.Ideal{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ideal/#gens-Union{Tuple{AbstractAlgebra.Generic.Ideal{T}}, Tuple{T}} where T<:RingElement","page":"Ideal functionality","title":"gens","text":"gens(I::Ideal{T}) where T <: RingElement\n\nReturn a list of generators of the ideal I in reduced form and canonicalised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> V = [1 + 2x^2 + 3x^3, 5x^4 + 1, 2x - 1]\n3-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 3*x^3 + 2*x^2 + 1\n 5*x^4 + 1\n 2*x - 1\n\njulia> I = Ideal(R, V)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.Poly{BigInt}}(AbstractAlgebra.Generic.Poly{BigInt}[3, x + 1], Univariate Polynomial Ring in x over Integers)\n\njulia> gens(I)\n2-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 3\n x + 1","category":"page"},{"location":"AbstractAlgebra/ideal/#Arithmetic-of-Ideals","page":"Ideal functionality","title":"Arithmetic of Ideals","text":"","category":"section"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"Ideals support addition, multiplication, scalar multiplication and equality testing of ideals.","category":"page"},{"location":"AbstractAlgebra/ideal/#Containment","page":"Ideal functionality","title":"Containment","text":"","category":"section"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"contains(::Generic.Ideal{T}, ::Generic.Ideal{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ideal/#contains-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.Ideal{T}, AbstractAlgebra.Generic.Ideal{T}}} where T<:RingElement","page":"Ideal functionality","title":"contains","text":"Base.contains(I::Ideal{T}, J::Ideal{T}) where T <: RingElement\n\nReturn true if the ideal J is contained in the ideal I.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"intersection(::Generic.Ideal{T}, ::Generic.Ideal{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ideal/#intersection-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.Ideal{T}, AbstractAlgebra.Generic.Ideal{T}}} where T<:RingElement","page":"Ideal functionality","title":"intersection","text":"intersection(I::Ideal{T}, J::Ideal{T}) where T <: RingElement\n\nReturn the intersection of the ideals I and J.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> V = [1 + 2x^2 + 3x^3, 5x^4 + 1, 2x - 1]\n3-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 3*x^3 + 2*x^2 + 1\n 5*x^4 + 1\n 2*x - 1\n\njulia> W = [1 + 2x^2 + 3x^3, 5x^4 + 1]\n2-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 3*x^3 + 2*x^2 + 1\n 5*x^4 + 1\n\njulia> I = Ideal(R, V)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.Poly{BigInt}}(AbstractAlgebra.Generic.Poly{BigInt}[3, x + 1], Univariate Polynomial Ring in x over Integers)\n\njulia> J = Ideal(R, W)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.Poly{BigInt}}(AbstractAlgebra.Generic.Poly{BigInt}[282, 3*x + 255, x^2 + 107], Univariate Polynomial Ring in x over Integers)\n\njulia> contains(J, I)\nfalse\n\njulia> contains(I, J)\ntrue\n\njulia> intersection(I, J) == J\ntrue","category":"page"},{"location":"AbstractAlgebra/ideal/#Normal-form","page":"Ideal functionality","title":"Normal form","text":"","category":"section"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"For ideal of polynomial rings it is possible to return the normal form of a polynomial with respect to an ideal.","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"normal_form(::U, ::Generic.Ideal{U}) where {T <: RingElement, U <: Union{PolyElem{T}, MPolyElem{T}}}","category":"page"},{"location":"AbstractAlgebra/ideal/#normal_form-Union{Tuple{U}, Tuple{T}, Tuple{U, AbstractAlgebra.Generic.Ideal{U}}} where {T<:RingElement, U<:Union{MPolyElem{T}, PolyElem{T}}}","page":"Ideal functionality","title":"normal_form","text":"normal_form(p::U, I::Ideal{U}) where {T <: RingElement, U <: Union{AbstractAlgebra.PolyElem{T}, AbstractAlgebra.MPolyElem{T}}}\n\nReturn the normal form of the polynomial p with respect to the ideal I.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/ideal/","page":"Ideal functionality","title":"Ideal functionality","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"]; ordering=:degrevlex)\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> V = [3*x^2*y - 3*y^2, 9*x^2*y + 7*x*y]\n2-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n 3*x^2*y - 3*y^2\n 9*x^2*y + 7*x*y\n\njulia> I = Ideal(R, V)\nAbstractAlgebra.Generic.Ideal{AbstractAlgebra.Generic.MPoly{BigInt}}(AbstractAlgebra.Generic.MPoly{BigInt}[7*x*y + 9*y^2, 243*y^3 - 147*y^2, x*y^2 + 36*y^3 - 21*y^2, x^2*y + 162*y^3 - 99*y^2], Multivariate Polynomial Ring in x, y over Integers)\n\n\njulia> normal_form(30x^5*y + 2x + 1, I)\n135*y^4 + 138*y^3 - 147*y^2 + 2*x + 1","category":"page"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"CurrentModule = Oscar","category":"page"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"Pages = [\"CohomCalg.md\"]","category":"page"},{"location":"ToricVarieties/cohomCalg/#Line-bundle-cohomology-with-cohomCalg","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"","category":"section"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"We employ the cohomCalg algorithm  (2010) to compute the dimension of line bundle cohomologies as well as vanishing sets.","category":"page"},{"location":"ToricVarieties/cohomCalg/#Dimensions-of-line-bundle-cohomology","page":"Line bundle cohomology with cohomCalg","title":"Dimensions of line bundle cohomology","text":"","category":"section"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"all_cohomologies(l::ToricLineBundle)\ncohomology(l::ToricLineBundle, i::Int)","category":"page"},{"location":"ToricVarieties/cohomCalg/#all_cohomologies-Tuple{ToricLineBundle}","page":"Line bundle cohomology with cohomCalg","title":"all_cohomologies","text":"all_cohomologies(l::ToricLineBundle)\n\nComputes the dimension of all sheaf cohomologies of the  toric line bundle l by use of the cohomCalg algorithm  Ralph Blumenhagen, Benjamin Jurke, Thorsten Rahn, Helmut Roschy (2010), [cohomCalg:Implementation(@cite), Helmut Roschy, Thorsten Rahn (2010), Shin-Yao Jow (2011), Ralph Blumenhagen, Benjamin Jurke, Thorsten Rahn, Helmut Roschy (2012).\n\nExamples\n\njulia> dP3 = del_pezzo(3)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> all_cohomologies(ToricLineBundle(dP3, [1,2,3,4]))\n3-element Vector{fmpz}:\n 0\n 16\n 0\n\n\n\n","category":"method"},{"location":"ToricVarieties/cohomCalg/#cohomology-Tuple{ToricLineBundle, Int64}","page":"Line bundle cohomology with cohomCalg","title":"cohomology","text":"cohomology(l::ToricLineBundle, i::Int)\n\nComputes the dimension of the i-th sheaf cohomology of the toric line bundle l by use of the cohomCalg algorithm Ralph Blumenhagen, Benjamin Jurke, Thorsten Rahn, Helmut Roschy (2010), [cohomCalg:Implementation(@cite), Helmut Roschy, Thorsten Rahn (2010), Shin-Yao Jow (2011), Ralph Blumenhagen, Benjamin Jurke, Thorsten Rahn, Helmut Roschy (2012).\n\nExamples\n\njulia> dP3 = del_pezzo(3)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> cohomology(ToricLineBundle(dP3, [4,1,1,1]), 0)\n12\n\n\n\n","category":"method"},{"location":"ToricVarieties/cohomCalg/#Toric-vanishing-sets","page":"Line bundle cohomology with cohomCalg","title":"Toric vanishing sets","text":"","category":"section"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"Vanishing sets describe subsets of the Picard group of toric varieties. Their computations is based on  (2010), i.e. this functionality is only available if the toric variety in question is either smooth and complete or alternatively, simplicial and projective. This approach to identify vanishing sets on toric varieties was originally introduced in Martin Bies (2018). As described there, on a technical level, a vanishing set is the complement of a finite family of polyhedra.","category":"page"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"For a given toric variety tvs, the vanishing sets are computed as follows:","category":"page"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"vanishing_sets(variety::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/cohomCalg/#vanishing_sets-Tuple{Oscar.AbstractNormalToricVariety}","page":"Line bundle cohomology with cohomCalg","title":"vanishing_sets","text":"vanishing_sets(variety::AbstractNormalToricVariety)\n\nCompute the vanishing sets of an abstract toric variety v by use of the cohomCalg algorithm.\n\n\n\n","category":"method"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"The return value is a vector of vanishing sets. This vector has length dim(variety) + 1. The first vanishing set in this vector describes all line bundles for which the zero-th cohomology class vanishes. More generally, if a line bundle is contained in the k-th vanishing set, then its k-1th cohomology class vanishes. The following method can be used to check if a line bundle l is contained in a vanishing sets: toric vanishing set:","category":"page"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"contains(tvs::ToricVanishingSet, l::ToricLineBundle)","category":"page"},{"location":"ToricVarieties/cohomCalg/#contains-Tuple{ToricVanishingSet, ToricLineBundle}","page":"Line bundle cohomology with cohomCalg","title":"contains","text":"contains(tvs::ToricVanishingSet, l::ToricLineBundle)\n\nChecks if the toric line bundle l is contained in the toric vanishing set tvs.\n\nExamples\n\njulia> dP1 = del_pezzo(1)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(dP1, [3,2])\nA toric line bundle on a normal toric variety\n\njulia> all_cohomologies(l)\n3-element Vector{fmpz}:\n 7\n 0\n 0\n\njulia> vs = vanishing_sets(dP1)\n3-element Vector{ToricVanishingSet}:\n A toric vanishing set for cohomology index 0\n A toric vanishing set for cohomology index 1\n A toric vanishing set for cohomology index 2\n\njulia> contains(vs[1], l)\nfalse\n\njulia> contains(vs[2], l)\ntrue\n\njulia> contains(vs[3], l)\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"For each vanishing set, tvs we support the property isfull(tvs). It returns true if the vanishing set covers the entire Picard group. of the toric variety in question. Otherwise, it returns false.","category":"page"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"In addition, we support the following attributes:","category":"page"},{"location":"ToricVarieties/cohomCalg/","page":"Line bundle cohomology with cohomCalg","title":"Line bundle cohomology with cohomCalg","text":"toric_variety(tvs::ToricVanishingSet)\npolyhedra(tvs::ToricVanishingSet)\ncohomology_index(tvs::ToricVanishingSet)","category":"page"},{"location":"ToricVarieties/cohomCalg/#toric_variety-Tuple{ToricVanishingSet}","page":"Line bundle cohomology with cohomCalg","title":"toric_variety","text":"toric_variety(tvs::ToricVanishingSet)\n\nReturn the toric variety of the vanishing set tvs.\n\nExamples\n\njulia> dP1 = del_pezzo(1)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> vs = vanishing_sets(dP1)\n3-element Vector{ToricVanishingSet}:\n A toric vanishing set for cohomology index 0\n A toric vanishing set for cohomology index 1\n A toric vanishing set for cohomology index 2\n\njulia> toric_variety(vs[3])\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety over QQ without torusfactor\n\n\n\n","category":"method"},{"location":"ToricVarieties/cohomCalg/#polyhedra-Tuple{ToricVanishingSet}","page":"Line bundle cohomology with cohomCalg","title":"polyhedra","text":"polyhedra(tvs::ToricVanishingSet)\n\nReturn the vector of the polyhedra whose complement defines the vanishing set tvs.\n\nExamples\n\n```jldoctest julia> dP1 = del_pezzo(1) A normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> vs = vanishing_sets(dP1) 3-element Vector{ToricVanishingSet}:  A toric vanishing set for cohomology index 0  A toric vanishing set for cohomology index 1  A toric vanishing set for cohomology index 2\n\njulia> polyhedra(vs[3]) 1-element Vector{Polyhedra{fmpq}}:  A polyhedron in ambient dimension 2\n\n\n\n","category":"method"},{"location":"ToricVarieties/cohomCalg/#cohomology_index-Tuple{ToricVanishingSet}","page":"Line bundle cohomology with cohomCalg","title":"cohomology_index","text":"cohomology_index(tvs::ToricVanishingSet)\n\nReturn the cohomology index of the toric vanishing set tvs.\n\nExamples\n\njulia> dP1 = del_pezzo(1)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> vs = vanishing_sets(dP1)\n3-element Vector{ToricVanishingSet}:\n A toric vanishing set for cohomology index 0\n A toric vanishing set for cohomology index 1\n A toric vanishing set for cohomology index 2\n\njulia> cohomology_index(vs[3])\n2\n\n\n\n","category":"method"},{"location":"manualindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/gfp/#Galois-fields","page":"Galois fields","title":"Galois fields","text":"","category":"section"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"Nemo allows the creation of Galois fields of the form mathbbZpmathbbZ for a prime p. Note that these are not the same as finite fields of degree 1, as Conway polynomials are not used and no generator is given.","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"For convenience, the following constructors are provided.","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"GF(n::UInt)\nGF(n::Int)\nGF(n::fmpz)","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"For example, one can create the Galois field of characteristic 7 as follows.","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"R = GF(7)","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"Elements of the field are then created in the usual way.","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"a = R(3)","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"Elements of Galois fields have type gfp_elem when p is given to the constructor as an Int or UInt, and of type gfp_fmpz_elem if p is given as an fmpz, and the type of the parent objects is GaloisField or GaloisFmpzField respectively.","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"The modulus p of an element of a Galois field is stored in its parent object.","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"The gfp_elem and gfp_fmpz_elem types belong to the abstract type FinFieldElem and the GaloisField and GaloisFmpzField parent object types belong to the abstract type FinField.","category":"page"},{"location":"Nemo/gfp/#Galois-field-functionality","page":"Galois fields","title":"Galois field functionality","text":"","category":"section"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"Galois fields in Nemo provide all the residue ring functionality of AbstractAlgebra.jl:","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/residue","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"In addition, all the functionality for rings is available:","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/ring","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"Below we describe the functionality that is provided in addition to these.","category":"page"},{"location":"Nemo/gfp/#Basic-manipulation","page":"Galois fields","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"Examples","category":"page"},{"location":"Nemo/gfp/","page":"Galois fields","title":"Galois fields","text":"F = GF(3)\n\na = characteristic(F)\nb = order(F)","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/polynomial/#Univariate-polynomials","page":"Univariate polynomials","title":"Univariate polynomials","text":"","category":"section"},{"location":"Nemo/polynomial/#Introduction","page":"Univariate polynomials","title":"Introduction","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Nemo allow the creation of dense, univariate polynomials over any computable ring R. There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"The following table shows each of the polynomial types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.Poly{T} Generic.PolyRing{T}\nmathbbZ Flint fmpz_poly FmpzPolyRing\nmathbbZnmathbbZ (small n) Flint nmod_poly NmodPolyRing\nmathbbZnmathbbZ (large n) Flint fmpz_mod_poly FmpzModPolyRing\nmathbbQ Flint fmpq_poly FmpqPolyRing\nmathbbZpmathbbZ (small prime p) Flint gfp_poly GFPPolyRing\nmathbbZpmathbbZ (large prime p) Flint gfp_fmpz_poly GFPFmpzPolyRing\nmathbbF_p^n (small p) Flint fq_nmod_poly FqNmodPolyRing\nmathbbF_p^n (large p) Flint fq_poly FqPolyRing\nmathbbR Arb arb_poly ArbPolyRing\nmathbbC Arb acb_poly AcbPolyRing","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"The string representation of the variable and the base ring R of a generic polynomial is stored in its parent object. ","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"All polynomial element types belong to the abstract type PolyElem and all of the polynomial ring types belong to the abstract type PolyRing. This enables one to write generic functions that can accept any Nemo univariate polynomial type.","category":"page"},{"location":"Nemo/polynomial/#Polynomial-functionality","page":"Univariate polynomials","title":"Polynomial functionality","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"All univariate polynomial types in Nemo provide the AbstractAlgebra univariate polynomial functionality:","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/polynomial","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Generic polynomials are also available.","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"We describe here only functions that are in addition to that guaranteed by AbstractAlgebra.jl, for specific coefficient rings.","category":"page"},{"location":"Nemo/polynomial/#Remove-and-valuation","page":"Univariate polynomials","title":"Remove and valuation","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"evaluate2(::arb_poly, ::Integer)\nevaluate2(::arb_poly, ::Float64)\nevaluate2(::arb_poly, ::fmpz)\nevaluate2(::arb_poly, ::fmpq)\nevaluate2(::arb_poly, ::arb)\nevaluate2(::arb_poly, ::acb)","category":"page"},{"location":"Nemo/polynomial/#evaluate2-Tuple{arb_poly, Integer}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::arb_poly, y::Integer)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{arb_poly, Float64}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::arb_poly, y::Float64)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{arb_poly, fmpz}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::arb_poly, y::fmpz)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{arb_poly, fmpq}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::arb_poly, y::fmpq)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{arb_poly, arb}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::arb_poly, y::arb)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{arb_poly, acb}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::arb_poly, y::acb)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"evaluate2(::acb_poly, ::Integer)\nevaluate2(::acb_poly, ::Float64)\nevaluate2(::acb_poly, ::fmpz)\nevaluate2(::acb_poly, ::fmpq)\nevaluate2(::acb_poly, ::arb)\nevaluate2(::acb_poly, ::acb)","category":"page"},{"location":"Nemo/polynomial/#evaluate2-Tuple{acb_poly, Integer}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::acb_poly, y::Integer)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{acb_poly, Float64}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::acb_poly, y::Float64)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{acb_poly, fmpz}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::acb_poly, y::fmpz)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{acb_poly, fmpq}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::acb_poly, y::fmpq)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{acb_poly, arb}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::acb_poly, y::arb)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#evaluate2-Tuple{acb_poly, acb}","page":"Univariate polynomials","title":"evaluate2","text":"evaluate2(x::acb_poly, y::acb)\n\nReturn a tuple p q consisting of the polynomial x evaluated at y and its derivative evaluated at y.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"RR = RealField(64)\nT, z = PolynomialRing(RR, \"z\")\n   \nh = z^2 + 2z + 1\n\ns, t = evaluate2(h, RR(\"2.0 +/- 0.1\"))","category":"page"},{"location":"Nemo/polynomial/#Signature","page":"Univariate polynomials","title":"Signature","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"signature(::fmpz_poly)\nsignature(::fmpq_poly)","category":"page"},{"location":"Nemo/polynomial/#signature-Tuple{fmpz_poly}","page":"Univariate polynomials","title":"signature","text":"signature(f::fmpz_poly)\n\nReturn the signature of the polynomial f, i.e. a tuple (r s) such that r is the number of real roots of f and s is half the number of complex roots.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#signature-Tuple{fmpq_poly}","page":"Univariate polynomials","title":"signature","text":"signature(f::fmpq_poly)\n\nReturn the signature of f, i.e. a tuple (r s) where r is the number of real roots of f and s is half the number of complex roots.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"R, x = PolynomialRing(ZZ, \"x\")\n\nf = x^3 + 3x + 1\n\n(r, s) = signature(f)","category":"page"},{"location":"Nemo/polynomial/#Root-finding","page":"Univariate polynomials","title":"Root finding","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"roots(::acb_poly)","category":"page"},{"location":"Nemo/polynomial/#roots-Tuple{acb_poly}","page":"Univariate polynomials","title":"roots","text":"roots(x::acb_poly; target=0, isolate_real=false, initial_prec=0, max_prec=0, max_iter=0)\n\nAttempts to isolate the complex roots of the complex polynomial x by iteratively refining balls in which they lie.\n\nThis is done by increasing the working precision, starting at initial_prec. The maximal number of iterations can be set using max_iter and the maximal precision can be set using max_prec.\n\nIf isolate_real is set and x is strictly real, then the real roots will be isolated from the non-real roots. Every root will have either zero, positive or negative real part.\n\nIt is assumed that x is squarefree.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"CC = ComplexField(64)\nC, y = PolynomialRing(CC, \"y\")\n\nm = y^2 + 2y + 3\nn = m + CC(\"0 +/- 0.0001\", \"0 +/- 0.0001\")\n\nr = roots(n)\n\np = y^7 - 1\n\nr = roots(n, isolate_real = true)","category":"page"},{"location":"Nemo/polynomial/#Construction-from-roots","page":"Univariate polynomials","title":"Construction from roots","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"from_roots(::ArbPolyRing, ::Vector{arb})\nfrom_roots(::AcbPolyRing, ::Vector{acb})","category":"page"},{"location":"Nemo/polynomial/#from_roots-Tuple{ArbPolyRing, Vector{arb}}","page":"Univariate polynomials","title":"from_roots","text":"from_roots(R::ArbPolyRing, b::Vector{arb})\n\nConstruct a polynomial in the given polynomial ring from a list of its roots.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#from_roots-Tuple{AcbPolyRing, Vector{acb}}","page":"Univariate polynomials","title":"from_roots","text":"from_roots(R::AcbPolyRing, b::Vector{acb})\n\nConstruct a polynomial in the given polynomial ring from a list of its roots.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"RR = RealField(64)\nR, x = PolynomialRing(RR, \"x\")\n\nxs = arb[inv(RR(i)) for i=1:5]\nf = from_roots(R, xs)","category":"page"},{"location":"Nemo/polynomial/#Bounding-absolute-values-of-roots","page":"Univariate polynomials","title":"Bounding absolute values of roots","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"roots_upper_bound(::arb_poly)\nroots_upper_bound(::acb_poly)","category":"page"},{"location":"Nemo/polynomial/#roots_upper_bound-Tuple{arb_poly}","page":"Univariate polynomials","title":"roots_upper_bound","text":"roots_upper_bound(x::arb_poly) -> arb\n\nReturns an upper bound for the absolute value of all complex roots of x.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#roots_upper_bound-Tuple{acb_poly}","page":"Univariate polynomials","title":"roots_upper_bound","text":"roots_upper_bound(x::acb_poly) -> arb\n\nReturns an upper bound for the absolute value of all complex roots of x.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#Lifting","page":"Univariate polynomials","title":"Lifting","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"When working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from mathbbZnmathbbZ to mathbbZ.","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"lift(::FmpzPolyRing, ::nmod_poly)\nlift(::FmpzPolyRing, ::gfp_poly)\nlift(::FmpzPolyRing, ::fmpz_mod_poly)\nlift(::FmpzPolyRing, ::gfp_fmpz_poly)","category":"page"},{"location":"Nemo/polynomial/#lift-Tuple{FmpzPolyRing, nmod_poly}","page":"Univariate polynomials","title":"lift","text":"lift(R::FmpzPolyRing, y::nmod_poly)\n\nLift from a polynomial over mathbbZnmathbbZ to a polynomial over mathbbZ with minimal reduced nonnegative coefficients. The ring R specifies the ring to lift into.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#lift-Tuple{FmpzPolyRing, gfp_poly}","page":"Univariate polynomials","title":"lift","text":"lift(R::FmpzPolyRing, y::gfp_poly)\n\nLift from a polynomial over mathbbZnmathbbZ to a polynomial over mathbbZ with minimal reduced nonnegative coefficients. The ring R specifies the ring to lift into.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#lift-Tuple{FmpzPolyRing, fmpz_mod_poly}","page":"Univariate polynomials","title":"lift","text":"lift(R::FmpzPolyRing, y::fmpz_mod_poly)\n\nLift from a polynomial over mathbbZnmathbbZ to a polynomial over mathbbZ with minimal reduced nonnegative coefficients. The ring R specifies the ring to lift into.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#lift-Tuple{FmpzPolyRing, gfp_fmpz_poly}","page":"Univariate polynomials","title":"lift","text":"lift(R::FmpzPolyRing, y::gfp_fmpz_poly)\n\nLift from a polynomial over mathbbZnmathbbZ to a polynomial over mathbbZ with minimal reduced nonnegative coefficients. The ring R specifies the ring to lift into.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"R = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R, \"x\")\nT, y = PolynomialRing(ZZ, \"y\")\n\nf = x^2 + 2x + 1\n\na = lift(T, f)","category":"page"},{"location":"Nemo/polynomial/#Overlapping-and-containment","page":"Univariate polynomials","title":"Overlapping and containment","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Occasionally it is useful to be able to tell when inexact polynomials overlap or contain other exact or inexact polynomials. The following functions are provided for this purpose.","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"overlaps(::arb_poly, ::arb_poly)\noverlaps(::acb_poly, ::acb_poly)","category":"page"},{"location":"Nemo/polynomial/#overlaps-Tuple{arb_poly, arb_poly}","page":"Univariate polynomials","title":"overlaps","text":"overlaps(x::arb_poly, y::arb_poly)\n\nReturn true if the coefficient balls of x overlap the coefficient balls of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#overlaps-Tuple{acb_poly, acb_poly}","page":"Univariate polynomials","title":"overlaps","text":"overlaps(x::acb_poly, y::acb_poly)\n\nReturn true if the coefficient boxes of x overlap the coefficient boxes of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"contains(::arb_poly, ::arb_poly)\ncontains(::acb_poly, ::acb_poly)","category":"page"},{"location":"Nemo/polynomial/#contains-Tuple{arb_poly, arb_poly}","page":"Univariate polynomials","title":"contains","text":"contains(x::arb_poly, y::arb_poly)\n\nReturn true if the coefficient balls of x contain the corresponding coefficient balls of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#contains-Tuple{acb_poly, acb_poly}","page":"Univariate polynomials","title":"contains","text":"contains(x::acb_poly, y::acb_poly)\n\nReturn true if the coefficient boxes of x contain the corresponding coefficient boxes of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"contains(::arb_poly, ::fmpz_poly)\ncontains(::arb_poly, ::fmpq_poly)\ncontains(::acb_poly, ::fmpz_poly)\ncontains(::acb_poly, ::fmpq_poly)","category":"page"},{"location":"Nemo/polynomial/#contains-Tuple{arb_poly, fmpz_poly}","page":"Univariate polynomials","title":"contains","text":"contains(x::arb_poly, y::fmpz_poly)\n\nReturn true if the coefficient balls of x contain the corresponding exact coefficients of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#contains-Tuple{arb_poly, fmpq_poly}","page":"Univariate polynomials","title":"contains","text":"contains(x::arb_poly, y::fmpq_poly)\n\nReturn true if the coefficient balls of x contain the corresponding exact coefficients of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#contains-Tuple{acb_poly, fmpz_poly}","page":"Univariate polynomials","title":"contains","text":"contains(x::acb_poly, y::fmpz_poly)\n\nReturn true if the coefficient boxes of x contain the corresponding exact coefficients of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#contains-Tuple{acb_poly, fmpq_poly}","page":"Univariate polynomials","title":"contains","text":"contains(x::acb_poly, y::fmpq_poly)\n\nReturn true if the coefficient boxes of x contain the corresponding exact coefficients of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"It is sometimes also useful to be able to determine if there is a unique integer contained in the coefficient of an inexact constant polynomial.","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"unique_integer(::arb_poly)\nunique_integer(::acb_poly)","category":"page"},{"location":"Nemo/polynomial/#unique_integer-Tuple{arb_poly}","page":"Univariate polynomials","title":"unique_integer","text":"unique_integer(x::arb_poly)\n\nReturn a tuple (t, z) where t is true if there is a unique integer contained in each of the coefficients of x, otherwise sets t to false. In the former case, z is set to the integer polynomial.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#unique_integer-Tuple{acb_poly}","page":"Univariate polynomials","title":"unique_integer","text":"unique_integer(x::acb_poly)\n\nReturn a tuple (t, z) where t is true if there is a unique integer contained in the (constant) polynomial x, along with that integer z in case it is, otherwise sets t to false.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"RR = RealField(64)\nCC = ComplexField(64)\nR, x = PolynomialRing(RR, \"x\")\nC, y = PolynomialRing(CC, \"y\")\nZx, zx = PolynomialRing(ZZ, \"x\")\nQx, qx = PolynomialRing(QQ, \"x\")\n\nf = x^2 + 2x + 1\nh = f + RR(\"0 +/- 0.0001\")\nk = f + RR(\"0 +/- 0.0001\") * x^4\nm = y^2 + 2y + 1\nn = m + CC(\"0 +/- 0.0001\", \"0 +/- 0.0001\")\n\ncontains(h, f)\noverlaps(f, k)\ncontains(n, m)\nt, z = unique_integer(k)\nisreal(n)","category":"page"},{"location":"Nemo/polynomial/#Factorisation","page":"Univariate polynomials","title":"Factorisation","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Certain polynomials can be factored (fmpz_poly',nmodpoly,gfppoly,fmpzmodpoly,gfpfmpzpoly,fqpoly,fqnmod_poly`) and the interface follows the specification in AbstractAlgebra.jl. The following additional functions are available.","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"factor_distinct_deg(::nmod_poly)\nfactor_distinct_deg(::gfp_poly)\nfactor_distinct_deg(::fmpz_mod_poly)\nfactor_distinct_deg(::gfp_fmpz_poly)\nfactor_distinct_deg(::fq_poly)\nfactor_distinct_deg(::fq_nmod_poly)","category":"page"},{"location":"Nemo/polynomial/#factor_distinct_deg-Tuple{nmod_poly}","page":"Univariate polynomials","title":"factor_distinct_deg","text":"factor_distinct_deg(x::nmod_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#factor_distinct_deg-Tuple{gfp_poly}","page":"Univariate polynomials","title":"factor_distinct_deg","text":"factor_distinct_deg(x::gfp_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#factor_distinct_deg-Tuple{fmpz_mod_poly}","page":"Univariate polynomials","title":"factor_distinct_deg","text":"factor_distinct_deg(x::fmpz_mod_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#factor_distinct_deg-Tuple{gfp_fmpz_poly}","page":"Univariate polynomials","title":"factor_distinct_deg","text":"factor_distinct_deg(x::fmpz_mod_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#factor_distinct_deg-Tuple{fq_poly}","page":"Univariate polynomials","title":"factor_distinct_deg","text":"factor_distinct_deg(x::fq_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/#factor_distinct_deg-Tuple{fq_nmod_poly}","page":"Univariate polynomials","title":"factor_distinct_deg","text":"factor_distinct_deg(x::fq_nmod_poly)\n\nReturn the distinct degree factorisation of a squarefree polynomial x.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"R = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R, \"x\")\n\nf = x^2 + 2x + 1\ng = x^3 + 3x + 1\n\nR = factor(f*g)\nS = factor_squarefree(f*g)\nT = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))","category":"page"},{"location":"Nemo/polynomial/#Special-functions","page":"Univariate polynomials","title":"Special functions","text":"","category":"section"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"cyclotomic(::Int, ::fmpz_poly)","category":"page"},{"location":"Nemo/polynomial/#cyclotomic-Tuple{Int64, fmpz_poly}","page":"Univariate polynomials","title":"cyclotomic","text":"cyclotomic(n::Int, x::fmpz_poly)\n\nReturn the nth cyclotomic polynomial, defined as Phi_n(x) = prod_omega (x-omega) where omega runs over all the nth primitive roots of unity.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"swinnerton_dyer(::Int, ::fmpz_poly)","category":"page"},{"location":"Nemo/polynomial/#swinnerton_dyer-Tuple{Int64, fmpz_poly}","page":"Univariate polynomials","title":"swinnerton_dyer","text":"swinnerton_dyer(n::Int, x::fmpz_poly)\n\nReturn the Swinnerton-Dyer polynomial S_n, defined as the integer polynomial S_n = prod (x pm sqrt2 pm sqrt3 pm sqrt5 pm ldots pm sqrtp_n) where p_n denotes the n-th prime number and all combinations of signs are taken. This polynomial has degree 2^n and is irreducible over the integers (it is the minimal polynomial of sqrt2 + ldots + sqrtp_n).\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"cos_minpoly(::Int, ::fmpz_poly)","category":"page"},{"location":"Nemo/polynomial/#cos_minpoly-Tuple{Int64, fmpz_poly}","page":"Univariate polynomials","title":"cos_minpoly","text":"cos_minpoly(n::Int, x::fmpz_poly)\n\nReturn the minimal polynomial of 2 cos(2 pi  n). For suitable choice of n, this gives the minimal polynomial of 2 cos(a pi) or 2 sin(a pi) for any rational a.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"theta_qexp(::Int, ::Int, ::fmpz_poly)","category":"page"},{"location":"Nemo/polynomial/#theta_qexp-Tuple{Int64, Int64, fmpz_poly}","page":"Univariate polynomials","title":"theta_qexp","text":"theta_qexp(e::Int, n::Int, x::fmpz_poly)\n\nReturn the q-expansion to length n of the Jacobi theta function raised to the power r, i.e. vartheta(q)^r where vartheta(q) = 1 + sum_k=1^infty q^k^2.\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"eta_qexp(::Int, ::Int, ::fmpz_poly)","category":"page"},{"location":"Nemo/polynomial/#eta_qexp-Tuple{Int64, Int64, fmpz_poly}","page":"Univariate polynomials","title":"eta_qexp","text":"eta_qexp(e::Int, n::Int, x::fmpz_poly)\n\nReturn the q-expansion to length n of the Dedekind eta function (without the leading factor q^124) raised to the power r, i.e. (q^-124 eta(q))^r = prod_k=1^infty (1 - q^k)^r. In particular, r = -1 gives the generating function of the partition function p(k), and r = 24 gives, after multiplication by q, the modular discriminant Delta(q) which generates the Ramanujan tau function tau(k).\n\n\n\n","category":"method"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"Examples","category":"page"},{"location":"Nemo/polynomial/","page":"Univariate polynomials","title":"Univariate polynomials","text":"R, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")\n\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/numberfield/#Number-field-arithmetic","page":"Number field arithmetic","title":"Number field arithmetic","text":"","category":"section"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Number fields are provided in Nemo by Antic. This allows construction of absolute number fields and basic arithmetic computations therein.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Number fields are constructed using the AnticNumberField function. However, for convenience we define","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"NumberField = AnticNumberField","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"so that number fields can be constructed using NumberField rather than AnticNumberField. ","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The types of number field elements in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Library Field Element type Parent type\nAntic mathbbQx(f) nf_elem AnticNumberField","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"All the number field types belong to the Field abstract type and the number field element types belong to the FieldElem abstract type.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The Hecke.jl library radically expands on number field functionality, providing ideals, orders, class groups, relative extensions, class field theory, etc.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The basic number field element type used in Hecke is the Nemo/antic number field element type, making the two libraries tightly integrated.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"https://thofma.github.io/Hecke.jl/stable/","category":"page"},{"location":"Nemo/numberfield/#Number-field-functionality","page":"Number field arithmetic","title":"Number field functionality","text":"","category":"section"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The number fields in Nemo provide all of the AbstractAlgebra field functionality:","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Below, we document the additional functionality provided for number field elements.","category":"page"},{"location":"Nemo/numberfield/#Constructors","page":"Number field arithmetic","title":"Constructors","text":"","category":"section"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"In order to construct number field elements in Nemo, one must first construct the number field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"NumberField(::fmpq_poly, ::String)\nCyclotomicField(::Int, ::String)\nCyclotomicRealSubfield(::Int, ::String)","category":"page"},{"location":"Nemo/numberfield/#NumberField-Tuple{fmpq_poly, String}","page":"Number field arithmetic","title":"NumberField","text":"NumberField(f::fmpq_poly, s::Union{AbstractString, Char, Symbol};\n            cached::Bool = true, check::Bool = true)\n\nReturn a tuple R x consisting of the parent object R and generator x of the number field mathbbQx(f) where f is the supplied polynomial. The supplied string s specifies how the generator of the number field should be printed.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/#CyclotomicField-Tuple{Int64, String}","page":"Number field arithmetic","title":"CyclotomicField","text":"CyclotomicField(n::Int, s::Union{AbstractString, Char, Symbol} = \"z_$n\", t = \"_\\$\"; cached = true)\n\nReturn a tuple R x consisting of the parent object R and generator x of the n-th cyclotomic field, mathbbQ(zeta_n). The supplied string s specifies how the generator of the number field should be printed. If provided, the string t specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/#CyclotomicRealSubfield-Tuple{Int64, String}","page":"Number field arithmetic","title":"CyclotomicRealSubfield","text":"CyclotomicRealSubfield(n::Int, s::Union{AbstractString, Char, Symbol} = \"(z_$n + 1/z_$n)\", t = \"\\$\"; cached = true)\n\nReturn a tuple R x consisting of the parent object R and generator x of the totally real subfield of the n-th cyclotomic field, mathbbQ(zeta_n). The supplied string s specifies how the generator of the number field should be printed. If provided, the string t specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Here are some examples of creating number fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\nL, b = CyclotomicField(5, \"b\")\nM, c = CyclotomicRealField(5, \"c\")\n\nd = K(3)\nf = L(b)\ng = L(ZZ(11))\nh = L(ZZ(11)//3)\nk = M(x)","category":"page"},{"location":"Nemo/numberfield/#Number-field-element-constructors","page":"Number field arithmetic","title":"Number field element constructors","text":"","category":"section"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"gen(::AnticNumberField)","category":"page"},{"location":"Nemo/numberfield/#gen-Tuple{AnticNumberField}","page":"Number field arithmetic","title":"gen","text":"gen(a::AnticNumberField)\n\nReturn the generator of the given number field.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The easiest way of constructing number field elements is to use element arithmetic with the generator, to construct the desired element by its representation as a polynomial. See the following examples for how to do this.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\n\nd = gen(K)\nf = a^2 + 2a - 7","category":"page"},{"location":"Nemo/numberfield/#Basic-functionality","page":"Number field arithmetic","title":"Basic functionality","text":"","category":"section"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"mul_red!(::nf_elem, ::nf_elem, ::nf_elem, ::Bool)","category":"page"},{"location":"Nemo/numberfield/#mul_red!-Tuple{nf_elem, nf_elem, nf_elem, Bool}","page":"Number field arithmetic","title":"mul_red!","text":"mul_red!(z::nf_elem, x::nf_elem, y::nf_elem, red::Bool)\n\nMultiply x by y and set the existing number field element z to the result. Reduction modulo the defining polynomial is only performed if red is set to true. Note that x and y must be reduced. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"reduce!(::nf_elem)","category":"page"},{"location":"Nemo/numberfield/#reduce!-Tuple{nf_elem}","page":"Number field arithmetic","title":"reduce!","text":"reduce!(x::nf_elem)\n\nReduce the given number field element by the defining polynomial, in-place. This only needs to be done after accumulating values computed by mul_red! where reduction has not been performed. All standard Nemo number field functions automatically reduce their outputs.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"The following coercion function is provided for a number field R.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R(f::fmpq_poly)","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Coerce the given rational polynomial into the number field R, i.e. consider the polynomial to be the representation of a number field element and return it.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Conversely, if R is the polynomial ring to which the generating polynomial of a number field belongs, then we can coerce number field elements into the ring R using the following function.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R(b::nf_elem)","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Coerce the given number field element into the polynomial ring R of which the number field is a quotient.","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\n\nf = R(a^2 + 2a + 3)\ng = K(x^2 + 2x + 1)","category":"page"},{"location":"Nemo/numberfield/#Basic-manipulation","page":"Number field arithmetic","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"var(::AnticNumberField)","category":"page"},{"location":"Nemo/numberfield/#var-Tuple{AnticNumberField}","page":"Number field arithmetic","title":"var","text":"var(a::AnticNumberField)\n\nReturns the identifier (as a symbol, not a string), that is used for printing the generator of the given number field.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"isgen(::nf_elem)","category":"page"},{"location":"Nemo/numberfield/#isgen-Tuple{nf_elem}","page":"Number field arithmetic","title":"isgen","text":"isgen(a::nf_elem)\n\nReturn true if the given number field element is the generator of the number field, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"coeff(::nf_elem, ::Int)","category":"page"},{"location":"Nemo/numberfield/#coeff-Tuple{nf_elem, Int64}","page":"Number field arithmetic","title":"coeff","text":"coeff(x::nf_elem, n::Int)\n\nReturn the n-th coefficient of the polynomial representation of the given number field element. Coefficients are numbered from 0, starting with the constant coefficient.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"denominator(::nf_elem)","category":"page"},{"location":"Nemo/numberfield/#denominator-Tuple{nf_elem}","page":"Number field arithmetic","title":"denominator","text":"denominator(a::nf_elem)\n\nReturn the denominator of the polynomial representation of the given number field element.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"degree(::AnticNumberField)","category":"page"},{"location":"Nemo/numberfield/#degree-Tuple{AnticNumberField}","page":"Number field arithmetic","title":"degree","text":"degree(a::AnticNumberField)\n\nReturn the degree of the given number field, i.e. the degree of its defining polynomial.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\n\nd = a^2 + 2a - 7\nm = gen(K)\n\nc = coeff(d, 1)\nisgen(m)\nq = degree(K)\nr, s = signature(K)\nv = var(R)","category":"page"},{"location":"Nemo/numberfield/#Norm-and-trace","page":"Number field arithmetic","title":"Norm and trace","text":"","category":"section"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"norm(::nf_elem)","category":"page"},{"location":"Nemo/numberfield/#norm-Tuple{nf_elem}","page":"Number field arithmetic","title":"norm","text":"norm(a::nf_elem)\n\nReturn the absolute norm of a. The result will be a rational number.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"tr(::nf_elem)","category":"page"},{"location":"Nemo/numberfield/#tr-Tuple{nf_elem}","page":"Number field arithmetic","title":"tr","text":"tr(a::nf_elem)\n\nReturn the absolute trace of a. The result will be a rational number.\n\n\n\n","category":"method"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"Examples","category":"page"},{"location":"Nemo/numberfield/","page":"Number field arithmetic","title":"Number field arithmetic","text":"R, x = PolynomialRing(QQ, \"x\")\nK, a = NumberField(x^3 + 3x + 1, \"a\")\n\nc = 3a^2 - a + 1\n\nd = norm(c)\nf = tr(c)","category":"page"},{"location":"ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"CurrentModule = Oscar","category":"page"},{"location":"ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"Pages = [\"CyclicQuotientSingularities.md\"]","category":"page"},{"location":"ToricVarieties/CyclicQuotientSingularities/#Cyclic-Quotient-Singularities","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"","category":"section"},{"location":"ToricVarieties/CyclicQuotientSingularities/#Introduction","page":"Cyclic Quotient Singularities","title":"Introduction","text":"","category":"section"},{"location":"ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"Cyclic quotient singularities are quotients of mathbbC^2 by the action of mathbbZnmathbbZ acting via  left(beginarrayccxi  00  xi^qendarrayright), where xi is a n-th root of unity, and q and n are integers, such that q is coprime with n, and 0qn.","category":"page"},{"location":"ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"For the notation we rely on Jan Arthur Christophersen (1991) and Jan Stevens (1991).","category":"page"},{"location":"ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"warning: Warning\nNote that Jan Arthur Christophersen (1991) and Jan Stevens (1991) use Hirzebruch-Jung continued fraction, which differ from the commonly known continued fraction from literature and used in the rest of OSCAR.","category":"page"},{"location":"ToricVarieties/CyclicQuotientSingularities/#Constructors","page":"Cyclic Quotient Singularities","title":"Constructors","text":"","category":"section"},{"location":"ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"CyclicQuotientSingularity(n::fmpz, q::fmpz)","category":"page"},{"location":"ToricVarieties/CyclicQuotientSingularities/#CyclicQuotientSingularity-Tuple{fmpz, fmpz}","page":"Cyclic Quotient Singularities","title":"CyclicQuotientSingularity","text":"CyclicQuotientSingularity(n::fmpz, q::fmpz)\n\nReturn the cyclic quotient singularity for the parameters n and q, with 0qn and qn coprime.\n\nExamples\n\njulia> cqs = CyclicQuotientSingularity(7,5)\nThe cyclic quotient singularity Y(7, 5)\n\njulia> isaffine(cqs)\ntrue\n\njulia> issmooth(cqs)\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/CyclicQuotientSingularities/#Attributes","page":"Cyclic Quotient Singularities","title":"Attributes","text":"","category":"section"},{"location":"ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"continued_fraction_hirzebruch_jung(cqs::CyclicQuotientSingularity)\ndual_continued_fraction_hirzebruch_jung(cqs::CyclicQuotientSingularity)","category":"page"},{"location":"ToricVarieties/CyclicQuotientSingularities/#continued_fraction_hirzebruch_jung-Tuple{CyclicQuotientSingularity}","page":"Cyclic Quotient Singularities","title":"continued_fraction_hirzebruch_jung","text":"continued_fraction_hirzebruch_jung(cqs::CyclicQuotientSingularity)\n\nReturn the Hirzebruch-Jung continued fraction associated with the cyclic quotient singularity, i.e. the Hirzebruch-Jung continued fraction corresponding to nq.\n\nThe rational number corresponding to a Hirzebruch-Jung continued fraction c_1c_2ldotsc_n is r(c_1c_2ldotsc_n) =\nc_1-frac1r(c_2ldotsc_n) where r(c_n) = c_n.  Note that this is differs in sign from what is commonly known as continued fraction.\n\nExamples\n\njulia> cqs = CyclicQuotientSingularity(7,5)\nThe cyclic quotient singularity Y(7, 5)\n\njulia> cf = continued_fraction_hirzebruch_jung(cqs)\n3-element Vector{fmpz}:\n 2\n 2\n 3\n\njulia> ecf = cf[1]-1//(cf[2]-fmpq(1,cf[3]))\n7//5\n\n\n\n","category":"method"},{"location":"ToricVarieties/CyclicQuotientSingularities/#dual_continued_fraction_hirzebruch_jung-Tuple{CyclicQuotientSingularity}","page":"Cyclic Quotient Singularities","title":"dual_continued_fraction_hirzebruch_jung","text":"dual_continued_fraction_hirzebruch_jung(cqs::CyclicQuotientSingularity)\n\nReturn the dual Hirzebruch-Jung continued fraction associated with the cyclic quotient singularity, i.e. the Hirzebruch-Jung continued fraction corresponding to q(n-q).\n\nThe rational number corresponding to a Hirzebruch-Jung continued fraction c_1c_2ldotsc_n is r(c_1c_2ldotsc_n) =\nc_1-frac1r(c_2ldotsc_n) where r(c_n) = c_n.  Note that this is differs in sign from what is commonly known as continued fraction.\n\nExamples\n\njulia> cqs = CyclicQuotientSingularity(7,5)\nThe cyclic quotient singularity Y(7, 5)\n\njulia> dcf = dual_continued_fraction_hirzebruch_jung(cqs)\n2-element Vector{fmpz}:\n 4\n 2\n\njulia> edcf = dcf[1] - fmpq(1,dcf[2])\n7//2\n\n\n\n","category":"method"},{"location":"ToricVarieties/CyclicQuotientSingularities/#Auxillary-Methods","page":"Cyclic Quotient Singularities","title":"Auxillary Methods","text":"","category":"section"},{"location":"ToricVarieties/CyclicQuotientSingularities/","page":"Cyclic Quotient Singularities","title":"Cyclic Quotient Singularities","text":"continued_fraction_hirzebruch_jung_to_rational(v::Vector{fmpz})\nrational_to_continued_fraction_hirzebruch_jung(r::fmpq)","category":"page"},{"location":"ToricVarieties/CyclicQuotientSingularities/#continued_fraction_hirzebruch_jung_to_rational-Tuple{Vector{fmpz}}","page":"Cyclic Quotient Singularities","title":"continued_fraction_hirzebruch_jung_to_rational","text":"continued_fraction_hirzebruch_jung_to_rational(v::Vector{fmpz})\n\nReturn the rational number corresponding to a Hirzebruch-Jung continued fraction given as a vector of (positive) integers.\n\nThe rational number corresponding to a Hirzebruch-Jung continued fraction c_1c_2ldotsc_n is r(c_1c_2ldotsc_n) =\nc_1-frac1r(c_2ldotsc_n) where r(c_n) = c_n.  Note that this is differs in sign from what is commonly known as continued fraction.\n\nExamples\n\njulia> cqs = CyclicQuotientSingularity(7,5)\nThe cyclic quotient singularity Y(7, 5)\n\njulia> v = continued_fraction_hirzebruch_jung(cqs)\n3-element Vector{fmpz}:\n 2\n 2\n 3\n\njulia> continued_fraction_hirzebruch_jung_to_rational(v)\n7//5\n\n\n\n","category":"method"},{"location":"ToricVarieties/CyclicQuotientSingularities/#rational_to_continued_fraction_hirzebruch_jung-Tuple{fmpq}","page":"Cyclic Quotient Singularities","title":"rational_to_continued_fraction_hirzebruch_jung","text":"rational_to_continued_fraction_hirzebruch_jung(r::fmpq)\n\nEncode a (positive) rational number as a Hirzebruch-Jung continued fraction, i.e. find the Hirzebruch-Jung continued fraction corresponding to the given rational number.\n\nThe rational number corresponding to a Hirzebruch-Jung continued fraction c_1c_2ldotsc_n is r(c_1c_2ldotsc_n) =\nc_1-frac1r(c_2ldotsc_n) where r(c_n) = c_n.  Note that this is differs in sign from what is commonly known as continued fraction.\n\nExamples\n\njulia> r = fmpq(2464144958, 145732115)\n2464144958//145732115\n\njulia> cf = rational_to_continued_fraction_hirzebruch_jung(r)\n7-element Vector{fmpz}:\n 17\n 11\n 23\n 46\n 18\n 19\n 37\n\njulia> continued_fraction_hirzebruch_jung_to_rational(cf)\n2464144958//145732115\n\njulia> r == continued_fraction_hirzebruch_jung_to_rational(cf)\ntrue\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/univpolynomial/#Universal-polynomial","page":"Universal polynomial","title":"Universal polynomial","text":"","category":"section"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"AbstractAlgebra.jl provides a module, implemented in src/generic/UnivPoly.jl for a universal polynomial ring. This is very similar to the multivariate polynomial rings, except that variables can be added to the ring at any time.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"To compensate for the fact that the number of variables may change, many of the functions relax their restrictions on exponent vectors. For example, if one creates a polynomial when the ring only has two variables, each exponent vector would consist of two integers. Later, when the ring has more variable, these exponent vectors will still be accepted. The exponent vectors are simply padded out to the full number of variables behind the scenes.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/#Generic-sparse-distributed-universal-multivariable-polynomial-types","page":"Universal polynomial","title":"Generic sparse distributed universal multivariable polynomial types","text":"","category":"section"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"AbstractAlgebra provides a generic universal polynomial type Generic.UnivPoly{T, U} where T is the type of elements of the coefficient ring and U is the type of the elements of the underlying multivariate polynomial ring. Essentially, U can be any type belonging to MPolyElem{T}.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"Parent objects of such polynomials have type Generic.UnivPolyRing{T, U}.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/#Abstract-types","page":"Universal polynomial","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"AbstractAlgebra also provides abstract types for universal polynomials and their rings. These are UnivPolyElem{T, U} and UnivPolyRing{T, U} respectively. These in turn belong to Ring.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/#Polynomial-ring-constructors","page":"Universal polynomial","title":"Polynomial ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"In order to construct universal polynomials in AbstractAlgebra.jl, one must first construct the universal polynomial ring itself. This is unique given a base ring.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"The universal polynomial ring over a given base ring R is constructed with one of the following constructor functions.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"UniversalPolynomialRing(R::Ring; cached::Bool = true, ordering::Symbol=:lex)","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"Given a base ring R and an array S of strings, return an object representing the universal polynomial ring S = Rldots with no variables in it initially.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"Examples","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"julia> S = UniversalPolynomialRing(ZZ)\nUniversal Polynomial Ring over Integers","category":"page"},{"location":"AbstractAlgebra/univpolynomial/#Adding-variables","page":"Universal polynomial","title":"Adding variables","text":"","category":"section"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"There are two ways to add variables to a universal polynomial ring S.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"gen(S::UnivPolyRing, var::T) where T <: Union{Char, Symbol, String}\ngens(S::UnivPolyRing, vars::Vector{T}) where T <: Union{Char, Symbol, String}","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"Examples","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"julia> S = UniversalPolynomialRing(ZZ)\nUniversal Polynomial Ring over Integers\n\njulia> x = gen(S, \"x\")\nx\n\njulia> y, z = gens(S, [\"y\", \"z\"])\n(y, z)","category":"page"},{"location":"AbstractAlgebra/univpolynomial/#Universal-polynomial-functionality","page":"Universal polynomial","title":"Universal polynomial functionality","text":"","category":"section"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"The universal polynomial ring behaves exactly like a multivariate polynomial ring with the few differences noted above.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"The only functionality not implemented is the ability to do divrem by an ideal of polynomials.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"The universal polynomial ring is very useful for doing symbolic manipulation. However, it is important to understand that AbstractAlgebra is not a symbolic system and the performance of the universal polynomial ring will closely match that of a multivariate polynomial ring with the same number of variables.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"The disadvantage of this approach to symbolic manipulation is that some manipulations that would be offered by a symbolic system are not available, as variables are not identified by their names alone in AbstractAlgebra, as would be the case symbolically, but by objects.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"The most powerful symbolic tools we offer are the generalised evaluation functions, the multivariate coefficient functionality, the ability to change coefficient ring and to map coefficients according to a supplied function and the ability to convert a multivariate which happens to have just one variable into a dense univariate polynomial.","category":"page"},{"location":"AbstractAlgebra/univpolynomial/","page":"Universal polynomial","title":"Universal polynomial","text":"Further facilities may be added in future to ease symbolic manipulations.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"using Oscar","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Pages = [\"grouphom.md\"]","category":"page"},{"location":"Groups/grouphom/#Group-homomorphisms","page":"Group homomorphisms","title":"Group homomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"In Oscar, a group homomorphism from G to H is an object of parametric type GAPGroupHomomorphism{S,T}, where S and T are the types of G and H respectively.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"A homomorphism from G to H can be defined in two ways.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Writing explicitly the images of the generators of G:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"f = hom(G,H,[x1,x2,...],[y1,y2,...])","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Here, [x1,x2,...] must be a generating set for G (not necessarily minimal) and [y1,y2,...] is a vector of elements of H of the same length of [x1,x2,...]. This assigns to f the value of the group homomorphism sending x_i into y_i.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"An exception is thrown if such a homomorphism does not exist.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Taking an existing function g satisfying the group homomorphism properties:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"f = hom(G,H,g)","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"An exception is thrown if the function g does not define a group homomorphism.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Example: The following procedures define the same homomorphism (conjugation by x) in the two ways explained above.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"julia> S=symmetric_group(4);\n\njulia> x=S[1];\n\njulia> f=hom(S,S,gens(S),[S[1]^x,S[2]^x]);\n\njulia> g=hom(S,S,y->y^x);\n\njulia> f==g\ntrue","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"hom(G::GAPGroup, H::GAPGroup, img::Function)\nhom(G::GAPGroup, H::GAPGroup, gensG::Vector, imgs::Vector)\nimage(f::GAPGroupHomomorphism, x::GAPGroupElem)\npreimage(f::GAPGroupHomomorphism, x::GAPGroupElem)\nrestrict_homomorphism(f::GAPGroupHomomorphism, H::GAPGroup)","category":"page"},{"location":"Groups/grouphom/#hom-Tuple{Oscar.GAPGroup, Oscar.GAPGroup, Function}","page":"Group homomorphisms","title":"hom","text":"hom(G::GAPGroup, H::GAPGroup, f::Function)\n\nReturn the group homomorphism defined by the function f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#hom-Tuple{Oscar.GAPGroup, Oscar.GAPGroup, Vector{T} where T, Vector{T} where T}","page":"Group homomorphisms","title":"hom","text":"hom(G::GAPGroup, H::GAPGroup, gensG::Vector = gens(G), imgs::Vector; check::Bool = true)\n\nReturn the group homomorphism defined by gensG[i] -> imgs[i] for every i. In order to work, the elements of gensG must generate G.\n\nIf check is set to false then it is not checked whether the mapping defines a group homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#image-Tuple{GAPGroupHomomorphism, GAPGroupElem}","page":"Group homomorphisms","title":"image","text":"image(f::GAPGroupHomomorphism, x::GAPGroupElem)\n(f::GAPGroupHomomorphism)(x::GAPGroupElem)\n\nReturn f(x).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#preimage-Tuple{GAPGroupHomomorphism, GAPGroupElem}","page":"Group homomorphisms","title":"preimage","text":"preimage(f::GAPGroupHomomorphism, x::GAPGroupElem)\n\nReturn an element y in the domain of f with the property f(y) == x. See haspreimage(f::GAPGroupHomomorphism, x::GAPGroupElem; check::Bool = true) for a check whether x has such a preimage.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#restrict_homomorphism-Tuple{GAPGroupHomomorphism, Oscar.GAPGroup}","page":"Group homomorphisms","title":"restrict_homomorphism","text":"restrict_homomorphism(f::GAPGroupHomomorphism, H::Group)\nrestrict_homomorphism(f::GAPGroupElem{AutomorphismGroup{T}}, H::T) where T <: Group\n\nReturn the restriction of f to H. An exception is thrown if H is not a subgroup of domain(f).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Oscar has also the following standard homomorphism.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"id_hom\ntrivial_morphism","category":"page"},{"location":"Groups/grouphom/#id_hom","page":"Group homomorphisms","title":"id_hom","text":"id_hom(G::GAPGroup)\n\nReturn the identity homomorphism on the group G.\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouphom/#trivial_morphism","page":"Group homomorphisms","title":"trivial_morphism","text":"trivial_morphism(G::GAPGroup, H::GAPGroup = G)\n\nReturn the homomorphism from G to H sending every element of G into the identity of H.\n\n\n\n\n\n","category":"function"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"To evaluate the homomorphism f in the element x of G, it is possible to use the instruction","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"image(f,x)","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"or the more compact notations f(x) and x^f.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Example:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"julia> S=symmetric_group(4);\n\njulia> f=hom(S,S,x->x^S[1]);\n\njulia> x=cperm(S,[1,2]);\n\njulia> image(f,x)\n(2,3)\n\njulia> f(x)\n(2,3)\n\njulia> x^f\n(2,3)","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"A sort of \"inverse\" of the evaluation is the following","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"haspreimage(f::GAPGroupHomomorphism, x::GAPGroupElem; check::Bool = true)","category":"page"},{"location":"Groups/grouphom/#haspreimage-Tuple{GAPGroupHomomorphism, GAPGroupElem}","page":"Group homomorphisms","title":"haspreimage","text":"haspreimage(f::GAPGroupHomomorphism, x::GAPGroupElem; check::Bool = true)\n\nReturn (true, y) if there exists y in domain(f) such that f(y) = x holds; otherwise, return (false, o) where o is the identity of domain(f).\n\nIf check is set to false then the test whether x is an element of image(f) is omitted.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Example:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"julia> S=symmetric_group(4);\n\njulia> f=hom(S,S,x->x^S[1]);\n\njulia> x=cperm(S,[1,2]);\n\njulia> haspreimage(f,x)\n(true, (1,4))","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"warning: Warning\nDo not confuse haspreimage with the function has_preimage, which works on variable of type GrpGenToGrpGenMor.","category":"page"},{"location":"Groups/grouphom/#Operations-on-homomorphisms","page":"Group homomorphisms","title":"Operations on homomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Oscar supports the following operations on homomorphisms.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"inv(f) = the inverse of f. An exception is thrown if f is not bijective.\nf^n = the homomorphism f composed n times with itself. An exception is thrown if the domain and the codomain of f do not coincide (unless n=1). If n is negative, the result is the inverse of f composed n times with itself.\ncompose(f, g) = composition of f and g. This works only if the codomain of f coincides with the domain of g. Shorter equivalent expressions are f*g and g(f).\nExample:","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"julia> S=symmetric_group(4);\n\njulia> f=hom(S,S,x->x^S[1]);\n\njulia> g=hom(S,S,x->x^S[2]);\n\njulia> f*g==hom(S,S,x->x^(S[1]*S[2]))\ntrue\n\njulia> f==f^-3\ntrue","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"note: Note\nThe composition operation * has to be read from the right to the left. So, (f*g)(x) is equivalent to g(f(x)).","category":"page"},{"location":"Groups/grouphom/#Properties-of-homomorphisms","page":"Group homomorphisms","title":"Properties of homomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"Oscar implements the following attributes of homomorphisms, in addition to the usual domain and codomain.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"isinjective(f::GAPGroupHomomorphism)\nissurjective(f::GAPGroupHomomorphism)\nisbijective(f::GAPGroupHomomorphism)\nisinvertible(f::GAPGroupHomomorphism)\nisinvariant(f::GAPGroupHomomorphism, H::GAPGroup)","category":"page"},{"location":"Groups/grouphom/#isinjective-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"isinjective","text":"isinjective(f::GAPGroupHomomorphism)\n\nReturn whether f is injective.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#issurjective-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"issurjective","text":"issurjective(f::GAPGroupHomomorphism)\n\nReturn whether f is surjective.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#isbijective-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"isbijective","text":"isbijective(f::GAPGroupHomomorphism)\n\nReturn whether f is bijective.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#isinvertible-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"isinvertible","text":"isinvertible(f::GAPGroupHomomorphism)\n\nReturn whether f is invertible.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#isinvariant-Tuple{GAPGroupHomomorphism, Oscar.GAPGroup}","page":"Group homomorphisms","title":"isinvariant","text":"isinvariant(f::GAPGroupHomomorphism, H::Group)\nisinvariant(f::GAPGroupElem{AutomorphismGroup{T}}, H::T)\n\nReturn whether f(H) == H holds. An exception is thrown if domain(f) and codomain(f) are not equal or if H is not contained in domain(f).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#Subgroups-described-by-homomorphisms","page":"Group homomorphisms","title":"Subgroups described by homomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"The following functions compute subgroups or quotients of either the domain or the codomain. Analogously to the functions described in Sections Subgroups and Quotients, the output consists of a pair (H, g), where H is a subgroup (resp. quotient) and g is its embedding (resp. projection) homomorphism.","category":"page"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"kernel(f::GAPGroupHomomorphism)\nimage(f::GAPGroupHomomorphism)\nimage(f::GAPGroupHomomorphism{S, T}, H::S) where S <: GAPGroup where T <: GAPGroup\ncokernel(f::GAPGroupHomomorphism)\npreimage(f::GAPGroupHomomorphism{S, T}, H::T) where S <: GAPGroup where T <: GAPGroup","category":"page"},{"location":"Groups/grouphom/#kernel-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"kernel","text":"kernel(f::GAPGroupHomomorphism)\n\nReturn the kernel of f, together with its embedding into domain(f).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#image-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"image","text":"image(f::GAPGroupHomomorphism)\n\nReturn the image of f as subgroup of codomain(f), together with the embedding homomorphism.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#image-Union{Tuple{S}, Tuple{T}, Tuple{GAPGroupHomomorphism{S, T}, S}} where {T<:Oscar.GAPGroup, S<:Oscar.GAPGroup}","page":"Group homomorphisms","title":"image","text":"image(f::GAPGroupHomomorphism{S, T}, H::S) where S <: GAPGroup where T <: GAPGroup\n(f::GAPGroupHomomorphism{S, T})(H::S)\n\nReturn f(H), together with the embedding homomorphism into codomain(f).\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#cokernel-Tuple{GAPGroupHomomorphism}","page":"Group homomorphisms","title":"cokernel","text":"cokernel(f::GAPGroupHomomorphism)\n\nReturn the cokernel of f, that is, the quotient of the codomain of f by the normal closure of the image.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#preimage-Union{Tuple{S}, Tuple{T}, Tuple{GAPGroupHomomorphism{S, T}, T}} where {T<:Oscar.GAPGroup, S<:Oscar.GAPGroup}","page":"Group homomorphisms","title":"preimage","text":"preimage(f::GAPGroupHomomorphism{S, T}, H::T) where S <: GAPGroup where T <: GAPGroup\n\nIf H is a subgroup of the codomain of f, return the subgroup f^-1(H), together with its embedding homomorphism into the domain of f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#Group-isomorphisms","page":"Group homomorphisms","title":"Group isomorphisms","text":"","category":"section"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"isisomorphic(G::GAPGroup, H::GAPGroup)\nisisomorphic_with_map(G::GAPGroup, H::GAPGroup)\nisomorphism(G::GAPGroup, H::GAPGroup)","category":"page"},{"location":"Groups/grouphom/#isisomorphic-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Group homomorphisms","title":"isisomorphic","text":"isisomorphic(G::Group, H::Group)\n\nReturn true if G and H are isomorphic groups, and false otherwise.\n\nExamples\n\njulia> isisomorphic(symmetric_group(3), dihedral_group(6))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#isisomorphic_with_map-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Group homomorphisms","title":"isisomorphic_with_map","text":"isisomorphic_with_map(G::Group, H::Group)\n\nReturn (true,f) if G and H are isomorphic groups, where f is a group isomorphism. Otherwise, return (false,f), where f is the trivial homomorphism.\n\nExamples\n\njulia> isisomorphic_with_map(symmetric_group(3), dihedral_group(6))\n(true, Group homomorphism from\nSym( [ 1 .. 3 ] )\nto\n<pc group of size 6 with 2 generators>)\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#isomorphism-Tuple{Oscar.GAPGroup, Oscar.GAPGroup}","page":"Group homomorphisms","title":"isomorphism","text":"isomorphism(G::Group, H::Group)\n\nReturn a group isomorphism between G and H if they are isomorphic groups. Otherwise throw an exception.\n\nExamples\n\njulia> isomorphism(symmetric_group(3), dihedral_group(6))\nGroup homomorphism from\nSym( [ 1 .. 3 ] )\nto\n<pc group of size 6 with 2 generators>\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/","page":"Group homomorphisms","title":"Group homomorphisms","text":"isomorphism(::Type{T}, G::GAPGroup) where T <: Union{FPGroup, PcGroup, PermGroup}\nisomorphism(::Type{GrpAbFinGen}, G::GAPGroup)\nsimplified_fp_group(G::FPGroup)","category":"page"},{"location":"Groups/grouphom/#isomorphism-Union{Tuple{T}, Tuple{Type{T}, Oscar.GAPGroup}} where T<:Union{FPGroup, PcGroup, PermGroup}","page":"Group homomorphisms","title":"isomorphism","text":"isomorphism(::Type{T}, G::GAPGroup) where T <: Union{FPGroup, PcGroup, PermGroup}\n\nReturn an isomorphism from G to a group of type T. An exception is thrown if no such isomorphism exists.\n\nIsomorphisms are cached in G, subsequent calls of isomorphism with the same T yield identical results.\n\nIf only the image of such an isomorphism is needed, use T(G).\n\nExamples\n\njulia> G = dihedral_group(6)\n<pc group of size 6 with 2 generators>\n\njulia> iso = isomorphism(PermGroup, G)\nGroup homomorphism from\n<pc group of size 6 with 2 generators>\nto\nGroup([ (1,2)(3,6)(4,5), (1,3,5)(2,4,6) ])\n\njulia> PermGroup(G)\nGroup([ (1,2)(3,6)(4,5), (1,3,5)(2,4,6) ])\n\njulia> codomain(iso) === ans\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#isomorphism-Tuple{Type{GrpAbFinGen}, Oscar.GAPGroup}","page":"Group homomorphisms","title":"isomorphism","text":"isomorphism(::Type{GrpAbFinGen}, G::GAPGroup)\n\nReturn a map from G to an isomorphic (additive) group of type GrpAbFinGen. An exception is thrown if G is not abelian or not finite.\n\n\n\n\n\n","category":"method"},{"location":"Groups/grouphom/#simplified_fp_group-Tuple{FPGroup}","page":"Group homomorphisms","title":"simplified_fp_group","text":"simplified_fp_group(G::FPGroup)\n\nReturn a group H of type FPGroup and an isomorphism f from G to H, where the presentation of H was obtained from the presentation of G by applying Tietze transformations in order to reduce it with respect to the number of generators, the number of relators, and the relator lengths.\n\nExamples\n\njulia> F = free_group(3)\n<free group on the generators [ f1, f2, f3 ]>\n\njulia> G = quo(F, [gen(F,1)])[1]\n<fp group of size infinity on the generators [ f1, f2, f3 ]>\n\njulia> simplified_fp_group(G)[1]\n<fp group of size infinity on the generators [ f2, f3 ]>\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/#AbstractAlgebra.jl","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/#Introduction","page":"AbstractAlgebra.jl","title":"Introduction","text":"","category":"section"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"AbstractAlgebra.jl is a computer algebra package for the Julia programming language, maintained by William Hart, Tommy Hofmann, Claus Fieker and Fredrik Johansson and other interested contributors.","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Source code","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"AbstractAlgebra.jl grew out of the Nemo project after a number of requests from the community for the pure Julia part of Nemo to be split off into a separate project. See the Nemo website for more details about Nemo.","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Nemo website","category":"page"},{"location":"AbstractAlgebra/#Features","page":"AbstractAlgebra.jl","title":"Features","text":"","category":"section"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"The features of AbstractAlgebra.jl include:","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Use of Julia multiprecision integers and rationals\nFinite fields (prime order, naive implementation only)\nNumber fields (naive implementation only)\nUnivariate polynomials\nMultivariate polynomials\nRelative and absolute power series\nLaurent series\nFraction fields\nResidue rings, including mathbbZnmathbbZ\nMatrices and linear algebra","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"All implementations are fully recursive and generic, so that one can build matrices over polynomial rings, over a finite field, for example.","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"AbstractAlgebra.jl also provides a set of abstract types for Groups, Rings, Fields, Modules and elements thereof, which allow external types to be made part of the AbstractAlgebra.jl type hierarchy.","category":"page"},{"location":"AbstractAlgebra/#Installation","page":"AbstractAlgebra.jl","title":"Installation","text":"","category":"section"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"To use AbstractAlgebra we require Julia 1.6 or higher. Please see https://julialang.org/downloads/ for instructions on how to obtain Julia for your system.","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"At the Julia prompt simply type","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"julia> Pkg.add(\"AbstractAlgebra\")","category":"page"},{"location":"AbstractAlgebra/#Quick-start","page":"AbstractAlgebra.jl","title":"Quick start","text":"","category":"section"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Here are some examples of using AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"This example makes use of multivariate polynomials.","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR, (x, y, z) = PolynomialRing(ZZ, [\"x\", \"y\", \"z\"])\n\nf = x + y + z + 1\n\np = f^20;\n\n@time q = p*(p+1);","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Here is an example using generic recursive ring constructions.","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR = GF(7)\n\nS, y = PolynomialRing(R, \"y\")\n\nT = ResidueRing(S, y^3 + 3y + 1)\n\nU, z = PolynomialRing(T, \"z\")\n\nf = (3y^2 + y + 2)*z^2 + (2*y^2 + 1)*z + 4y + 3;\n\ng = (7y^2 - y + 7)*z^2 + (3y^2 + 1)*z + 2y + 1;\n\ns = f^4;\n\nt = (s + g)^4;\n\n@time resultant(s, t)","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"Here is an example using matrices.","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR, x = PolynomialRing(ZZ, \"x\")\n\nS = MatrixSpace(R, 10, 10)\n\nM = rand(S, 0:3, -10:10);\n\n@time det(M)","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"And here is an example with power series.","category":"page"},{"location":"AbstractAlgebra/","page":"AbstractAlgebra.jl","title":"AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR, x = QQ[\"x\"]\n\nS, t = PowerSeriesRing(R, 30, \"t\")\n\nu = t + O(t^100)\n\n@time divexact((u*exp(x*u)), (exp(u)-1));","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/module/#Finitely-presented-modules","page":"Finitely presented modules","title":"Finitely presented modules","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"AbstractAlgebra allows the construction of finitely presented modules (i.e. with finitely many generators and relations), starting from free modules.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"The generic code provided by AbstractAlgebra will only work for modules over euclidean domains.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Free modules can be built over both commutative and noncommutative rings. Other types of module are restricted to fields and euclidean rings.","category":"page"},{"location":"AbstractAlgebra/module/#Abstract-types","page":"Finitely presented modules","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"AbstractAlgebra provides two abstract types for finitely presented modules and their elements:","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"FPModule{T} is the abstract type for finitely presented module parent","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"types","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"FPModuleElem{T} is the abstract type for finitely presented module","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"element types","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Note that the abstract types are parameterised. The type T should usually be the type of elements of the ring the module is over.","category":"page"},{"location":"AbstractAlgebra/module/#Module-functions","page":"Finitely presented modules","title":"Module functions","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"All finitely presented modules over a Euclidean domain implement the following functions.","category":"page"},{"location":"AbstractAlgebra/module/#Basic-functions","page":"Finitely presented modules","title":"Basic functions","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"zero(M::FPModule)","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"iszero(m::FPModuleElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return true if the given module element is zero.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"ngens(M::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return the number of generators of the module M in its current representation.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"gen(M::FPModule{T}, i::Int) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return the i-th generator (indexed from 1) of the module M.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"gens(M::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return a Julia array of the generators of the module M.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"rels(M::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Return a Julia vector of all the relations between the generators of M. Each relation is given as an AbstractAlgebra row matrix.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = FreeModule(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> n = ngens(M)\n2\n\njulia> G = gens(M)\n2-element Vector{AbstractAlgebra.Generic.FreeModuleElem{Rational{BigInt}}}:\n (1//1, 0//1)\n (0//1, 1//1)\n\njulia> R = rels(M)\nAbstractAlgebra.Generic.MatSpaceElem{Rational{BigInt}}[]\n\njulia> g1 = gen(M, 1)\n(1//1, 0//1)\n\njulia> !iszero(g1)\ntrue\n\njulia> M = FreeModule(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> z = zero(M)\n(0//1, 0//1)\n\njulia> iszero(z)\ntrue","category":"page"},{"location":"AbstractAlgebra/module/#Element-constructors","page":"Finitely presented modules","title":"Element constructors","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"We can construct elements of a module M by specifying linear combinations of the generators of M. This is done by passing a vector of ring elements.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"(M::FPModule{T})(v::Vector{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Construct the element of the module M corrsponding to sum_i givi where gi are the generators of the module M. The resulting element will lie in the module M.","category":"page"},{"location":"AbstractAlgebra/module/#Coercions","page":"Finitely presented modules","title":"Coercions","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Given a module M and an element n of a module N, it is possible to coerce n into M using the notation M(n) in certain circumstances.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"In particular the element n will be automatically coerced along any canonical injection of a submodule map and along any canonical projection of a quotient map. There must be a path from N to M along such maps.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"F = FreeModule(ZZ, 3)\n\nS1, f = sub(F, [rand(F, -10:10)])\n\nS, g = sub(F, [rand(F, -10:10)])\nQ, h = quo(F, S)\n\nm = rand(S1, -10:10)\nn = Q(m)","category":"page"},{"location":"AbstractAlgebra/module/#Arithmetic-operators","page":"Finitely presented modules","title":"Arithmetic operators","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Elements of a module can be added, subtracted or multiplied by an element of the ring the module is defined over and compared for equality.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"In the case of a noncommutative ring, both left and right scalar multiplication are defined.","category":"page"},{"location":"AbstractAlgebra/module/#Basic-manipulation","page":"Finitely presented modules","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"zero(M::FPModule)","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = FreeModule(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> z = zero(M)\n(0//1, 0//1)","category":"page"},{"location":"AbstractAlgebra/module/#Element-indexing","page":"Finitely presented modules","title":"Element indexing","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Base.getindex(m::FPModuleElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/#getindex-Union{Tuple{AbstractAlgebra.FPModuleElem{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"getindex","text":"getindex(a::Fac, b) -> Int\n\nIf b is a factor of a, the corresponding exponent is returned. Otherwise an error is thrown.\n\n\n\ngetindex(A::SMat, i::Int, j::Int)\n\nGiven a sparse matrix A = (a_ij)_i j, return the entry a_ij.\n\n\n\ngetindex(A::SMat, i::Int) -> SRow\n\nGiven a sparse matrix A and an index i, return the i-th row of A.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> F = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> m = F(BigInt[2, -5, 4])\n(2, -5, 4)\n\njulia> m[1]\n2","category":"page"},{"location":"AbstractAlgebra/module/#Module-comparison","page":"Finitely presented modules","title":"Module comparison","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"==(::FPModule{T}, ::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/#==-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Finitely presented modules","title":"==","text":"==(M::FPModule{T}, N::FPModule{T}) where T <: RingElement\n\nReturn true if the modules are (constructed to be) the same module elementwise. This is not object equality and it is not isomorphism. In fact, each method of constructing modules (submodules, quotient modules, products, etc.) must extend this notion of equality to the modules they create.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = FreeModule(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> M == M\ntrue\n","category":"page"},{"location":"AbstractAlgebra/module/#Isomorphism","page":"Finitely presented modules","title":"Isomorphism","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"isisomorphic(::FPModule{T}, ::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/#isisomorphic-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}}} where T<:RingElement","page":"Finitely presented modules","title":"isisomorphic","text":"isisomorphic(M::FPModule{T}, N::FPModule{T}) where T <: RingElement\n\nReturn true if the modules M and N are isomorphic.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"note: Note\nNote that this function relies on the Smith normal form over the base ring of the modules being able to be made unique. This is true for Euclidean domains for which divrem has a fixed choice of quotient and remainder, but it will not in general be true for Euclidean rings that are not domains.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> m1 = rand(M, -10:10)\n(0, -8, -8)\n\njulia> m2 = rand(M, -10:10)\n(-7, -5, -10)\n\njulia> S, f = sub(M, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 3 over Integers)\n\njulia> I, g = image(f)\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 3 over Integers)\n\njulia> isisomorphic(S, I)\ntrue\n","category":"page"},{"location":"AbstractAlgebra/module/#Invariant-Factor-Decomposition","page":"Finitely presented modules","title":"Invariant Factor Decomposition","text":"","category":"section"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"For modules over a euclidean domain one can take the invariant factor decomposition to determine the structure of the module. The invariant factors are unique up to multiplication by a unit, and even unique if a  canonical_unit is available for the ring that canonicalises elements.","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"snf(::FPModule{T}) where T <: RingElement\ninvariant_factors(::FPModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module/#snf-Union{Tuple{AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"snf","text":"snf(m::FPModule{T}) where T <: RingElement\n\nReturn a pair M, f consisting of the invariant factor decomposition M of the module m and a module homomorphism (isomorphisms) f  M to m. The module M is itself a module which can be manipulated as any other module in the system.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/#invariant_factors-Union{Tuple{AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:RingElement","page":"Finitely presented modules","title":"invariant_factors","text":"invariant_factors(m::FPModule{T}) where T <: RingElement\n\nReturn a vector of the invariant factors of the module M.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module/","page":"Finitely presented modules","title":"Finitely presented modules","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> m1 = rand(M, -10:10)\n(9, 7, 7)\n\njulia> m2 = rand(M, -10:10)\n(-6, 2, -8)\n\njulia> S, f = sub(M, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 3 over Integers)\n\njulia> Q, g = quo(M, S)\n(Quotient module over Integers with 3 generators and relations:\n[3 9 -1], [0 20 -10], Module homomorphism with\nDomain: Free module of rank 3 over Integers\nCodomain: Quotient module over Integers with 3 generators and relations:\n[3 9 -1], [0 20 -10])\n\njulia> I, f = snf(Q)\n(Invariant factor decomposed module over Integers with invariant factors BigInt[10, 0], Module homomorphism with\nDomain: Invariant factor decomposed module over Integers with invariant factors BigInt[10, 0]\nCodomain: Quotient module over Integers with 3 generators and relations:\n[3 9 -1], [0 20 -10])\n\njulia> invs = invariant_factors(Q)\n2-element Vector{BigInt}:\n 10\n  0\n","category":"page"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"using Oscar","category":"page"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"Pages = [\"pcgroup.md\"]","category":"page"},{"location":"Groups/pcgroup/#Polycyclic-groups","page":"Polycyclic groups","title":"Polycyclic groups","text":"","category":"section"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"PcGroup\nPcGroupElem","category":"page"},{"location":"Groups/pcgroup/#PcGroup","page":"Polycyclic groups","title":"PcGroup","text":"PcGroup\n\nPolycyclic group\n\nExamples\n\ncyclic_group(n::Int): cyclic group of order n\nabelian_group(PcGroup, v::Vector{Int}): direct product of cyclic groups of the orders v[1], v[2], ..., v[length(v)]\n\n\n\n\n\n","category":"type"},{"location":"Groups/pcgroup/#PcGroupElem","page":"Polycyclic groups","title":"PcGroupElem","text":"PcGroupElem\n\nElement of a polycyclic group.\n\n\n\n\n\n","category":"type"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"Julia has the following functions that allow to generate polycyclic groups:","category":"page"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"abelian_group(::Type{T}, v::Vector{Int}) where T <: GAPGroup\ncyclic_group\ndihedral_group\nquaternion_group","category":"page"},{"location":"Groups/pcgroup/#abelian_group-Union{Tuple{T}, Tuple{Type{T}, Vector{Int64}}} where T<:Oscar.GAPGroup","page":"Polycyclic groups","title":"abelian_group","text":"abelian_group(::Type{T}, v::Vector{Int}) where T <: Group -> PcGroup\n\nReturn the direct product of cyclic groups of the orders v[1], v[2], ldots, v[n], as an instance of T. Here, T must be one of PermGroup, FPGroup, or PcGroup.\n\nwarning: Warning\nThe type need to be specified in the input of the function abelian_group, otherwise a group of type GrpAbFinGen is returned, which is not a GAP group type. In future versions of Oscar, this may change.\n\n\n\n","category":"method"},{"location":"Groups/pcgroup/#cyclic_group","page":"Polycyclic groups","title":"cyclic_group","text":"cyclic_group(::Type{T} = PcGroup, n::Int) where T <: GAPGroup\n\nReturn the cyclic group of order n, as an instance of T.\n\n\n\n\n\n","category":"function"},{"location":"Groups/pcgroup/#dihedral_group","page":"Polycyclic groups","title":"dihedral_group","text":"dihedral_group(::Type{T} = PcGroup, n::Int)\n\nReturn the dihedral group of order n, as an instance of T, where T is in {PcGroup,PermGroup,FPGroup}. An exception is thrown if n is odd.\n\n\n\n\n\n","category":"function"},{"location":"Groups/pcgroup/#quaternion_group","page":"Polycyclic groups","title":"quaternion_group","text":"quaternion_group(::Type{T} = PcGroup, n::Int)\n\nReturn the (generalized) quaternion group of order n, as an instance of T, where n is a power of 2 and T is in {PcGroup,PermGroup,FPGroup}.\n\nExamples\n\njulia> g = quaternion_group(8)\n<pc group of size 8 with 3 generators>\n\njulia> quaternion_group(PermGroup, 8)\nGroup([ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ])\n\njulia> g = quaternion_group(FPGroup, 8)\n<fp group of size 8 on the generators [ r, s ]>\n\njulia> relators(g)\n3-element Vector{FPGroupElem}:\n r^2*s^-2\n s^4\n r^-1*s*r*s\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"The generators of a polycyclic group are displayed as f1, f2, f3, etc., and every element of a polycyclic group is displayed as product of such generators.","category":"page"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"Example:","category":"page"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"julia> G=abelian_group(PcGroup, [2,4]);\n\njulia> G[1], G[2]\n(f1, f2)\n\njulia> G[2]*G[1]\nf1*f2","category":"page"},{"location":"Groups/pcgroup/","page":"Polycyclic groups","title":"Polycyclic groups","text":"Note that this does not define Julia variables named f1, f2, etc.! To get the generators of the group G, use gens(G); for convenience they can also be accessed as G[1], G[2], as shown in Section Elements of groups.","category":"page"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"CurrentModule = Oscar","category":"page"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"Pages = [\"ToricDivisors.md\"]","category":"page"},{"location":"ToricVarieties/ToricDivisors/#Toric-Divisors","page":"Toric Divisors","title":"Toric Divisors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisors/#Introduction","page":"Toric Divisors","title":"Introduction","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"Toric divisors are those divisors that are invariant under the torus action. They are formal sums of the codimension one orbits, and these in turn correspond to the rays of the underlying fan.","category":"page"},{"location":"ToricVarieties/ToricDivisors/#Constructors","page":"Toric Divisors","title":"Constructors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisors/#General-constructors","page":"Toric Divisors","title":"General constructors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"DivisorOfCharacter(v::AbstractNormalToricVariety, character::Vector{Int})\nToricDivisor(v::AbstractNormalToricVariety, coeffs::Vector{Int})","category":"page"},{"location":"ToricVarieties/ToricDivisors/#DivisorOfCharacter-Tuple{Oscar.AbstractNormalToricVariety, Vector{Int64}}","page":"Toric Divisors","title":"DivisorOfCharacter","text":"DivisorOfCharacter(v::AbstractNormalToricVariety, character::Vector{Int})\n\nConstruct the torus invariant divisor associated to a character of the normal toric variety v.\n\nExamples\n\njulia> DivisorOfCharacter(projective_space(NormalToricVariety, 2), [1,2])\nA torus-invariant, non-prime divisor on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#ToricDivisor-Tuple{Oscar.AbstractNormalToricVariety, Vector{Int64}}","page":"Toric Divisors","title":"ToricDivisor","text":"ToricDivisor(v::AbstractNormalToricVariety, coeffs::Vector{Int})\n\nConstruct the torus invariant divisor on the normal toric variety v as linear combination of the torus invariant prime divisors of v. The coefficients of thi linear combination are passed as list of integers as first argument.\n\nExamples\n\njulia> ToricDivisor(projective_space(NormalToricVariety, 2), [1,1,2])\nA torus-invariant, non-prime divisor on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#Special-constructors","page":"Toric Divisors","title":"Special constructors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"Addition of toric divisors td1 and td2 (on the same toric variety) and scalar multiplication with c (it can be either valued in Int64 or fmpz) is supported via c * td1 + td2. One can subtract them via td1 - td2.","category":"page"},{"location":"ToricVarieties/ToricDivisors/#Equality","page":"Toric Divisors","title":"Equality","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"Equality of two toric divisors td1 and td2 (on the same toric variety) is achieved by checking if their coefficients are identical. This is implemented via td1 == td2.","category":"page"},{"location":"ToricVarieties/ToricDivisors/#Properties-of-toric-divisors","page":"Toric Divisors","title":"Properties of toric divisors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"To check if a toric divisor td is trivial, one can invoke istrivial(td). Internally, this executes the following method:","category":"page"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"isprincipal(td::ToricDivisor)","category":"page"},{"location":"ToricVarieties/ToricDivisors/#isprincipal-Tuple{ToricDivisor}","page":"Toric Divisors","title":"isprincipal","text":"isprincipal(td::ToricDivisor)\n\nDetermine whether the toric divisor td is principal.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> isprincipal(td)\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"Beyond this, we support the following properties of toric divisors:","category":"page"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"isample(td::ToricDivisor)\nis_basepoint_free(td::ToricDivisor)\niscartier(td::ToricDivisor)\niseffective(td::ToricDivisor)\nisintegral(td::ToricDivisor)\nisnef(td::ToricDivisor)\nisprime(td::ToricDivisor)\nis_q_cartier(td::ToricDivisor)\nis_very_ample(td::ToricDivisor)","category":"page"},{"location":"ToricVarieties/ToricDivisors/#isample-Tuple{ToricDivisor}","page":"Toric Divisors","title":"isample","text":"isample(td::ToricDivisor)\n\nDetermine whether the toric divisor td is ample.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> isample(td)\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#is_basepoint_free-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_basepoint_free","text":"is_basepoint_free(td::ToricDivisor)\n\nDetermine whether the toric divisor td is basepoint free.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> is_basepoint_free(td)\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#iscartier-Tuple{ToricDivisor}","page":"Toric Divisors","title":"iscartier","text":"iscartier(td::ToricDivisor)\n\nChecks if the divisor td is Cartier.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> iscartier(td)\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#iseffective-Tuple{ToricDivisor}","page":"Toric Divisors","title":"iseffective","text":"iseffective(td::ToricDivisor)\n\nDetermine whether the toric divisor td is effective.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> iseffective(td)\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#isintegral-Tuple{ToricDivisor}","page":"Toric Divisors","title":"isintegral","text":"isintegral(td::ToricDivisor)\n\nDetermine whether the toric divisor td is integral.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> isintegral(td)\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#isnef-Tuple{ToricDivisor}","page":"Toric Divisors","title":"isnef","text":"isnef(td::ToricDivisor)\n\nDetermine whether the toric divisor td is nef.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> isnef(td)\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#isprime-Tuple{ToricDivisor}","page":"Toric Divisors","title":"isprime","text":"isprime(td::ToricDivisor)\n\nDetermine whether the toric divisor td is a prime divisor.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> isprime(td)\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#is_q_cartier-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_q_cartier","text":"is_q_cartier(td::ToricDivisor)\n\nDetermine whether the toric divisor td is Q-Cartier.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> is_q_cartier(td)\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#is_very_ample-Tuple{ToricDivisor}","page":"Toric Divisors","title":"is_very_ample","text":"is_very_ample(td::ToricDivisor)\n\nDetermine whether the toric divisor td is very ample.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> is_very_ample(td)\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#Operations-for-toric-divisors","page":"Toric Divisors","title":"Operations for toric divisors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"coefficients(td::ToricDivisor)\npolyhedron(td::ToricDivisor)\ntoric_variety(td::ToricDivisor)","category":"page"},{"location":"ToricVarieties/ToricDivisors/#coefficients-Tuple{ToricDivisor}","page":"Toric Divisors","title":"coefficients","text":"coefficients(td::ToricDivisor)\n\nIdentify the coefficients of a toric divisor in the group of torus invariant Weil divisors.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> D = ToricDivisor(F4, [1,2,3,4])\nA torus-invariant, non-prime divisor on a normal toric variety\n\njulia> coefficients(D)\n4-element Vector{fmpz}:\n 1\n 2\n 3\n 4\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#polyhedron-Tuple{ToricDivisor}","page":"Toric Divisors","title":"polyhedron","text":"polyhedron(td::ToricDivisor)\n\nConstruct the polyhedron P_D of a torus invariant divisor D=td as in 4.3.2 of David A. Cox, John B. Little, Henry K. Schenck (2011). The lattice points of this polyhedron correspond to the global sections of the divisor.\n\nExamples\n\nThe polyhedron of the divisor with all coefficients equal to zero is a point, if the ambient variety is complete. Changing the coefficients corresponds to moving hyperplanes. One direction moves the hyperplane away from the origin, the other moves it across. In the latter case there are no global sections anymore and the polyhedron becomes empty.\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> td0 = ToricDivisor(F4, [0,0,0,0])\nA torus-invariant, non-prime divisor on a normal toric variety\n\njulia> isfeasible(polyhedron(td0))\ntrue\n\njulia> dim(polyhedron(td0))\n0\n\njulia> td1 = ToricDivisor(F4, [1,0,0,0])\nA torus-invariant, prime divisor on a normal toric variety\n\njulia> isfeasible(polyhedron(td1))\ntrue\n\njulia> td2 = ToricDivisor(F4, [-1,0,0,0])\nA torus-invariant, non-prime divisor on a normal toric variety\n\njulia> isfeasible(polyhedron(td2))\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#toric_variety-Tuple{ToricDivisor}","page":"Toric Divisors","title":"toric_variety","text":"toric_variety(td::ToricDivisor)\n\nReturn the toric variety of a torus-invariant Weil divisor.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4);\n\njulia> D = ToricDivisor(F4, [1,2,3,4]);\n\njulia> toric_variety(D)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#Special-divisors","page":"Toric Divisors","title":"Special divisors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisors/","page":"Toric Divisors","title":"Toric Divisors","text":"trivial_divisor(v::AbstractNormalToricVariety)\nanticanonical_divisor(v::AbstractNormalToricVariety)\ncanonical_divisor(v::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/ToricDivisors/#trivial_divisor-Tuple{Oscar.AbstractNormalToricVariety}","page":"Toric Divisors","title":"trivial_divisor","text":"trivial_divisor(v::AbstractNormalToricVariety)\n\nConstruct the trivial divisor of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> trivial_divisor(v)\nA torus-invariant, non-prime divisor on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#anticanonical_divisor-Tuple{Oscar.AbstractNormalToricVariety}","page":"Toric Divisors","title":"anticanonical_divisor","text":"anticanonical_divisor(v::AbstractNormalToricVariety)\n\nConstruct the anticanonical divisor of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> anticanonical_divisor(v)\nA torus-invariant, non-prime divisor on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisors/#canonical_divisor-Tuple{Oscar.AbstractNormalToricVariety}","page":"Toric Divisors","title":"canonical_divisor","text":"canonical_divisor(v::AbstractNormalToricVariety)\n\nConstruct the canonical divisor of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> canonical_divisor(v)\nA torus-invariant, non-prime divisor on a normal toric variety\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"CurrentModule = Oscar.Graphs","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"using Oscar\nusing Oscar.Graphs","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"Pages = [\"graphs.md\"]","category":"page"},{"location":"Combinatorics/graphs/#Graphs","page":"Graphs","title":"Graphs","text":"","category":"section"},{"location":"Combinatorics/graphs/#Introduction","page":"Graphs","title":"Introduction","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"Graphs are a fundamental object within all of mathematics and computer science. A graph consists of two sets of data:","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"a finite set V = 1ldotsn of vertices; and\na finite set E subseteq Vtimes V of edges.","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"There are two types of graphs, directed and undirected. For a directed graph the elements of E are considered to be ordered pairs, for an undirected graph the elements of E are unordered pairs or rather sets with two elements.","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"The interface is modeled alongside the Graphs.jl interface to allow for easier integration elsewhere.","category":"page"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"warning: Warning\nThe mechanism for removing a vertex is slightly different in out implementation to the Graphs.jl implementation: In Graphs.jl first the vertex to be removed is swapped with the last vertex, then the last vertex is removed. In our implementation, the vertex is removed and all subsequent vertices have their labels changed. Hence edges can be different in the two implementations after removing a vertex.","category":"page"},{"location":"Combinatorics/graphs/#Construction","page":"Graphs","title":"Construction","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"Graph{T}(nverts::Int64) where {T <: Union{Directed, Undirected}}\ndualgraph(p::Polyhedron)\nedgegraph(p::Polyhedron)","category":"page"},{"location":"Combinatorics/graphs/#Graph-Union{Tuple{Int64}, Tuple{T}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"Graph","text":"Graph{T}(nverts::Int64) where {T <: Union{Directed, Undirected}}\n\nConstruct a graph on nverts vertices and no edges. T indicates whether the graph should be Directed or Undirected.\n\nExamples\n\nMake a directed graph with 5 vertices and print the number of nodes and edges.\n\njulia> g = Graph{Directed}(5);\n\njulia> nv(g)\n5\n\njulia> ne(g)\n0\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#dualgraph-Tuple{Polyhedron}","page":"Graphs","title":"dualgraph","text":"dualgraph(p::Polyhedron)\n\nReturn the dual graph of a Polyhedron, vertices of the graph correspond to facets of the polyhedron and there is an edge between two vertices if the corresponding facets are neighboring, meaning their intersection is a codimension 2 face of the polyhedron.\n\nFor bounded polyhedra containing 0 in the interior this is the same as the edge graph the polar dual polyhedron.\n\nExamples\n\nConstruct the dual graph of the cube. This is the same as the edge graph of the octahedron, so it has 6 vertices and 12 edges.\n\njulia> c = cube(3);\n\njulia> g = dualgraph(c);\n\njulia> nv(g)\n6\n\njulia> ne(g)\n12\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#edgegraph-Tuple{Polyhedron}","page":"Graphs","title":"edgegraph","text":"edgegraph(p::Polyhedron)\n\nReturn the edge graph of a Polyhedron, vertices of the graph correspond to vertices of the polyhedron, there is an edge between two vertices if the polyhedron has an edge between the corresponding vertices. The resulting graph is Undirected.\n\nExamples\n\nConstruct the edge graph of the cube. Like the cube it has 8 vertices and 12 edges.\n\njulia> c = cube(3);\n\njulia> g = edgegraph(c);\n\njulia> nv(g)\n8\n\njulia> ne(g)\n12\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#Modifying-graphs","page":"Graphs","title":"Modifying graphs","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"add_edge!(g::Graph{T}, source::Int64, target::Int64) where {T <: Union{Directed, Undirected}}\nadd_vertices!(g::Graph{T}, n::Int64) where {T <: Union{Directed, Undirected}}\nadd_vertex!(g::Graph{T}) where {T <: Union{Directed, Undirected}}\nrem_edge!(g::Graph{T}, s::Int64, t::Int64) where {T <: Union{Directed, Undirected}}\nrem_vertex!(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}","category":"page"},{"location":"Combinatorics/graphs/#add_edge!-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"add_edge!","text":"add_edge!(g::Graph{T}, s::Int64, t::Int64) where {T <: Union{Directed, Undirected}}\n\nAdd edge (s,t) to the graph g.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> ne(g)\n1\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#add_vertices!-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"add_vertices!","text":"add_vertices!(g::Graph{T}, n::Int64) where {T <: Union{Directed, Undirected}}\n\nAdd a n new vertices to the graph g.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> nv(g)\n2\n\njulia> add_vertices!(g, 5);\n\njulia> nv(g)\n7\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#add_vertex!-Union{Tuple{Oscar.Graphs.Graph{T}}, Tuple{T}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"add_vertex!","text":"add_vertex!(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nAdd a vertex to the graph g. The return value is the new vertex.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> nv(g)\n2\n\njulia> add_vertex!(g)\n3\n\njulia> nv(g)\n3\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#rem_edge!-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"rem_edge!","text":"rem_edge!(g::Graph{T}, s::Int64, t::Int64) where {T <: Union{Directed, Undirected}}\n\nRemove edge (s,t) from the graph g.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> add_edge!(g, 1, 2);\n\njulia> ne(g)\n1\n\njulia> rem_edge!(g, 1, 2);\n\njulia> ne(g)\n0\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#rem_vertex!-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"rem_vertex!","text":"rem_vertex!(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nRemove the vertex v from the graph g.\n\nExamples\n\njulia> g = Graph{Directed}(2);\n\njulia> nv(g)\n2\n\njulia> rem_vertex!(g, 1)\n\njulia> nv(g)\n1\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#Auxiliary-functions","page":"Graphs","title":"Auxiliary functions","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"all_neighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\nautomorphisms(g::Graph{T}) where {T <: Union{Directed, Undirected}}\ncomplete_graph(n::Int64)\ncomplete_bipartite_graph(n::Int64, m::Int64)\nedges(g::Graph{T}) where {T <: Union{Directed, Undirected}}\nhas_edge(g::Graph{T}, source::Int64, target::Int64) where {T <: Union{Directed, Undirected}}\nhas_vertex(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\ninneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\nne(g::Graph{T}) where {T <: Union{Directed, Undirected}}\nneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\nnv(g::Graph{T}) where {T <: Union{Directed, Undirected}}\noutneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\nshortest_path_dijkstra","category":"page"},{"location":"Combinatorics/graphs/#all_neighbors-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"all_neighbors","text":"all_neighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nReturn all vertices of a graph g that are connected to the vertex v via an edge, independent of the edge direction.\n\nExamples\n\njulia> g = Graph{Directed}(5);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> all_neighbors(g, 3)\n2-element Vector{Int64}:\n 1\n 4\n\njulia> all_neighbors(g, 4)\n1-element Vector{Int64}:\n 3\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#automorphisms-Union{Tuple{Oscar.Graphs.Graph{T}}, Tuple{T}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"automorphisms","text":"automorphisms(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn generators of the automorphism group of the graph g.\n\nExamples\n\njulia> g = complete_graph(4);\n\njulia> Graphs.automorphisms(g)\n3-element Vector{Vector{Int64}}:\n [1, 2, 4, 3]\n [1, 3, 2, 4]\n [2, 1, 3, 4]\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#complete_graph-Tuple{Int64}","page":"Graphs","title":"complete_graph","text":"complete_graph(n::Int64)\n\nAssemble the undirected complete graph on n nodes.\n\nExamples\n\njulia> g = complete_graph(3);\n\njulia> collect(edges(g))\n3-element Vector{Edge}:\n Edge(2, 1)\n Edge(3, 1)\n Edge(3, 2)\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#complete_bipartite_graph-Tuple{Int64, Int64}","page":"Graphs","title":"complete_bipartite_graph","text":"complete_bipartite_graph(n::Int64, m::Int64)\n\nAssemble the undirected complete bipartite graph between n and m nodes.\n\nExamples\n\njulia> g = complete_bipartite_graph(2,2);\n\njulia> collect(edges(g))\n4-element Vector{Edge}:\n Edge(3, 1)\n Edge(3, 2)\n Edge(4, 1)\n Edge(4, 2)\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#edges-Union{Tuple{Oscar.Graphs.Graph{T}}, Tuple{T}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"edges","text":"edges(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn an iterator over the edges of the graph g.\n\nExamples\n\nA triangle has three edges.\n\njulia> triangle = simplex(2);\n\njulia> g = edgegraph(triangle);\n\njulia> collect(edges(g))\n3-element Vector{Edge}:\n Edge(2, 1)\n Edge(3, 1)\n Edge(3, 2)\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#has_edge-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"has_edge","text":"has_edge(g::Graph{T}, source::Int64, target::Int64) where {T <: Union{Directed, Undirected}}\n\nCheck for an edge in a graph.\n\nExamples\n\nCheck for the edge 1to 2 in the edge graph of a triangle.\n\njulia> triangle = simplex(2);\n\njulia> g = edgegraph(triangle);\n\njulia> has_edge(g, 1, 2)\ntrue\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#has_vertex-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"has_vertex","text":"has_vertex(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nCheck for a vertex in a graph.\n\nExamples\n\nThe edge graph of a triangle only has 3 vertices.\n\njulia> triangle = simplex(2);\n\njulia> g = edgegraph(triangle);\n\njulia> has_vertex(g, 1)\ntrue\n\njulia> has_vertex(g, 4)\nfalse\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#inneighbors-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"inneighbors","text":"inneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nReturn the vertices of a graph g that have an edge going towards v. For an undirected graph, all neighboring vertices are returned.\n\nExamples\n\njulia> g = Graph{Directed}(5);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> inneighbors(g, 3)\n1-element Vector{Int64}:\n 1\n\njulia> inneighbors(g, 1)\nInt64[]\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#ne-Union{Tuple{Oscar.Graphs.Graph{T}}, Tuple{T}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"ne","text":"ne(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn the number of edges of a graph.\n\nExamples\n\nThe edge graph of the cube has 12 edges just like the cube itself.\n\njulia> c = cube(3);\n\njulia> g = edgegraph(c);\n\njulia> ne(g)\n12\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#neighbors-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"neighbors","text":"neighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nReturn the neighboring vertices of a vertex v in a graph g. If the graph is directed, the neighbors reachable via outgoing edges are returned.\n\nExamples\n\njulia> g = Graph{Directed}(5);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> neighbors(g, 3)\n1-element Vector{Int64}:\n 4\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#nv-Union{Tuple{Oscar.Graphs.Graph{T}}, Tuple{T}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"nv","text":"nv(g::Graph{T}) where {T <: Union{Directed, Undirected}}\n\nReturn the number of vertices of a graph.\n\nExamples\n\nThe edge graph of the cube has eight vertices, just like the cube itself.\n\njulia> c = cube(3);\n\njulia> g = edgegraph(c);\n\njulia> nv(g)\n8\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#outneighbors-Union{Tuple{T}, Tuple{Oscar.Graphs.Graph{T}, Int64}} where T<:Union{Polymake.Directed, Polymake.Undirected}","page":"Graphs","title":"outneighbors","text":"outneighbors(g::Graph{T}, v::Int64) where {T <: Union{Directed, Undirected}}\n\nReturn the vertices of a graph g that are target of an edge coming from v. For an undirected graph, all neighboring vertices are returned.\n\nExamples\n\njulia> g = Graph{Directed}(5);\n\njulia> add_edge!(g, 1, 3);\n\njulia> add_edge!(g, 3, 4);\n\njulia> outneighbors(g, 3)\n1-element Vector{Int64}:\n 4\n\njulia> outneighbors(g, 4)\nInt64[]\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#shortest_path_dijkstra","page":"Graphs","title":"shortest_path_dijkstra","text":"shortest_path_dijkstra(g::Graph{T}, s::Int64, t::Int64; reverse::Bool=false) where {T <: Union{Directed, Undirected}}\n\nCompute the shortest path between two vertices in a graph using Dijkstra's algorithm. All edges are set to have a length of 1. The optional parameter indicates whether the edges should be considered reversed.\n\nExamples\n\njulia> g = Graph{Directed}(3);\n\njulia> add_edge!(g, 1, 2);\n\njulia> add_edge!(g, 2, 3);\n\njulia> add_edge!(g, 3, 1);\n\njulia> shortest_path_dijkstra(g, 3, 1)\n2-element Vector{Int64}:\n 3\n 1\n\njulia> shortest_path_dijkstra(g, 1, 3)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> shortest_path_dijkstra(g, 3, 1; reverse=true)\n3-element Vector{Int64}:\n 3\n 2\n 1\n\n\n\n","category":"function"},{"location":"Combinatorics/graphs/#Edges","page":"Graphs","title":"Edges","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"dst(e::Edge)\nreverse(e::Edge)\nsrc(e::Edge)","category":"page"},{"location":"Combinatorics/graphs/#dst-Tuple{Oscar.Graphs.Edge}","page":"Graphs","title":"dst","text":"dst(e::Edge)\n\nReturn the destination of an edge.\n\nExamples\n\njulia> g = complete_graph(2);\n\njulia> E = collect(edges(g));\n\njulia> e = E[1]\nEdge(2, 1)\n\njulia> dst(e)\n1\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#reverse-Tuple{Oscar.Graphs.Edge}","page":"Graphs","title":"reverse","text":"reverse(e::Edge)\n\nReturn the edge in the opposite direction of the edge e.\n\nExamples\n\njulia> g = complete_graph(2);\n\njulia> E = collect(edges(g));\n\njulia> e = E[1]\nEdge(2, 1)\n\njulia> Graphs.reverse(e)\nEdge(1, 2)\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#src-Tuple{Oscar.Graphs.Edge}","page":"Graphs","title":"src","text":"src(e::Edge)\n\nReturn the source of an edge.\n\nExamples\n\njulia> g = complete_graph(2);\n\njulia> E = collect(edges(g));\n\njulia> e = E[1]\nEdge(2, 1)\n\njulia> src(e)\n2\n\n\n\n","category":"method"},{"location":"Combinatorics/graphs/#Saving-and-loading","page":"Graphs","title":"Saving and loading","text":"","category":"section"},{"location":"Combinatorics/graphs/","page":"Graphs","title":"Graphs","text":"Objects of type Graph can be saved to a file and loaded with the methods load and save.  The file is in JSON format and contains the underlying polymake object. In particular, this file can now be read by both polymake and Oscar.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/#Map-with-inverse","page":"Map with inverse","title":"Map with inverse","text":"","category":"section"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"It is not possible to provide generic functionality to invert a map. However, sometimes one knows an inverse map explicitly and would like to keep track of this.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Recall that as map composition is not commutative, there is a notion of a left inverse and a right inverse for maps.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"To keep track of such inverse maps, AbstractAlgebra provides data types Generic.MapWithRetraction and Generic.MapWithSection.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Given a map f  X to Y, a retraction of f is a map g  Y to X such that g(f(x)) = x for all x in X.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Given a map f  X to Y, a section of f is a map g  Y to X such that f(g(x)) = x for all y in Y.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"In AbstractAlgebra, a map with retraction/section is an object containing a pair of maps, the second of which is a retraction/section of the first.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Maps with retraction/section can be composed, and we also define the inverse of such a pair to be the map with the pair swapped. Thus the inverse of a map with retraction is a map with section.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/#Map-with-inverse-constructors","page":"Map with inverse","title":"Map with inverse constructors","text":"","category":"section"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"To construct a map with retraction/section from a pair of maps, we have the following functions:","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"map_with_retraction(m::Map{D, C}, r::Map{C, D}) where {D, C}\nmap_with_section(m::Map{D, C}, s::Map{C, D}) where {D, C}","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Construct the map with retraction/section given a known retraction/section r or s respectively, of m.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"For convenience we allow construction of maps with retraction/section from a pair of Julia functions/closures.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"map_with_retraction_from_func(f::Function, r::Function, R, S)\nmap_with_section_from_func(f::Function, s::Function, R, S)","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Construct the map with retraction/section such that the map is given by the function f and the retraction/section is given by the function r or s respectively. Here R is the parent object representing the domain and S is the parent object representing the codomain of f.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Examples","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"julia> f = map_with_retraction_from_func(x -> x + 1, x -> x - 1, ZZ, ZZ)\nMap with retraction with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> a = f(ZZ(1))\n2","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/#Functionality-for-maps-with-inverses","page":"Map with inverse","title":"Functionality for maps with inverses","text":"","category":"section"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"The following functionality is provided for maps with inverses.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"inv(M::Generic.MapWithRetraction)\ninv(M::Generic.MapWithSection)","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Return the map with the two maps contained in M swapped. In the first case, a MapWithSection is returned. In the second case a MapWithRetraction is returned.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"To access the two maps stored in a map with retraction/section, we have the following:","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"image_map(M::Generic.MapWithRetraction)\nimage_map(M::Generic.MapWithSection)\nretraction_map(M::Generic.MapWithRetraction)\nsection_map(M::Generic.MapWithSection)","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"The first two of these functions return the first map in a map with retraction/section, the second two functions return the corresponding second maps.","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"Examples","category":"page"},{"location":"AbstractAlgebra/map_with_inverse/","page":"Map with inverse","title":"Map with inverse","text":"julia> f = map_with_retraction_from_func(x -> x + 1, x -> x - 1, ZZ, ZZ)\nMap with retraction with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> g = inv(f)\nMap with section with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> h = f*g\nComposite map consisting of the following\n\nIntegers -> Integers\nthen\nIntegers -> Integers\n\njulia> a = h(ZZ(1))\n1\n","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"CurrentModule = Oscar","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"Pages = [\"ToricDivisorClasses.md\"]","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/#Toric-Divisor-Classes","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisorClasses/#Introduction","page":"Toric Divisor Classes","title":"Introduction","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"Toric divisor classes are equivalence classes of Weil divisors modulo linear equivalence.","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/#Constructors","page":"Toric Divisor Classes","title":"Constructors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisorClasses/#General-constructors","page":"Toric Divisor Classes","title":"General constructors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"ToricDivisorClass(v::AbstractNormalToricVariety, coeffs::Vector{fmpz})\nToricDivisorClass(v::AbstractNormalToricVariety, coeffs::Vector{Int})","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/#ToricDivisorClass-Tuple{Oscar.AbstractNormalToricVariety, Vector{fmpz}}","page":"Toric Divisor Classes","title":"ToricDivisorClass","text":"ToricDivisorClass(v::AbstractNormalToricVariety, coeffs::Vector{fmpz})\n\nConstruct the toric divisor class associated to a list of integers which specify an element of the class group of the normal toric variety v.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> tdc = ToricDivisorClass(P2, class_group(P2)([fmpz(1)]))\nA divisor class on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisorClasses/#ToricDivisorClass-Tuple{Oscar.AbstractNormalToricVariety, Vector{Int64}}","page":"Toric Divisor Classes","title":"ToricDivisorClass","text":"ToricDivisorClass(v::AbstractNormalToricVariety, coeffs::Vector{Int})\n\nConstruct the toric divisor class associated to a list of integers which specify an element of the class group of the normal toric variety v.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> tdc = ToricDivisorClass(P2, class_group(P2)([1]))\nA divisor class on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisorClasses/#Special-constructors","page":"Toric Divisor Classes","title":"Special constructors","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"Addition of toric divisor classes tdc1 and tdc2 (on the same toric variety) and scalar multiplication with c (it can be either valued in Int64 or fmpz) is supported via c * tdc1 + tdc2. One can subtract them via tdc1 - tdc2.","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/#Equality","page":"Toric Divisor Classes","title":"Equality","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"Equality of two toric divisor classes tdc1 and tdc2 (on the same toric variety) is achieved by checking if their difference is a trivial class, i.e. the divisor class of a principal toric divisor. This is implemented via tdc1 == tdc2.","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/#Properties-of-toric-divisor-classes","page":"Toric Divisor Classes","title":"Properties of toric divisor classes","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"To check if a toric divisor class tdc is trivial, one can invoke istrivial(tdc).","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/#Operations-for-toric-divisor-classes","page":"Toric Divisor Classes","title":"Operations for toric divisor classes","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"divisor_class(tdc::ToricDivisorClass)\ntoric_variety(tdc::ToricDivisorClass)\ntoric_divisor(tdc::ToricDivisorClass)","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/#divisor_class-Tuple{ToricDivisorClass}","page":"Toric Divisor Classes","title":"divisor_class","text":"divisor_class(tdc::ToricDivisorClass)\n\nReturn the element of the class group corresponding to the toric divisor class tdc.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> tdc = ToricDivisorClass(P2, class_group(P2)([1]))\nA divisor class on a normal toric variety\n\njulia> divisor_class(tdc)\nElement of\nGrpAb: Z\nwith components [1]\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisorClasses/#toric_variety-Tuple{ToricDivisorClass}","page":"Toric Divisor Classes","title":"toric_variety","text":"toric_variety(tdc::ToricDivisorClass)\n\nReturn the toric variety on which the toric divisor class tdc is defined.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> tdc = ToricDivisorClass(P2, class_group(P2)([1]))\nA divisor class on a normal toric variety\n\njulia> toric_variety(tdc)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisorClasses/#toric_divisor-Tuple{ToricDivisorClass}","page":"Toric Divisor Classes","title":"toric_divisor","text":"toric_divisor(tdc::ToricDivisorClass)\n\nConstructs a toric divisor corresponding to the toric divisor class  tdc.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> tdc = ToricDivisorClass(P2, class_group(P2)([1]))\nA divisor class on a normal toric variety\n\njulia> toric_divisor(tdc)\nA torus-invariant, prime divisor on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisorClasses/#Special-divisor-classes","page":"Toric Divisor Classes","title":"Special divisor classes","text":"","category":"section"},{"location":"ToricVarieties/ToricDivisorClasses/","page":"Toric Divisor Classes","title":"Toric Divisor Classes","text":"trivial_divisor_class(v::AbstractNormalToricVariety)\nanticanonical_divisor_class(v::AbstractNormalToricVariety)\ncanonical_divisor_class(v::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/ToricDivisorClasses/#trivial_divisor_class-Tuple{Oscar.AbstractNormalToricVariety}","page":"Toric Divisor Classes","title":"trivial_divisor_class","text":"trivial_divisor_class(v::AbstractNormalToricVariety)\n\nConstruct the trivial divisor class of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> trivial_divisor_class(v)\nA divisor class on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisorClasses/#anticanonical_divisor_class-Tuple{Oscar.AbstractNormalToricVariety}","page":"Toric Divisor Classes","title":"anticanonical_divisor_class","text":"anticanonical_divisor_class(v::AbstractNormalToricVariety)\n\nConstruct the anticanonical divisor class of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> anticanonical_divisor_class(v)\nA divisor class on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricDivisorClasses/#canonical_divisor_class-Tuple{Oscar.AbstractNormalToricVariety}","page":"Toric Divisor Classes","title":"canonical_divisor_class","text":"canonical_divisor_class(v::AbstractNormalToricVariety)\n\nConstruct the canonical divisor class of a normal toric variety.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> canonical_divisor_class(v)\nA divisor class on a normal toric variety\n\n\n\n","category":"method"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"CurrentModule = Oscar","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"using Oscar","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Pages = [\"integer.md\"]","category":"page"},{"location":"Rings/integer/#Integers","page":"Integers","title":"Integers","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"An important design decision in Oscar.jl is to use Julia as the user language by default. This means that integers typed at the REPL are Julia integers. However, for performance reasons, Oscar has its own integer format.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Julia has a number of different integer types, but the two that are most relevant here are Int and BigInt. All the Julia integer types belong to Integer.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The Int type is for machine integers which are highly efficient, but can only represent integers up to a certain size, and most basic arithmetic operations are performed unchecked, that is, they can silently overflow. The Int type is the type of literal input such as 12, and should be used for loop control flow, array indices, and other situations where the overflow can be provably avoided.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The BigInt type is backed by GMP multiprecision integers and can represent integers whose size is usually only limited by available memory. While the BigInt type avoids overflow problems, it can be relatively slow in the Int range.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Oscar currently has the integer type fmpz, which for performance reasons scales internally from machine integers to GMP multiprecision integers.","category":"page"},{"location":"Rings/integer/#The-ring-of-integers","page":"Integers","title":"The ring of integers","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Every object in Oscar representing a mathematical element has a parent. This is an object encoding information about where that element belongs.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The parent of an Oscar integer is the ring of integers ZZ.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"ZZ","category":"page"},{"location":"Rings/integer/#Integer-constructors","page":"Integers","title":"Integer constructors","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Oscar integers are created using ZZ:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"ZZ(2)^100\nZZ(618970019642690137449562111)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"One can also construct the integer 0 with the empty constructor:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"ZZ()","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The following special constructors are also provided:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"zero(ZZ)\none(ZZ)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"zero(ZZ)\none(ZZ)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Note that ZZ is not a Julia type, but the above methods of constructing Oscar integers are similar to the way that Julia integer types can be used to construct Julia integers.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Int(123)\nBigInt(123456343567843598776327698374259876295438725)\nzero(BigInt)\none(Int)","category":"page"},{"location":"Rings/integer/#Limitations","page":"Integers","title":"Limitations","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Oscar integers have the same limitations as GMP multiprecision integers, namely that they are limited by the available memory on the machine and in any case to signed integers whose absolute value does not exceed 2^37 bits.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nThe Julia Int type is either a 32 or 64 bit integer, depending on the machine architecture (usually 64 bits on most modern machines). The range of values is machine dependent, but can be found by typing typemin(Int) and typemax(Int) in Julia.","category":"page"},{"location":"Rings/integer/#Julia-integers-in-Oscar-functions","page":"Integers","title":"Julia integers in Oscar functions","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"For convenience, all basic arithmetic and exact division functions in Oscar also accept Julia integers. If all of the arguments to an Oscar function are julia integers, the resulting integers should be julia integers. However, once at least one of the arguments is an fmpz, the function will generally behave as if all integer arguments were promoted to the type fmpz, and the integers in the return generally should also be of type fmpz. For example:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divexact(ZZ(234), 2)\ntypeof(gcd(4, 6))\ntypeof(gcdx(4, 6))\ntypeof(gcd(4, ZZ(6)))\ntypeof(gcdx(4, ZZ(6)))\ntypeof(jacobi_symbol(ZZ(2), ZZ(3)))","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"In the first example, 2 is a Julia integer but is still valid in the call to the Oscar function divexact. In the last example, the exceptional function jacobi_symbol returns an Int as this will always be able to hold the three possible return values of -1, 0, or 1.","category":"page"},{"location":"Rings/integer/#Predicates","page":"Integers","title":"Predicates","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"iszero(n::fmpz) -> Bool\nisone(n::fmpz) -> Bool\nisunit(n::fmpz) -> Bool\nisodd(n::fmpz) -> Bool\niseven(n::fmpz) -> Bool\nissquare(n::fmpz) -> Bool\nisprime(n::fmpz) -> Bool\nisprobable_prime(n::fmpz) -> Bool","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The isprime predicate will prove primality, whereas isprobable_prime may declare a composite number to be prime with very low probability.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Negative numbers, 0 and 1 are not considered prime by isprime and isprobable_prime.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"isone(ZZ(1))\nisunit(ZZ(-1))\nissquare(ZZ(16))\nisprobable_prime(ZZ(23))","category":"page"},{"location":"Rings/integer/#Properties","page":"Integers","title":"Properties","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"sign(n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the sign of n, i.e. nn if n neq 0, or 0 otherwise.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"sign(ZZ(23))\nsign(ZZ(0))\nsign(ZZ(-1))","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"abs(n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the absolute value of n, i.e. n if n geq 0 and -n otherwise","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"abs(ZZ(-3))","category":"page"},{"location":"Rings/integer/#Basic-arithmetic","page":"Integers","title":"Basic arithmetic","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Oscar provides the basic arithmetic operations +, - and * and comparison operators ==, !=, <, <=, >, >=, including mixed operations between Julia and Oscar integers. It also provides division and powering as described below.","category":"page"},{"location":"Rings/integer/#Division-in-Oscar","page":"Integers","title":"Division in Oscar","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Oscar distinguishes a number of different kinds of division:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Exact division (divexact)\nEuclidean division (div, rem, divrem and mod)\nConstruction of fractions (a//b)\nFloating point division (a/b)\nDivisibility testing (divides)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"These choices have been made for maximum parsimony with the Julia language.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nIt is a common error to enter 1/2 for the fraction 'one half' in Julia. This expression is reserved for floating point division. Instead, the double slash operator // should be used for fractions.","category":"page"},{"location":"Rings/integer/#integer_exact_division","page":"Integers","title":"Exact Division","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divexact(a::fmpz, b::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the quotient of a by b. The result of the exact division of two integers will always be another integer. Exact division raises an exception if the division is not exact, or if division by zero is attempted.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divexact(ZZ(6), ZZ(3))\ndivexact(ZZ(6), ZZ(0))\ndivexact(ZZ(6), ZZ(5))\ndivexact(ZZ(6), 2)","category":"page"},{"location":"Rings/integer/#Powering","page":"Integers","title":"Powering","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"^(a::fmpz, b::Int) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the result of powering a by b.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"ZZ(37)^37\nZZ(1)^(-2)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nAn exception will be raised if an integer other than -1 or 1 is raised to a negative exponent.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nIn Julia 2^-2 is called a literal power. The value returned is a floating point value. To get behaviour that agrees with Oscar, one can write 2^Int(-2).","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The following is allowed for convenience.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"ZZ(0)^0","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nIn Julia, 2^64 will return zero, as the Julia integer 2 is a machine integer. In Oscar, the expression ZZ(2)^64 will return the expected result, just as the Julia equivalent BigInt(2)^64 does.","category":"page"},{"location":"Rings/integer/#integer_euclidean_division","page":"Integers","title":"Euclidean division","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The ring of integers is a Euclidean domain and Oscar provides Euclidean division through the functions divrem, div and rem.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Integer Euclidean division of a by b computes a quotient and remainder such that","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"a = qb + r","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"with r  b.","category":"page"},{"location":"Rings/integer/#Division-with-remainder","page":"Integers","title":"Division with remainder","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divrem(a::fmpz, b::fmpz) -> (fmpz, fmpz) : division with remainder\ndiv(a::fmpz, b::fmpz) -> fmpz : quotient only\nrem(a::fmpz, b::fmpz) -> fmpz : remainder only","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Both rem and divrem compute the remainder r such that when r neq 0 the sign of r is the same as the sign of a.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"All three functions raise an exception if the modulus b is zero.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divrem(ZZ(5), ZZ(3))\ndiv(ZZ(7), ZZ(2))\nrem(ZZ(4), ZZ(3))\ndiv(ZZ(2), ZZ(0))","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nThe rem function does not provide a minimal set of representatives, e.g. rem(-2, 3) = -2 but rem(1, 3) = 1.","category":"page"},{"location":"Rings/integer/#Modular-arithmetic","page":"Integers","title":"Modular arithmetic","text":"","category":"section"},{"location":"Rings/integer/#Modular-reduction","page":"Integers","title":"Modular reduction","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"mod(a::fmpz, b::fmpz) -> fmpz : remainder only","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The mod function computes a remainder r such that when r neq 0 the sign of r is the same as the sign of b. Thus, if b  0 then mod(a, b) will be in the range 0 b). An exception is raised if the modulus b is zero. This is summarised in the following table.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"remainder division sign rounding\nrem div/divrem same as dividend towards zero\nmod  same as divisor towards -infty","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"There is no function implemented to compute the quotient corresponding to the remainder given by mod.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"mod(ZZ(4), ZZ(3))\nmod(ZZ(2), ZZ(0)) ","category":"page"},{"location":"Rings/integer/#integer_divisibility_testing","page":"Integers","title":"Divisibility testing","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divides(a::fmpz, b::fmpz) -> (Bool, fmpz)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"In Oscar, we say that b divides a if there exists c in the same ring such that a = bc.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The call divides(a, b) returns a tuple (flag, q) where flag is either true if b divides a in which case q will be a quotient, or flag is false if b does not divide a in which case q will be an integer whose value is not defined.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divides(ZZ(6), ZZ(3))\ndivides(ZZ(5), ZZ(2))","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Note that for convenience we define:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divides(ZZ(0), ZZ(0))","category":"page"},{"location":"Rings/integer/#Greatest-common-divisor","page":"Integers","title":"Greatest common divisor","text":"","category":"section"},{"location":"Rings/integer/#Greatest-common-divisor-2","page":"Integers","title":"Greatest common divisor","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"gcd(a::fmpz, b::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the greatest common divisor of its inputs, which is by definition the largest integer dividing the two inputs, unless both inputs are zero in which case it returns zero. The result will always be non-negative and will only be zero if both inputs are zero.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"gcd(ZZ(34), ZZ(17))\ngcd(ZZ(3), ZZ(0))","category":"page"},{"location":"Rings/integer/#Extended-GCD","page":"Integers","title":"Extended GCD","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"gcdx(a::fmpz, b::fmpz) -> (fmpz, fmpz, fmpz)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return a tuple (g s t) such that g is the greatest common divisor of a and b and g = as + bt. Normally s and t are chosen so that s  b(2g) and t  a(2g), where this uniquely defines s and t. The following cases are handled specially:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"if a = b then t = bb\nif b = 0 or b = 2g then s = aa\nif a = 0 or a = 2g then t = bb","category":"page"},{"location":"Rings/integer/#Least-common-multiple","page":"Integers","title":"Least common multiple","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"lcm(a::fmpz, b::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the least common multiple of a and b. This is the least positive multiple of a and b, unless a = 0 or b = 0 which case we define the least common multiple to be zero.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"lcm(ZZ(6), ZZ(21))\nlcm(ZZ(0), ZZ(0))","category":"page"},{"location":"Rings/integer/#Roots","page":"Integers","title":"Roots","text":"","category":"section"},{"location":"Rings/integer/#Square-roots","page":"Integers","title":"Square roots","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Julia and Oscar distinguish two kinds of square root:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Integer square root (isqrt)\nFloating point square root (sqrt)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"We describe only the first of these here.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"isqrt(n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the floor of the square root of its argument, i.e. the largest integer whose square does not exceed its input. An exception is raised if a negative input is passed.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"isqrt(ZZ(16))\nisqrt(ZZ(0))\nisqrt(ZZ(5))\nisqrt(ZZ(-3))","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"isqrtrem(n::fmpz) -> (fmpz, fmpz)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the tuple (s, r) such that s is equal to isqrt(n) and n = s^2 + r.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"isqrtrem(ZZ(16))\nisqrtrem(ZZ(5))","category":"page"},{"location":"Rings/integer/#General-roots","page":"Integers","title":"General roots","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"root(a::fmpz, n::Int) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the value r of largest absolute value such that r^n leq a. When a is a perfect n-th power, the return value will be an n-th root of a.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"When n is even, the non-negative root is always returned. An exception is raised if n leq 0 or if n is even and a  0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"root(ZZ(16), 4)\nroot(ZZ(5), 2)\nroot(ZZ(-5), 3)\nroot(ZZ(0), 4)\nroot(ZZ(-5), 2)\nroot(ZZ(12), -2)","category":"page"},{"location":"Rings/integer/#Conversions","page":"Integers","title":"Conversions","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Int(n::fmpz) -> Int\nBigInt(n::fmpz) -> BigInt","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Convert the Oscar integer to the respective Julia integer.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"n = ZZ(123)\nInt(n)\nBigInt(n)","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"In the case of Int, if the Oscar integer is too large to fit, an exception is raised.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Int(ZZ(12348732648732648763274868732687324))","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"fits(::Type{Int}, n::fmpz) -> Bool","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return true if the Oscar integer will fit in an Int.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"fits(Int, ZZ(123))\nfits(Int, ZZ(12348732648732648763274868732687324))","category":"page"},{"location":"Rings/integer/#Factorisation","page":"Integers","title":"Factorisation","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"factor(n::fmpz) -> Fac{fmpz}","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return a factorisation of the given integer. The return value is a special factorisation struct which can be manipulated using the functions below.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"factor(ZZ(-6000361807272228723606))\nfactor(ZZ(0))","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"unit(F::Fac) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"F = factor(ZZ(-12))\nunit(F)","category":"page"},{"location":"Rings/integer/#Factorisation-are-iterable","page":"Integers","title":"Factorisation are iterable","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Once created, a factorisation is iterable:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"F = factor(ZZ(-60))\nfor (p, e) in F; println(\"$p^$e\"); end","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"The pairs (p, e) in a factorisation represent the prime power factors p^e of the non-unit part of the factorisation. They can be placed in an array using collect:","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"F = factor(ZZ(-60))\ncollect(F)","category":"page"},{"location":"Rings/integer/#Accessing-exponents-in-a-factorisation","page":"Integers","title":"Accessing exponents in a factorisation","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"One can also determine whether a given prime is in the non-unit part of a factorisation and if so return its exponent. If the exponent of a prime that is not in a factorisation is requested, an exception is raised.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"For convenience, a Int can be used instead of an Oscar integer for this functionality.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"F = factor(ZZ(-60))\n5 in F\nZZ(3) in F\n7 in F\nF[3]\nF[ZZ(7)]","category":"page"},{"location":"Rings/integer/#Combinatorial-functions","page":"Integers","title":"Combinatorial functions","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nThe functions in this section that take Int arguments will return an Int, which may overflow or throw an error. Use the fmpz versions if this is not the desired behaviour.","category":"page"},{"location":"Rings/integer/#Factorial","page":"Integers","title":"Factorial","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"factorial(n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the factorial of n, i.e. n. An exception is raised if n  0. We define 0 = 1.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"rising_factorial(x::Int, n::Int) -> Int\nrising_factorial(x::fmpz, n::Int) -> fmpz\nrising_factorial(x::fmpz, n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return x(x + 1)(x + 2)ldots(x + n - 1). An exception is raised if n  0. We define rising_factorial(x, 0) to be 1.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"factorial(ZZ(30))\nrising_factorial(ZZ(-30), 3)","category":"page"},{"location":"Rings/integer/#Primorial","page":"Integers","title":"Primorial","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"primorial(n::Int) -> Int\nprimorial(n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the primorial P(n), i.e. the product of all primes less than or equal to n. An exception is raised if n  0. We define P(0) = P(1) = 1.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"primorial(ZZ(100))","category":"page"},{"location":"Rings/integer/#Bell-numbers","page":"Integers","title":"Bell numbers","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"bell(n::Int) -> Int\nbell(n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the n-th Bell number B(n), i.e. the number of ways of partitioning a set of n elements. An exception is raised if n  0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"bell(ZZ(20))","category":"page"},{"location":"Rings/integer/#Binomial-coefficients","page":"Integers","title":"Binomial coefficients","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"binomial(n::fmpz, k::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the binomial coefficient fracn (n-1) cdots (n-k+1)k for k ge 0 and returns 0 for k < 0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nJulia already defines the binomial function for Int, which throws an error on overflow.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"binomial(ZZ(72), ZZ(15))","category":"page"},{"location":"Rings/integer/#Integer-partitions","page":"Integers","title":"Integer partitions","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"number_of_partitions(n::Int) -> Int\nnumber_of_partitions(n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the number of integer partitions p(n) of n, i.e. the number of distinct ways to write n as a sum of positive integers. Note that p(0) = 1, as the empty sum is counted. For n  0 we return zero.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"number_of_partitions(ZZ(10^6))","category":"page"},{"location":"Rings/integer/#Fibonacci-sequence","page":"Integers","title":"Fibonacci sequence","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"fibonacci(n::Int) -> Int\nfibonacci(n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the n-th Fibonacci number F(n), defined by the recurrence relation F(1) = 1, F(2) = 1 and F(n) = F(n - 1) + F(n - 2) for n geq 3. We define F(0) = 0 and for n  0 we have F(-n) = (-1)^n+1F(n).","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"fibonacci(ZZ(100))\nfibonacci(-2)","category":"page"},{"location":"Rings/integer/#Number-theoretic-functionality","page":"Integers","title":"Number theoretic functionality","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"note: Note\nThe functions in this section that take Int arguments will return a Int, which may overflow or throw an error. Use the fmpz versions if this is not the desired behaviour.","category":"page"},{"location":"Rings/integer/#Moebius-mu-function","page":"Integers","title":"Moebius mu function","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"moebius_mu(n::Int) -> Int\nmoebius_mu(n::fmpz) -> Int ","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the Moebius function mu(n), which is defined to be 0 if n is not squarefree and otherwise is defined to be +1 or -1 if n has an even or odd number of prime factors, respectively. Alternatively, mu(n) can be defined to be the sum of the primitive n-th roots of unity. An exception is raised if n leq 0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"moebius_mu(30)","category":"page"},{"location":"Rings/integer/#Jacobi-symbols","page":"Integers","title":"Jacobi symbols","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"jacobi_symbol(m::Int, n::Int) -> Int\njacobi_symbol(m::fmpz, n::fmpz) -> Int","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the Jacobi symbol left(fracmnright), which is defined for integers m and odd, positive integers n. If the factorisation of n is n = p_1^i_1p_2^i_2ldots p_r^i_r then we define","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"left(fracmnright) = left(fracmp_1right)^i_1left(fracmp_2right)^i_2ldots left(fracmp_rright)^i_r","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"where left(fracmpright) on the right hand side is the Legendre symbol, which is defined for an odd prime number p to be 0 if p divides m and otherwise +1 or -1 depending on whether m is a square modulo p or not. An exception is raised if n is even or if n leq 0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"jacobi_symbol(3, 37)","category":"page"},{"location":"Rings/integer/#Sigma-function","page":"Integers","title":"Sigma function","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divisor_sigma(m::Int, n::Int) -> Int\ndivisor_sigma(m::fmpz, n::Int) -> fmpz\ndivisor_sigma(m::fmpz, n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the sum of the n-th powers of the divisors of m","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"sigma(m n) = sum_dm d^n","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"If m leq 0 or n  0 we raise an exception.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"divisor_sigma(60, 5)","category":"page"},{"location":"Rings/integer/#Euler-totient-function","page":"Integers","title":"Euler totient function","text":"","category":"section"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"euler_phi(n::Int) -> Int\neuler_phi(n::fmpz) -> fmpz","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"Return the Euler totient function varphi(n), i.e. the number of positive integers 1 leq x leq n which are coprime to n. Note that varphi(1) = 1. We raise an exception if n leq 0.","category":"page"},{"location":"Rings/integer/","page":"Integers","title":"Integers","text":"euler_phi(200)","category":"page"},{"location":"Groups/fpgroup/","page":"Finitely presented groups","title":"Finitely presented groups","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/fpgroup/","page":"Finitely presented groups","title":"Finitely presented groups","text":"using Oscar","category":"page"},{"location":"Groups/fpgroup/","page":"Finitely presented groups","title":"Finitely presented groups","text":"Pages = [\"fpgroup.md\"]","category":"page"},{"location":"Groups/fpgroup/#Finitely-presented-groups","page":"Finitely presented groups","title":"Finitely presented groups","text":"","category":"section"},{"location":"Groups/fpgroup/","page":"Finitely presented groups","title":"Finitely presented groups","text":"FPGroup\nFPGroupElem\nfree_group(n::Int)\nrelators(G::FPGroup)","category":"page"},{"location":"Groups/fpgroup/#FPGroup","page":"Finitely presented groups","title":"FPGroup","text":"FPGroup\n\nFinitely presented group. Such groups can be constructed a factors of free groups, see free_group.\n\n\n\n\n\n","category":"type"},{"location":"Groups/fpgroup/#FPGroupElem","page":"Finitely presented groups","title":"FPGroupElem","text":"TODO: document this\n\n\n\n\n\n","category":"type"},{"location":"Groups/fpgroup/#free_group-Tuple{Int64}","page":"Finitely presented groups","title":"free_group","text":"free_group(n::Int, s::Union{String, Symbol} = \"f\") -> FPGroup\nfree_group(L::Vector{<:Union{String, Symbol}}) -> FPGroup\nfree_group(L::Union{String, Symbol}...) -> FPGroup\n\nThe first form returns the free group of rank n, where the generators are printed as s1, s2, ..., the default being f1, f2, ...\n\nThe second form, if L has length n, returns the free group of rank n, where the i-th generator is printed as L[i].\n\nThe third form, if there are n arguments L..., returns the free group of rank n, where the i-th generator is printed as L[i].\n\nwarning: Note\nVariables named like the group generators are not created by this function.\n\n\n\n\n\n","category":"method"},{"location":"Groups/fpgroup/#relators-Tuple{FPGroup}","page":"Finitely presented groups","title":"relators","text":"relators(G::FPGroup)\n\nReturn a vector of relators for the finitely presented group, i.e., elements x_1 x_2 ldots x_n in F = free_group(ngens(G)) such that G is isomorphic with Fx_1 x_2 ldots x_n.\n\n\n\n","category":"method"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"CurrentModule = Oscar","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"using Oscar","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"Pages = [\"free_associative_algebra.md\"]","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Free-Associative-Algebras","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Two-sided-ideals","page":"Free Associative Algebras","title":"Two-sided ideals","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Types","page":"Free Associative Algebras","title":"Types","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"The OSCAR type for two-sided ideals in a free associative algebra is FreeAssAlgIdeal{T}, where T is the element type of the algebra.","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Constructors","page":"Free Associative Algebras","title":"Constructors","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"ideal(R::FreeAssAlgebra, g::Vector{T}) where T <: FreeAssAlgElem\nideal(g::Vector{T}) where T <: FreeAssAlgElem","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#Ideal-Membership","page":"Free Associative Algebras","title":"Ideal Membership","text":"","category":"section"},{"location":"NoncommutativeAlgebra/free_associative_algebra/","page":"Free Associative Algebras","title":"Free Associative Algebras","text":"ideal_membership(a::FreeAssAlgElem, I::FreeAssAlgIdeal, deg_bound::Int)","category":"page"},{"location":"NoncommutativeAlgebra/free_associative_algebra/#ideal_membership-Tuple{FreeAssAlgElem, Oscar.FreeAssAlgIdeal, Int64}","page":"Free Associative Algebras","title":"ideal_membership","text":"ideal_membership(a::FreeAssAlgElem, I::FreeAssAlgIdeal, deg_bound::Int)\n\nReturn true if calucations with intermediate degrees bounded by deg_bound prove that a is in I. Otherwise, a return of false indicates an inconclusive answer, but larger deg_bounds give more confidence in a negative answer.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/laurent_polynomial/#Generic-Laurent-polynomials","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"","category":"section"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"Laurent polynomials are similar to polynomials but can have terms of negative degrees, and form a ring denoted by Rx x^-1 where R is the coefficient ring.","category":"page"},{"location":"AbstractAlgebra/laurent_polynomial/#Generic-Laurent-polynomial-types","page":"Generic Laurent polynomials","title":"Generic Laurent polynomial types","text":"","category":"section"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"AbstractAlgebra.jl provides a generic implementation of Laurent polynomials, built in terms of regular polynomials in the file src/generic/LaurentPoly.jl.","category":"page"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"The type LaurentPolyWrap{T, ...} <: LaurentPolyElem{T} implements generic Laurent polynomials by wrapping regular polynomials: a Laurent polynomial l wraps a polynomial p and an integer n such that l = x^-n * p.","category":"page"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"The corresponding parent type is LaurentPolyWrapRing{T, ...} <: LaurentPolynomialRing{T}.","category":"page"},{"location":"AbstractAlgebra/laurent_polynomial/#Abstract-types","page":"Generic Laurent polynomials","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"Two abstract types LaurentPolyElem{T} and LaurentPolynomialRing{T} are defined to represent Laurent polynomials and rings thereof, parameterized on a base ring T.","category":"page"},{"location":"AbstractAlgebra/laurent_polynomial/#Laurent-polynomials-ring-constructor","page":"Generic Laurent polynomials","title":"Laurent polynomials ring constructor","text":"","category":"section"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"In order to instantiate Laurent polynomials, one must first construct the parent ring:","category":"page"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"LaurentPolynomialRing","category":"page"},{"location":"AbstractAlgebra/laurent_polynomial/#LaurentPolynomialRing","page":"Generic Laurent polynomials","title":"LaurentPolynomialRing","text":"LaurentPolynomialRing(R::Ring, s::Union{AbstractString, Char, Symbol})\n\nGiven a base ring R and string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new Laurent polynomial ring S = Rx 1x and the generator x of the ring.\n\nExamples\n\njulia> R, x = LaurentPolynomialRing(ZZ, \"x\")\n(Univariate Laurent Polynomial Ring in x over Integers, x)\n\njulia> 2x^-3 + x^2\nx^2 + 2*x^-3\n\njulia> rand(R, -3:3, -9:9)\n-3*x^2 - 8*x + 4 + 3*x^-1 - 6*x^-2 + 9*x^-3\n\n\n\nLaurentPolynomialRing(R::AbstractAlgebra.Ring, s::Vector{T}; cached::Bool = true) where T <: Union{String, Char, Symbol}\n\nGiven a base ring R and an array of strings s specifying how the generators (variables) should be printed, return a tuple T, (x1, x2, ...) representing the new ring T = Rx1 1x1 x2 1x2  and the generators x1 x2  of the  ring. By default the parent object T will depend only on R and x1, x2, ... and will be cached. Setting the optional argument cached to false will prevent the parent object T from being cached.\n\n\n\n","category":"type"},{"location":"AbstractAlgebra/laurent_polynomial/#Basic-functionality","page":"Generic Laurent polynomials","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"Laurent polynomials implement the ring interface, and some methods from the polynomial interface, for example:","category":"page"},{"location":"AbstractAlgebra/laurent_polynomial/","page":"Generic Laurent polynomials","title":"Generic Laurent polynomials","text":"julia> R, x = LaurentPolynomialRing(ZZ, \"x\")\n(Univariate Laurent Polynomial Ring in x over Integers, x)\n\njulia> var(R)\n:x\n\njulia> symbols(R)\n1-element Vector{Symbol}:\n :x\n\njulia> nvars(R)\n1\n\njulia> f = x^-2 + 2x\n2*x + x^-2\n\njulia> coeff.(f, -2:2)\n5-element Vector{BigInt}:\n 1\n 0\n 0\n 2\n 0\n\njulia> set_coefficient!(f, 3, ZZ(5))\n5*x^3 + 2*x + x^-2\n\njulia> isgen(f)\nfalse\n\njulia> shift_left(f,2)\n5*x^5 + 2*x^3 + 1\n\njulia> map_coefficients(x->2x, f)\n10*x^3 + 4*x + 2*x^-2\n\njulia> change_base_ring(RealField, f)\n5.0*x^3 + 2.0*x + x^-2\n\njulia> leading_coefficient(f), trailing_coefficient(f)\n(5, 1)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/acb/#Complex-balls","page":"Complex balls","title":"Complex balls","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Arbitrary precision complex ball arithmetic is supplied by Arb which provides a ball representation which tracks error bounds rigorously. Complex numbers are  represented in rectangular form a+bi where ab are arb balls.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"The Arb complex field is constructed using the AcbField constructor. This constructs the parent object for the Arb complex field.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"We define","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"ComplexField = AcbField","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"so that one can construct the Arb complex field parent using ComplexField instead of AcbField.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"The types of complex boxes in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Library Field Element type Parent type\nArb mathbbC (boxes) acb AcbField","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"All the complex field types belong to the Field abstract type and the types of elements in this field, i.e. complex boxes in this case, belong to the FieldElem abstract type.","category":"page"},{"location":"Nemo/acb/#Complex-ball-functionality","page":"Complex balls","title":"Complex ball functionality","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"The complex balls in Nemo provide all the field functionality defined by AbstractAlgebra:.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Below, we document the additional functionality provided for complex balls.","category":"page"},{"location":"Nemo/acb/#Complex-field-constructors","page":"Complex balls","title":"Complex field constructors","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"In order to construct complex boxes in Nemo, one must first construct the Arb complex field itself. This is accomplished with the following constructor.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"AcbField(prec::Int)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Return the Arb complex field with precision in bits prec used for operations on interval midpoints. The precision used for interval radii is a fixed implementation-defined constant (30 bits).","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Here is an example of creating an Arb complex field and using the resulting parent object to coerce values into the resulting field.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\n\na = CC(\"0.25\")\nb = CC(\"0.1\")\nc = CC(0.5)\nd = CC(12)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Note that whilst one can coerce double precision floating point values into an Arb complex field, unless those values can be represented exactly in double precision the resulting ball can't be any more precise than the double precision supplied.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"If instead, values can be represented precisely using decimal arithmetic then one can supply them to Arb using a string. In this case, Arb will store them to the precision specified when creating the Arb complex field.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"If the values can be stored precisely as a binary floating point number, Arb will store the values exactly. See the function isexact below for more information.","category":"page"},{"location":"Nemo/acb/#Constructors","page":"Complex balls","title":"Constructors","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"onei(::AcbField)","category":"page"},{"location":"Nemo/acb/#onei-Tuple{AcbField}","page":"Complex balls","title":"onei","text":"onei(r::AcbField)\n\nReturn exact one times i in the given Arb complex field.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\n\nc = onei(CC)","category":"page"},{"location":"Nemo/acb/#Basic-functionality","page":"Complex balls","title":"Basic functionality","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"The following basic functionality is provided by the default Arb complex field implementation in Nemo, to support construction of generic rings over complex fields. Any custom complex field implementation in Nemo should provide analogues of these functions along with the usual arithmetic operations.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"parent_type(::Type{acb})","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Gives the type of the parent object of an Arb complex field element.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"elem_type(R::AcbField)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Given the parent object for an Arb complex field, return the type of elements of the field.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"mul!(c::acb, a::acb, b::acb)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Multiply a by b and set the existing Arb complex field element c to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"addeq!(c::acb, a::acb)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"In-place addition adds a to c and sets c to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"deepcopy(a::acb)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Return a copy of the Arb complex field element a, recursively copying the internal data. Arb complex field elements are mutable in Nemo so a shallow copy is not sufficient.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Given the parent object R for an Arb complex field, the following coercion functions are provided to coerce various elements into the Arb complex field. Developers provide these by overloading the call operator for the complex field parent objects.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"R()","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Coerce zero into the Arb complex field.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"R(n::Integer)\nR(f::fmpz)\nR(q::fmpq)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Coerce an integer or rational value into the Arb complex field.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"R(f::Float64)\nR(f::BigFloat)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Coerce the given floating point number into the Arb complex field.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"R(f::AbstractString)\nR(f::AbstractString, g::AbstractString)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Coerce the decimal number, given as a string, into the Arb complex field. In each case f is the real part and g is the imaginary part.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"R(f::arb)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Coerce the given Arb real ball into the Arb complex field.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"R(f::acb)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Take an Arb complex field element that is already in an Arb field and simply return it. A copy of the original is not made.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Here are some examples of coercing elements into the Arb complex field.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"RR = RealField(64)\nCC = ComplexField(64)\n\na = CC(3)\nb = CC(QQ(2,3))\nc = CC(\"3 +/- 0.0001\")\nd = CC(\"-1.24e+12345\")\nf = CC(\"nan +/- inf\")\ng = CC(RR(3))","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"In addition to the above, developers of custom complex field types must ensure that they provide the equivalent of the function base_ring(R::AcbField) which should return Union{}. In addition to this they should ensure that each complex field element contains a field parent specifying the parent object of the complex field element, or at least supply the equivalent of the function parent(a::acb) to return the parent object of a complex field element.","category":"page"},{"location":"Nemo/acb/#Basic-manipulation","page":"Complex balls","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"isfinite(::acb)","category":"page"},{"location":"Nemo/acb/#isfinite-Tuple{acb}","page":"Complex balls","title":"isfinite","text":"isfinite(x::acb)\n\nReturn true if x is finite, i.e. its real and imaginary parts have finite midpoint and radius, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"isexact(::acb)","category":"page"},{"location":"Nemo/acb/#isexact-Tuple{acb}","page":"Complex balls","title":"isexact","text":"isexact(x::acb)\n\nReturn true if x is exact, i.e. has its real and imaginary parts have zero radius, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"isinteger(::acb)","category":"page"},{"location":"Nemo/acb/#isinteger-Tuple{acb}","page":"Complex balls","title":"isinteger","text":"isinteger(x::acb)\n\nReturn true if x is an exact integer, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"accuracy_bits(::acb)","category":"page"},{"location":"Nemo/acb/#accuracy_bits-Tuple{acb}","page":"Complex balls","title":"accuracy_bits","text":"accuracy_bits(x::acb)\n\nReturn the relative accuracy of x measured in bits, capped between typemax(Int) and -typemax(Int).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\n\na = CC(\"1.2 +/- 0.001\")\nb = CC(3)\n\nisreal(a)\nisfinite(b)\nisinteger(b)\nc = real(a)\nd = imag(b)\nf = accuracy_bits(a)","category":"page"},{"location":"Nemo/acb/#Containment","page":"Complex balls","title":"Containment","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"It is often necessary to determine whether a given exact value or box is contained in a given complex box or whether two boxes overlap. The following functions are provided for this purpose.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"overlaps(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#overlaps-Tuple{acb, acb}","page":"Complex balls","title":"overlaps","text":"overlaps(x::acb, y::acb)\n\nReturns true if any part of the box x overlaps any part of the box y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"contains(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#contains-Tuple{acb, acb}","page":"Complex balls","title":"contains","text":"contains(x::acb, y::acb)\n\nReturns true if the box x contains the box y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"contains(::acb, ::Integer)\ncontains(::acb, ::fmpz)\ncontains(::acb, ::fmpq)","category":"page"},{"location":"Nemo/acb/#contains-Tuple{acb, Integer}","page":"Complex balls","title":"contains","text":"contains(x::acb, y::Integer)\n\nReturns true if the box x contains the given integer value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/acb/#contains-Tuple{acb, fmpz}","page":"Complex balls","title":"contains","text":"contains(x::acb, y::fmpz)\n\nReturns true if the box x contains the given integer value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/acb/#contains-Tuple{acb, fmpq}","page":"Complex balls","title":"contains","text":"contains(x::acb, y::fmpq)\n\nReturns true if the box x contains the given rational value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"The following functions are also provided for determining if a box intersects a certain part of the complex number plane.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"contains_zero(::acb)","category":"page"},{"location":"Nemo/acb/#contains_zero-Tuple{acb}","page":"Complex balls","title":"contains_zero","text":"contains_zero(x::acb)\n\nReturns true if the box x contains zero, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"1 +/- 0.001\")\ny = CC(\"3\")\n\noverlaps(x, y)\ncontains(x, y)\ncontains(y, 3)\ncontains(x, ZZ(1)//2)\ncontains_zero(x)","category":"page"},{"location":"Nemo/acb/#Comparison","page":"Complex balls","title":"Comparison","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Nemo provides a full range of comparison operations for Arb complex boxes. ","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"In addition to the standard comparisons, we introduce an exact equality. This is distinct from arithmetic equality implemented by ==, which merely compares up to the minimum of the precisions of its operands.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"isequal(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#isequal-Tuple{acb, acb}","page":"Complex balls","title":"isequal","text":"isequal(x::acb, y::acb)\n\nReturn true if the boxes x and y are precisely equal, i.e. their real and imaginary parts have the same midpoints and radii.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"A full range of ad hoc comparison operators is provided. These are implemented directly in Julia, but we document them as though only == were provided.","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Function\n==(x::acb, y::Integer)\n==(x::Integer, y::acb)\n==(x::acb, y::fmpz)\n==(x::fmpz, y::acb)\n==(x::arb, y::fmpz)\n==(x::fmpz, y::arb)\n==(x::acb, y::Float64)\n==(x::Float64, y::acb)","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"1 +/- 0.001\")\ny = CC(\"3\")\nz = CC(\"4\")\n\nisequal(x, deepcopy(x))\nx == 3\nZZ(3) == z\nx != 1.23","category":"page"},{"location":"Nemo/acb/#Absolute-value","page":"Complex balls","title":"Absolute value","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"-1 +/- 0.001\")\n\na = abs(x)","category":"page"},{"location":"Nemo/acb/#Shifting","page":"Complex balls","title":"Shifting","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"-3 +/- 0.001\")\n\na = ldexp(x, 23)\nb = ldexp(x, -ZZ(15))","category":"page"},{"location":"Nemo/acb/#Miscellaneous-operations","page":"Complex balls","title":"Miscellaneous operations","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"trim(::acb)","category":"page"},{"location":"Nemo/acb/#trim-Tuple{acb}","page":"Complex balls","title":"trim","text":"trim(x::acb)\n\nReturn an acb box containing x but which may be more economical, by rounding off insignificant bits from midpoints.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"unique_integer(::acb)","category":"page"},{"location":"Nemo/acb/#unique_integer-Tuple{acb}","page":"Complex balls","title":"unique_integer","text":"unique_integer(x::acb)\n\nReturn a pair where the first value is a boolean and the second is an fmpz integer. The boolean indicates whether the box x contains a unique integer. If this is the case, the second return value is set to this unique integer.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\nx = CC(\"-3 +/- 0.001\", \"0.1\")\n\na = trim(x)\nb, c = unique_integer(x)\nd = conj(x)\nf = angle(x)","category":"page"},{"location":"Nemo/acb/#Constants","page":"Complex balls","title":"Constants","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"const_pi(::AcbField)","category":"page"},{"location":"Nemo/acb/#const_pi-Tuple{AcbField}","page":"Complex balls","title":"const_pi","text":"const_pi(r::AcbField)\n\nReturn pi = 314159ldots as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(200)\n\na = const_pi(CC)","category":"page"},{"location":"Nemo/acb/#Mathematical-and-special-functions","page":"Complex balls","title":"Mathematical and special functions","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"rsqrt(::acb)","category":"page"},{"location":"Nemo/acb/#rsqrt-Tuple{acb}","page":"Complex balls","title":"rsqrt","text":"rsqrt(x::acb)\n\nReturn the reciprocal of the square root of x, i.e. 1sqrtx.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"cispi(::acb)","category":"page"},{"location":"Nemo/acb/#cispi-Tuple{acb}","page":"Complex balls","title":"cispi","text":"cispi(x::acb)\n\nReturn the exponential of pi i x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"root_of_unity(::AcbField, k::Int)","category":"page"},{"location":"Nemo/acb/#root_of_unity-Tuple{AcbField, Int64}","page":"Complex balls","title":"root_of_unity","text":"root_of_unity(C::AcbField, k::Int)\n\nReturn exp(2pi ik).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"log_sinpi(::acb)","category":"page"},{"location":"Nemo/acb/#log_sinpi-Tuple{acb}","page":"Complex balls","title":"log_sinpi","text":"log_sinpi(x::acb)\n\nReturn logsin(pi x), constructed without branch cuts off the real line.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"gamma(::acb)","category":"page"},{"location":"Nemo/acb/#gamma-Tuple{acb}","page":"Complex balls","title":"gamma","text":"gamma(x::acb)\n\nReturn the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"lgamma(::acb)","category":"page"},{"location":"Nemo/acb/#lgamma-Tuple{acb}","page":"Complex balls","title":"lgamma","text":"lgamma(x::acb)\n\nReturn the logarithm of the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"rgamma(::acb)","category":"page"},{"location":"Nemo/acb/#rgamma-Tuple{acb}","page":"Complex balls","title":"rgamma","text":"rgamma(x::acb)\n\nReturn the reciprocal of the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"digamma(::acb)","category":"page"},{"location":"Nemo/acb/#digamma-Tuple{acb}","page":"Complex balls","title":"digamma","text":"digamma(x::acb)\n\nReturn the  logarithmic derivative of the gamma function evaluated at x, i.e. psi(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"zeta(::acb)","category":"page"},{"location":"Nemo/acb/#zeta-Tuple{acb}","page":"Complex balls","title":"zeta","text":"zeta(x::acb)\n\nReturn the Riemann zeta function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"barnes_g(::acb)","category":"page"},{"location":"Nemo/acb/#barnes_g-Tuple{acb}","page":"Complex balls","title":"barnes_g","text":"barnes_g(x::acb)\n\nReturn the Barnes G-function, evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"log_barnes_g(::acb)","category":"page"},{"location":"Nemo/acb/#log_barnes_g-Tuple{acb}","page":"Complex balls","title":"log_barnes_g","text":"log_barnes_g(x::acb)\n\nReturn the logarithm of the Barnes G-function, evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"erf(::acb)","category":"page"},{"location":"Nemo/acb/#erf-Tuple{acb}","page":"Complex balls","title":"erf","text":"erf(x::acb)\n\nReturn the error function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"erfi(::acb)","category":"page"},{"location":"Nemo/acb/#erfi-Tuple{acb}","page":"Complex balls","title":"erfi","text":"erfi(x::acb)\n\nReturn the imaginary error function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"exp_integral_ei(::acb)","category":"page"},{"location":"Nemo/acb/#exp_integral_ei-Tuple{acb}","page":"Complex balls","title":"exp_integral_ei","text":"exp_integral_ei(x::acb)\n\nReturn the exponential integral evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"sin_integral(::acb)","category":"page"},{"location":"Nemo/acb/#sin_integral-Tuple{acb}","page":"Complex balls","title":"sin_integral","text":"sin_integral(x::acb)\n\nReturn the sine integral evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"cos_integral(::acb)","category":"page"},{"location":"Nemo/acb/#cos_integral-Tuple{acb}","page":"Complex balls","title":"cos_integral","text":"cos_integral(x::acb)\n\nReturn the exponential cosine integral evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"sinh_integral(::acb)","category":"page"},{"location":"Nemo/acb/#sinh_integral-Tuple{acb}","page":"Complex balls","title":"sinh_integral","text":"sinh_integral(x::acb)\n\nReturn the hyperbolic sine integral evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"cosh_integral(::acb)","category":"page"},{"location":"Nemo/acb/#cosh_integral-Tuple{acb}","page":"Complex balls","title":"cosh_integral","text":"cosh_integral(x::acb)\n\nReturn the hyperbolic cosine integral evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"dedekind_eta(::acb)","category":"page"},{"location":"Nemo/acb/#dedekind_eta-Tuple{acb}","page":"Complex balls","title":"dedekind_eta","text":"dedekind_eta(x::acb)\n\nReturn the Dedekind eta function eta(tau) at tau = x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"modular_weber_f(::acb)","category":"page"},{"location":"Nemo/acb/#modular_weber_f-Tuple{acb}","page":"Complex balls","title":"modular_weber_f","text":"modular_weber_f(x::acb)\n\nReturn the modular Weber function mathfrakf(tau) = fraceta^2(tau)eta(tau2)eta(2tau) at x in the complex upper half plane.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"modular_weber_f1(::acb)","category":"page"},{"location":"Nemo/acb/#modular_weber_f1-Tuple{acb}","page":"Complex balls","title":"modular_weber_f1","text":"modular_weber_f1(x::acb)\n\nReturn the modular Weber function mathfrakf_1(tau) = fraceta(tau2)eta(tau) at x in the complex upper half plane.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"modular_weber_f2(::acb)","category":"page"},{"location":"Nemo/acb/#modular_weber_f2-Tuple{acb}","page":"Complex balls","title":"modular_weber_f2","text":"modular_weber_f2(x::acb)\n\nReturn the modular Weber function mathfrakf_2(tau) = fracsqrt2eta(2tau)eta(tau) at x in the complex upper half plane.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"j_invariant(::acb)","category":"page"},{"location":"Nemo/acb/#j_invariant-Tuple{acb}","page":"Complex balls","title":"j_invariant","text":"j_invariant(x::acb)\n\nReturn the j-invariant j(tau) at tau = x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"modular_lambda(::acb)","category":"page"},{"location":"Nemo/acb/#modular_lambda-Tuple{acb}","page":"Complex balls","title":"modular_lambda","text":"modular_lambda(x::acb)\n\nReturn the modular lambda function lambda(tau) at tau = x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"modular_delta(::acb)","category":"page"},{"location":"Nemo/acb/#modular_delta-Tuple{acb}","page":"Complex balls","title":"modular_delta","text":"modular_delta(x::acb)\n\nReturn the modular delta function Delta(tau) at tau = x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"eisenstein_g(::Int, ::acb)","category":"page"},{"location":"Nemo/acb/#eisenstein_g-Tuple{Int64, acb}","page":"Complex balls","title":"eisenstein_g","text":"eisenstein_g(k::Int, x::acb)\n\nReturn the non-normalized Eisenstein series G_k(tau) of mathrmSL_2(mathbbZ). Also defined for tau = i infty.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"hilbert_class_polynomial(::Int, ::FmpzPolyRing)","category":"page"},{"location":"Nemo/acb/#hilbert_class_polynomial-Tuple{Int64, FmpzPolyRing}","page":"Complex balls","title":"hilbert_class_polynomial","text":"hilbert_class_polynomial(D::Int, R::FmpzPolyRing)\n\nReturn in the ring R the Hilbert class polynomial of discriminant D, which is only defined for D  0 and D equiv 0 1 pmod 4.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"elliptic_k(::acb)","category":"page"},{"location":"Nemo/acb/#elliptic_k-Tuple{acb}","page":"Complex balls","title":"elliptic_k","text":"elliptic_k(x::acb)\n\nReturn the complete elliptic integral K(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"elliptic_e(::acb)","category":"page"},{"location":"Nemo/acb/#elliptic_e-Tuple{acb}","page":"Complex balls","title":"elliptic_e","text":"elliptic_e(x::acb)\n\nReturn the complete elliptic integral E(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"agm(::acb)\nagm(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#agm-Tuple{acb}","page":"Complex balls","title":"agm","text":"agm(x::acb)\n\nReturn the arithmetic-geometric mean of 1 and x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/#agm-Tuple{acb, acb}","page":"Complex balls","title":"agm","text":"agm(x::acb, y::acb)\n\nReturn the arithmetic-geometric mean of x and y.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"polygamma(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#polygamma-Tuple{acb, acb}","page":"Complex balls","title":"polygamma","text":"polygamma(s::acb, a::acb)\n\nReturn the generalised polygamma function psi(sz).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"zeta(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#zeta-Tuple{acb, acb}","page":"Complex balls","title":"zeta","text":"zeta(s::acb, a::acb)\n\nReturn the Hurwitz zeta function zeta(sa).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"rising_factorial(::acb, ::Int)","category":"page"},{"location":"Nemo/acb/#rising_factorial-Tuple{acb, Int64}","page":"Complex balls","title":"rising_factorial","text":"rising_factorial(x::acb, n::Int)\n\nReturn the rising factorial x(x + 1)ldots (x + n - 1) as an Acb.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"rising_factorial2(::acb, ::Int)","category":"page"},{"location":"Nemo/acb/#rising_factorial2-Tuple{acb, Int64}","page":"Complex balls","title":"rising_factorial2","text":"rising_factorial2(x::acb, n::Int)\n\nReturn a tuple containing the rising factorial x(x + 1)ldots (x + n - 1) and its derivative.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"polylog(::Union{acb,Int}, ::acb)","category":"page"},{"location":"Nemo/acb/#polylog-Tuple{Union{Int64, acb}, acb}","page":"Complex balls","title":"polylog","text":"polylog(s::Union{acb,Int}, a::acb)\n\nReturn the polylogarithm Li_s(a).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"log_integral(::acb)","category":"page"},{"location":"Nemo/acb/#log_integral-Tuple{acb}","page":"Complex balls","title":"log_integral","text":"log_integral(x::acb)\n\nReturn the logarithmic integral, evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"log_integral_offset(::acb)","category":"page"},{"location":"Nemo/acb/#log_integral_offset-Tuple{acb}","page":"Complex balls","title":"log_integral_offset","text":"log_integral_offset(x::acb)\n\nReturn the offset logarithmic integral, evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"exp_integral_e(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#exp_integral_e-Tuple{acb, acb}","page":"Complex balls","title":"exp_integral_e","text":"exp_integral_e(s::acb, x::acb)\n\nReturn the generalised exponential integral E_s(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"gamma(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#gamma-Tuple{acb, acb}","page":"Complex balls","title":"gamma","text":"gamma(s::acb, x::acb)\n\nReturn the upper incomplete gamma function Gamma(sx).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"gamma_regularized(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#gamma_regularized-Tuple{acb, acb}","page":"Complex balls","title":"gamma_regularized","text":"gamma_regularized(s::acb, x::acb)\n\nReturn the regularized upper incomplete gamma function Gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"gamma_lower(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#gamma_lower-Tuple{acb, acb}","page":"Complex balls","title":"gamma_lower","text":"gamma_lower(s::acb, x::acb)\n\nReturn the lower incomplete gamma function gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"gamma_lower_regularized(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#gamma_lower_regularized-Tuple{acb, acb}","page":"Complex balls","title":"gamma_lower_regularized","text":"gamma_lower_regularized(s::acb, x::acb)\n\nReturn the regularized lower incomplete gamma function gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"airy_ai(::acb)","category":"page"},{"location":"Nemo/acb/#airy_ai-Tuple{acb}","page":"Complex balls","title":"airy_ai","text":"airy_ai(x::acb)\n\nReturn the Airy function operatornameAi(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"airy_ai_prime(::acb)","category":"page"},{"location":"Nemo/acb/#airy_ai_prime-Tuple{acb}","page":"Complex balls","title":"airy_ai_prime","text":"airy_ai_prime(x::acb)\n\nReturn the derivative of the Airy function operatornameAi^prime(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"airy_bi(::acb)","category":"page"},{"location":"Nemo/acb/#airy_bi-Tuple{acb}","page":"Complex balls","title":"airy_bi","text":"airy_bi(x::acb)\n\nReturn the Airy function operatornameBi(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"airy_bi_prime(::acb)","category":"page"},{"location":"Nemo/acb/#airy_bi_prime-Tuple{acb}","page":"Complex balls","title":"airy_bi_prime","text":"airy_bi_prime(x::acb)\n\nReturn the derivative of the Airy function operatornameBi^prime(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"bessel_j(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#bessel_j-Tuple{acb, acb}","page":"Complex balls","title":"bessel_j","text":"bessel_j(nu::acb, x::acb)\n\nReturn the Bessel function J_nu(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"bessel_y(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#bessel_y-Tuple{acb, acb}","page":"Complex balls","title":"bessel_y","text":"bessel_y(nu::acb, x::acb)\n\nReturn the Bessel function Y_nu(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"bessel_i(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#bessel_i-Tuple{acb, acb}","page":"Complex balls","title":"bessel_i","text":"bessel_i(nu::acb, x::acb)\n\nReturn the Bessel function I_nu(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"bessel_k(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#bessel_k-Tuple{acb, acb}","page":"Complex balls","title":"bessel_k","text":"bessel_k(nu::acb, x::acb)\n\nReturn the Bessel function K_nu(x).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"hypergeometric_1f1(::acb, ::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#hypergeometric_1f1-Tuple{acb, acb, acb}","page":"Complex balls","title":"hypergeometric_1f1","text":"hypergeometric_1f1(a::acb, b::acb, x::acb)\n\nReturn the confluent hypergeometric function _1F_1(abx).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"hypergeometric_1f1_regularized(::acb, ::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#hypergeometric_1f1_regularized-Tuple{acb, acb, acb}","page":"Complex balls","title":"hypergeometric_1f1_regularized","text":"hypergeometric_1f1_regularized(a::acb, b::acb, x::acb)\n\nReturn the regularized confluent hypergeometric function _1F_1(abx)  Gamma(b).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"hypergeometric_u(::acb, ::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#hypergeometric_u-Tuple{acb, acb, acb}","page":"Complex balls","title":"hypergeometric_u","text":"hypergeometric_u(a::acb, b::acb, x::acb)\n\nReturn the confluent hypergeometric function U(abx).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"hypergeometric_2f1(::acb, ::acb, ::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#hypergeometric_2f1-NTuple{4, acb}","page":"Complex balls","title":"hypergeometric_2f1","text":"hypergeometric_2f1(a::acb, b::acb, c::acb, x::acb; flags=0)\n\nReturn the Gauss hypergeometric function _2F_1(abcx).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"jacobi_theta(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#jacobi_theta-Tuple{acb, acb}","page":"Complex balls","title":"jacobi_theta","text":"jacobi_theta(z::acb, tau::acb)\n\nReturn a tuple of four elements containing the Jacobi theta function values theta_1 theta_2 theta_3 theta_4 evaluated at z tau.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"weierstrass_p(::acb, ::acb)","category":"page"},{"location":"Nemo/acb/#weierstrass_p-Tuple{acb, acb}","page":"Complex balls","title":"weierstrass_p","text":"weierstrass_p(z::acb, tau::acb)\n\nReturn the Weierstrass elliptic function wp(ztau).\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(64)\n\ns = CC(1, 2)\nz = CC(\"1.23\", \"3.45\")\n\na = sin(z)^2 + cos(z)^2\nb = zeta(z)\nc = bessel_j(s, z)\nd = hypergeometric_1f1(s, s+1, z)","category":"page"},{"location":"Nemo/acb/#Linear-dependence","page":"Complex balls","title":"Linear dependence","text":"","category":"section"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"lindep(::Vector{acb}, n::Int)","category":"page"},{"location":"Nemo/acb/#lindep-Tuple{Vector{acb}, Int64}","page":"Complex balls","title":"lindep","text":"lindep(A::Vector{acb}, bits::Int)\n\nFind a small linear combination of the entries of the array A that is small (using LLL). The entries are first scaled by the given number of bits before truncating the real and imaginary parts to integers for use in LLL. This function can be used to find linear dependence between a list of complex numbers. The algorithm is heuristic only and returns an array of Nemo integers representing the linear combination.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"lindep(A::Matrix{acb}, bits::Int)","category":"page"},{"location":"Nemo/acb/#lindep-Tuple{Matrix{acb}, Int64}","page":"Complex balls","title":"lindep","text":"lindep(A::Matrix{acb}, bits::Int)\n\nFind a (common) small linear combination of the entries in each row of the array A, that is small (using LLL). It is assumed that the complex numbers in each row of the array share the same linear combination. The entries are first scaled by the given number of bits before truncating the real and imaginary parts to integers for use in LLL. This function can be used to find a common linear dependence shared across a number of lists of complex numbers. The algorithm is heuristic only and returns an array of Nemo integers representing the common linear combination.\n\n\n\n","category":"method"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"Examples","category":"page"},{"location":"Nemo/acb/","page":"Complex balls","title":"Complex balls","text":"CC = ComplexField(128)\n\n# These are two of the roots of x^5 + 3x + 1\na = CC(1.0050669478588622428791051888364775253, - 0.93725915669289182697903585868761513585)\nb = CC(-0.33198902958450931620250069492231652319)\n\n# We recover the polynomial from one root....\nV1 = [CC(1), a, a^2, a^3, a^4, a^5];\nW = lindep(V1, 20)\n\n# ...or from two\nV2 = [CC(1), b, b^2, b^3, b^4, b^5];\nVs = [V1 V2]\nX = lindep(Vs, 20)","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Direct-Sums","page":"Direct Sums","title":"Direct Sums","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"AbstractAlgebra allows the construction of the external direct sum of any nonempty vector of finitely presented modules.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Note that external direct sums are considered equal iff they are the same object.","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Generic-direct-sum-type","page":"Direct Sums","title":"Generic direct sum type","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"AbstractAlgebra provides a generic direct sum type Generic.DirectSumModule{T} where T is the element type of the base ring. The implementation is in src/generic/DirectSum.jl","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Elements of direct sum modules have type Generic.DirectSumModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Abstract-types","page":"Direct Sums","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Direct sum module types belong to the abstract type FPModule{T} and their elements to FPModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Constructors","page":"Direct Sums","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"DirectSum(::Vector{<:AbstractAlgebra.FPModule{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/direct_sum/#DirectSum-Union{Tuple{Vector{var\"#s271\"} where var\"#s271\"<:AbstractAlgebra.FPModule{T}}, Tuple{T}} where T<:RingElement","page":"Direct Sums","title":"DirectSum","text":"DirectSum(m::Vector{<:FPModule{T}}) where T <: RingElement\nDirectSum(vals::FPModule{T}...) where T <: RingElement\n\nReturn a tuple M f g consisting of M the direct sum of the modules m (supplied as a vector of modules), a vector f of the injections of the mi into M and a vector g of the projections from M onto the mi.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> F = FreeModule(ZZ, 5)\nFree module of rank 5 over Integers\n\njulia> m1 = F(BigInt[4, 7, 8, 2, 6])\n(4, 7, 8, 2, 6)\n\njulia> m2 = F(BigInt[9, 7, -2, 2, -4])\n(9, 7, -2, 2, -4)\n\njulia> S1, f1 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> m1 = F(BigInt[3, 1, 7, 7, -7])\n(3, 1, 7, 7, -7)\n\njulia> m2 = F(BigInt[-8, 6, 10, -1, 1])\n(-8, 6, 10, -1, 1)\n\njulia> S2, f2 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> m1 = F(BigInt[2, 4, 2, -3, -10])\n(2, 4, 2, -3, -10)\n\njulia> m2 = F(BigInt[5, 7, -6, 9, -5])\n(5, 7, -6, 9, -5)\n\njulia> S3, f3 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> D, f = DirectSum(S1, S2, S3)\n(DirectSumModule over Integers, AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers], AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n])","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Functionality-for-direct-sums","page":"Direct Sums","title":"Functionality for direct sums","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"In addition to the Module interface, AbstractAlgebra direct sums implement the following functionality.","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Basic-manipulation","page":"Direct Sums","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"summands(::Generic.DirectSumModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/direct_sum/#summands-Union{Tuple{AbstractAlgebra.Generic.DirectSumModule{T}}, Tuple{T}} where T<:RingElement","page":"Direct Sums","title":"summands","text":"summands(M::DirectSumModule{T}) where T <: RingElement\n\nReturn the modules that this module is a direct sum of.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> F = FreeModule(ZZ, 5)\nFree module of rank 5 over Integers\n\njulia> m1 = F(BigInt[4, 7, 8, 2, 6])\n(4, 7, 8, 2, 6)\n\njulia> m2 = F(BigInt[9, 7, -2, 2, -4])\n(9, 7, -2, 2, -4)\n\njulia> S1, f1 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> m1 = F(BigInt[3, 1, 7, 7, -7])\n(3, 1, 7, 7, -7)\n\njulia> m2 = F(BigInt[-8, 6, 10, -1, 1])\n(-8, 6, 10, -1, 1)\n\njulia> S2, f2 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> m1 = F(BigInt[2, 4, 2, -3, -10])\n(2, 4, 2, -3, -10)\n\njulia> m2 = F(BigInt[5, 7, -6, 9, -5])\n(5, 7, -6, 9, -5)\n\njulia> S3, f3 = sub(F, [m1, m2])\n(Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: Free module of rank 5 over Integers)\n\njulia> D, f = DirectSum(S1, S2, S3)\n(DirectSumModule over Integers, AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers, Module homomorphism with\nDomain: Submodule over Integers with 2 generators and no relations\n\nCodomain: DirectSumModule over Integers], AbstractAlgebra.Generic.ModuleHomomorphism{BigInt}[Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: DirectSumModule over Integers\nCodomain: Submodule over Integers with 2 generators and no relations\n])\n\njulia> summands(D)\n3-element Vector{AbstractAlgebra.Generic.Submodule{BigInt}}:\n Submodule over Integers with 2 generators and no relations\n\n Submodule over Integers with 2 generators and no relations\n\n Submodule over Integers with 2 generators and no relations","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"    (D::DirectSumModule{T}(::Vector{<:FPModuleElem{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given a vector (or 1-dim array) of module elements, where the i-th entry has to be an element of the i-summand of D, create the corresponding element in D.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> N = FreeModule(QQ, 2);\n\njulia> M = FreeModule(QQ, 1);\n\njulia> D, _ = DirectSum(M, N, M);\n\njulia> D([gen(M, 1), gen(N, 1), gen(M, 2)])\n(1//1, 1//1, 0//1, 0//1)","category":"page"},{"location":"AbstractAlgebra/direct_sum/#Special-Homomorphisms","page":"Direct Sums","title":"Special Homomorphisms","text":"","category":"section"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Due to the special structure as direct sums, homomorphisms can be created by specifying homomorphisms for all summands. In case of the codmain being a direct sum as well, any homomorphism may be thought of as a matrix containing maps from the i-th source summand to the j-th target module:","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"ModuleHomomorphism(D::DirectSumModule{T}, S::DirectSumModule{T}, m::Matrix{Any}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given a matrix m such that the (ij)-th entry is either 0 (Int(0)) or a ModuleHomomorphism from the i-th summand of D to the j-th summand of S, construct the corresponding homomorphism.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"ModuleHomomorphism(D::DirectSumModule{T}, S::FPModuleElem{T}, m::Vector{ModuleHomomorphism})","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given an array a of ModuleHomomorphism such that a_i, the i-th entry of a is a ModuleHomomorphism from the i-th summand of D into S, construct the direct sum of the components.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Given a matrix m such that the (ij)-th entry is either 0 (Int(0)) or a ModuleHomomorphism from the i-th summand of D to the j-th summand of S, construct the corresponding homomorphism.","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"Examples","category":"page"},{"location":"AbstractAlgebra/direct_sum/","page":"Direct Sums","title":"Direct Sums","text":"julia> N = FreeModule(QQ, 2);\n\njulia> D, _ = DirectSum(N, N);\n\njulia> p = ModuleHomomorphism(N, N, [3,4] .* basis(N));\n\njulia> q = ModuleHomomorphism(N, N, [5,7] .* basis(N));\n\njulia> phi = ModuleHomomorphism(D, D, [p 0; 0 q])\nModule homomorphism with\nDomain: DirectSumModule over Rationals\nCodomain: DirectSumModule over Rationals\n\njulia> r = ModuleHomomorphism(N, D, [2,3] .* gens(D)[1:2])\nModule homomorphism with\nDomain: Vector space of dimension 2 over Rationals\nCodomain: DirectSumModule over Rationals\n\njulia> psi = ModuleHomomorphism(D, D, [r, r])\nModule homomorphism with\nDomain: DirectSumModule over Rationals\nCodomain: DirectSumModule over Rationals","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/perm/#Permutations-and-Symmetric-groups","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"","category":"section"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"AbstractAlgebra.jl provides rudimentary native support for permutation groups (implemented in src/generic/PermGroups.jl). All functionality of permutations is accesible in the Generic submodule.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Permutations are represented internally via vector of integers, wrapped in type Perm{T}, where T<:Integer carries the information on the type of elements of a permutation. Symmetric groups are singleton parent objects of type SymmetricGroup{T} and are used mostly to store the length of a permutation, since it is not included in the permutation type.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Symmetric groups are created using the SymmetricGroup (inner) constructor.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Both SymmetricGroup and Perm and can be parametrized by any type T<:Integer . By default the parameter is the Int-type native to the systems architecture. However, if you are sure that your permutations are small enough to fit into smaller integer type (such as Int32, UInt16, or even Int8), you may choose to change the parametrizing type accordingly. In practice this may result in decreased memory footprint (when storing multiple permutations) and noticable faster performance, if your workload is heavy in operations on permutations, which e.g. does not fit into cache of your cpu.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"All the permutation group types belong to the Group abstract type and the corresponding permutation element types belong to the GroupElem abstract type.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Generic.setpermstyle","category":"page"},{"location":"AbstractAlgebra/perm/#setpermstyle","page":"Permutations and Symmetric groups","title":"setpermstyle","text":"setpermstyle(format::Symbol)\n\nSelect the style in which permutations are displayed (in the REPL or in general as strings). This can be either\n\n:array - as vector of integers whose n-th position represents the value at n), or\n:cycles - as, more familiar for mathematicians, decomposition into disjoint cycles, where the value at n is represented by the entry immediately following n in a cycle (the default).\n\nThe difference is purely esthetical.\n\nExamples:\n\njulia> setpermstyle(:array)\n:array\n\njulia> Perm([2,3,1,5,4])\n[2, 3, 1, 5, 4]\n\njulia> setpermstyle(:cycles)\n:cycles\n\njulia> Perm([2,3,1,5,4])\n(1,2,3)(4,5)\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/perm/#Permutations-constructors","page":"Permutations and Symmetric groups","title":"Permutations constructors","text":"","category":"section"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"There are several methods to construct permutations in AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"The easiest way is to directly call to the Perm (inner) constructor:","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Generic.Perm","category":"page"},{"location":"AbstractAlgebra/perm/#Perm","page":"Permutations and Symmetric groups","title":"Perm","text":"Perm{T<:Integer}\n\nThe type of permutations. Fieldnames:\n\nd::Vector{T} - vector representing the permutation\nmodified::Bool - bit to check the validity of cycle decomposition\ncycles::CycleDec{T} - (cached) cycle decomposition\n\nA permutation p consists of a vector (p.d) of n integers from 1 to n. If the i-th entry of the vector is j, this corresponds to p sending i to j. The cycle decomposition (p.cycles) is computed on demand and should never be accessed directly. Use cycles(p) instead.\n\nThere are two inner constructors of Perm:\n\nPerm(n::T) constructs the trivial Perm{T}-permutation of length n.\nPerm(v::AbstractVector{<:Integer} [,check=true]) constructs a permutation represented by v. By default Perm constructor checks if the vector constitutes a valid permutation. To skip the check call Perm(v, false).\n\nExamples:\n\njulia> Perm([1,2,3])\n()\n   \njulia> g = Perm(Int32[2,3,1])\n(1,2,3)\n\njulia> typeof(g)\nPerm{Int32}\n\n\n\n","category":"type"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Since the parent object can be reconstructed from the permutation itself, you can work with permutations without explicitly constructing the parent object.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"The other way is to first construct the permutation group they belong to. This is accomplished with the inner constructor SymmetricGroup(n::Integer) which constructs the permutation group on n symbols and returns the parent object representing the group.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Generic.SymmetricGroup","category":"page"},{"location":"AbstractAlgebra/perm/#SymmetricGroup","page":"Permutations and Symmetric groups","title":"SymmetricGroup","text":"SymmetricGroup{T<:Integer}\n\nThe full symmetric group singleton type. SymmetricGroup(n) constructs the full symmetric group S_n on n-symbols. The type of elements of the group is inferred from the type of n.\n\nExamples:\n\njulia> G = SymmetricGroup(5)\nFull symmetric group over 5 elements\n\njulia> elem_type(G)\nPerm{Int64}\n\njulia> H = SymmetricGroup(UInt16(5))\nFull symmetric group over 5 elements\n\njulia> elem_type(H)\nPerm{UInt16}\n\n\n\n","category":"type"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"A vector of integers can be then coerced to a permutation by calling a parent permutation group on it.   The advantage is that the vector is automatically converted to the integer type fixed at the creation of the parent object.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Examples:","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"julia> G = SymmetricGroup(BigInt(5)); p = G([2,3,1,5,4])\n(1,2,3)(4,5)\n\njulia> typeof(p)\nPerm{BigInt}\n\njulia> H = SymmetricGroup(UInt16(5)); r = H([2,3,1,5,4])\n(1,2,3)(4,5)\n\njulia> typeof(r)\nPerm{UInt16}\n\njulia> one(H)\n()","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"By default the coercion checks for non-unique values in the vector, but this can be switched off with G([2,3,1,5,4], false).","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Finally there is a perm\"...\" string macro to construct a permutation from a string input.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"@perm_str","category":"page"},{"location":"AbstractAlgebra/perm/#@perm_str","page":"Permutations and Symmetric groups","title":"@perm_str","text":"perm\"...\"\n\nString macro to parse disjoint cycles into Perm{Int}.\n\nStrings for the output of GAP could be copied directly into perm\"...\". Cycles of length 1 are not necessary, but can be included. A permutation of the minimal support is constructed, i.e. the maximal n in the decomposition determines the parent group S_n.\n\nExamples:\n\njulia> p = perm\"(1,3)(2,4)\"\n(1,3)(2,4)\n\njulia> typeof(p)\nPerm{Int64}\n\njulia> parent(p) == SymmetricGroup(4)\ntrue\n\njulia> p = perm\"(1,3)(2,4)(10)\"\n(1,3)(2,4)\n\njulia> parent(p) == SymmetricGroup(10)\ntrue\n\n\n\n","category":"macro"},{"location":"AbstractAlgebra/perm/#Permutation-interface","page":"Permutations and Symmetric groups","title":"Permutation interface","text":"","category":"section"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"The following basic functionality is provided by the default permutation group implementation in AbstractAlgebra.jl, to support construction of other generic constructions over permutation groups. Any custom permutation group implementation in AbstractAlgebra.jl should provide the group element arithmetic and comparison.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"A custom implementation also needs to implement hash(::Perm, ::UInt) and (possibly) deepcopy_internal(::Perm, ::ObjectIdDict).","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"note: Note\nPermutation group elements are mutable and so returning shallow copies is not sufficient.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"getindex(a::Perm, n::Integer)","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Allow access to entry n of the given permutation via the syntax a[n]. Note that entries are 1-indexed.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"setindex!(a::Perm, d::Integer, n::Integer)","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Set the n-th entry of the given permutation to d. This allows Julia to provide the syntax a[n] = d for setting entries of a permutation. Entries are 1-indexed.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"note: Note\nUsing setindex! invalidates the cycle decomposition cached in a permutation, which will be computed the next time it is needed.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Given the parent object G for a permutation group, the following coercion functions are provided to coerce various arguments into the permutation group. Developers provide these by overloading the permutation group parent objects.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"one(G)","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Return the identity permutation.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"G(A::Vector{<:Integer})","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Return the permutation whose entries are given by the elements of the supplied vector.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"G(p::Perm)","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Take a permutation that is already in the permutation group and simply return it. A copy of the original is not made if not necessary.","category":"page"},{"location":"AbstractAlgebra/perm/#Basic-manipulation","page":"Permutations and Symmetric groups","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Numerous functions are provided to manipulate permutation group elements.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"cycles(::Perm)","category":"page"},{"location":"AbstractAlgebra/perm/#cycles-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"cycles","text":"cycles(g::Perm)\n\nDecompose permutation g into disjoint cycles.\n\nReturn a CycleDec object which iterates over disjoint cycles of g. The ordering of cycles is not guaranteed, and the order within each cycle is computed up to a cyclic permutation. The cycle decomposition is cached in g and used in future computation of permtype, parity, sign, order and ^ (powering).\n\nExamples:\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> collect(cycles(g))\n3-element Vector{Vector{Int64}}:\n [1, 3, 5]\n [2, 4]\n [6]\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Cycle structure is cached in a permutation, since once available, it provides a convenient shortcut in many other algorithms.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"parity(::Perm)\nsign(::Perm)\npermtype(::Perm)","category":"page"},{"location":"AbstractAlgebra/perm/#parity-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"parity","text":"parity(g::Perm)\n\nReturn the parity of the given permutation, i.e. the parity of the number of transpositions in any decomposition of g into transpositions.\n\nparity returns 1 if the number is odd and 0 otherwise. parity uses cycle decomposition of g if already available, but will not compute it on demand. Since cycle structure is cached in g you may call cycles(g) before calling parity.\n\nExamples:\n\njulia> g = Perm([3,4,1,2,5])\n(1,3)(2,4)\n\njulia> parity(g)\n0\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> parity(g)\n1\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/#sign-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"sign","text":"sign(g::Perm)\n\nReturn the sign of a permutation.\n\nsign returns 1 if g is even and -1 if g is odd. sign represents the homomorphism from the permutation group to the unit group of mathbbZ whose kernel is the alternating group.\n\nExamples:\n\njulia> g = Perm([3,4,1,2,5])\n(1,3)(2,4)\n\njulia> sign(g)\n1\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> sign(g)\n-1\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/#permtype-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"permtype","text":"permtype(g::Perm)\n\nReturn the type of permutation g, i.e. lengths of disjoint cycles in cycle decomposition of g.\n\nThe lengths are sorted in decreasing order by default. permtype(g) fully determines the conjugacy class of g.\n\nExamples:\n\njulia> g = Perm([3,4,5,2,1,6])\n(1,3,5)(2,4)\n\njulia> permtype(g)\n3-element Vector{Int64}:\n 3\n 2\n 1\n\njulia> e = one(g)\n()\n\njulia> permtype(e)\n6-element Vector{Int64}:\n 1\n 1\n 1\n 1\n 1\n 1\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Additionally GroupsCore.jl package provides more functionality, notably functions gens and order. You may consult its documentation. Note that even an Int64 can be easily overflowed when computing with symmetric groups. Thus, by default, order returns (always correct) BigInts. If you are sure that the computation will not overflow, you may use order(::Type{T}, ...) to perform computations with machine integers. Julia's standard promotion rules apply for the returned value.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Since SymmetricGroup implements the iterator protocol, you may iterate over all permutations via a simple loop:","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"for p in SymmetricGroup(n)\n   ...\nend","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Iteration over all permutations in reasonable time, (i.e. in terms of minutes) is possible when n  13.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"You may also use the non-allocating Generic.elements! function for n  14 (or even 15 if you are patient enough), which is an order of magnitude faster.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Generic.elements!(::Generic.SymmetricGroup)","category":"page"},{"location":"AbstractAlgebra/perm/#elements!-Tuple{AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"elements!","text":"Generic.elements!(G::SymmetricGroup)\n\nReturn an unsafe iterator over all permutations in G. Only one permutation is allocated and then modified in-place using the non-recursive Heaps algorithm.\n\nNote: you need to explicitely copy permutations intended to be stored or modified.\n\nExamples:\n\njulia> elts = Generic.elements!(SymmetricGroup(5));\n\n\njulia> length(elts)\n120\n\njulia> for p in Generic.elements!(SymmetricGroup(3))\n         println(p)\n       end\n()\n(1,2)\n(1,3,2)\n(2,3)\n(1,2,3)\n(1,3)\n\njulia> A = collect(Generic.elements!(SymmetricGroup(3))); A\n6-element Vector{Perm{Int64}}:\n (1,3)\n (1,3)\n (1,3)\n (1,3)\n (1,3)\n (1,3)\n\njulia> unique(A)\n1-element Vector{Perm{Int64}}:\n (1,3)\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"However, since all permutations yielded by elements! are aliased (modified \"in-place\"), collect(Generic.elements!(SymmetricGroup(n))) returns a vector of identical permutations.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"note: Note\nIf you intend to use or store elements yielded by elements! you need to deepcopy them explicitly.","category":"page"},{"location":"AbstractAlgebra/perm/#Arithmetic-operators","page":"Permutations and Symmetric groups","title":"Arithmetic operators","text":"","category":"section"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"*(::Perm{T}, ::Perm{T}) where T\n^(::Perm, n::Integer)\nBase.inv(::Perm)","category":"page"},{"location":"AbstractAlgebra/perm/#*-Union{Tuple{T}, Tuple{Perm{T}, Perm{T}}} where T","page":"Permutations and Symmetric groups","title":"*","text":"*(g::Perm, h::Perm)\n\nReturn the composition h  g of two permutations.\n\nThis corresponds to the action of permutation group on the set [1..n] on the right and follows the convention of GAP.\n\nIf g and h are parametrized by different types, the result is promoted accordingly.\n\nExamples:\n\njulia> Perm([2,3,1,4])*Perm([1,3,4,2]) # (1,2,3)*(2,3,4)\n(1,3)(2,4)\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/#^-Tuple{Perm, Integer}","page":"Permutations and Symmetric groups","title":"^","text":"^(g::Perm, n::Integer)\n\nReturn the n-th power of a permutation g.\n\nBy default g^n is computed by cycle decomposition of g if n > 3. Generic.power_by_squaring provides a different method for powering which may or may not be faster, depending on the particular case. Due to caching of the cycle structure, repeated powering of g will be faster with the default method.\n\nExamples:\n\njulia> g = Perm([2,3,4,5,1])\n(1,2,3,4,5)\n\njulia> g^3\n(1,4,2,5,3)\n\njulia> g^5\n()\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/#inv-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"inv","text":"Base.inv(g::Perm)\n\nReturn the inverse of the given permutation, i.e. the permuation g^-1 such that g  g^-1 = g^-1  g is the identity permutation.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Permutations parametrized by different types can be multiplied, and follow the standard julia integer promotion rules:","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"g = rand(SymmetricGroup(Int8(5)));\nh = rand(SymmetricGroup(UInt32(5)));\ntypeof(g*h)\n\n# output\nPerm{UInt32}","category":"page"},{"location":"AbstractAlgebra/perm/#Coercion","page":"Permutations and Symmetric groups","title":"Coercion","text":"","category":"section"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"The following coercions are available for G::SymmetricGroup parent objects. Each of the methods perform basic sanity checks on the input which can be switched off by the second argument.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Examples","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"(G::SymmetricGroup)(::AbstractVector{<:Integer}[, check=true])","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Turn a vector of integers into a permutation (performing conversion, if necessary).","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"(G::SymmetricGroup)(::Perm[, check=true])","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Coerce a permutation p into group G (performing the conversion, if necessary). If p is already an element of G no copy is performed.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"(G::SymmetricGroup)(::String[, check=true])","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Parse the string input e.g. copied from the output of GAP. The method uses the same logic as the perm\"...\" macro. The string is sanitized and checked for disjoint cycles. Both string(p::Perm) (if setpermstyle(:cycles)) and string(cycles(p::Perm)) are valid input for this method.","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"(G::SymmetricGroup{T})(::CycleDec{T}[, check=true]) where T","category":"page"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"Turn a cycle decomposition object into a permutation.","category":"page"},{"location":"AbstractAlgebra/perm/#Comparison","page":"Permutations and Symmetric groups","title":"Comparison","text":"","category":"section"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"==(::Perm, ::Perm)\n==(::Generic.SymmetricGroup, ::Generic.SymmetricGroup)","category":"page"},{"location":"AbstractAlgebra/perm/#==-Tuple{Perm, Perm}","page":"Permutations and Symmetric groups","title":"==","text":"==(g::Perm, h::Perm)\n\nReturn true if permutations are equal, otherwise return false.\n\nPermutations parametrized by different integer types are considered equal if they define the same permutation in the abstract permutation group.\n\nExamples:\n\njulia> g = Perm(Int8[2,3,1])\n(1,2,3)\n\njulia> h = perm\"(3,1,2)\"\n(1,2,3)\n\njulia> g == h\ntrue\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/#==-Tuple{AbstractAlgebra.Generic.SymmetricGroup, AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"==","text":"==(G::SymmetricGroup, H::SymmetricGroup)\n\nReturn true if permutation groups are equal, otherwise return false.\n\nPermutation groups on the same number of letters, but parametrized by different integer types are considered different.\n\nExamples:\n\njulia> G = SymmetricGroup(UInt(5))\nPermutation group over 5 elements\n\njulia> H = SymmetricGroup(5)\nPermutation group over 5 elements\n\njulia> G == H\nfalse\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/#Misc","page":"Permutations and Symmetric groups","title":"Misc","text":"","category":"section"},{"location":"AbstractAlgebra/perm/","page":"Permutations and Symmetric groups","title":"Permutations and Symmetric groups","text":"rand(::Generic.SymmetricGroup)\nGeneric.matrix_repr(::Perm)\nGeneric.emb(::Generic.SymmetricGroup, ::Vector{Int}, ::Bool)\nGeneric.emb!(::Perm, ::Perm, V)","category":"page"},{"location":"AbstractAlgebra/perm/#rand-Tuple{AbstractAlgebra.Generic.SymmetricGroup}","page":"Permutations and Symmetric groups","title":"rand","text":"rand([rng=GLOBAL_RNG,] G::SymmetricGroup)\n\nReturn a random permutation from G.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/#matrix_repr-Tuple{Perm}","page":"Permutations and Symmetric groups","title":"matrix_repr","text":"matrix_repr(a::Perm)\n\nReturn the permutation matrix as a sparse matrix representing a via natural embedding of the permutation group into the general linear group over mathbbZ.\n\nExamples:\n\njulia> p = Perm([2,3,1])\n(1,2,3)\n\njulia> matrix_repr(p)\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n ⋅  1  ⋅\n ⋅  ⋅  1\n 1  ⋅  ⋅\n\njulia> Array(ans)\n3×3 Matrix{Int64}:\n 0  1  0\n 0  0  1\n 1  0  0\n\n\n\nmatrix_repr(Y::YoungTableau)\n\nConstruct sparse integer matrix representing the tableau.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1]);\n\n\njulia> matrix_repr(y)\n3×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:\n 1  2  3  4\n 5  6  7  ⋅\n 8  ⋅  ⋅  ⋅\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/#emb-Tuple{AbstractAlgebra.Generic.SymmetricGroup, Vector{Int64}, Bool}","page":"Permutations and Symmetric groups","title":"emb","text":"emb(G::SymmetricGroup, V::Vector{Int}, check::Bool=true)\n\nReturn the natural embedding of a permutation group into G as the subgroup permuting points indexed by V.\n\nExamples:\n\njulia> p = Perm([2,3,1])\n(1,2,3)\n\njulia> f = Generic.emb(SymmetricGroup(5), [3,2,5]);\n\n\njulia> f(p)\n(2,5,3)\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/perm/#emb!-Tuple{Perm, Perm, Any}","page":"Permutations and Symmetric groups","title":"emb!","text":"emb!(result::Perm, p::Perm, V)\n\nEmbed permutation p into permutation result on the indices given by V.\n\nThis corresponds to the natural embedding of S_k into S_n as the subgroup permuting points indexed by V.\n\nExamples:\n\njulia> p = Perm([2,1,4,3])\n(1,2)(3,4)\n\njulia> Generic.emb!(Perm(collect(1:5)), p, [3,1,4,5])\n(1,3)(4,5)\n\n\n\n","category":"method"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/residue/#Residue-rings","page":"Residue rings","title":"Residue rings","text":"","category":"section"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"Nemo allows the creation of residue rings of the form R(a) for an element a of a ring R.","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"We don't require (a) to be a prime or maximal ideal. Instead, we allow the creation of the residue ring R(a) for any nonzero a and simply raise an exception if an impossible inverse is encountered during computations  involving elements of R(a). Of course, a GCD function must be available for the base ring R.","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"There is a generic implementation of residue rings of this form in AbstractAlgebra.jl, which accepts any ring R as base ring.","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"The associated types of parent object and elements for each kind of residue rings in Nemo are given in the following table.","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.Res{T} Generic.ResRing{T}\nmathbbZ (Int modulus) Flint nmod NmodRing\nmathbbZ (ZZ modulus) Flint fmpz_mod FmpzModRing","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"The modulus a of a residue ring is stored in its parent object.","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"All residue element types belong to the abstract type ResElem and all the residue ring parent object types belong to the abstract type ResRing. This enables one to write generic functions that accept any Nemo residue type.","category":"page"},{"location":"Nemo/residue/#Residue-functionality","page":"Residue rings","title":"Residue functionality","text":"","category":"section"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"All the residue rings in Nemo provide the functionality described in AbstractAlgebra for residue rings:","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/residue","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"In addition, generic residue rings are available.","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"We describe Nemo specific residue ring functionality below.","category":"page"},{"location":"Nemo/residue/#GCD","page":"Residue rings","title":"GCD","text":"","category":"section"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"gcdx(::nmod, ::nmod)\ngcdx(::fmpz_mod, ::fmpz_mod)","category":"page"},{"location":"Nemo/residue/#gcdx-Tuple{nmod, nmod}","page":"Residue rings","title":"gcdx","text":"gcdx(a::nmod, b::nmod)\n\nCompute the extended gcd with the Euclidean structure inherited from mathbbZ.\n\n\n\n","category":"method"},{"location":"Nemo/residue/#gcdx-Tuple{fmpz_mod, fmpz_mod}","page":"Residue rings","title":"gcdx","text":"gcdx(a::fmpz_mod, b::fmpz_mod)\n\nCompute the extended gcd with the Euclidean structure inherited from mathbbZ.\n\n\n\n","category":"method"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"Examples","category":"page"},{"location":"Nemo/residue/","page":"Residue rings","title":"Residue rings","text":"R = ResidueRing(ZZ, 123456789012345678949)\n\ng, s, t = gcdx(R(123), R(456))","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"using Oscar","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"Pages = [\"binomial_ideals.md\"]","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/#Binomial-Primary-Decomposition","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/binomial_ideals/#Introduction","page":"Binomial Primary Decomposition","title":"Introduction","text":"","category":"section"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"A binomial is a polynomial consisting of at most two terms. A binomial ideal is an ideal which can be generated by binomials. A binomial primary decomposition is a primary decomposition of a binomial ideal into primary ideals which are binomial as well. In this section, focusing on polynomial rings over fields, we discuss functionality for computing such decompositions.","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"We begin by recalling that a proper ideal I of a polynomial ring Kx_1 dots x_n over a field K is called cellular if each variable x_i is either a nonzerodivisor or nilpotent modulo I. In this case, we refer to the nonzerodivisors among the variables as the cell variables with respect to I. A cellular decomposition of a proper binomial ideal I of Kx_1 dots x_n is a decomposition of I into cellular binomial ideals. Using Noetherian induction, it is not too difficult to show that such decompositions exist. ","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"With this notation, the algorithms for computing binomial primary decompositions proceed in two main steps:","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"First, compute a cellular decomposition of the given binomial ideal.\nThen, decompose each cellular component into primary binomial ideals.","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"While the first step can be performed over any ground field for which Gröbner bases are implemented, the second step may require a field extension: From a theoretical point of view, the existence of binomial primary decompositions is only guaranteed if the ground field is algebraically closed.","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"note: Note\nA pure difference binomial is a binomial which is the difference of two monomials. A unital binomial ideal is an ideal which can be generated by pure difference binomials and monomials. Note that cellular components of unital binomial ideals are unital as well. For unital binomial ideals in mathbb Qx_1 dots x_n, binomial primary decompositions exist already over cyclotomic extensions of mathbb Q. In particular, any such ideal can be decomposed over the abelian closure mathbb Q^textab of mathbb Q. While OSCAR offers functionality for doing this, computing  binomial primary decompositions  in other cases is not yet supported. See the number theory chapter for how to deal with mathbb Q^textab.","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"note: Note\nBinomial primary decompositions computed with OSCAR are not necessarily minimal.","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"Papers offering details on theory and algorithms as well as examples include:","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"David Eisenbud, Bernd Sturmfels (1996)\nIgnacio Ojeda Martínez de Castilla, Ramón Peidra Sánchez (2000)\nThomas Kahle (2010)\nZekiye Sahin Eser, Laura Felicia Matusevich (2016)\nZekiye Sahin Eser, Laura Felicia Matusevich (2019)","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/#Basic-Tests","page":"Binomial Primary Decomposition","title":"Basic Tests","text":"","category":"section"},{"location":"CommutativeAlgebra/binomial_ideals/#Binomiality-Test","page":"Binomial Primary Decomposition","title":"Binomiality Test","text":"","category":"section"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"isbinomial(f::MPolyElem)\nisbinomial(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/#isbinomial-Tuple{MPolyElem}","page":"Binomial Primary Decomposition","title":"isbinomial","text":"isbinomial(f::MPolyElem)\n\nReturn true if f consists of at most 2 terms, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/binomial_ideals/#isbinomial-Tuple{MPolyIdeal}","page":"Binomial Primary Decomposition","title":"isbinomial","text":"isbinomial(I::MPolyIdeal)\n\nReturn true if I can be generated by polynomials consisting of at most 2 terms, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\nf = 2*x+y\nisbinomial(f)\nJ = ideal(R, [x^2-y^3, z^2])\nisbinomial(J)","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/#Cellularity-Test","page":"Binomial Primary Decomposition","title":"Cellularity Test","text":"","category":"section"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"iscellular(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/#iscellular-Tuple{MPolyIdeal}","page":"Binomial Primary Decomposition","title":"iscellular","text":"iscellular(I::MPolyIdeal)\n\nGiven a binomial ideal  I, return true together with the indices of the cell variables if I is cellular. Return false together with the index of a variable which is a zerodivisor but not nilpotent modulo I, otherwise (return (false, [-1]) if I is not proper).\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:6)\n(Multivariate Polynomial Ring in 6 variables x[1], x[2], x[3], x[4], ..., x[6] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nideal(x[1]^3*x[5] - x[2]^3*x[5], x[3]*x[6] - x[4]*x[6], x[5]^2, x[6]^2, x[5]*x[6])\n\njulia> iscellular(I)\n(true, [1, 2, 3, 4])\n\njulia> R, (x,y,z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [x-y,x^3-1,z*y^2-z])\nideal(x - y, x^3 - 1, y^2*z - z)\n\njulia> iscellular(I)\n(false, [3])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/binomial_ideals/#Unitality-Test","page":"Binomial Primary Decomposition","title":"Unitality Test","text":"","category":"section"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"isunital(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/#isunital-Tuple{MPolyIdeal}","page":"Binomial Primary Decomposition","title":"isunital","text":"isunital(I::MPolyIdeal)\n\nGiven a binomial ideal I, return true if I can be generated by differences of monomials and monomials.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [x+y])\nideal(x + y)\n\njulia> isunital(I)\nfalse\n\njulia> J = ideal(R, [x^2-y^3, z^2])\nideal(x^2 - y^3, z^2)\n\njulia> isunital(J)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/binomial_ideals/#Cellular-Decomposition","page":"Binomial Primary Decomposition","title":"Cellular Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"cellular_decomposition(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/#cellular_decomposition-Tuple{MPolyIdeal}","page":"Binomial Primary Decomposition","title":"cellular_decomposition","text":"cellular_decomposition(I::MPolyIdeal)\n\nGiven a binomial ideal I, return a cellular decomposition of I.\n\nExamples\n\njulia> R, (x,y,z) =  PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [x-y,x^3-1,z*y^2-z])\nideal(x - y, x^3 - 1, y^2*z - z)\n\njulia> cellular_decomposition(I)\n2-element Vector{MPolyIdeal{fmpq_mpoly}}:\n ideal(y - 1, x - 1)\n ideal(x - y, x^3 - 1, y^2*z - z, z)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/binomial_ideals/#Primary-Decomposition-of-Cellular-Ideals","page":"Binomial Primary Decomposition","title":"Primary Decomposition of Cellular Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"cellular_hull(I::MPolyIdeal{fmpq_mpoly})\ncellular_associated_primes(I::MPolyIdeal{fmpq_mpoly})\ncellular_minimal_associated_primes(I::MPolyIdeal{fmpq_mpoly})\ncellular_primary_decomposition(I::MPolyIdeal{fmpq_mpoly})","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/#cellular_hull-Tuple{MPolyIdeal{fmpq_mpoly}}","page":"Binomial Primary Decomposition","title":"cellular_hull","text":"cellular_hull(I::MPolyIdeal{fmpq_mpoly})\n\nGiven a cellular binomial ideal I, return the intersection  of the minimal primary components of I.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:6)\n(Multivariate Polynomial Ring in 6 variables x[1], x[2], x[3], x[4], ..., x[6] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nideal(x[1]^3*x[5] - x[2]^3*x[5], x[3]*x[6] - x[4]*x[6], x[5]^2, x[6]^2, x[5]*x[6])\n\njulia> iscellular(I)\n(true, [1, 2, 3, 4])\n\njulia> cellular_hull(I)\nideal(x[6], x[5])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/binomial_ideals/#cellular_associated_primes-Tuple{MPolyIdeal{fmpq_mpoly}}","page":"Binomial Primary Decomposition","title":"cellular_associated_primes","text":"cellular_associated_primes(I::MPolyIdeal{fmpq_mpoly})\n\nGiven a cellular binomial ideal I, return the associated primes of I.\n\nThe result is defined over the abelian closure of mathbb Q. In the output, if needed, the generator for roots of unities is denoted by ζ. So ζ(3), for example, stands for a primitive third root of unity.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:6)\n(Multivariate Polynomial Ring in 6 variables x[1], x[2], x[3], x[4], ..., x[6] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nideal(x[1]^3*x[5] - x[2]^3*x[5], x[3]*x[6] - x[4]*x[6], x[5]^2, x[6]^2, x[5]*x[6])\n\njulia> cellular_associated_primes(I)\n5-element Vector{MPolyIdeal{AbstractAlgebra.Generic.MPoly{QabElem{nf_elem}}}}:\n ideal(x[5], x[6])\n ideal(x[1] - x[2], x[5], x[6])\n ideal(x[1] - ζ(3)*x[2], x[5], x[6])\n ideal(x[1] + (ζ(3) + 1)*x[2], x[5], x[6])\n ideal(x[3] - x[4], x[5], x[6])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/binomial_ideals/#cellular_minimal_associated_primes-Tuple{MPolyIdeal{fmpq_mpoly}}","page":"Binomial Primary Decomposition","title":"cellular_minimal_associated_primes","text":"cellular_minimal_associated_primes(I::MPolyIdeal{fmpq_mpoly})\n\nGiven a cellular binomial ideal I, return the minimal associated primes of I.\n\nThe result is defined over the abelian closure of mathbb Q. In the output, if needed, the generator for roots of unities is denoted by ζ. So ζ(3), for example, stands for a primitive third root of unity.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:6)\n(Multivariate Polynomial Ring in 6 variables x[1], x[2], x[3], x[4], ..., x[6] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nideal(x[1]^3*x[5] - x[2]^3*x[5], x[3]*x[6] - x[4]*x[6], x[5]^2, x[6]^2, x[5]*x[6])\n\njulia> cellular_minimal_associated_primes(I::MPolyIdeal{fmpq_mpoly})\n1-element Vector{MPolyIdeal{AbstractAlgebra.Generic.MPoly{QabElem{nf_elem}}}}:\n ideal(x[5], x[6])\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/binomial_ideals/#cellular_primary_decomposition-Tuple{MPolyIdeal{fmpq_mpoly}}","page":"Binomial Primary Decomposition","title":"cellular_primary_decomposition","text":"cellular_primary_decomposition(I::MPolyIdeal{fmpq_mpoly})\n\nGiven a cellular binomial ideal I, return a binomial primary decomposition of I.\n\nThe result is defined over the abelian closure of mathbb Q. In the output, if needed, the generator for roots of unities is denoted by ζ. So ζ(3), for example, stands for a primitive third root of unity.\n\nExamples\n\njulia> R, x = PolynomialRing(QQ, \"x\" => 1:6)\n(Multivariate Polynomial Ring in 6 variables x[1], x[2], x[3], x[4], ..., x[6] over Rational Field, fmpq_mpoly[x[1], x[2], x[3], x[4], x[5], x[6]])\n\njulia> I = ideal(R, [x[5]*(x[1]^3-x[2]^3), x[6]*(x[3]-x[4]), x[5]^2, x[6]^2, x[5]*x[6]])\nideal(x[1]^3*x[5] - x[2]^3*x[5], x[3]*x[6] - x[4]*x[6], x[5]^2, x[6]^2, x[5]*x[6])\n\njulia> cellular_primary_decomposition(I)\n5-element Vector{Tuple{MPolyIdeal{AbstractAlgebra.Generic.MPoly{QabElem{nf_elem}}}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{QabElem{nf_elem}}}}}:\n (ideal(x[6], x[5]), ideal(x[5], x[6]))\n (ideal(x[6], x[1] - x[2], x[5]^2), ideal(x[1] - x[2], x[5], x[6]))\n (ideal(x[6], x[1] - ζ(3)*x[2], x[5]^2), ideal(x[1] - ζ(3)*x[2], x[5], x[6]))\n (ideal(x[6], x[1] + (ζ(3) + 1)*x[2], x[5]^2), ideal(x[1] + (ζ(3) + 1)*x[2], x[5], x[6]))\n (ideal(x[5], x[3] - x[4], x[6]^2), ideal(x[3] - x[4], x[5], x[6]))\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/binomial_ideals/#Primary-Decomposition-of-Binomial-Ideals","page":"Binomial Primary Decomposition","title":"Primary Decomposition of Binomial  Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/binomial_ideals/","page":"Binomial Primary Decomposition","title":"Binomial Primary Decomposition","text":"binomial_primary_decomposition(I::MPolyIdeal{fmpq_mpoly})","category":"page"},{"location":"CommutativeAlgebra/binomial_ideals/#binomial_primary_decomposition-Tuple{MPolyIdeal{fmpq_mpoly}}","page":"Binomial Primary Decomposition","title":"binomial_primary_decomposition","text":"binomial_primary_decomposition(I::MPolyIdeal{fmpq_mpoly})\n\nGiven a binomial ideal I, return a binomial primary decomposition of I.\n\nThe result is defined over the abelian closure of mathbb Q. In the output, if needed, the generator for roots of unities is denoted by ζ. So ζ(3), for example, stands for a primitive third root of unity.\n\nExamples\n\njulia> R, (x,y,z) =  PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [x-y,x^3-1,z*y^2-z])\nideal(x - y, x^3 - 1, y^2*z - z)\n\njulia> binomial_primary_decomposition(I)\n3-element Vector{Tuple{MPolyIdeal{AbstractAlgebra.Generic.MPoly{QabElem{nf_elem}}}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{QabElem{nf_elem}}}}}:\n (ideal(x - y, x^3 - 1, y^2*z - z, z, y - ζ(3), x - ζ(3)), ideal(x*y^2 - 1, y - ζ(3), z))\n (ideal(x - y, x^3 - 1, y^2*z - z, z, y + ζ(3) + 1, x + ζ(3) + 1), ideal(x*y^2 - 1, y + ζ(3) + 1, z))\n (ideal(y - 1, x - 1, x*y - 1), ideal(y - 1, x - 1, x*y - 1))\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/rand/#Random-interface","page":"Random interface","title":"Random interface","text":"","category":"section"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"AbstractAlgebra makes use of the Julia Random interface for random generation.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"In addition we make use of an experimental package RandomExtensions.jl for extending the random interface in Julia.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"The latter is required because some of our types require more than one argument to specify how to randomise them.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"The usual way of generating random values that Julia and these extensions provide would look as follows:","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"julia> using AbstractAlgebra\n\njulia> using Random\n\njulia> using RandomExtensions\n\njulia> S, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> rand(Random.GLOBAL_RNG, make(S, 1:3, -10:10))\n-5*x + 4","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"This example generates a polynomial over the integers with degree in the range 1 to 3 and with coefficients in the range -10 to 10.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"In addition we implement shortened versions for ease of use which don't require creating a make instance or passing in the standard RNG.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"julia> using AbstractAlgebra\n\njulia> S, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> rand(S, 1:3, -10:10)\n-5*x + 4","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"Because rings can be constructed over other rings in a tower, all of this is supported by defining RandomExtensions.make instances that break the various levels of the ring down into separate make instances.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"For example, here is the implementation of make for polynomial rings such as the above:","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"function RandomExtensions.make(S::PolyRing, deg_range::UnitRange{Int}, vs...)\n   R = base_ring(S)\n   if length(vs) == 1 && elem_type(R) == Random.gentype(vs[1])\n      Make(S, deg_range, vs[1]) # forward to default Make constructor\n   else\n      make(S, deg_range, make(R, vs...))\n   end\nend","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"As you can see, it has two cases. The first is where this invocation of make is already at the bottom of the tower of rings, in which case it just forwards to the default Make constructor.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"The second case expects that we are higher up in the tower of rings and that make needs to be broken up (recursively) into the part that deals with the ring level we are at and the level that deals with the base ring.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"To help make we tell it the type of object we are hoping to randomly generate.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"RandomExtensions.maketype(S::PolyRing, dr::UnitRange{Int}, _) = elem_type(S)","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"Finally we implement the actual random generation itself.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"# define rand for make(S, deg_range, v)\nfunction rand(rng::AbstractRNG, sp::SamplerTrivial{<:Make3{<:RingElement,<:PolyRing,UnitRange{Int}}})\n   S, deg_range, v = sp[][1:end]\n   R = base_ring(S)\n   f = S()\n   x = gen(S)\n   # degree -1 is zero polynomial\n   deg = rand(rng, deg_range)\n   if deg == -1\n      return f\n   end\n   for i = 0:deg - 1\n      f += rand(rng, v)*x^i\n   end\n   # ensure leading coefficient is nonzero\n   c = R()\n   while iszero(c)\n      c = rand(rng, v)\n   end\n   f += c*x^deg\n   return f\nend","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"Note that when generating random elements of the base ring for example, one should use the random number generator rng that is passed in.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"As mentioned above, we define a simplified random generator that saves the user having to create make instances.","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"rand(rng::AbstractRNG, S::PolyRing, deg_range::UnitRange{Int}, v...) =\n   rand(rng, make(S, deg_range, v...))\n\nrand(S::PolyRing, degs, v...) = rand(Random.GLOBAL_RNG, S, degs, v...)","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"To test whether a random generator is working properly, the test_rand function exists in the AbstractAlgebra test submodule in the file test/runtests.jl. For example, in AbstractAlgebra test code:","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"using Test\n\nR, x = PolynomialRing(ZZ, \"x\")\n\ntest_rand(R, -1:10, -10:10)","category":"page"},{"location":"AbstractAlgebra/rand/","page":"Random interface","title":"Random interface","text":"In general, we try to use UnitRange's to specify how 'big' we want the random instance to be, e.g. the range of degrees a polynomial could take, the range random integers could lie in, etc. The objective is to make it easy for the user to control the 'size' of random values in test code.","category":"page"},{"location":"StraightLinePrograms/abstractalgebra/#AbstractAlgebra's-polynomial-interface","page":"AbstractAlgebra's polynomial interface","title":"AbstractAlgebra's polynomial interface","text":"","category":"section"},{"location":"StraightLinePrograms/abstractalgebra/","page":"AbstractAlgebra's polynomial interface","title":"AbstractAlgebra's polynomial interface","text":"This is the initial API of SLPs which hasn't been updated in a while and might not work as-is with the current state of the package.","category":"page"},{"location":"StraightLinePrograms/abstractalgebra/","page":"AbstractAlgebra's polynomial interface","title":"AbstractAlgebra's polynomial interface","text":"Currently, SLPs have a polynomial interface (SLPoly).","category":"page"},{"location":"StraightLinePrograms/abstractalgebra/#Examples","page":"AbstractAlgebra's polynomial interface","title":"Examples","text":"","category":"section"},{"location":"StraightLinePrograms/abstractalgebra/","page":"AbstractAlgebra's polynomial interface","title":"AbstractAlgebra's polynomial interface","text":"julia> using AbstractAlgebra, StraightLinePrograms, BenchmarkTools;\n\njulia> S = SLPolyRing(zz, [:x, :y]); x, y = gens(S)\n2-element Vector{SLPoly{Int64,SLPolyRing{Int64,AbstractAlgebra.Integers{Int64}}}}:\n x\n y\n\njulia> p = 3 + 2x * y^2 # each line of the SLP is shown with current value\n  #1 = * 2 x    ==>     (2x)\n  #2 = ^ y 2    ==>     y^2\n  #3 = * #1 #2  ==>     (2xy^2)\n  #4 = + 3 #3   ==>     (3 + (2xy^2))\n\njulia> p.cs # constants used in the program\n2-element Vector{Int64}:\n 3\n 2\n\njulia> p.lines # each line is a UInt64 encoding an opcode and 2 arguments\n Line(0x0500000028000001)\n Line(0x8780000020000002)\n Line(0x0500000030000004)\n Line(0x0300000010000005)\n\njulia> SLP.evaluate(p, [2, 3])\n39\n\njulia> p2 = (p*(x*y))^6\n#1 = *  2  x  ==>  (2x)\n#2 = ^  y  2  ==>  y^2\n#3 = * #1 #2  ==>  (2xy^2)\n#4 = +  3 #3  ==>  (3 + (2xy^2))\n#5 = *  x  y  ==>  (xy)\n#6 = * #4 #5  ==>  ((3 + (2xy^2))xy)\n#7 = ^ #6  6  ==>  ((3 + (2xy^2))xy)^6\n\njulia> R, (x1, y1) = PolynomialRing(zz, [\"x\", \"y\"]); R\nMultivariate Polynomial Ring in x, y over Integers\n\njulia> q = convert(R, p2)\n64*x^12*y^18+576*x^11*y^16+2160*x^10*y^14+4320*x^9*y^12+4860*x^8*y^10+2916*x^7*y^8+729*x^6*y^6\n\njulia> v = [3, 5]; @btime SLP.evaluate($q, $v)\n  32.101 μs (634 allocations: 45.45 KiB)\n-1458502820125772303\n\njulia> @btime SLP.evaluate($p2, $v)\n  270.341 ns (4 allocations: 352 bytes)\n-1458502820125772303\n\njulia> res = Int[]; @btime StraightLinePrograms.evaluate!($res, $p2, $v)\n  171.013 ns (0 allocations: 0 bytes)\n-1458502820125772303\n\njulia> res # intermediate computations (first 2 elements are constants)\n9-element Vector{Int64}:\n                    3\n                    2\n                    6\n                   25\n                  150\n                  153\n                   15\n                 2295\n -1458502820125772303\n\njulia> f2 = StraightLinePrograms.compile!(p2) # compile to machine code\n#3 (generic function with 1 method)\n\njulia> @btime SLP.evaluate($p2, $v)\n  31.153 ns (1 allocation: 16 bytes)\n-1458502820125772303\n\njulia> @btime $f2($v) # use a function barrier for last bit of efficiency\n 7.980 ns (0 allocations: 0 bytes)\n-1458502820125772303\n\njulia> q\n64*x^12*y^18+576*x^11*y^16+2160*x^10*y^14+4320*x^9*y^12+4860*x^8*y^10+2916*x^7*y^8+729*x^6*y^6\n\njulia> p3 = convert(S, q) # convert back q::Mpoly to an SLPoly\n #1 = ^    x   6  ==>  x^6\n #2 = ^    x   7  ==>  x^7\n #3 = ^    x   8  ==>  x^8\n #4 = ^    x   9  ==>  x^9\n #5 = ^    x  10  ==>  x^10\n #6 = ^    x  11  ==>  x^11\n #7 = ^    x  12  ==>  x^12\n #8 = ^    y   6  ==>  y^6\n #9 = ^    y   8  ==>  y^8\n#10 = ^    y  10  ==>  y^10\n#11 = ^    y  12  ==>  y^12\n#12 = ^    y  14  ==>  y^14\n#13 = ^    y  16  ==>  y^16\n#14 = ^    y  18  ==>  y^18\n#15 = *   64  #7  ==>  (64x^12)\n#16 = *  #15 #14  ==>  (64x^12y^18)\n#17 = *  576  #6  ==>  (576x^11)\n#18 = *  #17 #13  ==>  (576x^11y^16)\n#19 = +  #16 #18  ==>  ((64x^12y^18) + (576x^11y^16))\n#20 = * 2160  #5  ==>  (2160x^10)\n#21 = *  #20 #12  ==>  (2160x^10y^14)\n#22 = +  #19 #21  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14))\n#23 = * 4320  #4  ==>  (4320x^9)\n#24 = *  #23 #11  ==>  (4320x^9y^12)\n#25 = +  #22 #24  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14) + (4320x^9y^12))\n#26 = * 4860  #3  ==>  (4860x^8)\n#27 = *  #26 #10  ==>  (4860x^8y^10)\n#28 = +  #25 #27  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14) + (4320x^9y^12) + (4860x^8y^10))\n#29 = * 2916  #2  ==>  (2916x^7)\n#30 = *  #29  #9  ==>  (2916x^7y^8)\n#31 = +  #28 #30  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14) + (4320x^9y^12) + (4860x^8y^10) + (2916x^7y^8))\n#32 = *  729  #1  ==>  (729x^6)\n#33 = *  #32  #8  ==>  (729x^6y^6)\n#34 = +  #31 #33  ==>  ((64x^12y^18) + (576x^11y^16) + (2160x^10y^14) + (4320x^9y^12) + (4860x^8y^10) + (2916x^7y^8) + (729x^6y^6))\n\njulia> @btime SLP.evaluate($p3, $v)\n  699.465 ns (5 allocations: 1008 bytes)\n-1458502820125772303\n\njulia> @time f3 = StraightLinePrograms.compile!(p3);\n  0.002830 seconds (1.40 k allocations: 90.930 KiB)\n\njulia> @btime $f3($v)\n 80.229 ns (0 allocations: 0 bytes)\n-1458502820125772303\n\njulia> p4 = convert(S, q, limit_exp=true); # use different encoding\n\njulia> @btime SLP.evaluate($p4, $v)\n  766.864 ns (5 allocations: 1008 bytes)\n-1458502820125772303\n\njulia> @time f4 = StraightLinePrograms.compile!(p4);\n  0.002731 seconds (1.74 k allocations: 108.676 KiB)\n\njulia> @btime $f4($v)\n  11.781 ns (0 allocations: 0 bytes)\n-1458502820125772303","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/arb/#Real-balls","page":"Real balls","title":"Real balls","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Arbitrary precision real ball arithmetic is supplied by Arb which provides a ball representation which tracks error bounds rigorously. Real numbers are  represented in mid-rad interval form m pm r = m-r m+r.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"The Arb real field is constructed using the ArbField constructor. This constructs the parent object for the Arb real field.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"However, we define","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RealField = ArbField","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"so that one can construct the Arb real field parent object using RealField instead of ArbField.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"The types of real balls in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Library Field Element type Parent type\nArb mathbbR (balls) arb ArbField","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"All the real field types belong to the Field abstract type and the types of elements in this field, i.e. balls in this case, belong to the FieldElem abstract type.","category":"page"},{"location":"Nemo/arb/#Real-ball-functionality","page":"Real balls","title":"Real ball functionality","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Real balls in Nemo provide all the field functionality described in AbstractAlgebra:","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Below, we document the additional functionality provided for real balls.","category":"page"},{"location":"Nemo/arb/#Constructors","page":"Real balls","title":"Constructors","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"In order to construct real balls in Nemo, one must first construct the Arb real field itself. This is accomplished with the following constructor.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"ArbField(prec::Int)","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Return the Arb field with precision in bits prec used for operations on interval midpoints. The precision used for interval radii is a fixed implementation-defined constant (30 bits).","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"We define","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RealField = ArbField","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"so that one can use RealField in place of ArbField.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Here is an example of creating an Arb real field and using the resulting parent object to coerce values into the resulting field.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\na = RR(\"0.25\")\nb = RR(\"0.1 +/- 0.001\")\nc = RR(0.5)\nd = RR(12)","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Note that whilst one can coerce double precision floating point values into an Arb real field, unless those values can be represented exactly in double precision the resulting ball can't be any more precise than the double precision supplied.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"If instead, values can be represented precisely using decimal arithmetic then one can supply them to Arb using a string. In this case, Arb will store them to the precision specified when creating the Arb field.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"If the values can be stored precisely as a binary floating point number, Arb will store the values exactly. See the function isexact below for more information.","category":"page"},{"location":"Nemo/arb/#Real-ball-constructors","page":"Real balls","title":"Real ball constructors","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"ball(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#ball-Tuple{arb, arb}","page":"Real balls","title":"ball","text":"ball(x::arb, y::arb)\n\nConstructs an Arb ball enclosing x_m pm (x_r + y_m + y_r), given the pair (x y) = (x_m pm x_r y_m pm y_r).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\nc = ball(RR(3), RR(\"0.0001\"))","category":"page"},{"location":"Nemo/arb/#Conversions","page":"Real balls","title":"Conversions","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\nconvert(Float64, RR(1//3))","category":"page"},{"location":"Nemo/arb/#Basic-manipulation","page":"Real balls","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"isnonzero(::arb)","category":"page"},{"location":"Nemo/arb/#isnonzero-Tuple{arb}","page":"Real balls","title":"isnonzero","text":"isnonzero(x::arb)\n\nReturn true if x is certainly not equal to zero, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"isfinite(::arb)","category":"page"},{"location":"Nemo/arb/#isfinite-Tuple{arb}","page":"Real balls","title":"isfinite","text":"isfinite(x::arb)\n\nReturn true if x is finite, i.e. having finite midpoint and radius, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"isexact(::arb)","category":"page"},{"location":"Nemo/arb/#isexact-Tuple{arb}","page":"Real balls","title":"isexact","text":"isexact(x::arb)\n\nReturn true if x is exact, i.e. has zero radius, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"isinteger(::arb)","category":"page"},{"location":"Nemo/arb/#isinteger-Tuple{arb}","page":"Real balls","title":"isinteger","text":"isinteger(x::arb)\n\nReturn true if x is an exact integer, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"ispositive(::arb)","category":"page"},{"location":"Nemo/arb/#ispositive-Tuple{arb}","page":"Real balls","title":"ispositive","text":"ispositive(x::arb)\n\nReturn true if x is certainly positive, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"isnonnegative(::arb)","category":"page"},{"location":"Nemo/arb/#isnonnegative-Tuple{arb}","page":"Real balls","title":"isnonnegative","text":"isnonnegative(x::arb)\n\nReturn true if x is certainly nonnegative, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"isnegative(::arb)","category":"page"},{"location":"Nemo/arb/#isnegative-Tuple{arb}","page":"Real balls","title":"isnegative","text":"isnegative(x::arb)\n\nReturn true if x is certainly negative, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"isnonpositive(::arb)","category":"page"},{"location":"Nemo/arb/#isnonpositive-Tuple{arb}","page":"Real balls","title":"isnonpositive","text":"isnonpositive(x::arb)\n\nReturn true if x is certainly nonpositive, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"midpoint(::arb)","category":"page"},{"location":"Nemo/arb/#midpoint-Tuple{arb}","page":"Real balls","title":"midpoint","text":"midpoint(x::arb)\n\nReturn the midpoint of the ball x as an Arb ball.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"radius(::arb)","category":"page"},{"location":"Nemo/arb/#radius-Tuple{arb}","page":"Real balls","title":"radius","text":"radius(x::arb)\n\nReturn the radius of the ball x as an Arb ball.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"accuracy_bits(::arb)","category":"page"},{"location":"Nemo/arb/#accuracy_bits-Tuple{arb}","page":"Real balls","title":"accuracy_bits","text":"accuracy_bits(x::arb)\n\nReturn the relative accuracy of x measured in bits, capped between typemax(Int) and -typemax(Int).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\na = RR(\"1.2 +/- 0.001\")\nb = RR(3)\n\nispositive(a)\nisfinite(b)\nisinteger(b)\nisnegative(a)\nc = radius(a)\nd = midpoint(b)\nf = accuracy_bits(a)","category":"page"},{"location":"Nemo/arb/#Printing","page":"Real balls","title":"Printing","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Printing real balls can at first sight be confusing. Lets look at the following example:","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\na = RR(1)\nb = RR(2)\nc = RR(12)\n\nx = ball(a, b)\ny = ball(c, b)\n\nmid = midpoint(x)\nrad = radius(x)\n\nprint(x, \"\\n\", y, \"\\n\", mid, \"\\n\", rad)","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"which generates","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"[+/- 3.01]\n[1e+1 +/- 4.01]\n1.0000000000000000000\n[2.0000000037252902985 +/- 3.81e-20]","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"The first reason that c is not printed as [1 +/- 2] is that the midpoint does not have a greater exponent than the radius in its scientific notation. For similar reasons y is not printed as [12 +/- 2].","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"The second reason is that we get an additional error term after our addition. As we see, radius(c) is not equal to 2, which when printed rounds it up to a reasonable decimal place. This is because real balls keep track of rounding errors of basic arithmetic.","category":"page"},{"location":"Nemo/arb/#Containment","page":"Real balls","title":"Containment","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"It is often necessary to determine whether a given exact value or ball is contained in a given real ball or whether two balls overlap. The following functions are provided for this purpose.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"overlaps(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#overlaps-Tuple{arb, arb}","page":"Real balls","title":"overlaps","text":"overlaps(x::arb, y::arb)\n\nReturns true if any part of the ball x overlaps any part of the ball y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"contains(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#contains-Tuple{arb, arb}","page":"Real balls","title":"contains","text":"contains(x::arb, y::arb)\n\nReturns true if the ball x contains the ball y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"contains(::arb, ::Integer)\ncontains(::arb, ::fmpz)\ncontains(::arb, ::fmpq)\ncontains{T <: Integer}(::arb, ::Rational{T})\ncontains(::arb, ::BigFloat)","category":"page"},{"location":"Nemo/arb/#contains-Tuple{arb, Integer}","page":"Real balls","title":"contains","text":"contains(x::arb, y::Integer)\n\nReturns true if the ball x contains the given integer value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/#contains-Tuple{arb, fmpz}","page":"Real balls","title":"contains","text":"contains(x::arb, y::fmpz)\n\nReturns true if the ball x contains the given integer value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/#contains-Tuple{arb, fmpq}","page":"Real balls","title":"contains","text":"contains(x::arb, y::fmpq)\n\nReturns true if the ball x contains the given rational value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/#contains-Union{Tuple{T}, Tuple{arb, Rational{T}}} where T<:Integer","page":"Real balls","title":"contains","text":"contains(x::arb, y::Rational{T}) where {T <: Integer}\n\nReturns true if the ball x contains the given rational value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/#contains-Tuple{arb, BigFloat}","page":"Real balls","title":"contains","text":"contains(x::arb, y::BigFloat)\n\nReturns true if the ball x contains the given floating point value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"The following functions are also provided for determining if a ball intersects a certain part of the real number line.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"contains_zero(::arb)","category":"page"},{"location":"Nemo/arb/#contains_zero-Tuple{arb}","page":"Real balls","title":"contains_zero","text":"contains_zero(x::arb)\n\nReturns true if the ball x contains zero, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"contains_negative(::arb)","category":"page"},{"location":"Nemo/arb/#contains_negative-Tuple{arb}","page":"Real balls","title":"contains_negative","text":"contains_negative(x::arb)\n\nReturns true if the ball x contains any negative value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"contains_positive(::arb)","category":"page"},{"location":"Nemo/arb/#contains_positive-Tuple{arb}","page":"Real balls","title":"contains_positive","text":"contains_positive(x::arb)\n\nReturns true if the ball x contains any positive value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"contains_nonnegative(::arb)","category":"page"},{"location":"Nemo/arb/#contains_nonnegative-Tuple{arb}","page":"Real balls","title":"contains_nonnegative","text":"contains_nonnegative(x::arb)\n\nReturns true if the ball x contains any nonnegative value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"contains_nonpositive(::arb)","category":"page"},{"location":"Nemo/arb/#contains_nonpositive-Tuple{arb}","page":"Real balls","title":"contains_nonpositive","text":"contains_nonpositive(x::arb)\n\nReturns true if the ball x contains any nonpositive value, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"1 +/- 0.001\")\ny = RR(\"3\")\n\noverlaps(x, y)\ncontains(x, y)\ncontains(y, 3)\ncontains(x, ZZ(1)//2)\ncontains_zero(x)\ncontains_positive(y)","category":"page"},{"location":"Nemo/arb/#Comparison","page":"Real balls","title":"Comparison","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Nemo provides a full range of comparison operations for Arb balls. Note that a ball is considered less than another ball if every value in the first ball is less than every value in the second ball, etc.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"In addition to the standard comparison operators, we introduce an exact equality. This is distinct from arithmetic equality implemented by ==, which merely compares up to the minimum of the precisions of its operands.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"isequal(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#isequal-Tuple{arb, arb}","page":"Real balls","title":"isequal","text":"isequal(x::arb, y::arb)\n\nReturn true if the balls x and y are precisely equal, i.e. have the same midpoints and radii.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"We also provide a full range of ad hoc comparison operators. These are implemented directly in Julia, but we document them as though isless and == were provided.","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Function\n==(x::arb, y::Integer)\n==(x::Integer, y::arb)\n==(x::arb, y::fmpz)\n==(x::fmpz, y::arb)\n==(x::arb, y::Float64)\n==(x::Float64, y::arb)\nisless(x::arb, y::Integer)\nisless(x::Integer, y::arb)\nisless(x::arb, y::fmpz)\nisless(x::fmpz, y::arb)\nisless(x::arb, y::Float64)\nisless(x::Float64, y::arb)\nisless(x::arb, y::BigFloat)\nisless(x::BigFloat, y::arb)\nisless(x::arb, y::fmpq)\nisless(x::fmpq, y::arb)","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"1 +/- 0.001\")\ny = RR(\"3\")\nz = RR(\"4\")\n\nisequal(x, deepcopy(x))\nx == 3\nZZ(3) < z\nx != 1.23","category":"page"},{"location":"Nemo/arb/#Absolute-value","page":"Real balls","title":"Absolute value","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"-1 +/- 0.001\")\n\na = abs(x)","category":"page"},{"location":"Nemo/arb/#Shifting","page":"Real balls","title":"Shifting","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"-3 +/- 0.001\")\n\na = ldexp(x, 23)\nb = ldexp(x, -ZZ(15))","category":"page"},{"location":"Nemo/arb/#Miscellaneous-operations","page":"Real balls","title":"Miscellaneous operations","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"add_error!(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#add_error!-Tuple{arb, arb}","page":"Real balls","title":"add_error!","text":"add_error!(x::arb, y::arb)\n\nAdds the absolute values of the midpoint and radius of y to the radius of x.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"trim(::arb)","category":"page"},{"location":"Nemo/arb/#trim-Tuple{arb}","page":"Real balls","title":"trim","text":"trim(x::arb)\n\nReturn an arb interval containing x but which may be more economical, by rounding off insignificant bits from the midpoint.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"unique_integer(::arb)","category":"page"},{"location":"Nemo/arb/#unique_integer-Tuple{arb}","page":"Real balls","title":"unique_integer","text":"unique_integer(x::arb)\n\nReturn a pair where the first value is a boolean and the second is an fmpz integer. The boolean indicates whether the interval x contains a unique integer. If this is the case, the second return value is set to this unique integer.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"setunion(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#setunion-Tuple{arb, arb}","page":"Real balls","title":"setunion","text":"setunion(x::arb, y::arb)\n\nReturn an arb containing the union of the intervals represented by x and y.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nx = RR(\"-3 +/- 0.001\")\ny = RR(\"2 +/- 0.5\")\n\na = trim(x)\nb, c = unique_integer(x)\nd = setunion(x, y)","category":"page"},{"location":"Nemo/arb/#Constants","page":"Real balls","title":"Constants","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"const_pi(::ArbField)","category":"page"},{"location":"Nemo/arb/#const_pi-Tuple{ArbField}","page":"Real balls","title":"const_pi","text":"const_pi(r::ArbField)\n\nReturn pi = 314159ldots as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"const_e(::ArbField)","category":"page"},{"location":"Nemo/arb/#const_e-Tuple{ArbField}","page":"Real balls","title":"const_e","text":"const_e(r::ArbField)\n\nReturn e = 271828ldots as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"const_log2(::ArbField)","category":"page"},{"location":"Nemo/arb/#const_log2-Tuple{ArbField}","page":"Real balls","title":"const_log2","text":"const_log2(r::ArbField)\n\nReturn log(2) = 069314ldots as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"const_log10(::ArbField)","category":"page"},{"location":"Nemo/arb/#const_log10-Tuple{ArbField}","page":"Real balls","title":"const_log10","text":"const_log10(r::ArbField)\n\nReturn log(10) = 2302585ldots as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"const_euler(::ArbField)","category":"page"},{"location":"Nemo/arb/#const_euler-Tuple{ArbField}","page":"Real balls","title":"const_euler","text":"const_euler(r::ArbField)\n\nReturn Euler's constant gamma = 0577215ldots as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"const_catalan(::ArbField)","category":"page"},{"location":"Nemo/arb/#const_catalan-Tuple{ArbField}","page":"Real balls","title":"const_catalan","text":"const_catalan(r::ArbField)\n\nReturn Catalan's constant C = 0915965ldots as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"const_khinchin(::ArbField)","category":"page"},{"location":"Nemo/arb/#const_khinchin-Tuple{ArbField}","page":"Real balls","title":"const_khinchin","text":"const_khinchin(r::ArbField)\n\nReturn Khinchin's constant K = 2685452ldots as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"const_glaisher(::ArbField)","category":"page"},{"location":"Nemo/arb/#const_glaisher-Tuple{ArbField}","page":"Real balls","title":"const_glaisher","text":"const_glaisher(r::ArbField)\n\nReturn Glaisher's constant A = 1282427ldots as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(200)\n\na = const_pi(RR)\nb = const_e(RR)\nc = const_euler(RR)\nd = const_glaisher(RR)","category":"page"},{"location":"Nemo/arb/#Mathematical-and-special-functions","page":"Real balls","title":"Mathematical and special functions","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"rsqrt(::arb)","category":"page"},{"location":"Nemo/arb/#rsqrt-Tuple{arb}","page":"Real balls","title":"rsqrt","text":"rsqrt(x::arb)\n\nReturn the reciprocal of the square root of x, i.e. 1sqrtx.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"sqrt1pm1(::arb)","category":"page"},{"location":"Nemo/arb/#sqrt1pm1-Tuple{arb}","page":"Real balls","title":"sqrt1pm1","text":"sqrt1pm1(x::arb)\n\nReturn sqrt1+x-1, evaluated accurately for small x.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"sqrtpos(::arb)","category":"page"},{"location":"Nemo/arb/#sqrtpos-Tuple{arb}","page":"Real balls","title":"sqrtpos","text":"sqrtpos(x::arb)\n\nReturn the sqrt root of x, assuming that x represents a nonnegative number. Thus any negative number in the input interval is discarded.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"gamma(::arb)","category":"page"},{"location":"Nemo/arb/#gamma-Tuple{arb}","page":"Real balls","title":"gamma","text":"gamma(x::arb)\n\nReturn the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"lgamma(::arb)","category":"page"},{"location":"Nemo/arb/#lgamma-Tuple{arb}","page":"Real balls","title":"lgamma","text":"lgamma(x::arb)\n\nReturn the logarithm of the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"rgamma(::arb)","category":"page"},{"location":"Nemo/arb/#rgamma-Tuple{arb}","page":"Real balls","title":"rgamma","text":"rgamma(x::arb)\n\nReturn the reciprocal of the Gamma function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"digamma(::arb)","category":"page"},{"location":"Nemo/arb/#digamma-Tuple{arb}","page":"Real balls","title":"digamma","text":"digamma(x::arb)\n\nReturn the  logarithmic derivative of the gamma function evaluated at x, i.e. psi(x).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"gamma(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#gamma-Tuple{arb, arb}","page":"Real balls","title":"gamma","text":"gamma(s::arb, x::arb)\n\nReturn the upper incomplete gamma function Gamma(sx).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"gamma_regularized(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#gamma_regularized-Tuple{arb, arb}","page":"Real balls","title":"gamma_regularized","text":"gamma_regularized(s::arb, x::arb)\n\nReturn the regularized upper incomplete gamma function Gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"gamma_lower(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#gamma_lower-Tuple{arb, arb}","page":"Real balls","title":"gamma_lower","text":"gamma_lower(s::arb, x::arb)\n\nReturn the lower incomplete gamma function gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"gamma_lower_regularized(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#gamma_lower_regularized-Tuple{arb, arb}","page":"Real balls","title":"gamma_lower_regularized","text":"gamma_lower_regularized(s::arb, x::arb)\n\nReturn the regularized lower incomplete gamma function gamma(sx)  Gamma(s).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"zeta(::arb)","category":"page"},{"location":"Nemo/arb/#zeta-Tuple{arb}","page":"Real balls","title":"zeta","text":"zeta(x::arb)\n\nReturn the Riemann zeta function evaluated at x.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"atan2(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#atan2-Tuple{arb, arb}","page":"Real balls","title":"atan2","text":"atan2(y::arb, x::arb)\n\nReturn operatornameatan2(yx) = arg(x+yi). Same as atan(y, x).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"agm(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#agm-Tuple{arb, arb}","page":"Real balls","title":"agm","text":"agm(x::arb, y::arb)\n\nReturn the arithmetic-geometric mean of x and y\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"zeta(::arb, ::arb)","category":"page"},{"location":"Nemo/arb/#zeta-Tuple{arb, arb}","page":"Real balls","title":"zeta","text":"zeta(s::arb, a::arb)\n\nReturn the Hurwitz zeta function zeta(sa).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"root(::arb, ::Int)","category":"page"},{"location":"Nemo/arb/#root-Tuple{arb, Int64}","page":"Real balls","title":"root","text":"root(x::arb, n::Int)\n\nReturn the n-th root of x. We require x geq 0.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"factorial(::arb)","category":"page"},{"location":"Nemo/arb/#factorial-Tuple{arb}","page":"Real balls","title":"factorial","text":"factorial(x::arb)\n\nReturn the factorial of x.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"factorial(::Int, ::ArbField)","category":"page"},{"location":"Nemo/arb/#factorial-Tuple{Int64, ArbField}","page":"Real balls","title":"factorial","text":"factorial(n::Int, r::ArbField)\n\nReturn the factorial of n in the given Arb field.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"binomial(::arb, ::UInt)","category":"page"},{"location":"Nemo/arb/#binomial-Tuple{arb, UInt64}","page":"Real balls","title":"binomial","text":"binomial(x::arb, n::UInt)\n\nReturn the binomial coefficient x choose n.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"binomial(::UInt, ::UInt, ::ArbField)","category":"page"},{"location":"Nemo/arb/#binomial-Tuple{UInt64, UInt64, ArbField}","page":"Real balls","title":"binomial","text":"binomial(n::UInt, k::UInt, r::ArbField)\n\nReturn the binomial coefficient n choose k in the given Arb field.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"fibonacci(::fmpz, ::ArbField)","category":"page"},{"location":"Nemo/arb/#fibonacci-Tuple{fmpz, ArbField}","page":"Real balls","title":"fibonacci","text":"fibonacci(n::fmpz, r::ArbField)\n\nReturn the n-th Fibonacci number in the given Arb field.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"fibonacci(::Int, ::ArbField)","category":"page"},{"location":"Nemo/arb/#fibonacci-Tuple{Int64, ArbField}","page":"Real balls","title":"fibonacci","text":"fibonacci(n::Int, r::ArbField)\n\nReturn the n-th Fibonacci number in the given Arb field.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"gamma(::fmpz, ::ArbField)","category":"page"},{"location":"Nemo/arb/#gamma-Tuple{fmpz, ArbField}","page":"Real balls","title":"gamma","text":"gamma(x::fmpz, r::ArbField)\n\nReturn the Gamma function evaluated at x in the given Arb field.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"gamma(::fmpq, ::ArbField)","category":"page"},{"location":"Nemo/arb/#gamma-Tuple{fmpq, ArbField}","page":"Real balls","title":"gamma","text":"gamma(x::fmpq, r::ArbField)\n\nReturn the Gamma function evaluated at x in the given Arb field.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"zeta(::Int, ::ArbField)","category":"page"},{"location":"Nemo/arb/#zeta-Tuple{Int64, ArbField}","page":"Real balls","title":"zeta","text":"zeta(n::Int, r::ArbField)\n\nReturn the Riemann zeta function zeta(n) as an element of the given Arb field.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"bernoulli(::Int, ::ArbField)","category":"page"},{"location":"Nemo/arb/#bernoulli-Tuple{Int64, ArbField}","page":"Real balls","title":"bernoulli","text":"bernoulli(n::Int, r::ArbField)\n\nReturn the n-th Bernoulli number as an element of the given Arb field.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"rising_factorial(::arb, ::Int)","category":"page"},{"location":"Nemo/arb/#rising_factorial-Tuple{arb, Int64}","page":"Real balls","title":"rising_factorial","text":"rising_factorial(x::arb, n::Int)\n\nReturn the rising factorial x(x + 1)ldots (x + n - 1) as an Arb.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"rising_factorial(::fmpq, ::Int, ::ArbField)","category":"page"},{"location":"Nemo/arb/#rising_factorial-Tuple{fmpq, Int64, ArbField}","page":"Real balls","title":"rising_factorial","text":"rising_factorial(x::fmpq, n::Int, r::ArbField)\n\nReturn the rising factorial x(x + 1)ldots (x + n - 1) as an element of the given Arb field.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"rising_factorial2(::arb, ::Int)","category":"page"},{"location":"Nemo/arb/#rising_factorial2-Tuple{arb, Int64}","page":"Real balls","title":"rising_factorial2","text":"rising_factorial2(x::arb, n::Int)\n\nReturn a tuple containing the rising factorial x(x + 1)ldots (x + n - 1) and its derivative.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"polylog(::Union{arb,Int}, ::arb)","category":"page"},{"location":"Nemo/arb/#polylog-Tuple{Union{Int64, arb}, arb}","page":"Real balls","title":"polylog","text":"polylog(s::Union{arb,Int}, a::arb)\n\nReturn the polylogarithm Li_s(a).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"chebyshev_t(::Int, ::arb)","category":"page"},{"location":"Nemo/arb/#chebyshev_t-Tuple{Int64, arb}","page":"Real balls","title":"chebyshev_t","text":"chebyshev_t(n::Int, x::arb)\n\nReturn the value of the Chebyshev polynomial T_n(x).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"chebyshev_u(::Int, ::arb)","category":"page"},{"location":"Nemo/arb/#chebyshev_u-Tuple{Int64, arb}","page":"Real balls","title":"chebyshev_u","text":"chebyshev_u(n::Int, x::arb)\n\nReturn the value of the Chebyshev polynomial U_n(x).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"chebyshev_t2(::Int, ::arb)","category":"page"},{"location":"Nemo/arb/#chebyshev_t2-Tuple{Int64, arb}","page":"Real balls","title":"chebyshev_t2","text":"chebyshev_t2(n::Int, x::arb)\n\nReturn the tuple (T_n(x) T_n-1(x)).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"chebyshev_u2(::Int, ::arb)","category":"page"},{"location":"Nemo/arb/#chebyshev_u2-Tuple{Int64, arb}","page":"Real balls","title":"chebyshev_u2","text":"chebyshev_u2(n::Int, x::arb)\n\nReturn the tuple (U_n(x) U_n-1(x))\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"bell(::fmpz, ::ArbField)","category":"page"},{"location":"Nemo/arb/#bell-Tuple{fmpz, ArbField}","page":"Real balls","title":"bell","text":"bell(n::fmpz, r::ArbField)\n\nReturn the Bell number B_n as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"bell(::Int, ::ArbField)","category":"page"},{"location":"Nemo/arb/#bell-Tuple{Int64, ArbField}","page":"Real balls","title":"bell","text":"bell(n::Int, r::ArbField)\n\nReturn the Bell number B_n as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"numpart(::fmpz, ::ArbField)","category":"page"},{"location":"Nemo/arb/#numpart-Tuple{fmpz, ArbField}","page":"Real balls","title":"numpart","text":"numpart(n::fmpz, r::ArbField)\n\nReturn the number of partitions p(n) as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"numpart(::Int, ::ArbField)","category":"page"},{"location":"Nemo/arb/#numpart-Tuple{Int64, ArbField}","page":"Real balls","title":"numpart","text":"numpart(n::Int, r::ArbField)\n\nReturn the number of partitions p(n) as an element of r.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"airy_ai(::arb)","category":"page"},{"location":"Nemo/arb/#airy_ai-Tuple{arb}","page":"Real balls","title":"airy_ai","text":"airy_ai(x::arb)\n\nReturn the Airy function operatornameAi(x).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"airy_ai_prime(::arb)","category":"page"},{"location":"Nemo/arb/#airy_ai_prime-Tuple{arb}","page":"Real balls","title":"airy_ai_prime","text":"airy_ai_prime(x::arb)\n\nReturn the derivative of the Airy function operatornameAi^prime(x).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"airy_bi(::arb)","category":"page"},{"location":"Nemo/arb/#airy_bi-Tuple{arb}","page":"Real balls","title":"airy_bi","text":"airy_bi(x::arb)\n\nReturn the Airy function operatornameBi(x).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"airy_bi_prime(::arb)","category":"page"},{"location":"Nemo/arb/#airy_bi_prime-Tuple{arb}","page":"Real balls","title":"airy_bi_prime","text":"airy_bi_prime(x::arb)\n\nReturn the derivative of the Airy function operatornameBi^prime(x).\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\n\na = floor(exp(RR(1)))\nb = sinpi(QQ(5,6), RR)\nc = gamma(QQ(1,3), RealField(256))\nd = bernoulli(1000, RealField(53))\nf = polylog(3, RR(-10))","category":"page"},{"location":"Nemo/arb/#Linear-dependence","page":"Real balls","title":"Linear dependence","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"lindep(::Vector{arb}, n::Int)","category":"page"},{"location":"Nemo/arb/#lindep-Tuple{Vector{arb}, Int64}","page":"Real balls","title":"lindep","text":"lindep(A::Vector{arb}, bits::Int)\n\nFind a small linear combination of the entries of the array A that is small (using LLL). The entries are first scaled by the given number of bits before truncating to integers for use in LLL. This function can be used to find linear dependence between a list of real numbers. The algorithm is heuristic only and returns an array of Nemo integers representing the linear combination.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(128)\n\na = RR(-0.33198902958450931620250069492231652319)\n\nV = [RR(1), a, a^2, a^3, a^4, a^5]\nW = lindep(V, 20)","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"simplest_rational_inside(::arb)","category":"page"},{"location":"Nemo/arb/#simplest_rational_inside-Tuple{arb}","page":"Real balls","title":"simplest_rational_inside","text":"  simplest_rational_inside(x::arb)\n\nReturn the simplest fraction inside the ball x. A canonical fraction a_1b_1 is defined to be simpler than a_2b_2 iff b_1  b_2 or b_1 = b_2 and a_1  a_2.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(64)\nsimplest_rational_inside(const_pi(RR))","category":"page"},{"location":"Nemo/arb/#Random-generation","page":"Real balls","title":"Random generation","text":"","category":"section"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"rand(::ArbField)","category":"page"},{"location":"Nemo/arb/#rand-Tuple{ArbField}","page":"Real balls","title":"rand","text":"rand(r::ArbField; randtype::Symbol=:urandom)\n\nReturn a random element in given Arb field.\n\nThe randtype default is :urandom which return an arb contained in 01.\n\nThe rest of the methods return non-uniformly distributed values in order to exercise corner cases. The option :randtest will return a finite number, and :randtest_exact the same but with a zero radius. The option :randtest_precise return an arb with a radius around 2^-mathrmprec the magnitude of the midpoint, while :randtest_wide return a radius that might be big relative to its midpoint. The :randtest_special-option might return a midpoint and radius whose values are NaN or inf.\n\n\n\n","category":"method"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"Examples","category":"page"},{"location":"Nemo/arb/","page":"Real balls","title":"Real balls","text":"RR = RealField(100)\n\na = rand(RR)\nb = rand(RR; randtype = :null_exact)\nc = rand(RR; randtype = :exact)\nd = rand(RR; randtype = :special)","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"CurrentModule = Oscar","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"using Oscar","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Pages = [\"para_rational_curves.md\"]","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/#Rational-Parametrizations-of-Rational-Plane-Curves","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"","category":"section"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"note: Note\nIn this section, C will denote a complex projective plane curve, defined by an absolutely irreducible, homogeneous polynomial in three variables, with coeffients in mathbb Q. Moreover, we will write n = deg C.","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Recall that the curve C is rational if it is birationally equivalent to the projective line mathbb P^1(mathbb C). In other words, there exists a rational parametrization of C, that is, a birational map mathbb P^1(mathbb C)dashrightarrow C. Note that such a parametrization is given by three homogeneous polynomials of the same degree in the homogeneous coordinates on mathbb P^1(mathbb C).","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"note: Note\nThe curve C is rational iff its geometric genus is zero.","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Based on work of Max Noether on adjoint curves, Hilbert und Hurwitz showed that if C is rational, then there is a birational map C dashrightarrow D defined over mathbb Q such that D = mathbb P^1(mathbb C) if n is odd, and Dsubsetmathbb P^2(mathbb C) is a conic if n is even.","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"note: Note\nIf a conic D contains a rational point, then there exists a parametrization of D defined over mathbb Q; otherwise, there exists a parametrization of D defined over a quadratic field extension of mathbb Q.","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"The approach of Hilbert und Hurwitz is constructive and allows one, in principle, to find rational parametrizations. The resulting algorithm is not very practical, however, as the approach asks to compute adjoint curves repeatedly, at each of a number of reduction steps.","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"The algorithm implemented in OSCAR relies on reduction steps of a different type and requires the computation of adjoint curves only once. Its individual steps are interesting in their own right:","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"Assure that the curve  C is rational by checking that its geometric genus is zero;\ncompute a basis of the adjoint curves of C of degree n-2; each such basis defines a birational map C dashrightarrow C_n-2  where C_n-2 is a rational normal curve in mathbb P^n-2(mathbb C);\nthe anticanonical linear system on C_n-2 defines a birational map C_n-2dashrightarrow C_n-4, where C_n-4 is a rational normal curve in in mathbb P^n-4(mathbb C);\niterate the previous step to obtain a birational map  C_n-2 dashrightarrow dots dashrightarrow D,  where D = mathbb P^1(mathbb C) if n is odd, and Dsubsetmathbb P^2(mathbb C) is a conic if n is even;\ninvert the birational map  C dashrightarrow C_n-2 dashrightarrow dots dashrightarrow D; \nif n is even, compute a parametrization of the conic D and compose it with the inverted map above.","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"note: Note\nThe defining property of an adjoint curve is that it passes with “sufficiently high” multiplicity through the singularities of C. There are several concepts of making this precise. For each such concept, there is a corresponding  adjoint ideal of C, namely the homogeneous ideal formed by the defining polynomials of the adjoint curves. In OSCAR, we follow the concept of Gorenstein which leads to the largest possible adjoint ideal.","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"See Janko Böhm (1999) and Janko Böhm, Wolfram Decker, Santiago Laplagne, Gerhard Pfister (2017) for details and further references.","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/#Creating-Projective-Plane-Curves","page":"Rational Parametrizations of Rational Plane Curves","title":"Creating Projective Plane Curves","text":"","category":"section"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"The data structures for algebraic curves in OSCAR are still under development and subject to change. Here is the current constructor for projective plane curves:","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"ProjPlaneCurve(f::MPolyElem{T}) where {T <: FieldElem}","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/#ProjPlaneCurve-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:FieldElem","page":"Rational Parametrizations of Rational Plane Curves","title":"ProjPlaneCurve","text":"ProjPlaneCurve(f::MPolyElem{T}) where {T <: FieldElem}\n\nGiven a homogeneous polynomial f in three variables with coefficients in a field, create the projective plane curve defined by f.\n\nExamples\n\njulia> R, (x,y,z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by \n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> C = ProjPlaneCurve(z*x^2-y^3)\nProjective plane curve defined by x^2*z - y^3\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/para_rational_curves/#The-Genus-of-a-Plane-Curve","page":"Rational Parametrizations of Rational Plane Curves","title":"The Genus of a Plane Curve","text":"","category":"section"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":" geometric_genus(C::ProjectivePlaneCurve{T}) where T <: FieldElem","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/#geometric_genus-Union{Tuple{ProjectivePlaneCurve{T}}, Tuple{T}} where T<:FieldElem","page":"Rational Parametrizations of Rational Plane Curves","title":"geometric_genus","text":"geometric_genus(C::ProjectivePlaneCurve{T}) where T <: FieldElem\n\nReturn the geometric genus of C.\n\nExamples\n\njulia> R, (x,y,z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> C = ProjPlaneCurve(z*x^2-y^3)\nProjective plane curve defined by x^2*z - y^3\n\njulia> geometric_genus(C)\n0\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/para_rational_curves/#Adjoint-Ideals-of-Plane-Curves","page":"Rational Parametrizations of Rational Plane Curves","title":"Adjoint Ideals of Plane Curves","text":"","category":"section"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"adjoint_ideal(C::ProjPlaneCurve{fmpq})","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/#adjoint_ideal-Tuple{ProjPlaneCurve{fmpq}}","page":"Rational Parametrizations of Rational Plane Curves","title":"adjoint_ideal","text":"adjoint_ideal(C::ProjPlaneCurve{fmpq})\n\nReturn the Gorenstein adjoint ideal of C. \n\nExamples\n\njulia> R, (x,y,z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> C = ProjPlaneCurve(y^4-2*x^3*z+3*x^2*z^2-2*y^2*z^2)\nProjective plane curve defined by -2*x^3*z + 3*x^2*z^2 + y^4 - 2*y^2*z^2\n\njulia> I = adjoint_ideal(C)\nideal(-x*z + y^2, x*y - y*z, x^2 - x*z)\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/para_rational_curves/#Rational-Points-on-Conics","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Points on Conics","text":"","category":"section"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":"rational_point_conic(D::ProjPlaneCurve{fmpq})","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/#rational_point_conic-Tuple{ProjPlaneCurve{fmpq}}","page":"Rational Parametrizations of Rational Plane Curves","title":"rational_point_conic","text":"rational_point_conic(D::ProjPlaneCurve{fmpq})\n\nIf the conic D contains a rational point, return the homogeneous coordinates of such a point. If no such point exists, return a point on D defined over a quadratic field extension of mathbb Q.\n\nExamples\n\njulia> R, (x,y,z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> D = ProjPlaneCurve(x^2 + 2*y^2 + 5*z^2 - 4*x*y + 3*x*z + 17*y*z);\n\njulia> P = rational_point_conic(D)\n3-element Vector{AbstractAlgebra.Generic.MPoly{nf_elem}}:\n -1//4*a\n -1//4*a + 1//4\n 0\n\njulia> S = parent(P[1])\nMultivariate Polynomial Ring in x, y, z over Number field over Rational Field with defining polynomial t^2 - 2\n\njulia> NF = base_ring(S)\nNumber field over Rational Field with defining polynomial t^2 - 2\n\njulia> a = gen(NF)\na\n\njulia> minpoly(a)\nt^2 - 2\n\n\n\n","category":"method"},{"location":"AlgebraicGeometry/para_rational_curves/#Parametrizing-Rational-Plane-Curves","page":"Rational Parametrizations of Rational Plane Curves","title":"Parametrizing Rational Plane Curves","text":"","category":"section"},{"location":"AlgebraicGeometry/para_rational_curves/","page":"Rational Parametrizations of Rational Plane Curves","title":"Rational Parametrizations of Rational Plane Curves","text":" parametrization_plane_curve(C::ProjPlaneCurve{fmpq})","category":"page"},{"location":"AlgebraicGeometry/para_rational_curves/#parametrization_plane_curve-Tuple{ProjPlaneCurve{fmpq}}","page":"Rational Parametrizations of Rational Plane Curves","title":"parametrization_plane_curve","text":"parametrization_plane_curve(C::ProjPlaneCurve{fmpq})\n\nReturn a rational parametrization of  C. \n\nExamples\n\njulia> R, (x,y,z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> C = ProjPlaneCurve(y^4-2*x^3*z+3*x^2*z^2-2*y^2*z^2)\nProjective plane curve defined by -2*x^3*z + 3*x^2*z^2 + y^4 - 2*y^2*z^2\n\njulia> parametrization_plane_curve(C)\n3-element Vector{fmpq_mpoly}:\n 12*s^4 - 8*s^2*t^2 + t^4\n -12*s^3*t + 2*s*t^3\n 8*s^4\n\n\n\n","category":"method"},{"location":"Nemo/factor/","page":"Factorisation","title":"Factorisation","text":"CurrentModule = Nemo\nDocTestSetup = quote\n  using Nemo\nend","category":"page"},{"location":"Nemo/factor/#Factorisation","page":"Factorisation","title":"Factorisation","text":"","category":"section"},{"location":"Nemo/factor/","page":"Factorisation","title":"Factorisation","text":"Nemo provides a unified interface to handle factorisations using the Fact objects. These can only be constructed using the factor function for the respective ring elements. This is best illustrated by an example.","category":"page"},{"location":"Nemo/factor/","page":"Factorisation","title":"Factorisation","text":"julia> fac = factor(ZZ(-6000361807272228723606))\n-1 * 2 * 229^3 * 43669^3 * 3\n\njulia> unit(fac)\n-1\n\njulia> -6000361807272228723606 == unit(fac) * prod([ p^e for (p, e) in fac])\ntrue\n\njulia> for (p, e) in fac; println(\"$p $e\"); end\n2 1\n229 3\n43669 3\n3 1\n\njulia> 229 in fac\ntrue\n\njulia> fac[229]\n3","category":"page"},{"location":"Nemo/factor/#Basic-functionality","page":"Factorisation","title":"Basic functionality","text":"","category":"section"},{"location":"Nemo/factor/","page":"Factorisation","title":"Factorisation","text":"Objects of type Fac are iterable, that is, if a is an object of type Fac, then for (p, e) in a will iterate through all pairs (p, e), where p is a factor and e the corresponding exponent.","category":"page"},{"location":"Nemo/factor/","page":"Factorisation","title":"Factorisation","text":"in(::fmpz, ::Fac{fmpz})\ngetindex(::Fac{fmpz}, ::fmpz)\nlength(::Fac{fmpz})\nunit(::Fac{fmpz})","category":"page"},{"location":"Nemo/factor/#in-Tuple{fmpz, Fac{fmpz}}","page":"Factorisation","title":"in","text":"in(a, b::Fac)\n\nTest whether a is a factor of b.\n\n\n\n","category":"method"},{"location":"Nemo/factor/#getindex-Tuple{Fac{fmpz}, fmpz}","page":"Factorisation","title":"getindex","text":"getindex(a::Fac, b) -> Int\n\nIf b is a factor of a, the corresponding exponent is returned. Otherwise an error is thrown.\n\n\n\n","category":"method"},{"location":"Nemo/factor/#length-Tuple{Fac{fmpz}}","page":"Factorisation","title":"length","text":"length(a::Fac) -> Int\n\nReturn the number of factors of a, not including the unit.\n\n\n\n","category":"method"},{"location":"Nemo/factor/#unit-Tuple{Fac{fmpz}}","page":"Factorisation","title":"unit","text":"unit(a::Fac{T}) -> T\n\nReturn the unit of the factorization.\n\n\n\n","category":"method"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/developer/introduction/#Introduction-to-Nemo-development","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"","category":"section"},{"location":"Nemo/developer/introduction/#Relationship-to-AbstractAlgebra.jl","page":"Introduction to Nemo development","title":"Relationship to AbstractAlgebra.jl","text":"","category":"section"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Some time in the past, Nemo was split into two packages called Nemo.jl and AbstractAlgebra.jl. The purpose was to provide a Julia only package which did some subset of what Nemo could do, albeit slower. This was requested by people in the Julia community.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Unfortunately this hasn't been terribly successful. Most Julia developers expect that AbstractAlgebra and Nemo functionality will work for Julia matrices over AbstractAlgebra/Nemo rings. This would be possible for functions that do not conflict with Base or LinearAlgebra at least when working with non-empty matrices. However, for reasons that we explain in both the Appendix to the AbstractAlgebra package and in the parent object section of the developer documentation, this is not possible even in theory for functions that would conflict with Julia's standard library or for empty matrices (except in a limited number of special cases).","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Unfortunately the Julia standard library functions do not work with matrices of Nemo objects and there is little we can do about this. Moreover, some Julia functionality isn't supported by the underlying C libraries in Nemo and would be difficult or impossible to provide on the C side.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Nowadays we see AbstractAlgebra to provide three things to Nemo:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"An abstract type hierarchy\nGeneric ring constructions, e.g. generic polynomials and matrices\nGeneric implementations that should work for any ring implementing the required interfaces. These interfaces are documented in the AbstractAlgebra documentation.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Nemo itself is now more or less just a wrapper of four C libraries:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Flint : polynomials and matrices over Z, Q, Z/nZ, Qp, Fq\nArb : polynomials, matrices and special functions over balls over R and C\nAntic : algebraic number field element arithmetic\nCalcium : exact real and complex numbers, including algebraic numbers","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Each ring implemented in those C libraries is wrapped in such a way as to implement the interfaces described by AbstractAlgebra.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Most of the time an AbstractAlgebra implementation will work just as well using Nemo, but the latter will usually be faster, due to the extremely performant C code (around half a million lines of it).","category":"page"},{"location":"Nemo/developer/introduction/#Layout-of-files","page":"Introduction to Nemo development","title":"Layout of files","text":"","category":"section"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the src directory of Nemo are four directories flint, arb, antic and calcium, each containing the wrappers for the relevant C libraries. The test directory is similarly organised.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Within each of these directories is a set of files, one per module within the C libraries, e.g. the fmpz.jl file wraps the Flint fmpz module for multiple precision integers. The fmpz_poly.jl file wraps the Flint univariate polynomials over fmpz integers, and so on.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The fmpq prefix is for Flint rationals, fq for Flint finite fields with multiprecision characteristic, fq_nmod is the same but for single word characteristic. The padic prefix is for the field of p-adic numbers for a given p. The nmod prefix is for Z/nZ for a given n. The gfp prefix is the same as Z/nZ but where n is prime, so that we are dealing with a field.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The FlintTypes.jl file contains the implementation of all the Flint types.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the antic directory, nf_elem is for elements of a number field.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The AnticTypes.jl file contains the Antic types.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the arb directory the arb prefix is for arbitrary precision ball arithmetic over the reals. The acb prefix is similar but for complex numbers.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The ArbTypes.jl file contains the Arb types.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the calcium directory the ca prefix is for Calcium's type. There is also a qqbar file for the field of algebraic numbers.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the AbstractAlgebra.jl package the src directory contains a directory called generic. This is where the implementations of generic types, such as matrices, polynomials, series, etc. reside. Each file such as Matrix.jl corresponds to a generic group/ring/field or other algebraic construction (typically over a base ring). The files in this directory exist inside a submodule of AbstractAlgebra called Generic.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The file GenericTypes.jl is where all the generic types are implemented.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"At the top level of the src directory is a file Generic.jl which is where the Generic submodule of AbstractAlgebra begins and where imports are made from AbstractAlgebra into Generic.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the src directory we have implementations that work for every type belonging to a given abstract type, e.g. Matrix.jl has implementations that will work for any matrix type, whether from AbstractAlgebra's Generic module or even matrix types from Nemo, and so on. So long as they are implemented to provide the Matrix interface all the functions there will work for them. The same applies for Poly.jl for polynomial types, AbsSeries.jl for absolute series types, RelSeries.jl for relative series types, etc.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"In the src directory is AbstractTypes.jl where all the AbstractAlgebra abstract types are defined.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Also in the src directory is a subdirectory called Julia. This is where we give our own implementations of functionality for Julia Integers and Rationals and various other basic rings implemented in terms of Julia types. These are provided so that the package will work as a pure Julia package, replacing many of the rings and fields that would be available in Flint and the other C libraries with Julia equivalents.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Note that some of the implementations we give there would conflict with Base and so are only available inside AbstractAlgebra and are not exported!","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"We try to keep the test directory at the top level of the source tree organised in the same manner as the other directories just discussed, though there is currently no split between tests for Generic and for the implementations in src. All tests are currently combined in test/generic..","category":"page"},{"location":"Nemo/developer/introduction/#Git,-GitHub-and-project-workflows","page":"Introduction to Nemo development","title":"Git, GitHub and project workflows","text":"","category":"section"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The official repositories for AbstractAlgebra and Nemo are:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://github.com/Nemocas/AbstractAlgebra.jl","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://github.com/Nemocas/Nemo.jl","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"If you wish to contribute to these projects, the first step is to fork them on GitHub. The button for this is in the upper right of the main project page. You will need to sign up for a free GitHub account to do this.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Once you have your own GitHub copy of our repository you can push changes to it from your local machine and this will make them visible to the world.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Before sinking a huge amount of time into a contribution, please open a ticket on the official project page on GitHub explaining what you intend to do and discussing it with the other developers.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The easiest way to get going with development on your local machine is to dev AbstractAlgebra and/or Nemo. To do this, press the ] key in Julia to enter the special package mode and type:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"dev Nemo","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Now you will find a local copy on your machine of the Nemo repository in","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":".julia/dev/Nemo","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"However, this will be set up to push to the official repository instead of your own, so you will need to change this. For example, if your GitHub account name is myname, edit the .git/config file in your local Nemo directory to say:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"        url = https://github.com/Nemocas/Nemo.jl.git\n        pushurl = https://github.com/myname/Nemo.jl","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"instead of just the first line which will already be there.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"It is highly recommended that you do not work in the master branch, but create a new branch for each thing you want to contribute to Nemo.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"git checkout -b mynewbranch","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"If your contribution is small and does not take a long time to implement, everything will likely be fine if you simply commit the changes locally, then push them to your GitHub account online:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"git commit -a\ngit push --all","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"However, if you are working on a much larger project it is highly recommended that you frequently pull from the official master branch and rebase your new branch on top of any changes that have been made there:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"git checkout master\ngit pull\ngit checkout mynewbranch\ngit rebase master","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Note that rebasing will try to rewrite each of your commits over the top of the branch you are rebasing on (master in this case). This process will have many steps if there are many commits and lots of conflicts. Simply follow the instructions until the process is finished.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"The longer you leave it before rebasing on master the longer the rebase process will take. It can eventually become overwhelming as it is not replaying the latest state of your repository over master, but each commit that you made in order. You may have completely forgotten what those older commits were about, so this can become very difficult if not done regularly.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Once you have pushed your changes to your GitHub account, go to the official project GitHub page and you should see your branch mentioned near the top of the page. Open a pull request.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Someone will review your code and suggest changes they'd like made. Simply add more commits to your branch and push again. They will automatically get added to your pull request.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Note that we don't accept code without tests and documentation. We use Documenter.jl for our documentation, in Markdown format. See our existing code for examples of docstrings above functions in the source code and look in the docs/src directory to see how these docstrings are merged into our online documentation.","category":"page"},{"location":"Nemo/developer/introduction/#Development-list","page":"Introduction to Nemo development","title":"Development list","text":"","category":"section"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"All developers of AbstractAlgebra and Nemo are welcome to write to our development list to ask questions and discuss development:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://groups.google.com/g/nemo-devel","category":"page"},{"location":"Nemo/developer/introduction/#Reporting-bugs","page":"Introduction to Nemo development","title":"Reporting bugs","text":"","category":"section"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Bugs should be reported by opening an issue (ticket) on the official GitHub page for the relevant project. Please state the Julia version being used, the machine you are using and the version of AbstractAlgebra/Nemo you are using. The version can be found in the Project.toml file at the top level of the source tree.","category":"page"},{"location":"Nemo/developer/introduction/#Development-roadmap","page":"Introduction to Nemo development","title":"Development roadmap","text":"","category":"section"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"AbstractAlgebra has a special roadmap ticket which lists the most important tickets that have been opened. If you want to contribute something high value this is the place to start:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://github.com/Nemocas/AbstractAlgebra.jl/issues/492","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"This ticket is updated every so often.","category":"page"},{"location":"Nemo/developer/introduction/#Binaries","page":"Introduction to Nemo development","title":"Binaries","text":"","category":"section"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Binaries of C libraries for Nemo are currently made in a separate repository:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://github.com/JuliaPackaging/Yggdrasil","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"If code is added to any of the C libraries used by Nemo, this jll package must be updated first and the version updated in Nemo.jl before the new functionality can be used. Ask the core developers for help with this as various other tasks must be completed at the same time.","category":"page"},{"location":"Nemo/developer/introduction/#Relationship-to-Oscar","page":"Introduction to Nemo development","title":"Relationship to Oscar","text":"","category":"section"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Nemo and AbstractAlgebra are heavily used by the Oscar computer algebra system being developed in Germany by a number of universities involved in a large project known as TRR 195, funded by the DFG.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"Oscar is the number one customer for Nemo. Many bugs in Nemo are found and fixed by Oscar developers and most of the key Nemo developers are part of the Oscar project.","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"See the Oscar website for further details:","category":"page"},{"location":"Nemo/developer/introduction/","page":"Introduction to Nemo development","title":"Introduction to Nemo development","text":"https://oscar.computeralgebra.de/","category":"page"},{"location":"Hecke/abelian/maps/","page":"-","title":"-","text":"Maps between abelian groups are mainly of type GrpAbFinGenMap. They allow normal map operations such as image, preimage, domain, codomain and can be created in a variety of situations.","category":"page"},{"location":"Hecke/abelian/maps/#Maps","page":"-","title":"Maps","text":"","category":"section"},{"location":"Hecke/abelian/maps/","page":"-","title":"-","text":"Maps between abelian groups can be constructed via","category":"page"},{"location":"Hecke/abelian/maps/","page":"-","title":"-","text":"images of the generators\npairs of elements\nvia composition\nand isomorphism/ inclusion testing","category":"page"},{"location":"Hecke/abelian/maps/","page":"-","title":"-","text":"hom(G::GrpAbFinGen, H::GrpAbFinGen, A::Matrix{ <: Map{GrpAbFinGen, GrpAbFinGen}})\nisisomorphic(G::GrpAbFinGen, H::GrpAbFinGen)","category":"page"},{"location":"Hecke/abelian/maps/#hom-Tuple{GrpAbFinGen, GrpAbFinGen, Matrix{var\"#s271\"} where var\"#s271\"<:(Map{GrpAbFinGen, GrpAbFinGen, S, T} where {S, T})}","page":"-","title":"hom","text":"hom(G::GrpAbFinGen, H::GrpAbFinGen, A::Matrix{ <: Map{GrpAbFinGen, GrpAbFinGen}}) -> Map\n\nGiven groups G and H that are created as direct products as well as a matrix A containing maps Aij  G_i to H_j, return the induced homomorphism.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/maps/#isisomorphic-Tuple{GrpAbFinGen, GrpAbFinGen}","page":"-","title":"isisomorphic","text":"isisomorphic(G::GrpAbFinGen, H::GrpAbFinGen) -> Bool\n\nChecks if G and H are isomorphic.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/maps/","page":"-","title":"-","text":"using Hecke # hide\nG = free_abelian_group(2)\nh = hom(G, G, [gen(G, 2), 3*gen(G, 1)])\nh(gen(G, 1))\nh(gen(G, 2))","category":"page"},{"location":"Hecke/abelian/maps/","page":"-","title":"-","text":"Homomorphisms also allow addition and subtraction corresponding to the pointwise operation:","category":"page"},{"location":"Hecke/abelian/maps/","page":"-","title":"-","text":"using Hecke # hide\nG = free_abelian_group(2)\nh = hom(G, G, [2*gen(G, 2), 3*gen(G, 1)])\n(h+h)(gen(G, 1))","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/developer/typesystem/#The-type-system","page":"The type system","title":"The type system","text":"","category":"section"},{"location":"Nemo/developer/typesystem/#Use-of-Julia-types-in-Nemo","page":"The type system","title":"Use of Julia types in Nemo","text":"","category":"section"},{"location":"Nemo/developer/typesystem/#Concrete-and-abstract-types","page":"The type system","title":"Concrete and abstract types","text":"","category":"section"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Julia does not provide a traditional class/inheritance approach to programming. Instead, the basic unit of its object oriented approach is the type definition (struct and mutable struct) and inheritance exists only on the function side of the language rather than data side. Julia provides a rich system of abstract types and unions on the data side and multimethods on the function side to effect this.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"For example Julia's Number type is an abstract type containing all concrete types that behave like numbers, e.g. Int64, Float64, and so on.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Abstract types can also belong to other abstract types, forming a tree of abstract types.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"In Nemo the most important abstract types are Ring and Field, with the latter belonging to the former so that all fields are rings, and the abstract types RingElem and FieldElem for the objects that represent elements of rings and fields, again with the latter abstract type belonging to the former.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Because this hierarchy of abstract types must form a tree, Julia is strictly speaking single inheritance, as each concrete and abstract type can belong to at most one other abstract type. For example, one could not have a diamond of abstract types with ExactField belonging to both Field and ExactRing.","category":"page"},{"location":"Nemo/developer/typesystem/#Recovering-aspects-of-multiple-inheritance-in-Nemo","page":"The type system","title":"Recovering aspects of multiple inheritance in Nemo","text":"","category":"section"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Various possibilities exist to get around the limitation that abstract types must form a 'tree' in Nemo and AbstractAlgebra.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"One such possibility is union types. If a function should accept one of a number of concrete or abstract types that can't all be made to belong to a single abstract type due to this limitation then one can use a union type.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"For example, Nemo defines RingElement to be a union of RingElem and all the Julia standard types which behave like ring elements, e.g. all Integer types and types of rationals with Integer components.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Other union types are defined in src/AbstractAlgebra.jl in AbstractAlgebra.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"A second feature we make use of in Nemo is parameterised types. Each concrete and abstract type can take one or more parameters. These parameter can be any other type, either concrete or abstract. For example, in Julia Rational{T} is for rationals with numerator and denominator of type T.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"A great deal of control over parameterised types is possible, e.g. one can restrict the type parameter T using a where clause, e.g. to write a function that accepts all rational types with integer components of the same type one can use the type Rational{T} where T <: Integer.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Nemo makes use of such parameterised types for generic ring constructions such as generic polynomial rings and matrices over a given base ring. The type of the elements of the base ring is substituted for the parameter T in any concrete instantiation of the types Poly{T} and Mat{T}, which are defined in AbstractAlgebra in src/generic/GenericTypes.jl.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"The totality of all univariate polynomial types, including those of generic Poly{T} types and those coming from C libraries (such as fmpz_poly), is represented by the abstract type PolyElem{T} which in turn belongs to RingElem, both defined in AbstractAlgebra in src/AbstractTypes.jl.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Similarly, the totality of all matrix types, including explicit C types like fmpz_mat and the generic Mat{T} types is given by the abstract type MatElem{T}, again defined in AbstractAlgebra in src/AbstractTypes.jl.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"This hierarchy of types allows one to write functions at any level, e.g. for all univariate polynomial types, just those with a given base type T, or for a specific concrete type corresponding to just one kind of univariate polynomial.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"A third possibility to get around the single inheritance limitation of Julia is type traits. There is currently no explicit compiler/language support for traits, however various implementations exist that make use of type parameters in tricky ways. This allows one to add 'traits' to types, so long as those traits can be expressed as types. In this way, types can have multiple 'properties' at the same time, instead of belonging to just a single abstract type.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Nemo does not currently use type traits, though the map types in Nemo do make use of a custom analogue of this.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Note that unlike class based systems that dispatch on the type of a (sometimes implicit) this or self parameter, Julia methods dispatch on the type of all arguments. This is a natural fit for mathematics where all sorts of ad hoc left and right operations may be required.","category":"page"},{"location":"Nemo/developer/typesystem/#Encapsulation,-maps-and-runtime-flags","page":"The type system","title":"Encapsulation, maps and runtime flags","text":"","category":"section"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"One limitation of the Julia approach is that the type of an object cannot be changed at runtime. For example one might like to insist that a given ring is in fact a field. There are three standard ways to handle this in Julia.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"The first approach is to encapsulate the object in another object which does have the desired type. The second approach is to map the object to a different one of the required type (e.g. by applying a morphism). The third approach is to introduce data fields in the original type which can be changed at runtime, unlike its type. All three approaches come with downsides. ","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Encapsulation can be time consuming for the developer as methods which applied to the original object do not automatically apply to the encapsulated object. One can write methods which do, but this is not automatic.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Application of a map may come with a performance penalty and may be difficult for the user to navigate. Moreover, mutation of the resulting object does not result in mutation of the original object.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"The third option of adding runtime data fields essentially takes one back to writing a (possibly bug ridden) interpreter. It relies on the developer  implementing outer methods that make use of hand written control statements to determine which of a range of inner methods should be applied to the object. This misses the benefits of one of the main defining features of Julia, namely its multimethod system and can also make introspection more difficult.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Nemo does not apply any of these three approaches widely at present, though information which can only be known at runtime such as whether a ring is Euclidean will eventually have to be encoded using one of these three methods.","category":"page"},{"location":"Nemo/developer/typesystem/#Nemo's-custom-map-types","page":"The type system","title":"Nemo's custom map types","text":"","category":"section"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"It makes sense that map types in Nemo should be parameterised by the element types of both the domain and codomain of the map, and of course all maps in the system should somehow belong to an abstract type Map.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"This leads one to consider a two parameter system of types Map{D, C} where D and C are the domain and codomain types respectively.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"One may also wish to implement various types of map, e.g. linear maps (where the map contains a matrix representing the map) or functional maps (where the map is implemented by a Julia function) and so on. Notionally one imagines doing this with a hierarchy of two parameter abstract types all ultimately belonging to Map{D, C} as the root of the tree.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"This approach begins to break down when constructions from homological algebra begin to be applied to maps. In such cases, the maps themselves are the object of study and functions may be applied to maps to produce other maps.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"The simplest such function is composition. In a system where composition of maps always results in a map of the same type, no problem arises with the straightforward approach outlined above.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"However, for various reasons (including performance) it may not be desirable or even possible to construct a composition of two given maps using the same representation as the original maps. This means that the result of composing two maps of the same type may be a map of a different type, e.g. in the worst case a general composition type.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"This problem makes many homological and category theoretic operations on maps difficult or impossible to implement.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Other operations which may be desirable to implement are caching of maps (e.g. where the map is extremely time consuming to compute, such as discrete logarithms) and attaching category theoretic information to maps. Such operations can be effected by encapsulating existing maps in objects containing the extra information, e.g. a cache or a category. However all the methods that applied to the original map objects now no longer apply to the encapsulated objects.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"To work around these limitations Nemo implements a four parameter Map type, Map{D, C, T, U}.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"The first two parameters are the domain and codomain types as discussed above.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"The parameter T is a \"map class\" which is itself an abstract type existing in a hierarchy of abstract types. This parameter is best thought of as a trait, independent of the hierarchy of abstract types belonging to Map, giving additional flexibility to the map types in the system.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"For example, T may be set to LinearMap or FunctionalMap. This may be useful if one wishes to distinguish maps in other ways, e.g. whether they are homomorphisms, isomorphisms, maps with section or retraction etc. As usual, offering traits partially gets around the single inheritance problem.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"The final parameter U is used to allow maps of a given type U to be composed and still result in a map of type U, even though the concrete type of the composition is different to that of the original maps. Methods can be written for all maps of type U by matching this parameter, rather than matching on the concrete type U of the original maps.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"For example, two maps with concrete type MyRingHomomorphism would belong to Map{D, C, T, MyRingHomomorphism} as would any composition of such maps, even if the concrete type of the composition was not a MyRingHomomorphism.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Naturally four parameter types are rather unwieldy and so various helper functions are provided to compute four parameter map types. In the first instance one still has the type Map{D, C} which will give the union of all map types whose first two parameters are D and C, and where the remaining two parameters are arbitrary.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"However one can also pass a map class or a concrete type U to a Map function to compute the class of all maps of the given map class or type.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"For example, to write a function which accepts all maps of \"type\" MyRingHomomorphism, including all compositions of such maps, one inserts Map(MyRingHomomorphism) in place of the type, e.g.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"function myfun(f::Map(MyRingHomomorphism))","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Note the parentheses here, rather than curly braces; it's a function to compute a type! Now the function myfun will accept any map type whose fourth parameter U is set to MyRingHomomorphism.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"This four parameter system is flexible, but may need to be expanded in the future. For example it may be useful to have more than one trait T. This could be achieved either by making T a tuple of traits or by introducing a parameterised MapTrait type which can be placed at that location. Naturally the Map functions for computing the four parameter types will have to be similarly expanded to make it easier for the user.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"The map type system is currently considered experimental and our observation so far is that it is not intuitive for developers.","category":"page"},{"location":"Nemo/developer/typesystem/#Type-hierarchy-diagram","page":"The type system","title":"Type hierarchy diagram","text":"","category":"section"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"The most important abstract types in the system are the element types. Their hierarchy is shown in the following diagram.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"(Image: alt text)","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"Most of the element types have a corresponding parent abstract type. These are shown in the following diagram.","category":"page"},{"location":"Nemo/developer/typesystem/","page":"The type system","title":"The type system","text":"(Image: alt text)","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/rational/#Rational-field","page":"Rational field","title":"Rational field","text":"","category":"section"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/Rational.jl for making Julia Rational{BigInt}s conform to the AbstractAlgebra.jl Field interface.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"In addition to providing a parent object QQ for Julia Rational{BigInt}s, we implement any additional functionality required by AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"Because Rational{BigInt} cannot be directly included in the AbstractAlgebra.jl abstract type hierarchy, we achieve integration of Julia Rational{BigInt}s by introducing a type union, called FieldElement, which is a union of FieldElem and a number of Julia types, including Rational{BigInt}. Everywhere that FieldElem is notionally used in AbstractAlgebra.jl, we are in fact using FieldElement, with additional care being taken to avoid ambiguities.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"The details of how this is done are technical, and we refer the reader to the implementation for details. For most intents and purposes, one can think of the Julia Rational{BigInt} type as belonging to FieldElem.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"One other technicality is that Julia defines certain functions for Rational{BigInt}, such as sqrt and exp differently to what AbstractAlgebra.jl requires. To get around this, we redefine these functions internally to AbstractAlgebra.jl, without redefining them for users of AbstractAlgebra.jl. This allows the internals of AbstractAlgebra.jl to function correctly, without broadcasting pirate definitions of already defined Julia functions to the world.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"To access the internal definitions, one can use AbstractAlgebra.sqrt and AbstractAlgebra.exp, etc.","category":"page"},{"location":"AbstractAlgebra/rational/#Types-and-parent-objects","page":"Rational field","title":"Types and parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"Rationals have type Rational{BigInt}, as in Julia itself. We simply supplement the functionality for this type as required for computer algebra.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"The parent objects of such integers has type Rationals{BigInt}.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"For convenience, we also make Rational{Int} a part of the AbstractAlgebra.jl type hierarchy and its parent object (accessible as qq) has type Rationals{Int}. But we caution that this type is not particularly useful as a model of the rationals and may not function as expected within AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/rational/#Rational-constructors","page":"Rational field","title":"Rational constructors","text":"","category":"section"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"In order to construct rationals in AbstractAlgebra.jl, one can first construct the rational field itself. This is accomplished using either of the following constructors.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"FractionField(R::Integers{BigInt})","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"Rationals{BigInt}()","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"This gives the unique object of type Rationals{BigInt} representing the field of rationals in AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"In practice, one simply uses QQ which is assigned to be the return value of the above constructor. There is no need to call the constructor in practice.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"Here are some examples of creating the rational field and making use of the resulting parent object to coerce various elements into the field.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"julia> f = QQ()\n0//1\n\njulia> g = QQ(123)\n123//1\n\njulia> h = QQ(BigInt(1234))\n1234//1\n\njulia> k = QQ(BigInt(12), BigInt(7))\n12//7\n\njulia> QQ == FractionField(ZZ)\ntrue\n","category":"page"},{"location":"AbstractAlgebra/rational/#Basic-field-functionality","page":"Rational field","title":"Basic field functionality","text":"","category":"section"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"The rational field in AbstractAlgebra.jl implements the full Field and Fraction Field interfaces.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"We give some examples of such functionality.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"julia> f = QQ(12, 7)\n12//7\n\njulia> h = zero(QQ)\n0//1\n\njulia> k = one(QQ)\n1//1\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> U = base_ring(QQ)\nIntegers\n\njulia> V = base_ring(f)\nIntegers\n\njulia> T = parent(f)\nRationals\n\njulia> f == deepcopy(f)\ntrue\n\njulia> g = f + 12\n96//7\n\njulia> r = ZZ(12)//ZZ(7)\n12//7\n\njulia> n = numerator(r)\n12\n","category":"page"},{"location":"AbstractAlgebra/rational/#Rational-functionality-provided-by-AbstractAlgebra.jl","page":"Rational field","title":"Rational functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"The functionality below supplements that provided by Julia itself for its Rational{BigInt} type.","category":"page"},{"location":"AbstractAlgebra/rational/#Square-and-n-th-root","page":"Rational field","title":"Square and n-th root","text":"","category":"section"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"The functions sqrt, issquare, issquare_with_sqrt are all provided, as are root, ispower and ispower_with_root.","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"Examples","category":"page"},{"location":"AbstractAlgebra/rational/","page":"Rational field","title":"Rational field","text":"julia> d = AbstractAlgebra.sqrt(ZZ(36)//ZZ(25))\n6//5\n\njulia> issquare(ZZ(9)//ZZ(16))\ntrue\n\njulia> root(ZZ(27)//64, 3)\n3//4","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/series/#Power-series","page":"Power series","title":"Power series","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"AbstractAlgebra.jl allows the creation of capped relative and absolute power series over any computable commutative ring R.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Capped relative power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_k-1x^k-1 + O(x^k) where a_j in R and the relative precision k - j is at most equal to some specified precision n.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Capped absolute power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_n-1x^n-1 + O(x^n) where j geq 0, a_j in R and the precision n is fixed.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"There are two implementations of relative series: relative power series, implemented in src/RelSeries.jl for which j  0 in the above description, and Laurent series where j can be negative, implemented in src/Laurent.jl. Note that there are two implementations for Laurent series, one over rings and one over fields, though in practice most of the implementation uses the same code in both cases.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"There is a single implementation of absolute series: absolute power series, implemented in src/AbsSeries.jl.","category":"page"},{"location":"AbstractAlgebra/series/#Generic-power-series-types","page":"Power series","title":"Generic power series types","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"AbstractAlgebra.jl provides generic series types implemented in src/generic/AbsSeries.jl, src/generic/RelSeries.jl and src/generic/LaurentSeries.jl which implement the Series interface.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"These generic series have types Generic.RelSeries{T}, Generic.AbsSeries{T}, Generic.LaurentSeriesRingElem{T} and Generic.LaurentSeriesFieldElem{T}. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The parent objects have types Generic.AbsSeriesRing{T} and Generic.RelSeriesRing{T} and Generic.LaurentSeriesRing{T} respectively.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The default precision, string representation of the variable and base ring R of a generic power series are stored in its parent object.","category":"page"},{"location":"AbstractAlgebra/series/#Abstract-types","page":"Power series","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Relative power series elements belong to the abstract type RelSeriesElem.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Laurent series elements belong directly to either RingElem or FieldElem since it is more useful to be able to distinguish whether they belong to a ring or field than it is to distinguish that they are relative series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Absolute power series elements belong to AbsSeriesElem.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The parent types for relative and absolute power series, Generic.RelSeriesRing{T} and Generic.AbsSeriesRing{T} respectively, belong to SeriesRing{T}.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The parent types of Laurent series belong directly to Ring and Field respectively.","category":"page"},{"location":"AbstractAlgebra/series/#Series-ring-constructors","page":"Power series","title":"Series ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"In order to construct series in AbstractAlgebra.jl, one must first construct the ring itself. This is accomplished with any of the following constructors.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"PowerSeriesRing(R::Ring, prec_max::Int, s::AbstractString; cached::Bool = true, model=:capped_relative)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"LaurentSeriesRing(R::Ring, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"LaurentSeriesRing(R::Field, prec_max::Int, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Given a base ring R, a maximum precision (relative or absolute, depending on the model) and a string s specifying how the generator (variable) should be printed, return a typle S, x representing the series ring and its generator.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"By default, S will depend only on S, x and the maximum precision and will be cached. Setting the optional argument cached to false will prevent this.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"In the case of power series, the optional argument model can be set to either :capped_absolute or capped_relative, depending on which power series model is required.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"It is also possible to construct absolute and relative power series with a default variable. These are lightweight constructors and should be used in generic algorithms wherever possible when creating series rings where the symbol does not matter.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"AbsSeriesRing(R::Ring, prec::Int)\nRelSeriesRing(R::Ring, prec::Int)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the absolute or relative power series ring over the given base ring R and with precision cap given by prec. Note that a tuple is not returned, only the power series ring itself, not a generator.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Here are some examples of constructing various kinds of series rings and coercing various elements into those rings.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, x = PowerSeriesRing(ZZ, 10, \"x\")\n(Univariate power series ring in x over Integers, x + O(x^11))\n\njulia> S, y = PowerSeriesRing(ZZ, 10, \"y\"; model=:capped_absolute)\n(Univariate power series ring in y over Integers, y + O(y^10))\n\njulia> T, z = LaurentSeriesRing(ZZ, 10, \"z\")\n(Laurent series ring in z over Integers, z + O(z^11))\n\njulia> U, w = LaurentSeriesField(QQ, 10, \"w\")\n(Laurent series field in w over Rationals, w + O(w^11))\n\njulia> f = R()\nO(x^10)\n\njulia> g = S(123)\n123 + O(y^10)\n\njulia> h = U(BigInt(1234))\n1234 + O(w^10)\n\njulia> k = T(z + 1)\n1 + z + O(z^10)\n\njulia> V = AbsSeriesRing(ZZ, 10)\nUnivariate power series ring in x over Integers","category":"page"},{"location":"AbstractAlgebra/series/#Power-series-constructors","page":"Power series","title":"Power series constructors","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Series can be constructed using arithmetic operators using the generator of the series. Also see the big-oh notation below for specifying the precision.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"All of the standard ring constructors can also be used to construct power series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"(R::SeriesRing)() # constructs zero\n(R::SeriesRing)(c::Integer)\n(R::SeriesRing)(c::elem_type(R))\n(R::SeriesRing{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"In addition, the following constructors that are specific to power series are provided. They take an array of coefficients, a length, precision and valuation. Coefficients will be coerced into the coefficient ring if they are not already in that ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"For relative series we have:","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"(S::SeriesRing{T})(A::Vector{T}, len::Int, prec::Int, val::Int) where T <: RingElem\n(S::SeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: RingElem}\n(S::SeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: Integer}","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"And for absolute series:","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"(S::SeriesRing{T})(A::Vector{T}, len::Int, prec::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"It is also possible to create series directly without having to create the corresponding series ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"abs_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, var::AbstractString=\"x\"; max_precision::Int=prec, cached::Bool=true) where T\nrel_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, val::Int, var::AbstractString=\"x\"; max_precision::Int=prec, cached::Bool=true) where T\nlaurent_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, val::Int, scale::Int, var::AbstractString=\"x\"; max_precision::Int=prec, cached::Bool=true) where T","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> S, x = PowerSeriesRing(QQ, 10, \"x\"; model=:capped_absolute)\n(Univariate power series ring in x over Rationals, x + O(x^10))\n\njulia> f = S(Rational{BigInt}[0, 2, 3, 1], 4, 6)\n2*x + 3*x^2 + x^3 + O(x^6)\n\njulia> f = abs_series(ZZ, [1, 2, 3], 3, 5, \"y\")\n1 + 2*y + 3*y^2 + O(y^5)\n\njulia> g = rel_series(ZZ, [1, 2, 3], 3, 7, 4)\nx^4 + 2*x^5 + 3*x^6 + O(x^7)\n\njulia> k = abs_series(ZZ, [1, 2, 3], 1, 6, cached=false)\n1 + O(x^6)\n\njulia> p = rel_series(ZZ, BigInt[], 0, 3, 1)\nO(x^3)\n\njulia> q = abs_series(ZZ, [], 0, 6)\nO(x^6)\n\njulia> s = abs_series(ZZ, [1, 2, 3], 3, 5; max_precision=10)\n1 + 2*x + 3*x^2 + O(x^5)\n\njulia> s = laurent_series(ZZ, [1, 2, 3], 3, 5, 0, 2; max_precision=10)\n1 + 2*x^2 + 3*x^4 + O(x^5)","category":"page"},{"location":"AbstractAlgebra/series/#Big-oh-notation","page":"Power series","title":"Big-oh notation","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Series elements can be given a precision using the big-oh notation. This is provided by a function of the following form, (or something equivalent for Laurent series):","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"O(x::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, x = PowerSeriesRing(ZZ, 10, \"x\")\n(Univariate power series ring in x over Integers, x + O(x^11))\n\njulia> S, y = LaurentSeriesRing(ZZ, 10, \"y\")\n(Laurent series ring in y over Integers, y + O(y^11))\n\njulia> f = 1 + 2x + O(x^5)\n1 + 2*x + O(x^5)\n\njulia> g = 2y + 7y^2 + O(y^7)\n2*y + 7*y^2 + O(y^7)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"What is happening here in practice is that O(x^n) is creating the series 0 + O(x^n) and the rules for addition of series dictate that if this is added to a series of greater precision, then the lower of the two precisions must be used.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Of course it may be that the precision of the series that O(x^n) is added to is already lower than n, in which case adding O(x^n) has no effect. This is the case if the default precision is too low, since x on its own has the default precision.","category":"page"},{"location":"AbstractAlgebra/series/#Power-series-models","page":"Power series","title":"Power series models","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Capped relative power series have their maximum relative precision capped at some value prec_max. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form  c_ax^a + c_a+1x^a+1 + ldots + O(x^a + b).","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The zero power series is simply taken to be 0 + O(x^b).","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series f and g we have that divexact(f*g), g) == f.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"However, capped relative power series are not additively stable, i.e. we do not always have (f + g) - g = f.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Similar comments apply to Laurent series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"On the other hand, capped absolute power series have their absolute precision capped. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form c_ax^a + c_a+1x^a+1 + ldots + O(x^b).","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Capped absolute series are additively stable, but not necessarily multiplicatively stable.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"For all models, the maximum precision is also used as a default precision in the case of coercing coefficients into the ring and for any computation where the result could mathematically be given to infinite precision.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"In all models we say that two power series are equal if they agree up to the minimum absolute precision of the two power series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Thus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"During computations, it is possible for power series to lose relative precision due to cancellation. For example if f = x^3 + x^5 + O(x^8) and g = x^3 + x^6 + O(x^8) then f - g = x^5 - x^6 + O(x^8) which now has relative precision 3 instead of relative precision 5.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Amongst other things, this means that equality is not transitive. For example x^6 + O(x^11) == 0 + O(x^5) and x^7 + O(x^12) == 0 + O(x^5) but x^6 + O(x^11) neq x^7 + O(x^12).","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"For example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in y over the power series ring in x over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of (0 + O(x^10))y + (1 + O(x^10))?","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"If one takes it to be (0 + O(x^10)) then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Simply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"An absolute power series ring over a ring R with precision p behaves very much like the quotient Rx(x^p) of the polynomial ring over R. Therefore one can often treat absolute power series rings as though they were rings. However, this depends on all series being given a precision equal to the specified maximum precision and not a lower precision.","category":"page"},{"location":"AbstractAlgebra/series/#Functions-for-types-and-parents-of-series-rings","page":"Power series","title":"Functions for types and parents of series rings","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"base_ring(R::SeriesRing)\nbase_ring(a::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the coefficient ring of the given series ring or series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"parent(a::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the parent of the given series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"characteristic(R::SeriesRing)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the characteristic of the given series ring. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/series/#Series-functions","page":"Power series","title":"Series functions","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Unless otherwise noted, the functions below are available for all series models, including Laurent series. We denote this by using the abstract type RelSeriesElem, even though absolute series and Laurent series types do not belong to this abstract type.","category":"page"},{"location":"AbstractAlgebra/series/#Basic-functionality","page":"Power series","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Series implement the Ring Interface","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"zero(R::SeriesRing)\none(R::SeriesRing)\niszero(a::SeriesElem)\nisone(a::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"divexact(a::T, b::T) where T <: SeriesElem\ninv(a::SeriesElem) ","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Series also implement the Series Interface, the most important basic functions being the following.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"var(S::SeriesRing)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return a symbol for the variable of the given series ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"max_precision(S::SeriesRing)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the precision cap of the given series ring.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"precision(f::SeriesElem)\nvaluation(f::SeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"gen(R::SeriesRing)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"The following functions are also provided for all series.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"coeff(a::SeriesElem, n::Int)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Return the degree n coefficient of the given power series. Note coefficients are numbered from n = 0 for the constant coefficient. If n exceeds the current precision of the power series, the function returns a zero coefficient.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"For power series types, n must be non-negative. Laurent series do not have this restriction.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"modulus{T <: ResElem}(::SeriesElem{T})","category":"page"},{"location":"AbstractAlgebra/series/#modulus-Union{Tuple{SeriesElem{T}}, Tuple{T}} where T<:ResElem","page":"Power series","title":"modulus","text":"modulus(a::SeriesElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given power series.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"isgen(::RelSeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/#isgen-Tuple{RelSeriesElem}","page":"Power series","title":"isgen","text":"isgen(a::RelSeriesElem)\n\nReturn true if the given power series is arithmetically equal to the generator of its power series ring to its current precision, otherwise return false.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> S, x = PowerSeriesRing(ZZ, 10, \"x\")\n(Univariate power series ring in x over Integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^10)\n1 + 3*x + x^3 + O(x^10)\n\njulia> g = 1 + 2x + x^2 + O(x^10)\n1 + 2*x + x^2 + O(x^10)\n\njulia> h = zero(S)\nO(x^10)\n\njulia> k = one(S)\n1 + O(x^10)\n\njulia> isone(k)\ntrue\n\njulia> iszero(f)\nfalse\n\njulia> n = pol_length(f)\n4\n\njulia> c = polcoeff(f, 3)\n1\n\njulia> U = base_ring(S)\nIntegers\n\njulia> v = var(S)\n:x\n\njulia> max_precision(S) == 10\ntrue\n\njulia> T = parent(x + 1)\nUnivariate power series ring in x over Integers\n\njulia> g == deepcopy(g)\ntrue\n\njulia> t = divexact(2g, 2)\n1 + 2*x + x^2 + O(x^10)\n\njulia> p = precision(f)\n10\n\njulia> R, t = PowerSeriesRing(QQ, 10, \"t\")\n(Univariate power series ring in t over Rationals, t + O(t^11))\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate power series ring in t over Rationals, x + O(x^31))\n\njulia> a = O(x^4)\nO(x^4)\n\njulia> b = (t + 3)*x + (t^2 + 1)*x^2 + O(x^4)\n(3 + t + O(t^10))*x + (1 + t^2 + O(t^10))*x^2 + O(x^4)\n\njulia> k = isgen(gen(R))\ntrue\n\njulia> m = isunit(-1 + x + 2x^2)\ntrue\n\njulia> n = valuation(a)\n4\n\njulia> p = valuation(b)\n1\n\njulia> c = coeff(b, 2)\n1 + t^2 + O(t^10)\n\njulia> S, x = PowerSeriesRing(ZZ, 10, \"x\")\n(Univariate power series ring in x over Integers, x + O(x^11))\n\njulia> f = 1 + 3x + x^3 + O(x^5)\n1 + 3*x + x^3 + O(x^5)\n\njulia> g = S(BigInt[1, 2, 0, 1, 0, 0, 0], 4, 10, 3);\n\njulia> set_length!(g, 3)\nx^3 + 2*x^4 + O(x^10)\n\njulia> g = setcoeff!(g, 2, BigInt(11))\nx^3 + 2*x^4 + 11*x^5 + O(x^10)\n\njulia> fit!(g, 8)\n\njulia> g = setcoeff!(g, 7, BigInt(4))\nx^3 + 2*x^4 + 11*x^5 + O(x^10)","category":"page"},{"location":"AbstractAlgebra/series/#Change-base-ring","page":"Power series","title":"Change base ring","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"map_coefficients(::Any, ::AbsSeriesElem{<:RingElem})\nchange_base_ring(::Ring, ::AbsSeriesElem{<:RingElem})","category":"page"},{"location":"AbstractAlgebra/series/#map_coefficients-Tuple{Any, AbsSeriesElem{var\"#s271\"} where var\"#s271\"<:RingElem}","page":"Power series","title":"map_coefficients","text":"map_coefficients(f, p::SeriesElem{<: RingElement}; cached::Bool=true, parent::PolyRing)\n\nTransform the series p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/#change_base_ring-Tuple{AbstractAlgebra.Ring, AbsSeriesElem{var\"#s271\"} where var\"#s271\"<:RingElem}","page":"Power series","title":"change_base_ring","text":"change_base_ring(R::Ring, p::SeriesElem{<: RingElement}; parent::PolyRing)\n\nReturn the series obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the series will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, x = PowerSeriesRing(ZZ, 10, \"x\")\n(Univariate power series ring in x over Integers, x + O(x^11))\n\njulia> f = 4*x^6 + x^7 + 9*x^8 + 16*x^9 + 25*x^10 + O(x^11)\n4*x^6 + x^7 + 9*x^8 + 16*x^9 + 25*x^10 + O(x^11)\n\njulia> map_coefficients(AbstractAlgebra.sqrt, f)\n2*x^6 + x^7 + 3*x^8 + 4*x^9 + 5*x^10 + O(x^11)\n\njulia> change_base_ring(QQ, f)\n4*x^6 + x^7 + 9*x^8 + 16*x^9 + 25*x^10 + O(x^11)","category":"page"},{"location":"AbstractAlgebra/series/#Shifting","page":"Power series","title":"Shifting","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"shift_left{T <: RingElem}(::RelSeriesElem{T}, ::Int)","category":"page"},{"location":"AbstractAlgebra/series/#shift_left-Union{Tuple{T}, Tuple{RelSeriesElem{T}, Int64}} where T<:RingElem","page":"Power series","title":"shift_left","text":"shift_left(x::RelSeriesElem{T}, n::Int) where T <: RingElement\n\nReturn the power series x shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"shift_right{T <: RingElem}(::RelSeriesElem{T}, ::Int)","category":"page"},{"location":"AbstractAlgebra/series/#shift_right-Union{Tuple{T}, Tuple{RelSeriesElem{T}, Int64}} where T<:RingElem","page":"Power series","title":"shift_right","text":"shift_right(x::RelSeriesElem{T}, n::Int) where T <: RingElement\n\nReturn the power series x shifted right by n terms, i.e. divided by x^n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> a = 2x + x^3\n2*x + x^3 + O(x^31)\n\njulia> b = O(x^4)\nO(x^4)\n\njulia> c = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> d = 2x + x^3 + O(x^4)\n2*x + x^3 + O(x^4)\n\njulia> f = shift_left(a, 2)\n2*x^3 + x^5 + O(x^33)\n\njulia> g = shift_left(b, 2)\nO(x^6)\n\njulia> h = shift_right(c, 1)\n1 + 2*x + O(x^4)\n\njulia> k = shift_right(d, 3)\n1 + O(x^1)\n","category":"page"},{"location":"AbstractAlgebra/series/#Truncation","page":"Power series","title":"Truncation","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"truncate{T <: RingElem}(::RelSeriesElem{T}, ::Int)","category":"page"},{"location":"AbstractAlgebra/series/#truncate-Union{Tuple{T}, Tuple{RelSeriesElem{T}, Int64}} where T<:RingElem","page":"Power series","title":"truncate","text":"truncate(a::RelSeriesElem{T}, n::Int) where T <: RingElement\n\nReturn a truncated to (absolute) precision n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> a = 2x + x^3\n2*x + x^3 + O(x^31)\n\njulia> b = O(x^4)\nO(x^4)\n\njulia> c = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> d = 2x + x^3 + O(x^4)\n2*x + x^3 + O(x^4)\n\njulia> f = truncate(a, 3)\n2*x + O(x^3)\n\njulia> g = truncate(b, 2)\nO(x^2)\n\njulia> h = truncate(c, 7)\n1 + x + 2*x^2 + O(x^5)\n\njulia> k = truncate(d, 5)\n2*x + x^3 + O(x^4)\n","category":"page"},{"location":"AbstractAlgebra/series/#Division","page":"Power series","title":"Division","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Base.inv(::RelSeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/#inv-Tuple{RelSeriesElem}","page":"Power series","title":"inv","text":"Base.inv(a::RelSeriesElem)\n\nReturn the inverse of the power series a, i.e. 1a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> a = 1 + x + 2x^2 + O(x^5)\n1 + x + 2*x^2 + O(x^5)\n\njulia> b = S(-1)\n-1 + O(x^30)\n\njulia> c = inv(a)\n1 - x - x^2 + 3*x^3 - x^4 + O(x^5)\n\njulia> d = inv(b)\n-1 + O(x^30)\n","category":"page"},{"location":"AbstractAlgebra/series/#Composition","page":"Power series","title":"Composition","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"compose(a::RelSeriesElem, b::RelSeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/#compose-Tuple{RelSeriesElem, RelSeriesElem}","page":"Power series","title":"compose","text":"compose(a::RelSeriesElem, b::RelSeriesElem)\n\nCompose the series a with the series b and return the result, i.e. return acirc b. The two series do not need to be in the same ring, however the series b must have positive valuation or an exception is raised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Note that subst can be used instead of compose, however the provided functionality is the same. General series substitution is not well-defined.","category":"page"},{"location":"AbstractAlgebra/series/#Derivative-and-integral","page":"Power series","title":"Derivative and integral","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"derivative(a::RelSeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/#derivative-Tuple{RelSeriesElem}","page":"Power series","title":"derivative","text":"derivative(f::AbsSeriesElem{T})\n\nReturn the derivative of the power series f.\n\n\n\nderivative(f::RelSeriesElem{T})\n\nReturn the derivative of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\nderivative(f::AbstractAlgebra.MPolyElem{T}, j::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\nderivative(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\nderivative(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the derivative of the given Puiseux series a.\n\n\n\nderivative(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable of index n.\n\n\n\nderivative(x::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable v.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"integral(a::RelSeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/#integral-Tuple{RelSeriesElem}","page":"Power series","title":"integral","text":"integral(f::AbsSeriesElem{T})\n\nReturn the integral of the power series f.\n\n\n\nintegral(f::RelSeriesElem{T})\n\nReturn the integral of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\nintegral(f::RelSeriesElem{T}) -> RelSeriesElem\n\nReturn the integral of the power series f.\n\n\n\nintegral(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the integral of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/#Special-functions","page":"Power series","title":"Special functions","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Base.log(a::SeriesElem{T}) where T <: FieldElem","category":"page"},{"location":"AbstractAlgebra/series/#log-Union{Tuple{SeriesElem{T}}, Tuple{T}} where T<:FieldElem","page":"Power series","title":"log","text":"log(a::SeriesElem{T}) where T <: FieldElement\n\nReturn the logarithm of the power series a.\n\n\n\nlog(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the logarithm of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Base.exp(a::RelSeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/#exp-Tuple{RelSeriesElem}","page":"Power series","title":"exp","text":"exp(a::AbsSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::RelSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Base.sqrt(a::RelSeriesElem)","category":"page"},{"location":"AbstractAlgebra/series/#sqrt-Tuple{RelSeriesElem}","page":"Power series","title":"sqrt","text":"sqrt(a::RelSeriesElem)\n\nReturn the square root of the power series a. By default the function raises an exception if the input is not a square. If check=false this check is omitted.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S, x = PowerSeriesRing(R, 30, \"x\")\n(Univariate power series ring in x over Univariate Polynomial Ring in t over Rationals, x + O(x^31))\n\njulia> T, z = PowerSeriesRing(QQ, 30, \"z\")\n(Univariate power series ring in z over Rationals, z + O(z^31))\n\njulia> a = 1 + z + 3z^2 + O(z^5)\n1 + z + 3*z^2 + O(z^5)\n\njulia> b = z + 2z^2 + 5z^3 + O(z^5)\nz + 2*z^2 + 5*z^3 + O(z^5)\n\njulia> c = exp(x + O(x^40))\n1 + x + 1//2*x^2 + 1//6*x^3 + 1//24*x^4 + 1//120*x^5 + 1//720*x^6 + 1//5040*x^7 + 1//40320*x^8 + 1//362880*x^9 + 1//3628800*x^10 + 1//39916800*x^11 + 1//479001600*x^12 + 1//6227020800*x^13 + 1//87178291200*x^14 + 1//1307674368000*x^15 + 1//20922789888000*x^16 + 1//355687428096000*x^17 + 1//6402373705728000*x^18 + 1//121645100408832000*x^19 + 1//2432902008176640000*x^20 + 1//51090942171709440000*x^21 + 1//1124000727777607680000*x^22 + 1//25852016738884976640000*x^23 + 1//620448401733239439360000*x^24 + 1//15511210043330985984000000*x^25 + 1//403291461126605635584000000*x^26 + 1//10888869450418352160768000000*x^27 + 1//304888344611713860501504000000*x^28 + 1//8841761993739701954543616000000*x^29 + 1//265252859812191058636308480000000*x^30 + O(x^31)\n\njulia> d = divexact(x, exp(x + O(x^40)) - 1)\n1 - 1//2*x + 1//12*x^2 - 1//720*x^4 + 1//30240*x^6 - 1//1209600*x^8 + 1//47900160*x^10 - 691//1307674368000*x^12 + 1//74724249600*x^14 - 3617//10670622842880000*x^16 + 43867//5109094217170944000*x^18 - 174611//802857662698291200000*x^20 + 77683//14101100039391805440000*x^22 - 236364091//1693824136731743669452800000*x^24 + 657931//186134520519971831808000000*x^26 - 3392780147//37893265687455865519472640000000*x^28 + O(x^29)\n\njulia> f = exp(b)\n1 + z + 5//2*z^2 + 43//6*z^3 + 193//24*z^4 + O(z^5)\n\njulia> log(exp(b)) == b\ntrue\n\njulia> h = sqrt(a)\n1 + 1//2*z + 11//8*z^2 - 11//16*z^3 - 77//128*z^4 + O(z^5)\n","category":"page"},{"location":"AbstractAlgebra/series/#Random-generation","page":"Power series","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Random series can be constructed using the rand function. A range of possible valuations is provided. The maximum precision of the ring is used as a bound on the precision. Other parameters are used to construct random coefficients.","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"rand(R::SeriesRing, val_range::UnitRange{Int}, v...)","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"Examples","category":"page"},{"location":"AbstractAlgebra/series/","page":"Power series","title":"Power series","text":"using AbstractAlgebra # hide\nR, x = PowerSeriesRing(ZZ, 10, \"x\")\nf = rand(R, 3:5, -10:10)","category":"page"},{"location":"Nemo/ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/ff_embedding/#Finite-field-embeddings","page":"Finite field embeddings","title":"Finite field embeddings","text":"","category":"section"},{"location":"Nemo/ff_embedding/#Introduction","page":"Finite field embeddings","title":"Introduction","text":"","category":"section"},{"location":"Nemo/ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"Nemo allows the construction of finite field embeddings making use of the algorithm of Bosma, Cannon and Steel behind the scenes to ensure compatibility. Critical routines (e.g. polynomial factorization, matrix computations) are provided by the C library Flint, whereas high level tasks are written directly in Nemo.","category":"page"},{"location":"Nemo/ff_embedding/#Embedding-functionality","page":"Finite field embeddings","title":"Embedding functionality","text":"","category":"section"},{"location":"Nemo/ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"It is possible to explicitly call the embedding embed function to create an embedding, but it is also possible to directly ask for the conversion of a finite field element x in some other finite field k via calling k(x). The resulting embedding is of type FinFieldMorphism. It is also possible to compute the preimage map of an embedding via the preimage_map function, applied to an embedding or directly to the finite fields (this actually first computes the embedding), or via conversion. An error is thrown if the element you want to compute the preimage of is not in the image of the embedding.","category":"page"},{"location":"Nemo/ff_embedding/#Computing-an-embedding","page":"Finite field embeddings","title":"Computing an embedding","text":"","category":"section"},{"location":"Nemo/ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"embed(::FqNmodFiniteField, ::FqNmodFiniteField)","category":"page"},{"location":"Nemo/ff_embedding/#embed-Tuple{FqNmodFiniteField, FqNmodFiniteField}","page":"Finite field embeddings","title":"embed","text":"embed(k::T, K::T) where T <: FinField\n\nEmbed k in K, with some additional computations in order to satisfy compatibility conditions with previous and future embeddings.\n\n\n\n","category":"method"},{"location":"Nemo/ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"Examples","category":"page"},{"location":"Nemo/ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"julia> k2, x2 = FiniteField(19, 2, \"x2\")\n(Finite field of degree 2 over F_19, x2)\n\njulia> k4, x4 = FiniteField(19, 4, \"x4\")\n(Finite field of degree 4 over F_19, x4)\n\njulia> f = embed(k2, k4)\nMorphism from Finite field of degree 2 over F_19\nto Finite field of degree 4 over F_19\n\njulia> y = f(x2)\n6*x4^3+5*x4^2+9*x4+17\n\njulia> z = k4(x2)\n6*x4^3+5*x4^2+9*x4+17","category":"page"},{"location":"Nemo/ff_embedding/#Computing-the-preimage-of-an-embedding","page":"Finite field embeddings","title":"Computing the preimage of an embedding","text":"","category":"section"},{"location":"Nemo/ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"preimage_map(::FqNmodFiniteField, ::FqNmodFiniteField)\npreimage_map(::FinFieldMorphism)","category":"page"},{"location":"Nemo/ff_embedding/#preimage_map-Tuple{FqNmodFiniteField, FqNmodFiniteField}","page":"Finite field embeddings","title":"preimage_map","text":"preimage_map(k::T, k::T) where T <: FinField\n\nComputes the preimage map corresponding to the embedding of k into K.\n\n\n\n","category":"method"},{"location":"Nemo/ff_embedding/#preimage_map-Tuple{Nemo.FinFieldMorphism}","page":"Finite field embeddings","title":"preimage_map","text":"preimage_map(f::FinFieldMorphism)\n\nCompute the preimage map corresponding to the embedding f.\n\n\n\n","category":"method"},{"location":"Nemo/ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"Examples","category":"page"},{"location":"Nemo/ff_embedding/","page":"Finite field embeddings","title":"Finite field embeddings","text":"julia> k7, x7 = FiniteField(13, 7, \"x7\")\n(Finite field of degree 7 over F_13, x7)\n\njulia> k21, x21 = FiniteField(13, 21, \"x21\")\n(Finite field of degree 21 over F_13, x21)\n\njulia> s = preimage_map(k7, k21)\nPreimage of the morphism from Finite field of degree 7 over F_13\nto Finite field of degree 21 over F_13\n\njulia> y = k21(x7);\n\njulia> z = s(y)\nx7\n\njulia> t = k7(y)\nx7","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/matrix/#Matrices","page":"Matrices","title":"Matrices","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Nemo allow the creation of dense matrices over any computable ring R. There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of matrices over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"The following table shows each of the matrix types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of matrix (the type information is mainly of concern to developers).","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.Mat{T} Generic.MatSpace{T}\nmathbbZ Flint fmpz_mat FmpzMatSpace\nmathbbZnmathbbZ (small n) Flint nmod_mat NmodMatSpace\nmathbbZnmathbbZ (large n) Flint fmpz_mod_mat FmpzModMatSpace\nmathbbQ Flint fmpq_mat FmpqMatSpace\nmathbbZpmathbbZ (small p) Flint gfp_mat GFPMatSpace\nmathbbF_p^n (small p) Flint fq_nmod_mat FqNmodMatSpace\nmathbbF_p^n (large p) Flint fq_mat `FqMatSpace\nmathbbR Arb arb_mat ArbMatSpace\nmathbbC Arb acb_mat AcbMatSpace","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"The dimensions and base ring R of a generic matrix are stored in its parent object.","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"All matrix element types belong to the abstract type MatElem and all of the matrix space types belong to the abstract type MatSpace. This enables one to write generic functions that can accept any Nemo matrix type.","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Note that the preferred way to create matrices is not to use the type constructors but to use the matrix function, see also the Matrix element constructors section of the AbstractAlgebra manual.","category":"page"},{"location":"Nemo/matrix/#Matrix-functionality","page":"Matrices","title":"Matrix functionality","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"All matrix spaces in Nemo provide the matrix functionality of AbstractAlgebra:","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/matrix","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Some of this functionality is provided in Nemo by C libraries, such as Flint, for various specific rings.","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"In the following, we list the functionality which is provided in addition to the generic matrix functionality, for specific rings in Nemo.","category":"page"},{"location":"Nemo/matrix/#Comparison-operators","page":"Matrices","title":"Comparison operators","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"overlaps(::arb_mat, ::arb_mat)","category":"page"},{"location":"Nemo/matrix/#overlaps-Tuple{arb_mat, arb_mat}","page":"Matrices","title":"overlaps","text":"overlaps(x::arb_mat, y::arb_mat)\n\nReturns true if all entries of x overlap with the corresponding entry of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"overlaps(::acb_mat, ::acb_mat)","category":"page"},{"location":"Nemo/matrix/#overlaps-Tuple{acb_mat, acb_mat}","page":"Matrices","title":"overlaps","text":"overlaps(x::acb_mat, y::acb_mat)\n\nReturns true if all entries of x overlap with the corresponding entry of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"contains(::arb_mat, ::arb_mat)","category":"page"},{"location":"Nemo/matrix/#contains-Tuple{arb_mat, arb_mat}","page":"Matrices","title":"contains","text":"contains(x::arb_mat, y::arb_mat)\n\nReturns true if all entries of x contain the corresponding entry of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"contains(::acb_mat, ::acb_mat)","category":"page"},{"location":"Nemo/matrix/#contains-Tuple{acb_mat, acb_mat}","page":"Matrices","title":"contains","text":"contains(x::acb_mat, y::acb_mat)\n\nReturns true if all entries of x contain the corresponding entry of y, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"In addition we have the following ad hoc comparison operators.","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"C = RR[1 2; 3 4]\nD = RR[\"1 +/- 0.1\" \"2 +/- 0.1\"; \"3 +/- 0.1\" \"4 +/- 0.1\"]\noverlaps(C, D)\ncontains(D, C)","category":"page"},{"location":"Nemo/matrix/#Scaling","page":"Matrices","title":"Scaling","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"<<(::fmpz_mat, ::Int)","category":"page"},{"location":"Nemo/matrix/#<<-Tuple{fmpz_mat, Int64}","page":"Matrices","title":"<<","text":"<<(x::fmpz_mat, y::Int)\n\nReturn 2^yx.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":">>(::fmpz_mat, ::Int)","category":"page"},{"location":"Nemo/matrix/#>>-Tuple{fmpz_mat, Int64}","page":"Matrices","title":">>","text":">>(x::fmpz_mat, y::Int)\n\nReturn x2^y where rounding is towards zero.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 6 3])\n\nB = A<<5\nC = B>>2","category":"page"},{"location":"Nemo/matrix/#Determinant","page":"Matrices","title":"Determinant","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"det_divisor(::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#det_divisor-Tuple{fmpz_mat}","page":"Matrices","title":"det_divisor","text":"det_divisor(x::fmpz_mat)\n\nReturn some positive divisor of the determinant of x, if the determinant is nonzero, otherwise return zero.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"det_given_divisor(::fmpz_mat, ::Integer, ::Bool)\ndet_given_divisor(::fmpz_mat, ::fmpz, ::Bool)","category":"page"},{"location":"Nemo/matrix/#det_given_divisor-Tuple{fmpz_mat, Integer, Bool}","page":"Matrices","title":"det_given_divisor","text":"det_given_divisor(x::fmpz_mat, d::Integer, proved=true)\n\nReturn the determinant of x given a positive divisor of its determinant. If proved == true (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/#det_given_divisor-Tuple{fmpz_mat, fmpz, Bool}","page":"Matrices","title":"det_given_divisor","text":"det_given_divisor(x::fmpz_mat, d::fmpz, proved=true)\n\nReturn the determinant of x given a positive divisor of its determinant. If proved == true (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 6 3])\n\nc = det_divisor(A)\nd = det_given_divisor(A, c)","category":"page"},{"location":"Nemo/matrix/#Linear-solving","page":"Matrices","title":"Linear solving","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"cansolve(::fmpz_mat, ::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#cansolve-Tuple{fmpz_mat, fmpz_mat}","page":"Matrices","title":"cansolve","text":"cansolve(a::fmpz_mat, b::fmpz_mat) -> Bool, fmpz_mat\n\nReturn true and a matrix x such that ax = b, or false and some matrix in case x does not exist.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"solve_dixon(::fmpz_mat, ::fmpz_mat)\nsolve_dixon(::fmpq_mat, ::fmpq_mat)","category":"page"},{"location":"Nemo/matrix/#solve_dixon-Tuple{fmpz_mat, fmpz_mat}","page":"Matrices","title":"solve_dixon","text":"solve_dixon(a::fmpz_mat, b::fmpz_mat)\n\nReturn a tuple (x m) consisting of a column vector x such that ax = b pmodm. The element  b must be a column vector with the same number > of rows as a and a must be a square matrix. If these conditions are not met or (x d) does not exist, an exception is raised.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/#solve_dixon-Tuple{fmpq_mat, fmpq_mat}","page":"Matrices","title":"solve_dixon","text":"solve_dixon(a::fmpq_mat, b::fmpq_mat)\n\nSolve ax = b by clearing denominators and using Dixon's algorithm. This is usually faster for large systems.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\nT = MatrixSpace(ZZ, 3, 1)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 2 2])\nB = T([fmpz(4), 5, 7])\n\nX, m = solve_dixon(A, B)","category":"page"},{"location":"Nemo/matrix/#Pseudo-inverse","page":"Matrices","title":"Pseudo inverse","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"pseudo_inv(::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#pseudo_inv-Tuple{fmpz_mat}","page":"Matrices","title":"pseudo_inv","text":"pseudo_inv(x::fmpz_mat)\n\nReturn a tuple (z d) consisting of a matrix z and denominator d such that zd is the inverse of x.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([1 0 1; 2 3 1; 5 6 7])\n\nB, d = pseudo_inv(A)","category":"page"},{"location":"Nemo/matrix/#Nullspace","page":"Matrices","title":"Nullspace","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"nullspace_right_rational(x::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#nullspace_right_rational-Tuple{fmpz_mat}","page":"Matrices","title":"nullspace_right_rational","text":"nullspace_right_rational(x::fmpz_mat)\n\nReturn a tuple (r U) consisting of a matrix U such that the first r columns form the right rational nullspace of x, i.e. a set of vectors over mathbbZ giving a mathbbQ-basis  for the nullspace of x considered as a matrix over mathbbQ.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/#Modular-reduction","page":"Matrices","title":"Modular reduction","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"reduce_mod(::fmpz_mat, ::Integer)\nreduce_mod(::fmpz_mat, ::fmpz)","category":"page"},{"location":"Nemo/matrix/#reduce_mod-Tuple{fmpz_mat, Integer}","page":"Matrices","title":"reduce_mod","text":"reduce_mod(x::fmpz_mat, y::Integer)\n\nReduce the entries of x modulo y and return the result.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/#reduce_mod-Tuple{fmpz_mat, fmpz}","page":"Matrices","title":"reduce_mod","text":"reduce_mod(x::fmpz_mat, y::fmpz)\n\nReduce the entries of x modulo y and return the result.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 2 2])\n\nreduce_mod(A, ZZ(5))\nreduce_mod(A, 2)","category":"page"},{"location":"Nemo/matrix/#Lifting","page":"Matrices","title":"Lifting","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lift(::nmod_mat)\nlift(::gfp_mat)","category":"page"},{"location":"Nemo/matrix/#lift-Tuple{nmod_mat}","page":"Matrices","title":"lift","text":"lift(a::T) where {T <: Zmodn_mat}\n\nReturn a lift of the matrix a to a matrix over mathbbZ, i.e. where the entries of the returned matrix are those of a lifted to mathbbZ.\n\n\n\nlift(M::smodule, SM::smodule)\n\nrepresents the generators of SM in terms of the generators of M. Returns result, rest (Matrix(SM)-Matrix(rest) = Matrix(M)*Matrix(result)) If SM is in M, rest is the null module otherwise: rest = SM\n\n\n\nlift(M::smodule, SM::smodule, goodShape::Bool, isSB::Bool, divide::Bool)\n\nrepresents the generators of SM in terms of the generators of M. Returns result, rest (Matrix(SM)U-Matrix(rest) = Matrix(M)Matrix(result)) If SM is in M, rest is the null module otherwise: rest = SM (if not divide) or: rest=normalform(SM,std(M)) U is a diagonal matrix of units, differs from unity matrix only for local ring orderings\n\ngoodShape: maximal non-zero index in generators of SM <= that of M isSB: generators of M form a Groebner basis divide: allow SM not to be a submodule of M\n\n\n\n","category":"method"},{"location":"Nemo/matrix/#lift-Tuple{gfp_mat}","page":"Matrices","title":"lift","text":"lift(a::gfp_mat)\n\nReturn a lift of the matrix a to a matrix over mathbbZ, i.e. where the entries of the returned matrix are those of a lifted to mathbbZ.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"R = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 3, 3)\n\na = S([4 5 6; 7 3 2; 1 4 5])\n\n b = lift(a)","category":"page"},{"location":"Nemo/matrix/#Special-matrices","page":"Matrices","title":"Special matrices","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"hadamard(::FmpzMatSpace)","category":"page"},{"location":"Nemo/matrix/#hadamard-Tuple{FmpzMatSpace}","page":"Matrices","title":"hadamard","text":"hadamard(R::FmpzMatSpace)\n\nReturn the Hadamard matrix for the given matrix space. The number of rows and columns must be equal.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"ishadamard(::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#ishadamard-Tuple{fmpz_mat}","page":"Matrices","title":"ishadamard","text":"ishadamard(x::fmpz_mat)\n\nReturn true if the given matrix is Hadamard, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"hilbert(::FmpqMatSpace)","category":"page"},{"location":"Nemo/matrix/#hilbert-Tuple{FmpqMatSpace}","page":"Matrices","title":"hilbert","text":"hilbert(R::FmpqMatSpace)\n\nReturn the Hilbert matrix in the given matrix space. This is the matrix with entries H_ij = 1(i + j - 1).\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"R = MatrixSpace(ZZ, 3, 3)\nS = MatrixSpace(QQ, 3, 3)\n\nA = hadamard(R)\nishadamard(A)\nB = hilbert(R)","category":"page"},{"location":"Nemo/matrix/#Hermite-Normal-Form","page":"Matrices","title":"Hermite Normal Form","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"hnf(::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#hnf-Tuple{fmpz_mat}","page":"Matrices","title":"hnf","text":"hnf(x::fmpz_mat)\n\nReturn the Hermite Normal Form of x.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"hnf_with_transform(::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#hnf_with_transform-Tuple{fmpz_mat}","page":"Matrices","title":"hnf_with_transform","text":"hnf_with_transform(x::fmpz_mat)\n\nCompute a tuple (H T) where H is the Hermite normal form of x and T is a transformation matrix so that H = Tx.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"hnf_modular(::fmpz_mat, ::fmpz)","category":"page"},{"location":"Nemo/matrix/#hnf_modular-Tuple{fmpz_mat, fmpz}","page":"Matrices","title":"hnf_modular","text":"hnf_modular(x::fmpz_mat, d::fmpz)\n\nCompute the Hermite normal form of x given that d is a multiple of the determinant of the nonzero rows of x.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"hnf_modular_eldiv(::fmpz_mat, ::fmpz)","category":"page"},{"location":"Nemo/matrix/#hnf_modular_eldiv-Tuple{fmpz_mat, fmpz}","page":"Matrices","title":"hnf_modular_eldiv","text":"hnf_modular_eldiv(x::fmpz_mat, d::fmpz)\n\nCompute the Hermite normal form of x given that d is a multiple of the largest elementary divisor of x. The matrix x must have full rank.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"ishnf(::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#ishnf-Tuple{fmpz_mat}","page":"Matrices","title":"ishnf","text":"ishnf(x::fmpz_mat)\n\nReturn true if the given matrix is in Hermite Normal Form, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nB = hnf(A)\nH, T = hnf_with_transform(A)\nM = hnf_modular(A, fmpz(27))\nN = hnf_modular_eldiv(A, fmpz(27))\nishnf(M)","category":"page"},{"location":"Nemo/matrix/#Lattice-basis-reduction","page":"Matrices","title":"Lattice basis reduction","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Nemo provides LLL lattice basis reduction. Optionally one can specify the setup using a context object created by the following function.","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lll_ctx(delta::Float64, eta::Float64, rep=:zbasis, gram=:approx)","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Return a LLL context object specifying LLL parameters delta and eta and specifying the representation as either :zbasis or :gram and the Gram type as either :approx or :exact.","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lll(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"Nemo/matrix/#lll-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"lll","text":"lll(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nReturn the LLL reduction of the matrix x. By default the matrix x is a mathbbZ-basis and the Gram matrix is maintained throughout in approximate form. The LLL is performed with reduction parameters delta = 099 and eta = 051. All of these defaults can be overridden by specifying an optional context object.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lll_with_transform(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"Nemo/matrix/#lll_with_transform-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"lll_with_transform","text":"lll_with_transform(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nCompute a tuple (L T) where L is the LLL reduction of a and T is a transformation matrix so that L = Ta. All the default parameters can be overridden by supplying an optional context object.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lll_gram(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"Nemo/matrix/#lll_gram-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"lll_gram","text":"lll_gram(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51, :gram))\n\nGiven the Gram matrix x of a matrix, compute the Gram matrix of its LLL reduction.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lll_gram_with_transform(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"Nemo/matrix/#lll_gram_with_transform-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"lll_gram_with_transform","text":"lll_gram_with_transform(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51, :gram))\n\nGiven the Gram matrix x of a matrix M, compute a tuple (L T) where L is the gram matrix of the LLL reduction of the matrix and T is a transformation matrix so that L = TM.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lll_with_removal(::fmpz_mat, ::fmpz, ::lll_ctx)","category":"page"},{"location":"Nemo/matrix/#lll_with_removal-Tuple{fmpz_mat, fmpz, lll_ctx}","page":"Matrices","title":"lll_with_removal","text":"lll_with_removal(x::fmpz_mat, b::fmpz, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nCompute the LLL reduction of x and throw away rows whose norm exceeds the given bound b. Return a tuple (r L) where the first r rows of L are the rows remaining after removal.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lll_with_removal_transform(::fmpz_mat, ::fmpz, ::lll_ctx)","category":"page"},{"location":"Nemo/matrix/#lll_with_removal_transform-Tuple{fmpz_mat, fmpz, lll_ctx}","page":"Matrices","title":"lll_with_removal_transform","text":"lll_with_removal_transform(x::fmpz_mat, b::fmpz, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nCompute a tuple (r L T) where the first r rows of L are those remaining from the LLL reduction after removal of vectors with norm exceeding the bound b and T is a transformation matrix so that L = Tx.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lll!(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"Nemo/matrix/#lll!-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"lll!","text":"lll!(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51))\n\nPerform the LLL reduction of the matrix x inplace. By default the matrix x is a > mathbbZ-basis and the Gram matrix is maintained throughout in approximate form. The LLL is performed with reduction parameters delta = 099 and eta = 051. All of these defaults can be overridden by specifying an optional context object.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"lll_gram!(::fmpz_mat, ::lll_ctx)","category":"page"},{"location":"Nemo/matrix/#lll_gram!-Tuple{fmpz_mat, lll_ctx}","page":"Matrices","title":"lll_gram!","text":"lll_gram!(x::fmpz_mat, ctx::lll_ctx = lll_ctx(0.99, 0.51, :gram))\n\nGiven the Gram matrix x of a matrix, compute the Gram matrix of its LLL reduction inplace.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nL = lll(A, lll_ctx(0.95, 0.55, :zbasis, :approx)\nL, T = lll_with_transform(A)\n\nG == lll_gram(gram(A))\nG, T = lll_gram_with_transform(gram(A))\n\nr, L = lll_with_removal(A, fmpz(100))\nr, L, T = lll_with_removal_transform(A, fmpz(100))","category":"page"},{"location":"Nemo/matrix/#Smith-Normal-Form","page":"Matrices","title":"Smith Normal Form","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"snf(::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#snf-Tuple{fmpz_mat}","page":"Matrices","title":"snf","text":"snf(x::fmpz_mat)\n\nCompute the Smith normal form of x.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"snf_diagonal(::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#snf_diagonal-Tuple{fmpz_mat}","page":"Matrices","title":"snf_diagonal","text":"snf_diagonal(x::fmpz_mat)\n\nGiven a diagonal matrix x compute the Smith normal form of x.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"issnf(::fmpz_mat)","category":"page"},{"location":"Nemo/matrix/#issnf-Tuple{fmpz_mat}","page":"Matrices","title":"issnf","text":"issnf(x::fmpz_mat)\n\nReturn true if x is in Smith normal form, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nB = snf(A)\nissnf(B) == true\n\nB = S([fmpz(2) 0 0; 0 4 0; 0 0 7])\n\nC = snf_diagonal(B)","category":"page"},{"location":"Nemo/matrix/#Strong-Echelon-Form","page":"Matrices","title":"Strong Echelon Form","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"strong_echelon_form(::nmod_mat)\nstrong_echelon_form(::gfp_mat)","category":"page"},{"location":"Nemo/matrix/#strong_echelon_form-Tuple{nmod_mat}","page":"Matrices","title":"strong_echelon_form","text":"strong_echelon_form(a::nmod_mat)\n\nReturn the strong echeleon form of a. The matrix a must have at least as many rows as columns.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/#strong_echelon_form-Tuple{gfp_mat}","page":"Matrices","title":"strong_echelon_form","text":"strong_echelon_form(a::gfp_mat)\n\nReturn the strong echeleon form of a. The matrix a must have at least as many rows as columns.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"R = ResidueRing(ZZ, 12)\nS = MatrixSpace(R, 3, 3)\n\nA = S([4 1 0; 0 0 5; 0 0 0 ])\n\nB = strong_echelon_form(A)","category":"page"},{"location":"Nemo/matrix/#Howell-Form","page":"Matrices","title":"Howell Form","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"howell_form(::nmod_mat)\nhowell_form(::gfp_mat)","category":"page"},{"location":"Nemo/matrix/#howell_form-Tuple{nmod_mat}","page":"Matrices","title":"howell_form","text":"howell_form(a::nmod_mat)\n\nReturn the Howell normal form of a. The matrix a must have at least as many rows as columns.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/#howell_form-Tuple{gfp_mat}","page":"Matrices","title":"howell_form","text":"howell_form(a::gfp_mat)\n\nReturn the Howell normal form of a. The matrix a must have at least as many rows as columns.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"R = ResidueRing(ZZ, 12)\nS = MatrixSpace(R, 3, 3)\n\nA = S([4 1 0; 0 0 5; 0 0 0 ])\n\nB = howell_form(A)","category":"page"},{"location":"Nemo/matrix/#Gram-Schmidt-Orthogonalisation","page":"Matrices","title":"Gram-Schmidt Orthogonalisation","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"gso(::fmpq_mat)","category":"page"},{"location":"Nemo/matrix/#gso-Tuple{fmpq_mat}","page":"Matrices","title":"gso","text":"gso(x::fmpq_mat)\n\nReturn the Gram-Schmidt Orthogonalisation of the matrix x.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"S = MatrixSpace(QQ, 3, 3)\n\nA = S([4 7 3; 2 9 1; 0 5 3])\n\nB = gso(A)","category":"page"},{"location":"Nemo/matrix/#Exponential","page":"Matrices","title":"Exponential","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"A = RR[2 0 0; 0 3 0; 0 0 1]\n\nB = exp(A)","category":"page"},{"location":"Nemo/matrix/#Norm","page":"Matrices","title":"Norm","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"bound_inf_norm(::arb_mat)","category":"page"},{"location":"Nemo/matrix/#bound_inf_norm-Tuple{arb_mat}","page":"Matrices","title":"bound_inf_norm","text":"bound_inf_norm(x::arb_mat)\n\nReturns a nonnegative element z of type arb, such that z is an upper bound for the infinity norm for every matrix in x\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"bound_inf_norm(::acb_mat)","category":"page"},{"location":"Nemo/matrix/#bound_inf_norm-Tuple{acb_mat}","page":"Matrices","title":"bound_inf_norm","text":"bound_inf_norm(x::acb_mat)\n\nReturns a nonnegative element z of type acb, such that z is an upper bound for the infinity norm for every matrix in x\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"A = RR[1 2 3; 4 5 6; 7 8 9]\n\nd = bound_inf_norm(A)","category":"page"},{"location":"Nemo/matrix/#Shifting","page":"Matrices","title":"Shifting","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"A = RR[1 2 3; 4 5 6; 7 8 9]\n\nB = ldexp(A, 4)\n\noverlaps(16*A, B)","category":"page"},{"location":"Nemo/matrix/#Predicates","page":"Matrices","title":"Predicates","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Examples","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"A = CC[1 2 3; 4 5 6; 7 8 9]\n\nisreal(A)\n\nisreal(onei(CC)*A)","category":"page"},{"location":"Nemo/matrix/#Conversion-to-Julia-matrices","page":"Matrices","title":"Conversion to Julia matrices","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Julia matrices use a different data structure than Nemo matrices. Conversion to Julia matrices is usually only required for interfacing with other packages. It isn't necessary to convert Nemo matrices to Julia matrices in order to manipulate them.","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"This conversion can be performed with standard Julia syntax, such as the following, where A is an fmpz_mat:","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"Matrix{Int}(A)\nMatrix{BigInt}(A)","category":"page"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"In case the matrix cannot be converted without loss, an InexactError is thrown: in this case, cast to a matrix of BigInts rather than Ints.","category":"page"},{"location":"Nemo/matrix/#Eigenvalues-and-Eigenvectors-(experimental)","page":"Matrices","title":"Eigenvalues and Eigenvectors (experimental)","text":"","category":"section"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"eigvals(::acb_mat)\neigvals_simple(a::acb_mat)","category":"page"},{"location":"Nemo/matrix/#eigvals-Tuple{acb_mat}","page":"Matrices","title":"eigvals","text":"eigvals(A::acb_mat)\n\nReturns the eigenvalues of A as a vector of tuples (acb, Int). Each tuple (z, k) corresponds to a cluser of k eigenvalues of A.\n\nThis function is experimental.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/#eigvals_simple-Tuple{acb_mat}","page":"Matrices","title":"eigvals_simple","text":"eigvals_simple(A::acb_mat, alg = :default)\n\nReturns the eigenvalues of A as a vector of acb. It is assumed that A has only simple eigenvalues.\n\nThe algorithm used can be changed by setting the alg keyword to :vdhoeven_mourrain or :rump.\n\nThis function is experimental.\n\n\n\n","category":"method"},{"location":"Nemo/matrix/","page":"Matrices","title":"Matrices","text":"A = CC[1 2 3; 0 4 5; 0 0 6]\neigvals_simple(A)\nA = CC[2 2 3; 0 2 5; 0 0 2])\neigvals(A)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Sparse-distributed-multivariate-polynomials","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"AbstractAlgebra.jl provides a module, implemented in src/MPoly.jl for sparse distributed multivariate polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Generic-sparse-distributed-multivariable-polynomial-types","page":"Sparse distributed multivariate polynomials","title":"Generic sparse distributed multivariable polynomial types","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"AbstractAlgebra provides a generic multivariate polynomial type Generic.MPoly{T} where T is the type of elements of the coefficient ring.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The polynomials are implemented using a Julia array of coefficients and a 2-dimensional Julia array of UInts for the exponent vectors. Note that exponent n is represented by the n-th column of the exponent array, not the n-th row. This is because Julia uses a column major representation. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The top bit of each UInt is reserved for overflow detection.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Parent objects of such polynomials have type Generic.MPolyRing{T}.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The string representation of the variables of the polynomial ring and the base/coefficient ring R and the ordering are stored in the parent object.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Abstract-types","page":"Sparse distributed multivariate polynomials","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The polynomial element types belong to the abstract type MPolyElem{T} and the polynomial ring types belong to the abstract type MPolyRing{T}.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"note: Note\nNote that both the generic polynomial ring type Generic.MPolyRing{T} and the abstract type it belongs to, MPolyRing{T} are both called MPolyRing. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all multivariate polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Polynomial-ring-constructors","page":"Sparse distributed multivariate polynomials","title":"Polynomial ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"In order to construct multivariate polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"PolynomialRing(R::Ring, S::Vector{String}; cached::Bool = true, ordering::Symbol=:lex)\nPolynomialRing(R::Ring, n::Int, s::String; cached::Bool = false, ordering::Symbol = :lex)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#PolynomialRing-Tuple{AbstractAlgebra.Ring, Vector{String}}","page":"Sparse distributed multivariate polynomials","title":"PolynomialRing","text":"PolynomialRing(R::AbstractAlgebra.Ring, s::Vector{T}; cached::Bool = true, ordering::Symbol = :lex) where T <: Union{String, Char, Symbol}\n\nGiven a base ring R and an array of strings s specifying how the generators (variables) should be printed, return a tuple T, (x1, x2, ...) representing the new polynomial ring T = Rx1 x2  and the generators x1 x2  of the polynomial ring. By default the parent object T will depend only on R and x1, x2, ... and will be cached. Setting the optional argument cached to false will prevent the parent object T from being cached. S is a symbol corresponding to the ordering of the polynomial and can be one of :lex, :deglex or :degrevlex.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#PolynomialRing-Tuple{AbstractAlgebra.Ring, Int64, String}","page":"Sparse distributed multivariate polynomials","title":"PolynomialRing","text":"PolynomialRing(R::Ring, n::Int, s::String; cached::Bool = false, ordering::Symbol = :lex)\n\nGiven a string s and a number of variables n will do the same as the first constructor except that the variables will be automatically numbered. For example if s is the string x and n = 3 then the variables will print as x1, x2, x3.\n\nBy default the parent object S will depend only on R and  (x, ...) and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.\n\nThe optional named argument ordering can be used to specify an ordering. The currently supported options are :lex, :deglex and :degrevlex.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Like for univariate polynomials, a shorthand constructor is provided when the number of generators is greater than 1: given a base ring R, we abbreviate the constructor as follows:","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"R[\"x\", \"y\", ...]","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Here are some examples of creating multivariate polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"]; ordering=:deglex)\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> T, (z, t) = QQ[\"z\", \"t\"]\n(Multivariate Polynomial Ring in z, t over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[z, t])\n\njulia> f = R()\n0\n\njulia> g = R(123)\n123\n\njulia> h = R(BigInt(1234))\n1234\n\njulia> k = R(x + 1)\nx + 1\n\njulia> m = R(x + y + 1)\nx + y + 1\n\njulia> derivative(k, 1)\n1\n\njulia> derivative(k, 2)\n0\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Polynomial-constructors","page":"Sparse distributed multivariate polynomials","title":"Polynomial constructors","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Multivariate polynomials can be constructed from the generators in the usual way using arithmetic operations.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Also, all of the standard ring element constructors may be used to construct multivariate polynomials.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"(R::MPolyRing{T})() where T <: RingElement\n(R::MPolyRing{T})(c::Integer) where T <: RingElement\n(R::MPolyRing{T})(a::elem_type(R)) where T <: RingElement\n(R::MPolyRing{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"For more efficient construction of multivariate polynomial, one can use the MPoly build context, where terms (coefficient followed by an exponent vector) are pushed onto a context one at a time and then the polynomial constructed from those terms in one go using the finish function.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"MPolyBuildCtx(R::MPolyRing)\npush_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})\nfinish(M::MPolyBuildCtx)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#MPolyBuildCtx-Tuple{MPolyRing}","page":"Sparse distributed multivariate polynomials","title":"MPolyBuildCtx","text":"MPolyBuildCtx(R::MPolyRing)\n\nReturn a build context for creating polynomials in the given ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#push_term!-Tuple{MPolyBuildCtx, RingElem, Vector{Int64}}","page":"Sparse distributed multivariate polynomials","title":"push_term!","text":"push_term!(M::MPolyBuildCtx, c::RingElem, v::Vector{Int})\n\nAdd the term with coefficient c and exponent vector v to the polynomial under construction in the build context M.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#finish-Tuple{MPolyBuildCtx}","page":"Sparse distributed multivariate polynomials","title":"finish","text":"finish(M::MPolyBuildCtx)\n\nFinish construction of the polynomial, sort the terms, remove duplicate and zero terms and return the created polynomial.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that the finish function resets the build context so that it can be used to construct multiple polynomials..","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"When a multivariate polynomial type has a representation that allows constant time access (e.g. it is represented internally by arrays), the following additional constructor is available. It takes and array of coefficients and and array of exponent vectors.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"(S::MPolyRing{T})(A::Vector{T}, m::Vector{Vector{Int}}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Create the polynomial in the given ring with nonzero coefficients specified by the elements of A and corresponding exponent vectors given by the elements of m.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> C = MPolyBuildCtx(R)\nBuilder for an element of Multivariate Polynomial Ring in x, y over Integers\n\njulia> push_term!(C, ZZ(3), [1, 2]);\n\n\njulia> push_term!(C, ZZ(2), [1, 1]);\n\n\njulia> push_term!(C, ZZ(4), [0, 0]); \n\n\njulia> f = finish(C)\n3*x*y^2 + 2*x*y + 4\n\njulia> push_term!(C, ZZ(4), [1, 1]);\n\n\njulia> f = finish(C)\n4*x*y\n\njulia> S, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = S(Rational{BigInt}[2, 3, 1], [[3, 2], [1, 0], [0, 1]])\n2*x^3*y^2 + 3*x + y","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Functions-for-types-and-parents-of-multivariate-polynomial-rings","page":"Sparse distributed multivariate polynomials","title":"Functions for types and parents of multivariate polynomial rings","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"base_ring(R::MPolyRing)\nbase_ring(a::MPolyElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Return the coefficient ring of the given polynomial ring or polynomial, respectively.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"parent(a::MPolyElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Return the polynomial ring of the given polynomial.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"characteristic(R::MPolyRing)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Return the characteristic of the given polynomial ring. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Polynomial-functions","page":"Sparse distributed multivariate polynomials","title":"Polynomial functions","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/#Basic-manipulation","page":"Sparse distributed multivariate polynomials","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"All the standard ring functions are available, including the following.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"zero(R::MPolyRing)\none(R::MPolyRing)\niszero(a::MPolyElem)\nisone(a::MPolyElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"divexact(a::T, b::T) where T <: MPolyElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"All basic functions from the Multivariate Polynomial interface are provided.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"symbols(S::MPolyRing)\nnvars(f::MPolyRing)\ngens(S::MPolyRing)\ngen(S::MPolyRing, i::Int)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"ordering(S::MPolyRing{T})","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that the currently supported orderings are :lex, :deglex and :degrevlex.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"length(f::MPolyElem)\ndegrees(f::MPolyElem)\ntotal_degree(f::MPolyElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"isgen(x::MPolyElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"divexact(f::T, g::T) where T <: MPolyElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"For multivariate polynomial types that allow constant time access to coefficients, the following are also available, allowing access to the given coefficient, monomial or term. Terms are numbered from the most significant first.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"coeff(f::MPolyElem, n::Int)\ncoeff(a::MPolyElem, exps::Vector{Int})","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Access a coefficient by term number or exponent vector.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"monomial(f::MPolyElem, n::Int)\nmonomial!(m::T, f::T, n::Int) where T <: MPolyElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The second version writes the result into a preexisting polynomial object to save an allocation.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"term(f::MPolyElem, n::Int)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"exponent(f::MyMPolyElem}, i::Int, j::Int)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Return the exponent of the j-th variable in the i-th term of the polynomial f.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"exponent_vector(a::MPolyElem, i::Int)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"setcoeff!(a::MPolyElem{T}, exps::Vector{Int}, c::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Although multivariate polynomial rings are not usually Euclidean, the following functions from the Euclidean interface are often provided.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"divides(f::T, g::T) where T <: MPolyElem\nremove(f::T, g::T) where T <: MPolyElem\nvaluation(f::T, g::T) where T <: MPolyElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"divrem(f::T, g::T) where T <: MPolyElem\ndiv(f::T, g::T) where T <: MPolyElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Compute a tuple (q r) such that f = qg + r, where the coefficients of terms of r whose monomials are divisible by the leading monomial of g are reduced modulo the leading coefficient of g (according to the Euclidean function on the coefficients). The divrem version returns both quotient and remainder whilst the div version only returns the quotient.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that the result of these functions depend on the ordering of the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"gcd(f::T, g::T) where T <: MPolyElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following functionality is also provided for all multivariate polynomials.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"isunivariate(::MPolyRing{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#isunivariate-Union{Tuple{MPolyRing{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"isunivariate","text":"isunivariate(R::AbstractAlgebra.MPolyRing)\n\nReturns true if R is a univariate polynomial ring, i.e. has exactly one variable, and false otherwise.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"vars(p::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#vars-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"vars","text":"vars(p::AbstractAlgebra.MPolyElem{T}) where {T <: RingElement}\n\nReturn the variables actually occuring in p.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"var_index(::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#var_index-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"var_index","text":"var_index(p::AbstractAlgebra.MPolyElem{T}) where {T <: RingElement}\n\nReturn the index of the given variable x. If x is not a variable in a multivariate polynomial ring, an exception is raised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"degree(::MPolyElem{T}, ::Int) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#degree-Union{Tuple{T}, Tuple{MPolyElem{T}, Int64}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"degree","text":"degree(f::AbstractAlgebra.MPolyElem{T}, i::Int) where T <: RingElement\n\nReturn the degree of the polynomial f in terms of the i-th variable.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"degree(::MPolyElem{T}, ::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#degree-Union{Tuple{T}, Tuple{MPolyElem{T}, MPolyElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"degree","text":"degree(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the degree of the polynomial f in terms of the variable x.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"degrees(::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#degrees-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"degrees","text":"degrees(f::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn an array of the degrees of the polynomial f in terms of each variable.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"isconstant(::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#isconstant-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"isconstant","text":"isconstant(x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn true if x is a degree zero polynomial or the zero polynomial, i.e. a constant polynomial.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"isterm(::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#isterm-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"isterm","text":"isterm(x::MPoly)\n\nReturn true if the given polynomial has precisely one term.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"ismonomial(::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#ismonomial-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"ismonomial","text":"ismonomial(x::AbstractAlgebra.MPolyElem)\n\nReturn true if the given polynomial has precisely one term whose coefficient is one.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"isunivariate(::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#isunivariate-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"isunivariate","text":"isunivariate(p::AbstractAlgebra.MPolyElem)\n\nReturns true if p is a univariate polynomial, i.e. involves at most one variable (thus constant polynomials are considered univariate), and false otherwise. The result depends on the terms of the polynomial, not simply on the number of variables in the polynomial ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"coeff(::MPolyElem{T}, ::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#coeff-Union{Tuple{T}, Tuple{MPolyElem{T}, MPolyElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"coeff","text":"coeff(f::AbstractAlgebra.MPolyElem{T}, m::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the coefficient of the monomial m of the polynomial f. If there is no such monomial, zero is returned.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^2 + 2x + 1\nx^2 + 2*x + 1\n\njulia> V = vars(f)\n1-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x\n\njulia> var_index(y) == 2\ntrue\n\njulia> degree(f, x) == 2\ntrue\n\njulia> degree(f, 2) == 0\ntrue\n\njulia> d = degrees(f)\n2-element Vector{Int64}:\n 2\n 0\n\njulia> isconstant(R(1))\ntrue\n\njulia> isterm(2x)\ntrue\n\njulia> ismonomial(y)\ntrue\n\njulia> isunit(R(1))\ntrue\n\njulia> S, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> c1 = coeff(f, 1)\n1\n\njulia> c2 = coeff(f, x^3*y)\n1\n\njulia> m = monomial(f, 2)\nx*y^2\n\njulia> e1 = exponent(f, 1, 1)\n3\n\njulia> v1 = exponent_vector(f, 1)\n2-element Vector{Int64}:\n 3\n 1\n\njulia> t1 = term(f, 1)\nx^3*y\n\njulia> setcoeff!(f, [3, 1], 12)\n12*x^3*y + 3*x*y^2 + 1\n\njulia> S, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"]; ordering=:deglex)\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> V = symbols(S)\n2-element Vector{Symbol}:\n :x\n :y\n\njulia> X = gens(S)\n2-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:\n x\n y\n\njulia> ord = ordering(S)\n:deglex\n\njulia> S, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> n = length(f)\n3\n\njulia> isgen(y)\ntrue\n\njulia> nvars(S) == 2\ntrue\n\njulia> d = total_degree(f)\n4\n\njulia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = 2x^2*y + 2x + y + 1\n2*x^2*y + 2*x + y + 1\n\njulia> g = x^2*y^2 + 1\nx^2*y^2 + 1\n\njulia> flag, q = divides(f*g, f)\n(true, x^2*y^2 + 1)\n\njulia> d = divexact(f*g, f)\nx^2*y^2 + 1\n\njulia> v, q = remove(f*g^3, g)\n(3, 2*x^2*y + 2*x + y + 1)\n\njulia> n = valuation(f*g^3, g)\n3\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> f = 3x^2*y^2 + 2x + 1\n3*x^2*y^2 + 2*x + 1\n\njulia> f1 = divexact(f, 5)\n3//5*x^2*y^2 + 2//5*x + 1//5\n\njulia> f2 = divexact(f, QQ(2, 3))\n9//2*x^2*y^2 + 3*x + 3//2","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Square-root","page":"Sparse distributed multivariate polynomials","title":"Square root","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Over rings for which an exact square root is available, it is possible to take the square root of a polynomial or test whether it is a square.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"sqrt(f::MPolyElem, check::bool=true)\nissquare(::MPolyElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = -4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4\n-4*x^5*y^4 + 5*x^5*y^3 + 4*x^4 - x^3*y^4\n\njulia> sqrt(f^2)\n4*x^5*y^4 - 5*x^5*y^3 - 4*x^4 + x^3*y^4\n\njulia> issquare(f)\nfalse","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Iterators","page":"Sparse distributed multivariate polynomials","title":"Iterators","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following iterators are provided for multivariate polynomials.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"coefficients(p::MPoly)\nmonomials(p::MPoly)\nterms(p::MPoly)\nexponent_vectors(a::MPoly)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> S, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> C = collect(coefficients(f))\n3-element Vector{BigInt}:\n 1\n 3\n 1\n\njulia> M = collect(monomials(f))\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x^3*y\n x*y^2\n 1\n\njulia> T = collect(terms(f))\n3-element Vector{AbstractAlgebra.Generic.MPoly{BigInt}}:\n x^3*y\n 3*x*y^2\n 1\n\njulia> V = collect(exponent_vectors(f))\n3-element Vector{Vector{Int64}}:\n [3, 1]\n [1, 2]\n [0, 0]","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Changing-base-(coefficient)-rings","page":"Sparse distributed multivariate polynomials","title":"Changing base (coefficient) rings","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"In order to substitute the variables of a polynomial f over a ring T by elements in a T-algebra S, you first have to change the base ring of f using the following function, where g is a function representing the structure homomorphism of the T-algebra S.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"change_base_ring(::Ring, p::MPolyElem{T}) where {T <: RingElement}\nchange_coefficient_ring(::Ring, p::MPolyElem{T}) where {T <: RingElement}\nmap_coefficients(::Any, p::MPolyElem)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#change_base_ring-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring, MPolyElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"change_base_ring","text":"change_base_ring(R::Ring, p::MPolyElem{<: RingElement}; parent::MPolyRing, cached::Bool)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#change_coefficient_ring-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring, MPolyElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"change_coefficient_ring","text":"change_coefficient_ring(R::Ring, p::MPolyElem{<: RingElement}; parent::MPolyRing, cached::Bool)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#map_coefficients-Tuple{Any, MPolyElem}","page":"Sparse distributed multivariate polynomials","title":"map_coefficients","text":"map_coefficients(f, p::MPolyElem{<: RingElement}; parent::MPolyRing)\n\nTransform the polynomial p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> fz = x^2*y^2 + x + 1\nx^2*y^2 + x + 1\n\njulia> fq = change_base_ring(QQ, fz)\nx^2*y^2 + x + 1\n\njulia> fq = change_coefficient_ring(QQ, fz)\nx^2*y^2 + x + 1\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"In case a specific parent ring is constructed, it can also be passed to the function.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S,  = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x, y])\n\njulia> fz = x^5 + y^3 + 1\nx^5 + y^3 + 1\n\njulia> fq = change_base_ring(QQ, fz, parent=S)\nx^5 + y^3 + 1","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Multivariate-coefficients","page":"Sparse distributed multivariate polynomials","title":"Multivariate coefficients","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"In order to return the \"coefficient\" (as a multivariate polynomial in the same ring), of a given monomial (in which some of the variables may not appear and others may be required to appear to exponent zero), we can use the following function.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"coeff(a::MPolyElem{T}, vars::Vector{Int}, exps::Vector{Int}) where T <: RingElement\ncoeff(a::T, vars::Vector{T}, exps::Vector{Int}) where T <: MPolyElem","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#coeff-Union{Tuple{T}, Tuple{MPolyElem{T}, Vector{Int64}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"coeff","text":"coeff(a::AbstractAlgebra.MPolyElem{T}, vars::Vector{Int}, exps::Vector{Int}) where T <: RingElement\n\nReturn the \"coefficient\" of a (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the variables of the given indices raised to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. coeff(f, [1, 3], [0, 2]) returns the coefficient of x^0*z^2 in the polynomial f (assuming variables x y z in that order).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#coeff-Union{Tuple{T}, Tuple{T, Vector{T}, Vector{Int64}}} where T<:MPolyElem","page":"Sparse distributed multivariate polynomials","title":"coeff","text":"coeff(a::T, vars::Vector{T}, exps::Vector{Int}) where T <: AbstractAlgebra.MPolyElem\n\nReturn the \"coefficient\" of a (as a multivariate polynomial in the same ring) of the monomial consisting of the product of the given variables to the given exponents (note that not all variables need to appear and the exponents can be zero). E.g. coeff(f, [x, z], [0, 2]) returns the coefficient of x^0*z^2 in the polynomial f.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y, z) = PolynomialRing(ZZ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\njulia> f = x^4*y^2*z^2 - 2x^4*y*z^2 + 4x^4*z^2 + 2x^2*y^2 + x + 1\nx^4*y^2*z^2 - 2*x^4*y*z^2 + 4*x^4*z^2 + 2*x^2*y^2 + x + 1\n\njulia> coeff(f, [1, 3], [4, 2]) == coeff(f, [x, z], [4, 2])\ntrue\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Inflation/deflation","page":"Sparse distributed multivariate polynomials","title":"Inflation/deflation","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"deflation(f::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#deflation-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"deflation","text":"deflation(f::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nCompute deflation parameters for the exponents of the polynomial f. This is a pair of arrays of integers, the first array of which (the shift) gives the minimum exponent for each variable of the polynomial, and the second of which (the deflation) gives the gcds of all the exponents after subtracting the shift, again per variable. This functionality is used by gcd (and can be used by factorisation algorithms).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"deflate(f::MPolyElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\ndeflate(f::MPolyElem{T}, defl::Vector{Int}) where T <: RingElement\ndeflate(f::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#deflate-Union{Tuple{T}, Tuple{MPolyElem{T}, Vector{Int64}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"deflate","text":"deflate(f::AbstractAlgebra.MPolyElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been reduced by the given shifts (supplied as an array of shifts, one for each variable), then deflated (divided) by the given exponents (again supplied as an array of deflation factors, one for each variable). The algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#deflate-Union{Tuple{T}, Tuple{MPolyElem{T}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"deflate","text":"deflate(f::AbstractAlgebra.MPolyElem{T}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been deflated (divided) by the given exponents (supplied as an array of deflation factors, one for each variable).\n\nThe algorithm automatically replaces a deflation of 0 by 1, to avoid division by 0.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#deflate-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"deflate","text":"deflate(f::AbstractAlgebra.MPolyElem{T}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been deflated maximally, i.e. with each exponent divide by the largest integer which divides the degrees of all exponents of that variable in f.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"inflate(f::MPolyElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\ninflate(f::MPolyElem{T}, defl::Vector{Int}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#inflate-Union{Tuple{T}, Tuple{MPolyElem{T}, Vector{Int64}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"inflate","text":"inflate(f::AbstractAlgebra.MPolyElem{T}, shift::Vector{Int}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable) and then increased by the given shifts (again supplied as an array of shifts, one for each variable).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#inflate-Union{Tuple{T}, Tuple{MPolyElem{T}, Vector{Int64}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"inflate","text":"inflate(f::AbstractAlgebra.MPolyElem{T}, defl::Vector{Int}) where T <: RingElement\n\nReturn a polynomial with the same coefficients as f but whose exponents have been inflated (multiplied) by the given deflation exponents (supplied as an array of inflation factors, one for each variable).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5x*y^5 - x*y^2\nx^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2\n\njulia> def, shift = deflation(f)\n([1, 2], [3, 3])\n\njulia> f1 = deflate(f, def, shift)\nx^2*y^2 + 3*x*y^2 - x + 5*y - 1\n\njulia> f2 = inflate(f1, def, shift)\nx^7*y^8 + 3*x^4*y^8 - x^4*y^2 + 5*x*y^5 - x*y^2\n\njulia> f2 == f\ntrue\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Conversions","page":"Sparse distributed multivariate polynomials","title":"Conversions","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"to_univariate(R::PolyRing{T}, p::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#to_univariate-Union{Tuple{T}, Tuple{PolyRing{T}, MPolyElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"to_univariate","text":"to_univariate(R::AbstractAlgebra.PolyRing{T}, p::AbstractAlgebra.MPolyElem{T}) where T <: AbstractAlgebra.RingElement\n\nAssuming the polynomial p is actually a univariate polynomial, convert the polynomial to a univariate polynomial in the given univariate polynomial ring R. An exception is raised if the polynomial p involves more than one variable.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> S, z = PolynomialRing(ZZ, \"z\")\n(Univariate Polynomial Ring in z over Integers, z)\n\njulia> f = 2x^5 + 3x^4 - 2x^2 - 1\n2*x^5 + 3*x^4 - 2*x^2 - 1\n\njulia> g = to_univariate(S, f)\n2*z^5 + 3*z^4 - 2*z^2 - 1\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Evaluation","page":"Sparse distributed multivariate polynomials","title":"Evaluation","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following function allows evaluation of a polynomial at all its variables. The result is always in the ring that a product of a coefficient and one of the values belongs to, i.e. if all the values are in the coefficient ring, the result of the evaluation will be too.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"evaluate(::MPolyElem{T}, ::Vector{U}) where {T <: RingElement, U <: RingElement}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T}, Vector{U}}} where {T<:RingElement, U<:RingElement}","page":"Sparse distributed multivariate polynomials","title":"evaluate","text":"evaluate(a::AbstractAlgebra.MPolyElem{T}, vals::Vector{U}) where {T <: RingElement, U <: RingElement}\n\nEvaluate the polynomial expression by substituting in the array of values for each of the variables. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of the supplied vector.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following functions allow evaluation of a polynomial at some of its variables. Note that the result will be a product of values and an element of the polynomial ring, i.e. even if all the values are in the coefficient ring and all variables are given values, the result will be a constant polynomial, not a coefficient.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"evaluate(::MPolyElem{T}, ::Vector{Int}, ::Vector{U}) where {T <: RingElement, U <: RingElement}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T}, Vector{Int64}, Vector{U}}} where {T<:RingElement, U<:RingElement}","page":"Sparse distributed multivariate polynomials","title":"evaluate","text":"evaluate(a::AbstractAlgebra.MPolyElem{T}, vars::Vector{Int}, vals::Vector{U}) where {T <: RingElement, U <: RingElement}\n\nEvaluate the polynomial expression by substituting in the supplied values in the array vals for the corresponding variables with indices given by the array vars. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of vals.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"evaluate(::S, ::Vector{S}, ::Vector{U}) where {S <: MPolyElem{T}, U <: RingElement} where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#evaluate-Union{Tuple{U}, Tuple{S}, Tuple{T}, Tuple{S, Vector{S}, Vector{U}}} where {T<:RingElement, S<:MPolyElem{T}, U<:RingElement}","page":"Sparse distributed multivariate polynomials","title":"evaluate","text":"evaluate(a::S, vars::Vector{S}, vals::Vector{U}) where {S <: AbstractAlgebra.MPolyElem{T}, U <: RingElement} where T <: RingElement\n\nEvaluate the polynomial expression by substituting in the supplied values in the array vals for the corresponding variables (supplied as polynomials) given by the array vars. The evaluation will succeed if multiplication is defined between elements of the coefficient ring of a and elements of vals.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The following function allows evaluation of a polynomial at values in a not necessarily commutative ring, e.g. elements of a matrix algebra.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"evaluate(::MPolyElem{T}, ::Vector{U}) where {T <: RingElement, U <: NCRingElem}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#evaluate-Union{Tuple{U}, Tuple{T}, Tuple{MPolyElem{T}, Vector{U}}} where {T<:RingElement, U<:NCRingElem}","page":"Sparse distributed multivariate polynomials","title":"evaluate","text":"evaluate(a::AbstractAlgebra.MPolyElem{T}, vals::Vector{U}) where {T <: RingElement, U <: NCRingElem}\n\nEvaluate the polynomial expression at the supplied values, which may be any ring elements, commutative or non-commutative, but in the same ring. Evaluation always proceeds in the order of the variables as supplied when creating the polynomial ring to which a belongs. The evaluation will succeed if a product of a coefficient of the polynomial by one of the values is defined.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = 2x^2*y^2 + 3x + y + 1\n2*x^2*y^2 + 3*x + y + 1\n\njulia> evaluate(f, BigInt[1, 2])\n14\n\njulia> evaluate(f, [QQ(1), QQ(2)])\n14//1\n\njulia> evaluate(f, [1, 2])\n14\n\njulia> f(1, 2) == 14\ntrue\n\njulia> evaluate(f, [x + y, 2y - x])\n2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1\n\njulia> f(x + y, 2y - x)\n2*x^4 - 4*x^3*y - 6*x^2*y^2 + 8*x*y^3 + 2*x + 8*y^4 + 5*y + 1\n\njulia> R, (x, y, z) = PolynomialRing(ZZ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y, z])\n\njulia> f = x^2*y^2 + 2x*z + 3y*z + z + 1\nx^2*y^2 + 2*x*z + 3*y*z + z + 1\n\njulia> evaluate(f, [1, 3], [3, 4])\n9*y^2 + 12*y + 29\n\njulia> evaluate(f, [x, z], [3, 4])\n9*y^2 + 12*y + 29\n\njulia> evaluate(f, [1, 2], [x + z, x - z])\nx^4 - 2*x^2*z^2 + 5*x*z + z^4 - z^2 + z + 1\n\njulia> S = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> M1 = S([1 2; 3 4])\n[1   2]\n[3   4]\n\njulia> M2 = S([2 3; 1 -1])\n[2    3]\n[1   -1]\n\njulia> M3 = S([-1 1; 1 1])\n[-1   1]\n[ 1   1]\n\njulia> evaluate(f, [M1, M2, M3])\n[ 64    83]\n[124   149]","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Leading-and-constant-coefficients,-leading-monomials-and-leading-terms","page":"Sparse distributed multivariate polynomials","title":"Leading and constant coefficients, leading monomials and leading terms","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The leading and trailing coefficient, constant coefficient, leading monomial and leading term of a polynomial p are returned by the following functions:","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"leading_coefficient(::MPolyElem{T}) where T <: RingElement\ntrailing_coefficient(p::MPolyElem{T}) where T <: RingElement\nleading_monomial(::MPolyElem{T}) where T <: RingElement\nleading_term(::MPolyElem{T}) where T <: RingElement\nconstant_coefficient(::MPolyElem{T}) where T <: RingElement\ntail(::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#leading_coefficient-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"leading_coefficient","text":"leading_coefficient(p::MPolyElem)\n\nReturn the leading coefficient of the polynomial p.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#trailing_coefficient-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"trailing_coefficient","text":"trailing_coefficient(p::MPolyElem)\n\nReturn the trailing coefficient of the polynomial p, i.e. the coefficient of the last nonzero term, or zero if the polynomial is zero.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#leading_monomial-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"leading_monomial","text":"leading_monomial(p::MPolyElem)\n\nReturn the leading monomial of p. This function throws an ArgumentError if p is zero.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#leading_term-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"leading_term","text":"leading_term(p::MPolyElem)\n\nReturn the leading term of the polynomial p. This function throws an ArgumentError if p is zero.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#constant_coefficient-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"constant_coefficient","text":"constant_coefficient(p::MPolyElem)\n\nReturn the constant coefficient of the polynomial p or zero if it doesn't have one.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#tail-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"tail","text":"tail(p::MPolyElem)\n\nReturn the tail of the polynomial p, i.e. the polynomial without its leading term (if any).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"using AbstractAlgebra\nR,(x,y) = PolynomialRing(ZZ, [\"x\", \"y\"], ordering=:deglex)\np = 2*x*y + 3*y^3 + 1\nleading_term(p)\nleading_monomial(p)\nleading_coefficient(p)\nleading_term(p) == leading_coefficient(p) * leading_monomial(p)\nconstant_coefficient(p)\ntail(p)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Least-common-multiple,-greatest-common-divisor","page":"Sparse distributed multivariate polynomials","title":"Least common multiple, greatest common divisor","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"The greated common divisor of two polynomials a and b is returned by","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"gcd(a::Generic.MPoly{T}, b::Generic.MPoly{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#gcd-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.MPoly{T}, AbstractAlgebra.Generic.MPoly{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"gcd","text":"gcd(a::MPoly{T}, a::MPoly{T}) where {T <: RingElement}\n\nReturn the greatest common divisor of a and b in parent(a).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that this functionality is currently only provided for AbstractAlgebra generic polynomials. It is not automatically provided for all multivariate rings that implement the multivariate interface.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"However, if such a gcd is provided, the least common multiple of two polynomials a and b is returned by","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"lcm(a::MPolyElem{T}, b::MPolyElem{T}) where {T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#lcm-Union{Tuple{T}, Tuple{MPolyElem{T}, MPolyElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"lcm","text":"lcm(a::AbstractAlgebra.MPolyElem{T}, a::AbstractAlgebra.MPolyElem{T}) where {T <: RingElement}\n\nReturn the least common multiple of a and b in parent(a).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> using AbstractAlgebra\n\njulia> R,(x,y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> a = x*y + 2*y\nx*y + 2*y\n\njulia> b = x^3*y + y\nx^3*y + y\n\njulia> gcd(a,b)\ny\n\njulia> lcm(a,b)\nx^4*y + 2*x^3*y + x*y + 2*y\n\njulia> lcm(a,b) == a * b // gcd(a,b)\ntrue\n","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Derivations","page":"Sparse distributed multivariate polynomials","title":"Derivations","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"derivative(::MPolyElem{T}, ::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#derivative-Union{Tuple{T}, Tuple{MPolyElem{T}, MPolyElem{T}}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"derivative","text":"derivative(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"julia> R, (x, y) = AbstractAlgebra.PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integers, AbstractAlgebra.Generic.MPoly{BigInt}[x, y])\n\njulia> f = x*y + x + y + 1\nx*y + x + y + 1\n\njulia> derivative(f, x)\ny + 1\n\njulia> derivative(f, y)\nx + 1\n\njulia> derivative(f, 1)\ny + 1\n\njulia> derivative(f, 2)\nx + 1","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#Homogeneous-polynomials","page":"Sparse distributed multivariate polynomials","title":"Homogeneous polynomials","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"It is possible to test whether a polynomial is homogeneous with respect to the standard grading using the function","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"ishomogeneous(x::MPolyElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/mpolynomial/#ishomogeneous-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Sparse distributed multivariate polynomials","title":"ishomogeneous","text":"ishomogeneous(x::MPoly{T}) where {T <: RingElement}\n\nReturn true if the given polynomial is homogeneous with respect to the standard grading and false otherwise.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/mpolynomial/#Random-generation","page":"Sparse distributed multivariate polynomials","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Random multivariate polynomials in a given ring can be constructed by passing a range of degrees for the variables and a range on the number of terms. Additional parameters are used to generate the coefficients of the polynomial.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Note that zero coefficients may currently be generated, leading to less than the requested number of terms.","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"rand(R::MPolyRing, exp_range::UnitRange{Int}, term_range::UnitRange{Int}, v...)","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"Examples","category":"page"},{"location":"AbstractAlgebra/mpolynomial/","page":"Sparse distributed multivariate polynomials","title":"Sparse distributed multivariate polynomials","text":"using AbstractAlgebra # hide\nR, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\nf = rand(R, -1:2, 3:5, -10:10)\n\nS, (s, t) = PolynomialRing(GF(7), [\"x\", \"y\"])\ng = rand(S, -1:2, 3:5)","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"using Oscar","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Pages = [\"quotients.md\"]","category":"page"},{"location":"Groups/quotients/#quotient","page":"Quotients","title":"Quotients","text":"","category":"section"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Quotient groups in Oscar can be defined using the instruction quo in two ways.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Quotients by normal subgroups.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"quo(G::T, H::T) where T <: GAPGroup","category":"page"},{"location":"Groups/quotients/#quo-Union{Tuple{T}, Tuple{T, T}} where T<:Oscar.GAPGroup","page":"Quotients","title":"quo","text":"quo([::Type{Q}, ]G::T, N::T) where {Q <: GAPGroup, T <: GAPGroup}\n\nReturn the quotient group G/N, together with the projection G -> G/N.\n\nIf Q is given then G/N has type Q if possible, and an exception is thrown if not.\n\nIf Q is not given then the type of G/N is not determined by the type of G.\n\nG/N may have the same type as G (which is reasonable if N is trivial),\nG/N may have type PcGroup (which is reasonable if G/N is finite and solvable), or\nG/N may have type PermGroup (which is reasonable if G/N is finite and non-solvable).\nG/N may have type FPGroup (which is reasonable if G/N is infinite).\n\nAn exception is thrown if N is not a normal subgroup of G.\n\nExamples\n\njulia> G = symmetric_group(4)\nSym( [ 1 .. 4 ] )\n\njulia> N = pcore(G, 2)[1];\n\njulia> typeof(quo(G, N)[1])\nPcGroup\n\njulia> typeof(quo(PermGroup, G, N)[1])\nPermGroup\n\n\n\n\n\n","category":"method"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Quotients by elements.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"quo(G::T, elements::Vector{S}) where T <: GAPGroup where S <: GAPGroupElem","category":"page"},{"location":"Groups/quotients/#quo-Union{Tuple{T}, Tuple{S}, Tuple{T, Vector{S}}} where {S<:GAPGroupElem, T<:Oscar.GAPGroup}","page":"Quotients","title":"quo","text":"quo([::Type{Q}, ]G::T, elements::Vector{elem_type(G)})) where {Q <: GAPGroup, T <: GAPGroup}\n\nReturn the quotient group G/N, together with the projection G -> G/N, where N is the normal closure of elements in G.\n\nSee quo(G::T, N::T) where T <: GAPGroup for information about the type of G/N.\n\n\n\n\n\n","category":"method"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"This is the typical way to build finitely presented groups.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Example:","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"julia> F=free_group(2);\n\njulia> (f1,f2)=gens(F);\n\njulia> G,_=quo(F,[f1^2,f2^3,(f1*f2)^2]);\n\njulia> isfinite(G)\ntrue\n\njulia> isisomorphic(G,symmetric_group(3))\ntrue","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"Similarly to the subgroups, the output consists of a pair (Q,p), where Q is the quotient group and p is the projection homomorphism of G into Q.","category":"page"},{"location":"Groups/quotients/","page":"Quotients","title":"Quotients","text":"maximal_abelian_quotient","category":"page"},{"location":"Groups/quotients/#maximal_abelian_quotient","page":"Quotients","title":"maximal_abelian_quotient","text":"maximal_abelian_quotient([::Type{Q}, ]G::GAPGroup) where Q <: Union{GAPGroup, GrpAbFinGen}\n\nReturn F, epi such that F is the largest abelian factor group of G and epi is an epimorphism from G to F.\n\nIf Q is given then F has type Q if possible, and an exception is thrown if not.\n\nIf Q is not given then the type of F is not determined by the type of G.\n\nF may have the same type as G (which is reasonable if G is abelian),\nF may have type PcGroup (which is reasonable if F is finite), or\nF may have type FPGroup (which is reasonable if F is infinite).\n\nExamples\n\njulia> G = symmetric_group(4);\n\njulia> F, epi = maximal_abelian_quotient(G);\n\njulia> order(F)\n2\n\njulia> domain(epi) === G && codomain(epi) === F\ntrue\n\njulia> typeof(F)\nPcGroup\n\njulia> typeof(maximal_abelian_quotient(free_group(1))[1])\nFPGroup\n\njulia> typeof(maximal_abelian_quotient(PermGroup, G)[1])\nPermGroup\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/map_cache/#Cached-maps","page":"Cached maps","title":"Cached maps","text":"","category":"section"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"All basic map (i.e. those not built up from other maps) in AbstractAlgebra can be cached.","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"A cache is a dictionary that can be switched on and off at run time that keeps a cache of previous evaluations of the map. This can be useful if the map is extremely difficult to evaluate, e.g. a discrete logarithm map. Rather than evaluate the map afresh each time, the map first looks up the dictionary of previous known values of the map.","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"To facilitate caching of maps, the Generic module provides a type Generic.MapCache, which can be used to wrap any existing map object with a dictionary.","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"Importantly, the supertype of the resulting Generic.MapCache object is identical to that of the map being cached. This means that any functions that would accept the original map will also accept the cached version.","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"note: Note\nCaching of maps only works for maps that correctly abstract access to their fields using accessor functions, as described in the map interface.","category":"page"},{"location":"AbstractAlgebra/map_cache/#Cached-map-constructors","page":"Cached maps","title":"Cached map constructors","text":"","category":"section"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"To construct a cached map from an existing map object, we have the following function:","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"cached(M::Map; enabled=true, limit=100)","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"Return a cached map with the same supertype as M, caching up to limit values of the map M in a dictionary, assuming that the cache is enabled.","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"Caches can be disabled by setting the value of the parameter enabled to false. This allows for the user to quickly go through code and completely disable caches of maps that were previously enabled, for testing purposes, etc.","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"Caches can also be turned on and off at run time (see below).","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"Examples","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"julia> f = map_from_func(x -> x + 1, ZZ, ZZ)\nMap with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> g = cached(f);\n\njulia> f(ZZ(1)) == g(ZZ(1))\ntrue","category":"page"},{"location":"AbstractAlgebra/map_cache/#Functionality-for-cached-maps","page":"Cached maps","title":"Functionality for cached maps","text":"","category":"section"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"The following functions are provided for cached maps.","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"enable_cache!(M::MapCache)\ndisable_cache!(M::MapCache)","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"Temporarily enable or disable the cache for the given map. The values stored in the cache are not lost when it is disabled.","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"set_limit!(M::MapCache, limit::Int)","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"Set the limit on the number of values that can be cached in the dictionary, to the given value. Setting the value to 0 will effectively disable further caching for this map.","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"Examples","category":"page"},{"location":"AbstractAlgebra/map_cache/","page":"Cached maps","title":"Cached maps","text":"julia> f = cached(map_from_func(x -> x + 1, ZZ, ZZ));\n\njulia> a = f(ZZ(1))\n2\n\njulia> disable_cache!(f)\n\njulia> b = f(ZZ(1))\n2\n\njulia> enable_cache!(f)\n\njulia> c = f(ZZ(1))\n2\n\njulia> set_limit!(f, 200)\n200\n\njulia> d = f(ZZ(1))\n2","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/#Free-algebras","page":"Free algebras","title":"Free algebras","text":"","category":"section"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"AbstractAlgebra.jl provides a module, implemented in src/FreeAssAlgebra.jl for free associative algebras over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/#Generic-free-algebra-types","page":"Free algebras","title":"Generic free algebra types","text":"","category":"section"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"AbstractAlgebra provides a generic type Generic.FreeAssAlgElem{T} where T is the type of elements of the coefficient ring. The elements are implemented using a Julia array of coefficients and a vector of vectors of Ints for the monomial words. Parent objects of such elements have type Generic.FreeAssAlgebra{T}.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"The element types belong to the abstract type NCRingElem, and the algebra types belong to the abstract type NCRing.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"The following basic functions are implemented.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"base_ring(R::FreeAssAlgebra)\nbase_ring(a::FreeAssAlgElem)\nparent(a::FreeAssAlgElem)\ncharacteristic(R::FreeAssAlgebra)","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/#Free-algebra-constructors","page":"Free algebras","title":"Free algebra constructors","text":"","category":"section"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"FreeAssociativeAlgebra(R::Ring, s::Union{AbstractVector{<:AbstractString}, AbstractVector{Symbol}, AbstractVector{Char}}; cached::Bool = true)\nFreeAssociativeAlgebra(R::Ring, n::Int, s::Union{String, Char, Symbol}; cached::Bool = false)","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"The first constructor, given a base ring R and an array s of variables, will return a tuple S, (x, ...) representing the new algebra S = R leftx ldots right and a tuple of generators (x ).","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"The second constructor given a string s and a number of variables n will do the same as the first constructor except that the variables will be automatically numbered as, s1, s2, ..., sn.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"By default the parent object S will depend only on R and  (x, ...) and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"julia> R, (x, y) = FreeAssociativeAlgebra(ZZ, [\"x\", \"y\"])\n(Free associative algebra over Integers on x, y, AbstractAlgebra.Generic.FreeAssAlgElem{BigInt}[x, y])\n\njulia> (x + y + 1)^2\nx^2 + x*y + y*x + y^2 + 2*x + 2*y + 1\n\n\njulia> (x*y*x*x)^4\nx*y*x^3*y*x^3*y*x^3*y*x^2","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/#Free-algebra-element-constructors","page":"Free algebras","title":"Free algebra element constructors","text":"","category":"section"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"Elements of a free algebra can be constructed from the generators in the usual way using arithmetic operations. Also, all of the standard ring element constructors may be used. Finally, the MPolyBuildCtx is overloaded to work with coefficients and monomial words and not exponent vectors.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"julia> R, (x, y, z) = FreeAssociativeAlgebra(ZZ, [\"x\", \"y\", \"z\"])\n(Free associative algebra over Integers on x, y, z, AbstractAlgebra.Generic.FreeAssAlgElem{BigInt}[x, y, z])\n\njulia> B = MPolyBuildCtx(R)\nBuilder for an element of Free associative algebra over Integers on x, y, z\n\njulia> push_term!(B, ZZ(1), [1,2,3,1]); push_term!(B, ZZ(2), [3,3,1]); finish(B)\nx*y*z*x + 2*z^2*x\n\njulia> push_term!(B, ZZ(3), [3,3,3]); push_term!(B, ZZ(4), Int[]); finish(B)\n3*z^3 + 4\n\njulia> [gen(R, 2), R(9)]\n2-element Vector{AbstractAlgebra.Generic.FreeAssAlgElem{BigInt}}:\n y\n 9","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/#Element-functions","page":"Free algebras","title":"Element functions","text":"","category":"section"},{"location":"AbstractAlgebra/free_associative_algebra/#Basic-manipulation","page":"Free algebras","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"The standard ring functions are available. The following functions from the multivariate polynomial interface are provided.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"symbols(S::FreeAssAlgebra)\nnvars(f::FreeAssAlgebra)\ngens(S::FreeAssAlgebra)\ngen(S::FreeAssAlgebra, i::Int)\nisgen(x::FreeAssAlgElem)\ntotal_degree(a::FreeAssAlgElem)\nlength(f::FreeAssAlgElem)","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"As with multivariate polynomials, an implementation must provide access to the elements as a sum of individual terms in some order. The length function provides the number of such terms, and the following functions provide the first such term.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"leading_coefficient(a::FreeAssAlgElem)\nleading_monomial(a::FreeAssAlgElem)\nleading_term(a::FreeAssAlgElem)\nleading_exponent_word(a::FreeAssAlgElem)","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"For types that allow constant time access to coefficients, the following are also available, allowing access to the given coefficient, monomial or term. Terms are numbered from the most significant first.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"coeff(f::FreeAssAlgElem, n::Int)\nmonomial(f::FreeAssAlgElem, n::Int)\nterm(f::FreeAssAlgElem, n::Int)","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"In contrast with the interface for multivariable polynomials, the function exponent_vector is replaced by exponent_word","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"exponent_word(a::Generic.FreeAssAlgElem{T}, i::Int) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/#exponent_word-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.FreeAssAlgElem{T}, Int64}} where T<:RingElement","page":"Free algebras","title":"exponent_word","text":"exponent_word(a::FreeAssAlgElem{T}, i::Int) where T <: RingElement\n\nReturn a vector of variable indices corresponding to the monomial of the i-th term of a. Term numbering begins at 1, and the variable indices are given in the order of the variables for the ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"julia> R, (x, y, z) = FreeAssociativeAlgebra(ZZ, [\"x\", \"y\", \"z\"])\n(Free associative algebra over Integers on x, y, z, AbstractAlgebra.Generic.FreeAssAlgElem{BigInt}[x, y, z])\n\njulia> map(total_degree, (R(0), R(1), -x^2*y^2*z^2*x + z*y))\n(-1, 0, 7)\n\njulia> leading_term(-x^2*y^2*z^2*x + z*y)\n-x^2*y^2*z^2*x\n\njulia> leading_monomial(-x^2*y^2*z^2*x + z*y)\nx^2*y^2*z^2*x\n\njulia> leading_coefficient(-x^2*y^2*z^2*x + z*y)\n-1\n\njulia> exponent_word(-x^2*y^2*z^2*x + z*y, 1)\n7-element Vector{Int64}:\n 1\n 1\n 2\n 2\n 3\n 3\n 1","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/#Iterators","page":"Free algebras","title":"Iterators","text":"","category":"section"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"The following iterators are provided for elements of a free associative algebra, with exponent_words providing the analogous functionality that exponent_vectors provides for multivariate polynomials.","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"terms(p::FreeAssAlgElem)\ncoefficients(p::FreeAssAlgElem)\nmonomials(p::FreeAssAlgElem)","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"exponent_words(a::FreeAssAlgElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/#exponent_words-Union{Tuple{FreeAssAlgElem{T}}, Tuple{T}} where T<:RingElement","page":"Free algebras","title":"exponent_words","text":"exponent_words(a::AbstractAlgebra.FreeAssAlgElem{T}) where T <: RingElement\n\nReturn an iterator for the exponent words of the given polynomial. To retrieve an array of the exponent words, use collect(exponent_words(a)).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"Examples","category":"page"},{"location":"AbstractAlgebra/free_associative_algebra/","page":"Free algebras","title":"Free algebras","text":"julia> R, (a, b, c) = FreeAssociativeAlgebra(ZZ, [\"a\", \"b\", \"c\"])\n(Free associative algebra over Integers on a, b, c, AbstractAlgebra.Generic.FreeAssAlgElem{BigInt}[a, b, c])\n\njulia> collect(terms(3*b*a*c - b + c + 2))\n4-element Vector{Any}:\n 3*b*a*c\n -b\n c\n 2\n\njulia> collect(coefficients(3*b*a*c - b + c + 2))\n4-element Vector{Any}:\n  3\n -1\n  1\n  2\n\njulia> collect(monomials(3*b*a*c - b + c + 2))\n4-element Vector{Any}:\n b*a*c\n b\n c\n 1\n\njulia> collect(exponent_words(3*b*a*c - b + c + 2))\n4-element Vector{Vector{Int64}}:\n [2, 1, 3]\n [2]\n [3]\n []","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/polynomial/#Univariate-polynomial-functionality","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"AbstractAlgebra.jl provides a module, implemented in src/Poly.jl for polynomials over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy. This functionality will work for any univariate polynomial type which follows the Univariate Polynomial Ring interface.","category":"page"},{"location":"AbstractAlgebra/polynomial/#Generic-univariate-polynomial-types","page":"Univariate polynomial functionality","title":"Generic univariate polynomial types","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"AbstractAlgebra.jl provides a generic polynomial type based on Julia arrays which is implemented in src/generic/Poly.jl.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"These generic polynomials have type Generic.Poly{T} where T is the type of elements of the coefficient ring. Internally they consist of a Julia array of coefficients and some additional fields for length and a parent object, etc. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Parent objects of such polynomials have type Generic.PolyRing{T}.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"The string representation of the variable of the polynomial ring and the base/coefficient ring R is stored in the parent object.","category":"page"},{"location":"AbstractAlgebra/polynomial/#Abstract-types","page":"Univariate polynomial functionality","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"All univariate polynomial element types belong to the abstract type PolyElem{T} and the polynomial ring types belong to the abstract type PolyRing{T}. This enables one to write generic functions that can accept any AbstractAlgebra polynomial type.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"note: Note\nBoth the generic polynomial ring type Generic.PolyRing{T} and the abstract type it belongs to, PolyRing{T}, are called PolyRing. The former is a (parameterised) concrete type for a polynomial ring over a given base ring whose elements have type T. The latter is an abstract type representing all polynomial ring types in AbstractAlgebra.jl, whether generic or very specialised (e.g. supplied by a C library).","category":"page"},{"location":"AbstractAlgebra/polynomial/#Polynomial-ring-constructors","page":"Univariate polynomial functionality","title":"Polynomial ring constructors","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"In order to construct polynomials in AbstractAlgebra.jl, one must first construct the polynomial ring itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"PolynomialRing(R::Ring, s::AbstractString; cached::Bool = true)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Given a base ring R and string s specifying how the generator (variable) should be printed, return a tuple S, x representing the new polynomial ring S = Rx and the generator x of the ring. By default the parent object S will depend only on R and x and will be cached. Setting the optional argument cached to false will prevent the parent object S from being cached.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"A shorthand version of this function is provided: given a base ring R, we abbreviate the constructor as follows.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R[\"x\"]","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"It is also possible to create a polynomial ring with default symbol as follows. This is a lightweight constructor and should be used in generic algorithms wherever possible when creating polynomial rings where the symbol does not matter.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"PolyRing(R::Ring)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Given a base ring R return the polynomial ring S = Rx. Note that unlike the constructors above, the return type is not a tuple. Only the ring is returned and not the generator. The polynomial ring is not cached.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Here are some examples of creating polynomial rings and their associated generators.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> T, z = QQ[\"z\"]\n(Univariate Polynomial Ring in z over Rationals, z)\n\njulia> U = PolyRing(ZZ)\nUnivariate Polynomial Ring in x over Integers","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"All of the examples here are generic polynomial rings, but specialised implementations of polynomial rings provided by external modules will also usually provide a PolynomialRing constructor to allow creation of their polynomial rings.","category":"page"},{"location":"AbstractAlgebra/polynomial/#Polynomial-constructors","page":"Univariate polynomial functionality","title":"Polynomial constructors","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"The easiest way is simply using the generator returned by the PolynomialRing constructor and build up the polynomial using basic arithmetic.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"The Julia language has special syntax for the construction of polynomials in terms of a generator, e.g. we can write 2x instead of 2*x.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"A second way is to use the polynomial ring to construct a polynomial. There are the usual ways of constructing an element of a ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"(R::PolyRing)() # constructs zero\n(R::PolyRing)(c::Integer)\n(R::PolyRing)(c::elem_type(R))\n(R::PolyRing{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"For polynommials there is also the following more general constructor accepting an array of coefficients.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"(S::PolyRing{T})(A::Vector{T}) where T <: RingElem\n(S::PolyRing{T})(A::Vector{U}) where T <: RingElem, U <: RingElem\n(S::PolyRing{T})(A::Vector{U}) where T <: RingElem, U <: Integer","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Construct the polynomial in the ring S with the given array of coefficients, i.e. where A[1] is the constant coefficient.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"A third way of constructing polynomials is to construct them directly without creating the polynomial ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"polynomial(R::Ring, arr::Vector{T}, var::String=\"x\"; cached::Bool=true)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Given an array of coefficients construct the polynomial with those coefficients over the given ring and with the given variable.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x^3 + 3x + 21\nx^3 + 3*x + 21\n\njulia> g = (x + 1)*y^2 + 2x + 1\n(x + 1)*y^2 + 2*x + 1\n\njulia> R()\n0\n\njulia> S(1)\n1\n\njulia> S(y)\ny\n\njulia> S(x)\nx\n\njulia> S, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> f = S(Rational{BigInt}[2, 3, 1])\nx^2 + 3*x + 2\n\njulia> g = S(BigInt[1, 0, 4])\n4*x^2 + 1\n\njulia> h = S([4, 7, 2, 9])\n9*x^3 + 2*x^2 + 7*x + 4\n\njulia> p = polynomial(ZZ, [1, 2, 3])\n3*x^2 + 2*x + 1\n\njulia> f = polynomial(ZZ, [1, 2, 3], \"y\")\n3*y^2 + 2*y + 1","category":"page"},{"location":"AbstractAlgebra/polynomial/#Similar-and-zero","page":"Univariate polynomial functionality","title":"Similar and zero","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Another way of constructing polynomials is to construct one similar to an existing polynomial using either similar or zero. ","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"similar(x::MyPoly{T}, R::Ring=base_ring(x)) where T <: RingElem\nzero(x::MyPoly{T}, R::Ring=base_ring(x)) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Construct the zero polynomial with the same variable as the given polynomial with coefficients in the given ring. Both functions behave the same way for polynomials.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"similar(x::MyPoly{T}, R::Ring, var::String=String(var(parent(x)))) where T <: RingElem\nsimilar(x::MyPoly{T}, var::String=String(var(parent(x)))) where T <: RingElem\nzero(x::MyPoly{T}, R::Ring, var::String=String(var(parent(x)))) where T <: RingElem\nzero(x::MyPoly{T}, var::String=String(var(parent(x)))) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Construct the zero polynomial with the given variable and coefficients in the given ring, if specified, and in the coefficient ring of the given polynomial otherwise.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> f = 1 + 2x + 3x^2\n3*x^2 + 2*x + 1\n\njulia> g = similar(f)\n0\n\njulia> h = similar(f, QQ)\n0\n\njulia> k = similar(f, QQ, \"y\")\n0","category":"page"},{"location":"AbstractAlgebra/polynomial/#Functions-for-types-and-parents-of-polynomial-rings","page":"Univariate polynomial functionality","title":"Functions for types and parents of polynomial rings","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"base_ring(R::PolyRing)\nbase_ring(a::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Return the coefficient ring of the given polynomial ring or polynomial.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"parent(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Return the polynomial ring of the given polynomial..","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"characteristic(R::NCRing)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Return the characteristic of the given polynomial ring. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> U = base_ring(S)\nUnivariate Polynomial Ring in x over Integers\n\njulia> V = base_ring(y + 1)\nUnivariate Polynomial Ring in x over Integers\n\njulia> T = parent(y + 1)\nUnivariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers","category":"page"},{"location":"AbstractAlgebra/polynomial/#Euclidean-polynomial-rings","page":"Univariate polynomial functionality","title":"Euclidean polynomial rings","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"For polynomials over a field, the Euclidean Ring Interface is implemented.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"mod(f::PolyElem, g::PolyElem)\ndivrem(f::PolyElem, g::PolyElem)\ndiv(f::PolyElem, g::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"mulmod(f::PolyElem, g::PolyElem, m::PolyElem)\npowermod(f::PolyElem, e::Int, m::PolyElem)\ninvmod(f::PolyElem, m::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"divides(f::PolyElem, g::PolyElem)\nremove(f::PolyElem, p::PolyElem)\nvaluation(f::PolyElem, p::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"gcd(f::PolyElem, g::PolyElem)\nlcm(f::PolyElem, g::PolyElem)\ngcdx(f::PolyElem, g::PolyElem)\ngcdinv(f::PolyElem, g::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> S = ResidueRing(R, x^3 + 3x + 1)\nResidue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> T, y = PolynomialRing(S, \"y\")\n(Univariate Polynomial Ring in y over Residue ring of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, y)\n\njulia> f = (3*x^2 + x + 2)*y + x^2 + 1\n(3*x^2 + x + 2)*y + x^2 + 1\n\njulia> g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\n(5*x^2 + 2*x + 1)*y^2 + 2*x*y + x + 1\n\njulia> h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n(2*x^2 - 8*x + 4)*y^5 + 2*x*y + 1\n\njulia> invmod(f, g)\n(707//3530*x^2 + 2151//1765*x + 123//3530)*y - 178//1765*x^2 - 551//3530*x + 698//1765\n\njulia> mulmod(f, g, h)\n(-30*x^2 - 43*x - 9)*y^3 + (-7*x^2 - 23*x - 7)*y^2 + (4*x^2 - 10*x - 3)*y + x^2 - 2*x\n\njulia> powermod(f, 3, h)\n(69*x^2 + 243*x + 79)*y^3 + (78*x^2 + 180*x + 63)*y^2 + (27*x^2 + 42*x + 18)*y + 3*x^2 + 3*x + 2\n\njulia> h = mod(f, g)\n(3*x^2 + x + 2)*y + x^2 + 1\n\njulia> q, r = divrem(f, g)\n(0, (3*x^2 + x + 2)*y + x^2 + 1)\n\njulia> div(g, f)\n(-5//11*x^2 + 2//11*x + 6//11)*y - 13//121*x^2 - 3//11*x - 78//121\n\njulia> d = gcd(f*h, g*h)\ny + 1//11*x^2 + 6//11\n\njulia> k = gcdinv(f, h)\n(y + 1//11*x^2 + 6//11, 0)\n\njulia> m = lcm(f, h)\n(-14*x^2 - 23*x - 2)*y - 4*x^2 - 5*x + 1\n\njulia> flag, q = divides(g^2, g)\n(true, (5*x^2 + 2*x + 1)*y^2 + 2*x*y + x + 1)\n\njulia> valuation(3g^3, g) == 3\ntrue\n\njulia> val, q = remove(5g^3, g)\n(3, 5)\n\njulia> r, s, t = gcdx(g, h)\n(1, 311//3530*x^2 - 2419//3530*x + 947//1765, (707//3530*x^2 + 2151//1765*x + 123//3530)*y - 178//1765*x^2 - 551//3530*x + 698//1765)\n","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Functions in the Euclidean Ring interface are supported over residue rings that are not fields, except that if an impossible inverse is encountered during the computation an error is thrown.","category":"page"},{"location":"AbstractAlgebra/polynomial/#Polynomial-functions","page":"Univariate polynomial functionality","title":"Polynomial functions","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/#Basic-functionality","page":"Univariate polynomial functionality","title":"Basic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"All basic ring functionality is provided for polynomials. The most important such functions are the following.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"zero(R::PolyRing)\none(R::PolyRing)\niszero(a::PolyElem)\nisone(a::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"divexact(a::T, b::T) where T <: PolyElem","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"All functions in the polynomial interface are provided. The most important are the following.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"var(S::PolyRing)\nsymbols(S::PolyRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Return a symbol or length 1 array of symbols, respectively, specifying the variable of the polynomial ring. This symbol is converted to a string when printing polynomials in that ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"In addition, the following basic functions are provided.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"modulus{T <: ResElem}(::PolyElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#modulus-Union{Tuple{PolyElem{T}}, Tuple{T}} where T<:ResElem","page":"Univariate polynomial functionality","title":"modulus","text":"modulus(a::PolyElem{T}) where {T <: ResElem}\n\nReturn the modulus of the coefficients of the given polynomial.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"leading_coefficient(::PolyElem)\ntrailing_coefficient(::PolyElem)\nconstant_coefficient(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#leading_coefficient-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"leading_coefficient","text":"leading_coefficient(a::PolynomialElem)\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\nleading_coefficient(p::MPolyElem)\n\nReturn the leading coefficient of the polynomial p.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#trailing_coefficient-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"trailing_coefficient","text":"trailing_coefficient(a::PolynomialElem)\n\nReturn the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial is the zero polynomial, in which case a zero coefficient is returned.\n\n\n\ntrailing_coefficient(p::MPolyElem)\n\nReturn the trailing coefficient of the polynomial p, i.e. the coefficient of the last nonzero term, or zero if the polynomial is zero.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#constant_coefficient-Tuple{PolynomialElem{T} where T}","page":"Univariate polynomial functionality","title":"constant_coefficient","text":"constant_coefficient(a::PolynomialElem)\n\nReturn the constant coefficient of the given polynomial. If the polynomial is the zero polynomial, the function will return zero.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"set_coefficient!(::PolynomialElem{T}, ::Int, c::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/polynomial/#set_coefficient!-Union{Tuple{T}, Tuple{PolynomialElem{T}, Int64, T}} where T<:RingElement","page":"Univariate polynomial functionality","title":"set_coefficient!","text":"set_coefficient!(c::PolynomialElem{T}, n::Int, a::T) where T <: RingElement\nset_coefficient!(c::PolynomialElem{T}, n::Int, a::U) where {T <: RingElement, U <: Integer}\n\nSet the coefficient of degree n to a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"tail(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#tail-Tuple{PolynomialElem{T} where T}","page":"Univariate polynomial functionality","title":"tail","text":"tail(a::PolynomialElem)\n\nReturn the tail of the given polynomial, i.e. the polynomial without its leading term (if any).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"gen(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#gen-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"gen","text":"gen(M::SubQuo{T}, i::Int) where T\n\nReturn the ith generator of M.\n\n\n\ngen(a::MPolyRing{T}, i::Int) where {T <: RingElement}\n\nReturn the i-th generator (variable) of the given polynomial ring.\n\n\n\ngen(R::AbsSeriesRing{T}) where T <: RingElement\n\nReturn the generator of the power series ring, i.e. x + O(x^n) where n is the precision of the power series ring R.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"isgen(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#isgen-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"isgen","text":"isgen(a::PolynomialElem)\n\nReturn true if the given polynomial is the constant generator of its polynomial ring, otherwise return false.\n\n\n\nisgen(x::MPoly{T}) where {T <: RingElement}\n\nReturn true if the given polynomial is a generator (variable) of the polynomial ring it belongs to.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"ismonic(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#ismonic-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"ismonic","text":"ismonic(a::PolynomialElem)\n\nReturn true if the given polynomial is monic, i.e. has leading coefficient equal to one, otherwise return false.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"issquare(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#issquare-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"issquare","text":"issquare(f::PolyElem{T}) where T <: RingElement\n\nReturn true if f is a perfect square.\n\n\n\nissquare(a::FracElem{T}) where T <: RingElem\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"length(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#length-Tuple{PolynomialElem{T} where T}","page":"Univariate polynomial functionality","title":"length","text":"length(a::PolynomialElem)\n\nReturn the length of the polynomial. The length of a univariate polynomial is defined to be the number of coefficients in its dense representation, including zero coefficients. Thus naturally the zero polynomial has length zero and additionally for nonzero polynomials the length is one more than the degree. (Note that the leading coefficient will always be nonzero.)\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"degree(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#degree-Tuple{PolynomialElem{T} where T}","page":"Univariate polynomial functionality","title":"degree","text":"degree(a::PolynomialElem)\n\nReturn the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"ismonomial(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#ismonomial-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"ismonomial","text":"ismonomial(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial.\n\n\n\nismonomial(x::AbstractAlgebra.MPolyElem)\n\nReturn true if the given polynomial has precisely one term whose coefficient is one.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"ismonomial_recursive(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#ismonomial_recursive-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"ismonomial_recursive","text":"ismonomial_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial is a monomial. This function is recursive, with all scalar types returning true.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"isterm(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#isterm-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"isterm","text":"isterm(a::PolynomialElem)\n\nReturn true if the given polynomial has one term.\n\n\n\nisterm(x::MPoly)\n\nReturn true if the given polynomial has precisely one term.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"isterm_recursive(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#isterm_recursive-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"isterm_recursive","text":"isterm_recursive(a::PolynomialElem)\n\nReturn true if the given polynomial has one term. This function is recursive, with all scalar types returning true.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"isconstant(::PolynomialElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#isconstant-Tuple{PolynomialElem{T} where T}","page":"Univariate polynomial functionality","title":"isconstant","text":"isconstant(a::PolynomialElem)\n\nReturn true if a is a degree zero polynomial or the zero polynomial, i.e. a constant polynomial.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> T, z = PolynomialRing(QQ, \"z\")\n(Univariate Polynomial Ring in z over Rationals, z)\n\njulia> U = ResidueRing(ZZ, 17)\nResidue ring of Integers modulo 17\n\njulia> V, w = PolynomialRing(U, \"w\")\n(Univariate Polynomial Ring in w over Residue ring of Integers modulo 17, w)\n\njulia> var(R)\n:x\n\njulia> symbols(R)\n1-element Vector{Symbol}:\n :x\n\njulia> a = zero(S)\n0\n\njulia> b = one(S)\n1\n\njulia> isone(b)\ntrue\n\njulia> c = BigInt(1)//2*z^2 + BigInt(1)//3\n1//2*z^2 + 1//3\n\njulia> d = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> f = leading_coefficient(d)\nx\n\njulia> y = gen(S)\ny\n\njulia> g = isgen(w)\ntrue\n\njulia> divexact((2x + 1)*(x + 1), (x + 1))\n2*x + 1\n\njulia> m = isunit(b)\ntrue\n\njulia> n = degree(d)\n2\n\njulia> r = modulus(w)\n17\n\njulia> isterm(2y^2)\ntrue\n\njulia> ismonomial(y^2)\ntrue\n\njulia> ismonomial_recursive(x*y^2)\ntrue\n\njulia> ismonomial(x*y^2)\nfalse\n\njulia> S, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> f = x^3 + 3x + 1\nx^3 + 3*x + 1\n\njulia> g = S(BigInt[1, 2, 0, 1, 0, 0, 0]);\n\njulia> n = length(f)\n4\n\njulia> c = coeff(f, 1)\n3\n\njulia> g = set_coefficient!(g, 2, ZZ(11))\nx^3 + 11*x^2 + 2*x + 1\n\njulia> g = set_coefficient!(g, 7, ZZ(4))\n4*x^7 + x^3 + 11*x^2 + 2*x + 1","category":"page"},{"location":"AbstractAlgebra/polynomial/#Iterators","page":"Univariate polynomial functionality","title":"Iterators","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"An iterator is provided to return the coefficients of a univariate polynomial. The iterator is called coefficients and allows iteration over the coefficients, starting with the term of degree zero (if there is one). Note that coefficients of each degree are given, even if they are zero. This is best illustrated by example.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> f = x^2 + 2\nx^2 + 2\n\njulia> C = collect(coefficients(f))\n3-element Vector{BigInt}:\n 2\n 0\n 1\n\njulia> for c in coefficients(f)\n          println(c)\n       end\n2\n0\n1","category":"page"},{"location":"AbstractAlgebra/polynomial/#Truncation","page":"Univariate polynomial functionality","title":"Truncation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"truncate(::PolyElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#truncate-Tuple{PolyElem, Int64}","page":"Univariate polynomial functionality","title":"truncate","text":"truncate(a::PolynomialElem, n::Int)\n\nReturn a truncated to n terms.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"mullow{T <: RingElem}(::PolyElem{T}, ::PolyElem{T}, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#mullow-Union{Tuple{T}, Tuple{PolyElem{T}, PolyElem{T}, Int64}} where T<:RingElem","page":"Univariate polynomial functionality","title":"mullow","text":"mullow(a::PolyElem{T}, b::PolyElem{T}, n::Int) where T <: RingElement\n\nReturn atimes b truncated to n terms.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> h = truncate(f, 1)\n3\n\njulia> k = mullow(f, g, 4)\n(x^2 + x)*y^3 + (x^4 + 3*x^2 + 4*x + 1)*y^2 + (x^4 + x^3 + 2*x^2 + 7*x + 5)*y + 3*x^3 + 6*x + 6\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Reversal","page":"Univariate polynomial functionality","title":"Reversal","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"reverse(::PolyElem, ::Int)\nreverse(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#reverse-Tuple{PolyElem, Int64}","page":"Univariate polynomial functionality","title":"reverse","text":"reverse(x::PolynomialElem, len::Int)\n\nReturn the reverse of the polynomial x, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length). The resulting polynomial is normalised. If len is negative we throw a DomainError().\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#reverse-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"reverse","text":"reverse(x::PolynomialElem)\n\nReturn the reverse of the polynomial x, i.e. the leading coefficient of x becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = reverse(f, 7)\n3*y^6 + (x + 1)*y^5 + x*y^4\n\njulia> h = reverse(f)\n3*y^2 + (x + 1)*y + x\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Shifting","page":"Univariate polynomial functionality","title":"Shifting","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"shift_left(::PolyElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#shift_left-Tuple{PolyElem, Int64}","page":"Univariate polynomial functionality","title":"shift_left","text":"shift_left(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted left by n terms, i.e. multiplied by x^n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"shift_right(::PolyElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#shift_right-Tuple{PolyElem, Int64}","page":"Univariate polynomial functionality","title":"shift_right","text":"shift_right(f::PolynomialElem, n::Int)\n\nReturn the polynomial f shifted right by n terms, i.e. divided by x^n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = shift_left(f, 7)\nx*y^9 + (x + 1)*y^8 + 3*y^7\n\njulia> h = shift_right(f, 2)\nx\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Inflation-and-deflation","page":"Univariate polynomial functionality","title":"Inflation and deflation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"deflation(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#deflation-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"deflation","text":"deflation(p::PolyElem)\n\nReturn a tuple (shift, defl) where shift is the exponent of the trailing term of p and defl is the gcd of the distance between the exponents of the nonzero terms of p. If p = 0, both shift and defl will be zero.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"inflate(::PolyElem, ::Int, ::Int)\ninflate(::PolyElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/polynomial/#inflate-Tuple{PolyElem, Int64, Int64}","page":"Univariate polynomial functionality","title":"inflate","text":"inflate(f::PolyElem, shift::Int64, n::Int64) -> PolyElem\n\nGiven a polynomial f in x, return f(x^n)*x^j, i.e. multiply all exponents by n and shift f left by j.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#inflate-Tuple{PolyElem, Int64}","page":"Univariate polynomial functionality","title":"inflate","text":"inflate(f::PolyElem, n::Int64) -> PolyElem\n\nGiven a polynomial f in x, return f(x^n), i.e. multiply all exponents by n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"deflate(::PolyElem, ::Int, ::Int)\ndeflate(::PolyElem, ::Int)\ndeflate(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#deflate-Tuple{PolyElem, Int64, Int64}","page":"Univariate polynomial functionality","title":"deflate","text":"deflate(f::PolyElem, shift::Int64, n::Int64) -> PolyElem\n\nGiven a polynomial g in x^n such that f = g(x)*x^{shift}, write f as a polynomial in x, i.e. divide all exponents of g by n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#deflate-Tuple{PolyElem, Int64}","page":"Univariate polynomial functionality","title":"deflate","text":"deflate(f::PolyElem, n::Int64) -> PolyElem\n\nGiven a polynomial f in x^n, write it as a polynomial in x, i.e. divide all exponents by n.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#deflate-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"deflate","text":"deflate(x::PolyElem) -> PolyElem, Int\n\nDeflate the polynomial f maximally, i.e. find the largest n s.th. f can be deflated by n, i.e. f is actually a polynomial in x^n. Return g n where g is the deflation of f.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#Square-root","page":"Univariate polynomial functionality","title":"Square root","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Base.sqrt(::PolyElem{T}; check::Bool) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/polynomial/#sqrt-Union{Tuple{PolyElem{T}}, Tuple{T}} where T<:RingElement","page":"Univariate polynomial functionality","title":"sqrt","text":"Base.sqrt(f::PolyElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R, x = PolynomialRing(ZZ, \"x\")\ng = x^2+6*x+1\nsqrt(g^2)","category":"page"},{"location":"AbstractAlgebra/polynomial/#Change-of-base-ring","page":"Univariate polynomial functionality","title":"Change of base ring","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"change_base_ring(::Ring, ::PolyElem{T}) where T <: RingElement\nchange_coefficient_ring(::Ring, ::PolyElem{T}) where T <: RingElement\nmap_coefficients(::Any, ::PolyElem{<:RingElement})","category":"page"},{"location":"AbstractAlgebra/polynomial/#change_base_ring-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring, PolyElem{T}}} where T<:RingElement","page":"Univariate polynomial functionality","title":"change_base_ring","text":"change_base_ring(R::Ring, p::PolyElem{<: RingElement}; parent::PolyRing)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#change_coefficient_ring-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring, PolyElem{T}}} where T<:RingElement","page":"Univariate polynomial functionality","title":"change_coefficient_ring","text":"change_coefficient_ring(R::Ring, p::PolyElem{<: RingElement}; parent::PolyRing)\n\nReturn the polynomial obtained by coercing the non-zero coefficients of p into R.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#map_coefficients-Tuple{Any, PolyElem{var\"#s271\"} where var\"#s271\"<:RingElement}","page":"Univariate polynomial functionality","title":"map_coefficients","text":"map_coefficients(f, p::PolyElem{<: RingElement}; cached::Bool=true, parent::PolyRing)\n\nTransform the polynomial p by applying f on each non-zero coefficient.\n\nIf the optional parent keyword is provided, the polynomial will be an element of parent. The caching of the parent object can be controlled via the cached keyword argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R, x = PolynomialRing(ZZ, \"x\")\ng = x^3+6*x + 1\nchange_base_ring(GF(2), g)\nchange_coefficient_ring(GF(2), g)","category":"page"},{"location":"AbstractAlgebra/polynomial/#Pseudodivision","page":"Univariate polynomial functionality","title":"Pseudodivision","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Given two polynomials a b, pseudodivision computes polynomials q and r with length(r)  length(b) such that L^d a = bq + r where d = length(a) - length(b) + 1 and L is the leading coefficient of b.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"We call q the pseudoquotient and r the pseudoremainder.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"pseudorem{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#pseudorem-Union{Tuple{T}, Tuple{PolyElem{T}, PolyElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"pseudorem","text":"pseudorem(f::PolyElem{T}, g::PolyElem{T}) where T <: RingElement\n\nReturn the pseudoremainder of f divided by g. If g = 0 we throw a DivideError().\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"pseudodivrem{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#pseudodivrem-Union{Tuple{T}, Tuple{PolyElem{T}, PolyElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"pseudodivrem","text":"pseudodivrem(f::PolyElem{T}, g::PolyElem{T}) where T <: RingElement\n\nReturn a tuple (q r) consisting of the pseudoquotient and pseudoremainder of f divided by g. If g = 0 we throw a DivideError().\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> h = pseudorem(f, g)\nx^7 + 3*x^5 + 2*x^4 + x^3 + 5*x^2 + 4*x + 1\n\njulia> q, r = pseudodivrem(f, g)\n((x^2 + x)*y - x^4 - x^2 + 1, x^7 + 3*x^5 + 2*x^4 + x^3 + 5*x^2 + 4*x + 1)\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Content-and-primitive-part","page":"Univariate polynomial functionality","title":"Content and primitive part","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"content(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#content-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"content","text":"content(a::PolyElem)\n\nReturn the content of a, i.e. the greatest common divisor of its coefficients.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"primpart(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#primpart-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"primpart","text":"primpart(a::PolyElem)\n\nReturn the primitive part of a, i.e. the polynomial divided by its content.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")\n\nk = x*y^2 + (x + 1)*y + 3\n\nn = content(k)\np = primpart(k*(x^2 + 1))","category":"page"},{"location":"AbstractAlgebra/polynomial/#Evaluation,-composition-and-substitution","page":"Univariate polynomial functionality","title":"Evaluation, composition and substitution","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"evaluate{T <: RingElem}(::PolyElem{T}, ::T)\nevaluate(::PolyElem, ::Integer)","category":"page"},{"location":"AbstractAlgebra/polynomial/#evaluate-Union{Tuple{T}, Tuple{PolyElem{T}, T}} where T<:RingElem","page":"Univariate polynomial functionality","title":"evaluate","text":"evaluate(a::PolyElem, b::T) where T <: RingElement\n\nEvaluate the polynomial expression a at the value b and return the result.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#evaluate-Tuple{PolyElem, Integer}","page":"Univariate polynomial functionality","title":"evaluate","text":"evaluate(a::PolyElem, b::T) where T <: RingElement\n\nEvaluate the polynomial expression a at the value b and return the result.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"compose(::PolyElem, ::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#compose-Tuple{PolyElem, PolyElem}","page":"Univariate polynomial functionality","title":"compose","text":"compose(a::PolyElem, b::PolyElem)\n\nCompose the polynomial a with the polynomial b and return the result, i.e. return acirc b.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"subst{T <: RingElem}(::PolyElem{T}, ::Any)","category":"page"},{"location":"AbstractAlgebra/polynomial/#subst-Union{Tuple{T}, Tuple{PolyElem{T}, Any}} where T<:RingElem","page":"Univariate polynomial functionality","title":"subst","text":"subst(f::PolyElem{T}, a::Any) where T <: RingElement\n\nEvaluate the polynomial f at a. Note that a can be anything, whether a ring element or not.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"We also overload the functional notation so that the polynomial f can be evaluated at a by writing f(a).","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (x + 1)*y + (x^3 + 2x + 2)\n(x + 1)*y + x^3 + 2*x + 2\n\njulia> M = R[x + 1 2x; x - 3 2x - 1]\n[x + 1       2*x]\n[x - 3   2*x - 1]\n\njulia> k = evaluate(f, 3)\n12*x + 6\n\njulia> m = evaluate(f, x^2 + 2x + 1)\nx^5 + 4*x^4 + 7*x^3 + 7*x^2 + 4*x + 4\n\njulia> n = compose(f, g)\n(x^3 + 2*x^2 + x)*y^2 + (2*x^5 + 2*x^4 + 4*x^3 + 9*x^2 + 6*x + 1)*y + x^7 + 4*x^5 + 5*x^4 + 5*x^3 + 10*x^2 + 8*x + 5\n\njulia> p = subst(f, M)\n[3*x^3 - 3*x^2 + 3*x + 4       6*x^3 + 2*x^2 + 2*x]\n[3*x^3 - 8*x^2 - 2*x - 3   6*x^3 - 8*x^2 + 2*x + 2]\n\njulia> q = f(M)\n[3*x^3 - 3*x^2 + 3*x + 4       6*x^3 + 2*x^2 + 2*x]\n[3*x^3 - 8*x^2 - 2*x - 3   6*x^3 - 8*x^2 + 2*x + 2]\n\njulia> r = f(23)\n552*x + 26\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Derivative-and-integral","page":"Univariate polynomial functionality","title":"Derivative and integral","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"derivative(::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#derivative-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"derivative","text":"derivative(a::PolynomialElem)\n\nReturn the derivative of the polynomial a.\n\n\n\nderivative(f::AbsSeriesElem{T})\n\nReturn the derivative of the power series f.\n\n\n\nderivative(f::RelSeriesElem{T})\n\nReturn the derivative of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> derivative(f)\n1 + 9*x^2 + O(x^9)\n\n\n\nderivative(f::AbstractAlgebra.MPolyElem{T}, j::Int) where {T <: RingElement}\n\nReturn the partial derivative of f with respect to j-th variable of the polynomial ring.\n\n\n\nderivative(f::AbstractAlgebra.MPolyElem{T}, x::AbstractAlgebra.MPolyElem{T}) where T <: RingElement\n\nReturn the partial derivative of f with respect to x. The value x must be a generator of the polynomial ring of f.\n\n\n\nderivative(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the derivative of the given Puiseux series a.\n\n\n\nderivative(x::spoly{T}, n::Int) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable of index n.\n\n\n\nderivative(x::spoly{T}, v::spoly{T}) where T <: Nemo.RingElem\n\nReturn the derivative of x with respect to the variable v.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"integral{T <: Union{ResElem, FieldElem}}(::PolyElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#integral-Union{Tuple{PolyElem{T}}, Tuple{T}} where T<:Union{FieldElem, ResElem}","page":"Univariate polynomial functionality","title":"integral","text":"integral(x::PolyElem{T}) where {T <: Union{ResElem, FieldElement}}\n\nReturn the integral of the polynomial x.\n\n\n\nintegral(f::AbsSeriesElem{T})\n\nReturn the integral of the power series f.\n\n\n\nintegral(f::RelSeriesElem{T})\n\nReturn the integral of the power series f.\n\njulia> R, x = PowerSeriesRing(QQ, 10, \"x\")\n(Univariate power series ring in x over Rationals, x + O(x^11))\n\njulia> f = 2 + x + 3x^3\n2 + x + 3*x^3 + O(x^10)\n\njulia> integral(f)\n2*x + 1//2*x^2 + 3//4*x^4 + O(x^11)\n\n\n\nintegral(f::RelSeriesElem{T}) -> RelSeriesElem\n\nReturn the integral of the power series f.\n\n\n\nintegral(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the integral of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> T, z = PolynomialRing(QQ, \"z\")\n(Univariate Polynomial Ring in z over Rationals, z)\n\njulia> U = ResidueRing(T, z^3 + 3z + 1)\nResidue ring of Univariate Polynomial Ring in z over Rationals modulo z^3 + 3*z + 1\n\njulia> V, w = PolynomialRing(U, \"w\")\n(Univariate Polynomial Ring in w over Residue ring of Univariate Polynomial Ring in z over Rationals modulo z^3 + 3*z + 1, w)\n\njulia> f = x*y^2 + (x + 1)*y + 3\nx*y^2 + (x + 1)*y + 3\n\njulia> g = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n(z^2 + 2*z + 1)*w^2 + (z + 1)*w - 2*z + 4\n\njulia> h = derivative(f)\n2*x*y + x + 1\n\njulia> k = integral(g)\n(1//3*z^2 + 2//3*z + 1//3)*w^3 + (1//2*z + 1//2)*w^2 + (-2*z + 4)*w\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Resultant-and-discriminant","page":"Univariate polynomial functionality","title":"Resultant and discriminant","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"sylvester_matrix{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#sylvester_matrix-Union{Tuple{T}, Tuple{PolyElem{T}, PolyElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"sylvester_matrix","text":"sylvester_matrix(p::PolyElem, q::PolyElem)\n\nReturn the sylvester matrix of the given polynomials.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"resultant{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#resultant-Union{Tuple{T}, Tuple{PolyElem{T}, PolyElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"resultant","text":"resultant(p::PolyElem{T}, q::PolyElem{T}) where T <: RingElement\n\nReturn the resultant of the given polynomials.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"resx{T <: RingElem}(::PolyElem{T}, ::PolyElem{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#resx-Union{Tuple{T}, Tuple{PolyElem{T}, PolyElem{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"resx","text":"resx(a::PolyElem{T}, b::PolyElem{T}) where T <: RingElement\n\nReturn a tuple (r s t) such that r is the resultant of a and b and such that r = atimes s + btimes t.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"discriminant(a::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#discriminant-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"discriminant","text":"discriminant(a::PolyElem)\n\nReturn the discriminant of the given polynomial.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = 3x*y^2 + (x + 1)*y + 3\n3*x*y^2 + (x + 1)*y + 3\n\njulia> g = 6(x + 1)*y + (x^3 + 2x + 2)\n(6*x + 6)*y + x^3 + 2*x + 2\n\njulia> S = sylvester_matrix(f, g)\n[    3*x           x + 1               3]\n[6*x + 6   x^3 + 2*x + 2               0]\n[      0         6*x + 6   x^3 + 2*x + 2]\n\njulia> h = resultant(f, g)\n3*x^7 + 6*x^5 - 6*x^3 + 96*x^2 + 192*x + 96\n\njulia> k = discriminant(f)\nx^2 - 34*x + 1\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Newton-representation","page":"Univariate polynomial functionality","title":"Newton representation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"monomial_to_newton!{T <: RingElem}(::Vector{T}, ::Vector{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#monomial_to_newton!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"monomial_to_newton!","text":"monomial_to_newton!(P::Vector{T}, roots::Vector{T}) where T <: RingElement\n\nConverts a polynomial p, given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots r_0 r_1 ldots r_n-2. In other words, this determines output coefficients c_i such that c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + ldots + c_n-1(x-r_0)(x-r_1)cdots(x-r_n-2) is equal to the input polynomial.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"newton_to_monomial!{T <: RingElem}(::Vector{T}, ::Vector{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#newton_to_monomial!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"newton_to_monomial!","text":"newton_to_monomial!(P::Vector{T}, roots::Vector{T}) where T <: RingElement\n\nConverts a polynomial p, given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots r_0 r_1 ldots r_n-2 to the standard monomial basis. In other words, this evaluates c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + ldots + c_n-1(x-r_0)(x-r_1)cdots(x-r_n-2) where c_i are the input coefficients given by p.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = 3x*y^2 + (x + 1)*y + 3\n3*x*y^2 + (x + 1)*y + 3\n\njulia> g = deepcopy(f)\n3*x*y^2 + (x + 1)*y + 3\n\njulia> roots = [R(1), R(2), R(3)]\n3-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1\n 2\n 3\n\njulia> monomial_to_newton!(g.coeffs, roots)\n\njulia> newton_to_monomial!(g.coeffs, roots)","category":"page"},{"location":"AbstractAlgebra/polynomial/#Roots","page":"Univariate polynomial functionality","title":"Roots","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"roots(f::PolyElem)\nroots(f::PolyElem, R::Field)","category":"page"},{"location":"AbstractAlgebra/polynomial/#roots-Tuple{PolyElem}","page":"Univariate polynomial functionality","title":"roots","text":"roots(f::PolyElem)\n\nReturns the roots of the polynomial f in the base ring of f as an array.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#roots-Tuple{PolyElem, AbstractAlgebra.Field}","page":"Univariate polynomial functionality","title":"roots","text":"roots(f::PolyElem, R::Field)\n\nReturns the roots of the polynomial f in the field R as an array.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/#Interpolation","page":"Univariate polynomial functionality","title":"Interpolation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"interpolate{T <: RingElem}(::PolyRing, ::Vector{T}, ::Vector{T})","category":"page"},{"location":"AbstractAlgebra/polynomial/#interpolate-Union{Tuple{T}, Tuple{PolyRing, Vector{T}, Vector{T}}} where T<:RingElem","page":"Univariate polynomial functionality","title":"interpolate","text":"interpolate(S::PolyRing, x::Vector{T}, y::Vector{T}) where T <: RingElement\n\nGiven two arrays of values xs and ys of the same length n, find the polynomial f in the polynomial ring R of length at most n such that f has the value ys at the points xs. The values in the arrays xs and ys must belong to the base ring of the polynomial ring R. If no such polynomial exists, an exception is raised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> xs = [R(1), R(2), R(3), R(4)]\n4-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1\n 2\n 3\n 4\n\njulia> ys = [R(1), R(4), R(9), R(16)]\n4-element Vector{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1\n 4\n 9\n 16\n\njulia> f = interpolate(S, xs, ys)\ny^2\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Power-sums","page":"Univariate polynomial functionality","title":"Power sums","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"polynomial_to_power_sums(::PolyElem{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/#polynomial_to_power_sums-Union{Tuple{PolyElem{T}}, Tuple{T}} where T<:RingElem","page":"Univariate polynomial functionality","title":"polynomial_to_power_sums","text":"polynomial_to_power_sums(f::PolyElem{T}, n::Int=degree(f)) where T <: RingElement -> Vector{T}\n\nUses Newton (or Newton-Girard) formulas to compute the first n sums of powers of the roots of f from the coefficients of f, starting with the sum of (first powers of) the roots. The input polynomial must be monic, at least degree 1 and have nonzero constant coefficient.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"power_sums_to_polynomial(::Vector{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/polynomial/#power_sums_to_polynomial-Union{Tuple{Vector{T}}, Tuple{T}} where T<:RingElem","page":"Univariate polynomial functionality","title":"power_sums_to_polynomial","text":"power_sums_to_polynomial(P::Vector{T};\n                 parent::AbstractAlgebra.PolyRing{T}=\n\nAbstractAlgebra.PolyRing(parent(P[1])) where T <: RingElement -> PolyElem{T}\n\nUses the Newton (or Newton-Girard) identities to obtain the polynomial with given sums of powers of roots. The list must be nonempty and contain degree(f) entries where f is the polynomial to be recovered. The list must start with the sum of first powers of the roots.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> f = x^4 - 2*x^3 + 10*x^2 + 7*x - 5\nx^4 - 2*x^3 + 10*x^2 + 7*x - 5\n\njulia> V = polynomial_to_power_sums(f)\n4-element Vector{BigInt}:\n   2\n -16\n -73\n  20\n\njulia> power_sums_to_polynomial(V)\nx^4 - 2*x^3 + 10*x^2 + 7*x - 5","category":"page"},{"location":"AbstractAlgebra/polynomial/#Special-functions","page":"Univariate polynomial functionality","title":"Special functions","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"The following special functions can be computed for any polynomial ring. Typically one uses the generator x of a polynomial ring to get the respective special polynomials expressed in terms of that generator.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"chebyshev_t(::Int, ::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#chebyshev_t-Tuple{Int64, PolyElem}","page":"Univariate polynomial functionality","title":"chebyshev_t","text":"chebyshev_t(n::Int, x::PolyElem)\n\nReturn the Chebyshev polynomial of the first kind T_n(x), defined by T_n(x) = cos(n cos^-1(x)).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"chebyshev_u(::Int, ::PolyElem)","category":"page"},{"location":"AbstractAlgebra/polynomial/#chebyshev_u-Tuple{Int64, PolyElem}","page":"Univariate polynomial functionality","title":"chebyshev_u","text":"chebyshev_u(n::Int, x::PolyElem)\n\nReturn the Chebyshev polynomial of the first kind U_n(x), defined by (n+1) U_n(x) = T_n+1(x).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integers, y)\n\njulia> f = chebyshev_t(20, y)\n524288*y^20 - 2621440*y^18 + 5570560*y^16 - 6553600*y^14 + 4659200*y^12 - 2050048*y^10 + 549120*y^8 - 84480*y^6 + 6600*y^4 - 200*y^2 + 1\n\njulia> g = chebyshev_u(15, y)\n32768*y^15 - 114688*y^13 + 159744*y^11 - 112640*y^9 + 42240*y^7 - 8064*y^5 + 672*y^3 - 16*y\n","category":"page"},{"location":"AbstractAlgebra/polynomial/#Random-generation","page":"Univariate polynomial functionality","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"One may generate random polynomials with degrees in a given range. Additional parameters are used to construct coefficients as elements of the coefficient ring.","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"rand(R::PolyRing, deg_range::UnitRange{Int}, v...)\nrand(R::PolyRing, deg::Int, v...)","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/polynomial/","page":"Univariate polynomial functionality","title":"Univariate polynomial functionality","text":"R, x = PolynomialRing(ZZ, \"x\")\nf = rand(R, -1:3, -10:10)\n\nS, y = PolynomialRing(GF(7), \"y\")\ng = rand(S, 2:2)\n\nU, z = PolynomialRing(R, \"z\")\nh = rand(U, 3:3, -1:2, -10:10)","category":"page"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"DocTestSetup = quote\n    using Hecke\nend","category":"page"},{"location":"Hecke/abelian/introduction/#AbelianGroupLink","page":"Abelian Groups","title":"Abelian Groups","text":"","category":"section"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"Here we describe the interface to abelian groups in Hecke.","category":"page"},{"location":"Hecke/abelian/introduction/#Introduction","page":"Abelian Groups","title":"Introduction","text":"","category":"section"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"Within Hecke, abelian groups are of generic abstract type GrpAb which does not have to be finitely generated, mathbb Qmathbb Z is an example of a more general abelian group. Having said that, most of the functionality is restricted to abelian groups that are finitely presented as mathbb Z-modules.","category":"page"},{"location":"Hecke/abelian/introduction/#Basic-Creation","page":"Abelian Groups","title":"Basic Creation","text":"","category":"section"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"Finitely presented (as mathbb Z-modules) abelian groups are of type GrpAbFinGen with elements of type GrpAbFinGenElem. The creation is mostly via a relation matrix M = (m_ij) for 1le ile n and 1le jle m. This creates a group with m generators e_j and relations","category":"page"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"   sum_i=1^n m_ij e_j = 0","category":"page"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"abelian_group(M::fmpz_mat)\nabelian_group(M::Matrix{fmpz})\nabelian_group(M::Matrix{Integer})","category":"page"},{"location":"Hecke/abelian/introduction/#abelian_group-Tuple{fmpz_mat}","page":"Abelian Groups","title":"abelian_group","text":"abelian_group(::Type{T} = GrpAbFinGen, M::fmpz_mat) -> GrpAbFinGen\n\nCreates the abelian group with relation matrix M. That is, the group will have ncols(M) generators and each row of M describes one relation.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#abelian_group-Tuple{Matrix{fmpz}}","page":"Abelian Groups","title":"abelian_group","text":"abelian_group(::Type{T} = GrpAbFinGen, M::AbstractMatrix{<:IntegerUnion})\n\nCreates the abelian group with relation matrix M. That is, the group will have ncols(M) generators and each row of M describes one relation.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#abelian_group-Tuple{Matrix{Integer}}","page":"Abelian Groups","title":"abelian_group","text":"abelian_group(::Type{T} = GrpAbFinGen, M::AbstractMatrix{<:IntegerUnion})\n\nCreates the abelian group with relation matrix M. That is, the group will have ncols(M) generators and each row of M describes one relation.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"Alternatively, there are shortcuts to create products of cyclic groups:","category":"page"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"abelian_group(M::Vector{Union{fmpz, Integer}})","category":"page"},{"location":"Hecke/abelian/introduction/#abelian_group-Tuple{Vector{Union{Integer, fmpz}}}","page":"Abelian Groups","title":"abelian_group","text":"abelian_group(::Type{T} = GrpAbFinGen, M::AbstractVector{<:IntegerUnion}) -> GrpAbFinGen\nabelian_group(::Type{T} = GrpAbFinGen, M::IntegerUnion...) -> GrpAbFinGen\n\nCreates the direct product of the cyclic groups mathbfZm_i, where m_i is the ith entry of M.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"using Hecke # hide\nG = abelian_group(2, 2, 6)","category":"page"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"or even","category":"page"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"free_abelian_group(::Int)\nabelian_groups(n::Int)","category":"page"},{"location":"Hecke/abelian/introduction/#free_abelian_group-Tuple{Int64}","page":"Abelian Groups","title":"free_abelian_group","text":"free_abelian_group(::Type{T} = GrpAbFinGen, n::Int) -> GrpAbFinGen\n\nCreates the free abelian group of rank n.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#abelian_groups-Tuple{Int64}","page":"Abelian Groups","title":"abelian_groups","text":"abelian_groups(n::Int) -> Vector{GrpAbFinGen}\n\nGiven a positive integer n, return a list of all abelian groups of order n.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"using Hecke # hide\nabelian_groups(8)","category":"page"},{"location":"Hecke/abelian/introduction/#Invariants","page":"Abelian Groups","title":"Invariants","text":"","category":"section"},{"location":"Hecke/abelian/introduction/","page":"Abelian Groups","title":"Abelian Groups","text":"issnf(A::GrpAbFinGen)\nngens(A::GrpAbFinGen)\nnrels(G::GrpAbFinGen)\nrels(A::GrpAbFinGen)\nisfinite(A::GrpAbFinGen)\nisinfinite(A::GrpAbFinGen)\nrank(A::GrpAbFinGen)\norder(A::GrpAbFinGen)\nexponent(A::GrpAbFinGen)\nistrivial(A::GrpAbFinGen)\nistorsion(G::GrpAbFinGen)\niscyclic(G::GrpAbFinGen)\nelementary_divisors(G::GrpAbFinGen)","category":"page"},{"location":"Hecke/abelian/introduction/#issnf-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"issnf","text":"issnf(G::GrpAbFinGen) -> Bool\n\nReturns whether the current relation matrix of the group G is in Smith normal form.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#ngens-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"ngens","text":"ngens(G::GrpAbFinGen) -> Int\n\nReturns the number of generators of G in the current representation.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#nrels-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"nrels","text":"nrels(G::GrpAbFinGen) -> Int\n\nReturns the number of relations of G in the current representation.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#rels-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"rels","text":"rels(A::GrpAbFinGen) -> fmpz_mat\n\nReturns the currently used relations of G as a single matrix.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#isfinite-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"isfinite","text":"isfinite(A::GrpAbFinGen) -> Bool\n\nReturns whether A is finite.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#isinfinite-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"isinfinite","text":"isinfinite(A::GrpAbFinGen) -> Bool\n\nReturns whether A is infinite.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#rank-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"rank","text":"rank(A::GrpAbFinGen) -> Int\n\nReturns the rank of A, that is, the dimension of the mathbfQ-vectorspace A otimes_mathbf Z mathbf Q.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#order-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"order","text":"order(A::GrpAbFinGen) -> fmpz\n\nReturns the order of A. It is assumed that A is finite.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#exponent-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"exponent","text":"exponent(A::GrpAbFinGen) -> fmpz\n\nReturns the exponent of A. It is assumed that A is finite.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#istrivial-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"istrivial","text":"istrivial(A::GrpAbFinGen) -> Bool\n\nChecks if A is the trivial group.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#istorsion-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"istorsion","text":"istorsion(G::GrpAbFinGen) -> Bool\n\nReturns true if and only if G is a torsion group.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#iscyclic-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"iscyclic","text":"iscyclic(G::GrpAbFinGen) -> Bool\n\nReturns whether G is cyclic.\n\n\n\n","category":"method"},{"location":"Hecke/abelian/introduction/#elementary_divisors-Tuple{GrpAbFinGen}","page":"Abelian Groups","title":"elementary_divisors","text":"elementary_divisors(G::GrpAbFinGen) -> Vector{fmpz}\n\nGiven G, returns the elementary divisors of G, that is, the unique positive integers e_1dotsce_k with e_i mid e_i + 1 and G cong mathbfZe_1mathbfZ times dotsb times mathbfZe_kmathbfZ.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Quotient-modules","page":"Quotient modules","title":"Quotient modules","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"AbstractAlgebra allows the construction of quotient modules/spaces of AbstractAlgebra modules over euclidean domains. These are given as the quotient of a module by a submodule of that module.","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"We define two quotient modules to be equal if they are quotients of the same module M by two equal submodules.","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Generic-quotient-module-type","page":"Quotient modules","title":"Generic quotient module type","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"AbstractAlgebra implements the generic quotient module type Generic.QuotientModule{T} where T is the element type of the base ring, in src/generic/QuotientModule.jl.","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Elements of generic quotient modules have type Generic.QuotientModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Abstract-types","page":"Quotient modules","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Quotient module types belong to the FPModule{T} abstract type and their elements to FPModuleElem{T}.","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Constructors","page":"Quotient modules","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"quo(M::FPModule{T}, v::Generic.Submodule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/quotient_module/#quo-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.Generic.Submodule{T}}} where T<:RingElement","page":"Quotient modules","title":"quo","text":"quo(m::FPModule{T}, subm::FPModule{T}) where T <: RingElement\n\nReturn the quotient M of the module m by the module subm (which must have been (transitively) constructed as a submodule of m or be m itself) along with the canonical quotient map from m to M.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Note that a preimage of the canonical projection can be obtained using the preimage function described in the section on module homomorphisms. Note that a preimage element of the canonical projection is not unique and has no special properties.","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> N, f = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> Q, g = quo(M, N)\n(Quotient module over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Free module of rank 2 over Integers\nCodomain: Quotient module over Integers with 1 generator and no relations\n)\n\njulia> p = M([ZZ(3), ZZ(1)])\n(3, 1)\n\njulia> v2 = g(p)\n(-5)\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> N, f = sub(V, [m])\n(Subspace over Rationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Subspace over Rationals with 1 generator and no relations\n\nCodomain: Vector space of dimension 2 over Rationals)\n\njulia> Q, g = quo(V, N)\n(Quotient space over:\nRationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Vector space of dimension 2 over Rationals\nCodomain: Quotient space over:\nRationals with 1 generator and no relations\n)\n","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Functionality-for-submodules","page":"Quotient modules","title":"Functionality for submodules","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"In addition to the Module interface, AbstractAlgebra submodules implement the following functionality.","category":"page"},{"location":"AbstractAlgebra/quotient_module/#Basic-manipulation","page":"Quotient modules","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"supermodule(M::Generic.QuotientModule{T}) where T <: RingElement\n\ndim(N::Generic.QuotientModule{T}) where T <: FieldElement","category":"page"},{"location":"AbstractAlgebra/quotient_module/#supermodule-Union{Tuple{AbstractAlgebra.Generic.QuotientModule{T}}, Tuple{T}} where T<:RingElement","page":"Quotient modules","title":"supermodule","text":"supermodule(M::QuotientModule{T}) where T <: RingElement\n\nReturn the module that this module is a quotient of.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/quotient_module/#dim-Union{Tuple{AbstractAlgebra.Generic.QuotientModule{T}}, Tuple{T}} where T<:FieldElement","page":"Quotient modules","title":"dim","text":"dim(N::QuotientModule{T}) where T <: FieldElement\n\nReturn the dimension of the given vector quotient space.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"Examples","category":"page"},{"location":"AbstractAlgebra/quotient_module/","page":"Quotient modules","title":"Quotient modules","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> m = M([ZZ(2), ZZ(3)])\n(2, 3)\n\njulia> N, g = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 2 over Integers)\n\njulia> Q, h = quo(M, N)\n(Quotient module over Integers with 2 generators and relations:\n[2 3], Module homomorphism with\nDomain: Free module of rank 2 over Integers\nCodomain: Quotient module over Integers with 2 generators and relations:\n[2 3])\n\njulia> supermodule(Q) == M\ntrue\n\njulia> V = VectorSpace(QQ, 2)\nVector space of dimension 2 over Rationals\n\njulia> m = V([QQ(1), QQ(2)])\n(1//1, 2//1)\n\njulia> N, f = sub(V, [m])\n(Subspace over Rationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Subspace over Rationals with 1 generator and no relations\n\nCodomain: Vector space of dimension 2 over Rationals)\n\njulia> Q, g = quo(V, N)\n(Quotient space over:\nRationals with 1 generator and no relations\n, Module homomorphism with\nDomain: Vector space of dimension 2 over Rationals\nCodomain: Quotient space over:\nRationals with 1 generator and no relations\n)\n\njulia> dim(V)\n2\n\njulia> dim(Q)\n1\n","category":"page"},{"location":"AbstractAlgebra/ring_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"AbstractAlgebra/ring_introduction/","page":"Introduction","title":"Introduction","text":"A rich ring hierarchy is provided, supporting both commutative and noncommutative rings.","category":"page"},{"location":"AbstractAlgebra/ring_introduction/","page":"Introduction","title":"Introduction","text":"A number of basic rings are provided, such as the integers, integers mod n and numerous fields.","category":"page"},{"location":"AbstractAlgebra/ring_introduction/","page":"Introduction","title":"Introduction","text":"A recursive rings implementation is then built on top of the basic rings via a number of generic ring constructions. These include univariate and multivariate polynomials and power series, univariate Laurent and Puiseux series, residue rings, matrix algebras, etc.","category":"page"},{"location":"AbstractAlgebra/ring_introduction/","page":"Introduction","title":"Introduction","text":"Where possible, these constructions can be built on top of one another in generic towers.","category":"page"},{"location":"AbstractAlgebra/ring_introduction/","page":"Introduction","title":"Introduction","text":"The ring hierarchy can be extended by implementing new rings to follow one or more ring interfaces. Generic functionality provided by the system is then automatically available for the new rings. These implementations can either be generic or can be specialised implementations provided by, for example, a C library.","category":"page"},{"location":"AbstractAlgebra/ring_introduction/","page":"Introduction","title":"Introduction","text":"In most cases, the interfaces consist of a set of constructors and functions that must be implemented to satisfy the interface. These are the functions that the generic code relies on being available.","category":"page"},{"location":"Hecke/number_fields/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/number_fields/intro/#NumberFieldsLink","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Hecke/number_fields/intro/","page":"Introduction","title":"Introduction","text":"By definition, mathematically a number field is just a finite extension of the rational mathbfQ. In Hecke, a number field L is recursively defined as being the field of rational numbers mathbfQ or a finite extension of a number field K. In the second case, the extension can be defined in the one of the following two ways:","category":"page"},{"location":"Hecke/number_fields/intro/","page":"Introduction","title":"Introduction","text":"We have L = Kx(f), where f in Kx is an irreducible polynomial (simple extension), or\nWe have L = Kx_1dotscx_n(f_1(x_1)dotscf_n(x_n)), where f_1dotscf_n in Kx are univariate polynomials (non-simple extension).","category":"page"},{"location":"Hecke/number_fields/intro/","page":"Introduction","title":"Introduction","text":"In both cases we refer to K as the base field of the number field L. Another useful dichotomy comes from the type of the base field. We call L an absolute number field, if the base field is equal to the rational numbers mathbfQ.","category":"page"},{"location":"AbstractAlgebra/types/#Type-interface-of-AbstractAlgebra.jl","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"Apart from how we usually think of types in programming, we shall in this section discuss why we do not use the typical type interface.","category":"page"},{"location":"AbstractAlgebra/types/#Why-types-aren't-enough","page":"Type interface of AbstractAlgebra.jl","title":"Why types aren't enough","text":"","category":"section"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"Naively, one might have expected that structures like rings in AbstractAlgebra.jl could be modeled as types and their elements as objects with the given type. But there are various reasons why this is not a good model.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"Consider the ring R = mathbbZnmathbbZ for a multiprecision integer n. If we were to model the ring R as a type, then the type would somehow need to contain the modulus n. This is not possible in Julia, and in fact it is not desirable, since the compiler would then recompile all the associated functions every time a different modulus n was used.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"We could attach the modulus n to the objects representing elements of the ring, rather than their type.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"But now we cannot create new elements of the ring mathbbZnmathbbZ given only their type, since the type no longer contains the modulus n.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"Instead, the way we get around this in AbstractAlgebra.jl is to have special (singleton) objects that act like types, but are really just ordinary Julia objects. These objects, called parent objects, can contain extra information, such as the modulus n. In return, we associate this parent object with so called element objects.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"In order to create new elements of mathbbZnmathbbZ as above, we overload the call operator for the parent object.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"In the following AbstractAlgebra.jl example, we create the parent object R corresponding to the ring mathbbZ7mathbbZ. We then create a new element a of this ring by calling the parent object R.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"R = ResidueRing(ZZ, 7)\na = R(3)","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"Here, R is the parent object, containing the modulus 7. So this example creates the element a = 3 pmod7.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"Objects known as parents which contain additional information about groups, rings, fields and modules, etc., that can't be stored in types alone.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"These details are technical and can be skipped or skimmed by new users of Julia/AbstractAlgebra.jl. Types are almost never dealt with directly when scripting AbstractAlgebra.jl to do mathematical computations.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"In contrast, AbstractAlgebra.jl developers will want to know how we model mathematical objects and their rings, fields, groups, etc.","category":"page"},{"location":"AbstractAlgebra/types/#The-abstract-type-hierarchy-in-AbstractAlgebra.jl","page":"Type interface of AbstractAlgebra.jl","title":"The abstract type hierarchy in AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"In AbstractAlgebra.jl, we use the abstract type hierarchy in order to give structure when programming the mathematical structures. For example, abstract types in Julia can belong to one another in a hierarchy.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"For example, the Field abstract type belongs to the Ring abstract type. The full hierarchy can be seen in diagrams under the section on visualisation of the abstract types.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"In practice this is practical since it means that any generic function designed to work with ring objects will also work with field objects.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"In AbstractAlgebra.jl we also distinguish between the elements of a field, say, and the field itself.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"For example, we have an object of type Generic.PolyRing to model a generic polynomial ring, and elements of that polynomial ring would have type Generic.PolyElem.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"For this purpose, we also have a hierarchy of abstract types, such as FieldElem, that the types of element objects can belong to.","category":"page"},{"location":"AbstractAlgebra/types/#More-complex-example-of-parent-objects","page":"Type interface of AbstractAlgebra.jl","title":"More complex example of parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"Here is some code which constructs a polynomial ring over the integers, a polynomial in that ring and then does some introspection to illustrate the various relations between the objects and types.","category":"page"},{"location":"AbstractAlgebra/types/","page":"Type interface of AbstractAlgebra.jl","title":"Type interface of AbstractAlgebra.jl","text":"using AbstractAlgebra\n\nR, x = ZZ[\"x\"]\n\nf = x^2 + 3x + 1\n\ntypeof(R) <: PolyRing\n\ntypeof(f) <: PolyElem\n\nparent(f) == R","category":"page"},{"location":"General/serialization/","page":"Serialization","title":"Serialization","text":"Pages = [\"serialization.md\"]","category":"page"},{"location":"General/serialization/#Serialization","page":"Serialization","title":"Serialization","text":"","category":"section"},{"location":"General/serialization/","page":"Serialization","title":"Serialization","text":"For some of our datatypes we provide a way to save them in and load them from JSON format. This is still experimental and it will take some time until all corners of OSCAR are covered by this effort. The goal of this effort is threefold:","category":"page"},{"location":"General/serialization/","page":"Serialization","title":"Serialization","text":"Avoid recomputation by providing an easy way to store data.\nIncrease portability by giving a convenient possibility to transport data.\nIncrease overall software quality by testing against existing data and tracking errors through data computed by different versions.","category":"page"},{"location":"General/serialization/","page":"Serialization","title":"Serialization","text":"save\nload","category":"page"},{"location":"General/serialization/#save","page":"Serialization","title":"save","text":"save(obj::T, filename::String) where T\n\nSave an object T to a file.\n\n\n\n","category":"function"},{"location":"General/serialization/#load","page":"Serialization","title":"load","text":"load(filename::String)\n\nLoad the object stored in a file.\n\n\n\n","category":"function"},{"location":"ToricVarieties/AlgebraicCycles/","page":"Algebraic Cycles","title":"Algebraic Cycles","text":"CurrentModule = Oscar","category":"page"},{"location":"ToricVarieties/AlgebraicCycles/","page":"Algebraic Cycles","title":"Algebraic Cycles","text":"Pages = [\"AlgebraicCycles.md\"]","category":"page"},{"location":"ToricVarieties/AlgebraicCycles/#Algebraic-Cycles","page":"Algebraic Cycles","title":"Algebraic Cycles","text":"","category":"section"},{"location":"ToricVarieties/AlgebraicCycles/#Special-attributes-of-toric-varieties","page":"Algebraic Cycles","title":"Special attributes of toric varieties","text":"","category":"section"},{"location":"ToricVarieties/AlgebraicCycles/","page":"Algebraic Cycles","title":"Algebraic Cycles","text":"chow_ring(v::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/AlgebraicCycles/#chow_ring-Tuple{Oscar.AbstractNormalToricVariety}","page":"Algebraic Cycles","title":"chow_ring","text":"chow_ring(v::AbstractNormalToricVariety)\n\nReturn the Chow ring of the simplicial and complete toric variety v.\n\nExamples\n\njulia> p2 = projective_space(NormalToricVariety, 2);\n\njulia> ngens(chow_ring(p2))\n3\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"using Oscar","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Pages = [\"ideals.md\"]","category":"page"},{"location":"CommutativeAlgebra/ideals/#Ideals-in-Multivariate-Rings","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Types","page":"Ideals in Multivariate Rings","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The OSCAR type for ideals in multivariate polynomial rings is of parametrized form MPolyIdeal{T}, where T is the element type of the polynomial ring.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Constructors","page":"Ideals in Multivariate Rings","title":"Constructors","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"ideal(g::Vector{T}) where {T <: MPolyElem}","category":"page"},{"location":"CommutativeAlgebra/ideals/#ideal-Union{Tuple{Vector{T}}, Tuple{T}} where T<:MPolyElem","page":"Ideals in Multivariate Rings","title":"ideal","text":"ideal(g::Vector{T}) where {T <: MPolyElem}\n\nideal(g::Vector{T}) where {T <: MPolyElem_dec}\n\nGiven a vector g of polynomials in a polynomial ring R, say, return the ideal of R generated by these polynomials.\n\nIn the graded case, assure that the entries of g are homogeneous.\n\nideal(R::MPolyRing, g::Vector)\n\nGiven a vector g of polynomials in R, return the ideal of R generated by these polynomials.\n\nIn the graded case, assure that the entries of g are homogeneous.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R, [x*y-3*x,y^3-2*x^2*y])\nideal(x*y - 3*x, -2*x^2*y + y^3)\n\njulia> typeof(I)\nMPolyIdeal{fmpq_mpoly}\n\njulia> S, (x, y) = GradedPolynomialRing(QQ, [\"x\", \"y\"],  [1, 2])\n(Multivariate Polynomial Ring in x, y over Rational Field graded by\n  x -> [1]\n  y -> [2], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y])\n\njulia> J = ideal(S, [(x^2+y)^2])\nideal(x^4 + 2*x^2*y + y^2)\n\njulia> typeof(J)\nMPolyIdeal{MPolyElem_dec{fmpq, fmpq_mpoly}}\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Gröbner-Bases","page":"Ideals in Multivariate Rings","title":"Gröbner Bases","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Algorithmic means to deal with ideals in multivariate polynomial rings are provided by the concept of Gröbner bases and the workhorse of this concept, Buchberger's algorithm for computing Gröbner bases. For both the concept and the algorithm a convenient way of ordering the monomials appearing in multivariate polynomials and, thus, to distinguish leading terms of such polynomials is needed.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"note: Note\nThe performance of Buchberger's algorithm and the resulting Gröbner basis depend crucially on the choice of monomial ordering.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Monomial-Orderings","page":"Ideals in Multivariate Rings","title":"Monomial Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Given a ring R, we write Rx=Rx_1 ldots x_n for the polynomial ring over R in the set of variables x=x_1 ldots x_n. Monomials in x=x_1 ldots x_n are written using multi–indices: If alpha=(alpha_1 ldots alpha_n)in N^n, set x^alpha=x_1^alpha_1cdots x_n^alpha_n and ","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"textMon_n(x) =  textMon_n(x_1 ldots x_n) = x^alpha mid alpha in N^n","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"A monomial ordering on textMon_n(x)  is a total  ordering  on textMon_n(x) such that","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta Longrightarrow x^gamma x^alpha  x^gamma  x^beta\n text for all  alpha beta gamma in mathbb N^n","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"A monomial ordering  on textMon_n(x) is called","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"global if x^alpha  1 for all alpha not = (0 dots 0),\nlocal if  x^alpha  1 for all alpha not = (0 dots 0), and\nmixed if it is neither global nor local.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"We then also say that  is a global , local, or mixed monomial ordering on Rx.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Some monomial orderings are predefined in OSCAR.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Predefined-Global-Orderings","page":"Ideals in Multivariate Rings","title":"Predefined Global Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#The-Lexicographical-Ordering","page":"Ideals in Multivariate Rings","title":"The Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The lexicographical ordering lex is defined by setting","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#The-Degree-Lexicographical-Ordering","page":"Ideals in Multivariate Rings","title":"The Degree Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The degree lexicographical ordering deglex is defined by setting deg(x^alpha) = alpha_1 + cdots + alpha_n and","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow   deg(x^alpha)  deg(x^beta)  text or  exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#The-Reverse-Lexicographical-Ordering","page":"Ideals in Multivariate Rings","title":"The Reverse Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The reverse lexicographical ordering revlex is defined by setting","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i   beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#The-Degree-Reverse-Lexicographical-Ordering","page":"Ideals in Multivariate Rings","title":"The Degree Reverse Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The degree reverse lexicographical ordering degrevlex is defined by setting deg(x^alpha) = alpha_1 + cdots + alpha_n and","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow  deg(x^alpha)  deg(x^beta)  text or exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#Weighted-Lexicographical-Orderings","page":"Ideals in Multivariate Rings","title":"Weighted Lexicographical Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"If W is a vector of positive integers  w_1 dots w_n, the weighted lexicographical ordering wdeglex(W)  is defined by setting textwdeg(x^alpha) = w_1alpha_1 + cdots + w_nalpha_n and","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow   textwdeg(x^alpha)  textwdeg(x^beta)  text or  exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#Weighted-Reverse-Lexicographical-Orderings","page":"Ideals in Multivariate Rings","title":"Weighted Reverse Lexicographical Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"If W is a vector of positive integers  w_1 dots w_n, the weighted reverse lexicographical ordering wdegrevlex(W)  is defined by setting textwdeg(x^alpha) = w_1alpha_1 + cdots + w_nalpha_n and","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow  textwdeg(x^alpha)  textwdeg(x^beta)  text or exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#Predefined-Local-Orderings","page":"Ideals in Multivariate Rings","title":"Predefined Local Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#The-Negative-Lexicographical-Ordering","page":"Ideals in Multivariate Rings","title":"The Negative Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The negative lexicographical ordering neglex is defined by setting","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#The-Negative-Degree-Lexicographical-Ordering","page":"Ideals in Multivariate Rings","title":"The Negative Degree Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The negative degree lexicographical ordering negdeglex is defined by setting deg(x^alpha) = alpha_1 + cdots + alpha_n and","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow   deg(x^alpha)  deg(x^beta)  text or  exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#The-Negative-Reverse-Lexicographical-Ordering","page":"Ideals in Multivariate Rings","title":"The Negative Reverse Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The negative reverse lexicographical ordering negrevlex is defined by setting","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i   beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#The-Negative-Degree-Reverse-Lexicographical-Ordering","page":"Ideals in Multivariate Rings","title":"The Negative Degree Reverse Lexicographical Ordering","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The negative degree reverse lexicographical ordering negdegrevlex is defined by setting deg(x^alpha) = alpha_1 + cdots + alpha_n and","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow  deg(x^alpha)  deg(x^beta)  text or exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#Negative-Weighted-Lexicographical-Orderings","page":"Ideals in Multivariate Rings","title":"Negative Weighted Lexicographical Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"If W is a vector of positive integers  w_1 dots w_n, the negative weighted lexicographical ordering negwdeglex(W)  is defined by setting textwdeg(x^alpha) = w_1alpha_1 + cdots + w_nalpha_n and","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow   textwdeg(x^alpha)  textwdeg(x^beta)  text or  exists  1 leq i leq n alpha_1 = beta_1 dots alpha_i-1 = beta_i-1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#Negative-Weighted-Reverse-Lexicographical-Orderings","page":"Ideals in Multivariate Rings","title":"Negative Weighted Reverse Lexicographical Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"If W is a vector of positive integers  w_1 dots w_n, the negative weighted reverse lexicographical ordering negwdegrevlex(W)  is defined by setting textwdeg(x^alpha) = w_1alpha_1 + cdots + w_nalpha_n and","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha  x^beta   Leftrightarrow  textwdeg(x^alpha)  textwdeg(x^beta)  text or exists  1 leq i leq n alpha_n = beta_n dots alpha_i+1 = beta_i+1 alpha_i  beta_i","category":"page"},{"location":"CommutativeAlgebra/ideals/#Creating-Block-Orderings","page":"Ideals in Multivariate Rings","title":"Creating Block Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The concept of block orderings allows one to construct new monomial orderings from already given ones: If _1 and _2 are monomial orderings on textMon_s(x_1 ldots x_s) and textMon_n-s(x_s+1 ldots x_n), respectively, then the block ordering =(_1 _2) on textMon_n(x)=textMon_n(x_1 ldots x_n) is defined by setting","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alphax^beta  Leftrightarrow  x_1^alpha_1cdots x_s^alpha_s _1 x_1^beta_1cdots x_s^beta_s text or \nbigl(x_1^alpha_1cdots x_s^alpha_s = x_1^beta_1cdots x_s^beta_s text and   x_s+1^alpha_s+1cdots x_n^alpha_n _2\nx_s+1^beta_s+1cdots x_n^beta_nbigr)","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Note that =(_1 _2) is global (local) iff both _1 and _2 are global (local). Mixed orderings arise by choosing one of _1 and _2 global and the other one local.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Creating-Matrix-Orderings","page":"Ideals in Multivariate Rings","title":"Creating Matrix Orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Given a matrix Min textGL(nmathbb R), with rows m_1dotsm_n, the matrix ordering defined by M is obtained by setting","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"x^alpha_M x^beta  Leftrightarrow  exists 1leq ileq n  m_1alpha=m_1betaldots \nm_i-1alpha =m_i-1beta m_ialpham_ibeta","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"(here, alpha and beta are regarded as column vectors).","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"note: Note\nBy a theorem of Robbiano, every monomial ordering arises as a matrix ordering as above.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"To create matrix orderings, OSCAR allows for matrices with integer coefficients as input matrices.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Functions-for-creating-orderings","page":"Ideals in Multivariate Rings","title":"Functions for creating orderings","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"When computing Gröbner bases an ordering must be supplied. Standard Singular orderings, including block orderings, weighted orderings and local orderings are available.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The basic orderings are :lex, :revlex, :deglex, :degrevlex, :neglex, :negrevlex, :negdeglex, :negdegrevlex, :wdeglex, :wdegrevlex, :negwdeglex and :negwdegrevlex.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The orderings starting with w are weighted orderings.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The following functions exist for creating orderings:","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"lex(::AbstractVector{<:MPolyElem})\nrevlex(::AbstractVector{<:MPolyElem})\ndeglex(::AbstractVector{<:MPolyElem})\ndegrevlex(::AbstractVector{<:MPolyElem})\nneglex(::AbstractVector{<:MPolyElem})\nnegrevlex(::AbstractVector{<:MPolyElem})\nnegdeglex(::AbstractVector{<:MPolyElem})\nnegdegrevlex(::AbstractVector{<:MPolyElem})","category":"page"},{"location":"CommutativeAlgebra/ideals/#lex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem}","page":"Ideals in Multivariate Rings","title":"lex","text":"lex(v::AbstractVector{<:MPolyElem}) -> MonomialOrdering\n\nDefines the lex (lexicographic) ordering on the variables given.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#revlex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem}","page":"Ideals in Multivariate Rings","title":"revlex","text":"revlex(v::AbstractVector{<:MPolyElem}) -> MonomialOrdering\n\nDefines the revlex ordering on the variables given.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#deglex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem}","page":"Ideals in Multivariate Rings","title":"deglex","text":"deglex(v::AbstractVector{<:MPolyElem}) -> MonomialOrdering\n\nDefines the deglex ordering on the variables given.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#degrevlex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem}","page":"Ideals in Multivariate Rings","title":"degrevlex","text":"degrevlex(v::AbstractVector{<:MPolyElem}) -> MonomialOrdering\n\nDefines the degrevlex ordering on the variables given.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#neglex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem}","page":"Ideals in Multivariate Rings","title":"neglex","text":"neglex(v::AbstractVector{<:MPolyElem}) -> MonomialOrdering\n\nDefines the neglex ordering on the variables given.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#negrevlex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem}","page":"Ideals in Multivariate Rings","title":"negrevlex","text":"negrevlex(v::AbstractVector{<:MPolyElem}) -> MonomialOrdering\n\nDefines the negrevlex ordering on the variables given.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#negdeglex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem}","page":"Ideals in Multivariate Rings","title":"negdeglex","text":"negdeglex(v::AbstractVector{<:MPolyElem}) -> MonomialOrdering\n\nDefines the negdeglex ordering on the variables given.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#negdegrevlex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem}","page":"Ideals in Multivariate Rings","title":"negdegrevlex","text":"negdegrevlex(v::AbstractVector{<:MPolyElem}) -> MonomialOrdering\n\nDefines the negdegrevlex ordering on the variables given.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"wdeglex(::AbstractVector{<:MPolyElem}, ::Vector{Int})\nwdegrevlex(::AbstractVector{<:MPolyElem}, ::Vector{Int})\nnegwdeglex(::AbstractVector{<:MPolyElem}, ::Vector{Int})\nnegwdegrevlex(::AbstractVector{<:MPolyElem}, ::Vector{Int})\nmatrix_ordering(::AbstractVector{<:MPolyElem}, ::fmpz_mat)","category":"page"},{"location":"CommutativeAlgebra/ideals/#wdeglex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem, Vector{Int64}}","page":"Ideals in Multivariate Rings","title":"wdeglex","text":"wdeglex(v::AbstractVector{<:MPolyElem}, w::Vector{Int}) -> MonomialOrdering\n\nDefines the wdeglex ordering on the variables given with the weights w.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#wdegrevlex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem, Vector{Int64}}","page":"Ideals in Multivariate Rings","title":"wdegrevlex","text":"wdegrevlex(v::AbstractVector{<:MPolyElem}, w::Vector{Int}) -> MonomialOrdering\n\nDefines the wdegrevlex ordering on the variables given with the weights w.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#negwdeglex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem, Vector{Int64}}","page":"Ideals in Multivariate Rings","title":"negwdeglex","text":"negwdeglex(v::AbstractVector{<:MPolyElem}, w::Vector{Int}) -> MonomialOrdering\n\nDefines the negwdeglex ordering on the variables given with the weights w.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#negwdegrevlex-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem, Vector{Int64}}","page":"Ideals in Multivariate Rings","title":"negwdegrevlex","text":"negwdegrevlex(v::AbstractVector{<:MPolyElem}, w::Vector{Int}) -> MonomialOrdering\n\nDefines the negwdegrevlex ordering on the variables given with the weights w.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#matrix_ordering-Tuple{AbstractVector{var\"#s271\"} where var\"#s271\"<:MPolyElem, fmpz_mat}","page":"Ideals in Multivariate Rings","title":"matrix_ordering","text":"matrix_ordering(v::AbstractVector{<:MPolyElem}, M::fmpz_mat) -> MonomialOrdering\n\nDefines the matrix ordering on the variables given with the matrix M.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Block orderings can be obtained by concatening monomial orderings using the * operator.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Term over position and position over term module orderings are also available. These are also specified byy concatenation using the * operator. One creates the requisite module ordering (lex or revlex) for the generators of the free module.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Term over position is specified by appending the module ordering to the monomial ordering and position over term by prepending the module ordering.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Examples","page":"Ideals in Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"R, (x, y, s, t, u) = PolynomialRing(QQ, [\"x\", \"y\", \"s\", \"t\", \"u\"])\nO1 = degrevlex(gens(R))\nO2 = lex([x, y])*deglex([s, t, u])\nO3 = wdeglex(gens(R), [2, 3, 5, 7, 3])\n\nK = FreeModule(R, 3)\nO4 = revlex(gens(K))*degrevlex(gens(R))","category":"page"},{"location":"CommutativeAlgebra/ideals/#Normal-Forms","page":"Ideals in Multivariate Rings","title":"Normal Forms","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"normal_form(f::T, J::MPolyIdeal) where { T <: MPolyElem }\nnormal_form(A::Vector{T}, J::MPolyIdeal) where { T <: MPolyElem }","category":"page"},{"location":"CommutativeAlgebra/ideals/#normal_form-Union{Tuple{T}, Tuple{T, MPolyIdeal}} where T<:MPolyElem","page":"Ideals in Multivariate Rings","title":"normal_form","text":"normal_form(f::T, J::MPolyIdeal) where { T <: MPolyElem }\n\nCompute the normal form of the polynomial f w.r.t. a Groebner basis of J.\n\nCAVEAT: This computation needs a Groebner basis of J. If this Groebner basis is not available, one is computed automatically. This may take some time.\n\nExamples\n\njulia> R,(a,b,c) = PolynomialRing(QQ,[\"a\",\"b\",\"c\"])\n(Multivariate Polynomial Ring in a, b, c over Rational Field, fmpq_mpoly[a, b, c])\n\njulia> J = ideal(R,[-1+c+b,-1+b+c*a+2*a*b])\nideal(b + c - 1, 2*a*b + a*c + b - 1)\n\njulia> groebner_basis(J)\n2-element Vector{fmpq_mpoly}:\n b + c - 1\n a*c - 2*a + c\n\njulia> normal_form(-1+c+b+a^3, J)\na^3\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#normal_form-Union{Tuple{T}, Tuple{Vector{T}, MPolyIdeal}} where T<:MPolyElem","page":"Ideals in Multivariate Rings","title":"normal_form","text":"normal_form(A::Vector{T}, J::MPolyIdeal) where { T <: MPolyElem }\n\nCompute the normal form of the elements of the array A w.r.t. a Groebner basis of J.\n\nCAVEAT: This computation needs a Groebner basis of J. If this Groebner basis is not available, one is computed automatically. This may take some time.\n\nExamples\n\njulia> R,(a,b,c) = PolynomialRing(QQ,[\"a\",\"b\",\"c\"])\n(Multivariate Polynomial Ring in a, b, c over Rational Field, fmpq_mpoly[a, b, c])\n\njulia> A = [-1+c+b+a^3,-1+b+c*a+2*a^3,5+c*b+c^2*a]\n3-element Vector{fmpq_mpoly}:\n a^3 + b + c - 1\n 2*a^3 + a*c + b - 1\n a*c^2 + b*c + 5\n\njulia> J = ideal(R,[-1+c+b,-1+b+c*a+2*a*b])\nideal(b + c - 1, 2*a*b + a*c + b - 1)\n\njulia> groebner_basis(J)\n2-element Vector{fmpq_mpoly}:\n b + c - 1\n a*c - 2*a + c\n\njulia> normal_form(A, J)\n3-element Vector{fmpq_mpoly}:\n a^3\n 2*a^3 + 2*a - 2*c\n 4*a - 2*c^2 - c + 5\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Computing-Gröbner-Bases","page":"Ideals in Multivariate Rings","title":"Computing Gröbner Bases","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"groebner_basis(I::MPolyIdeal; ordering::Symbol = :degrevlex, complete_reduction::Bool = false)","category":"page"},{"location":"CommutativeAlgebra/ideals/#groebner_basis-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"groebner_basis","text":"function groebner_basis(I::MPolyIdeal;\n  ordering::MonomialOrdering = default_ordering(base_ring(I)),\n  complete_reduction::Bool = false, enforce_global_ordering::Bool = true)\n\nGiven an ideal I and optional parameters monomial ordering ordering and complete_reduction, compute a Groebner basis (if complete_reduction = true the reduced Groebner basis) of I w.r.t. the given monomial ordering ordering (as default degree reverse lexicographical). If enforce_global_ordering = false it is not checked whether the given ordering is global.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal([x*y-3*x,y^3-2*x^2*y])\nideal(x*y - 3*x, -2*x^2*y + y^3)\n\njulia> H = groebner_basis(I, ordering=lex(gens(R)))\n3-element Vector{fmpq_mpoly}:\n y^4 - 3*y^3\n x*y - 3*x\n 6*x^2 - y^3\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Gröbner-Bases-with-transformation-matrix","page":"Ideals in Multivariate Rings","title":"Gröbner Bases with transformation matrix","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"groebner_basis_with_transformation_matrix(I::MPolyIdeal; ordering::Symbol = :degrevlex, complete_reduction::Bool=false)","category":"page"},{"location":"CommutativeAlgebra/ideals/#groebner_basis_with_transformation_matrix-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"groebner_basis_with_transformation_matrix","text":"groebner_basis_with_transformation_matrix(I::MPolyIdeal; ordering::MonomialOrdering = default_ordering(base_ring(I)), complete_reduction::Bool=false)\n\nReturn a pair G, m where G is a Groebner basis of the ideal I with respect to the monomial ordering ordering (as default degree reverse lexicographical), and m is a transformation matrix from gens(I)toG. If complete_reductionis set to true (as default 'false') then G will be the reduced Groebner basis.\n\nExamples\n\njulia> R,(x,y) = PolynomialRing(QQ,[\"x\",\"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal([x*y^2-1,x^3+y^2+x*y])\nideal(x*y^2 - 1, x^3 + x*y + y^2)\n\njulia> G,m = groebner_basis_with_transformation_matrix(I)\n(fmpq_mpoly[x*y^2 - 1, x^3 + x*y + y^2, x^2 + y^4 + y], [1 0 -x^2-y; 0 1 y^2])\n\njulia> gens(I)*m == G\ntrue\n\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"fglm\n\nGröbner walks\n\nHilbert-driven","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"warning: Expert functions for Gröbner bases\nThe following functions are low-level implementations of various Gröbner basis algorithms with many adjustable arguments. Only use these functions directly if you know what you are doing.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"f4( I::MPolyIdeal; initial_hts::Int=17, nr_thrds::Int=1, max_nr_pairs::Int=0, la_option::Int=2, reduce_gb::Int=1, info_level::Int=0)","category":"page"},{"location":"CommutativeAlgebra/ideals/#f4-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"f4","text":"f4(I::MPolyIdeal, <keyword arguments>)\n\nCompute a Groebner basis of the given ideal I w.r.t. to the degree reverse lexicographical monomial ordering using Faugère's F4 algorithm. See Jean-Charles Faugère (1999) for more information.\n\nNote: At the moment only ground fields of characteristic p, p prime, p < 2^{31} are supported.\n\nArguments\n\nÌ::MPolyIdeal: input ideal.\ninitial_hts::Int=17: initial hash table size log_2.\nnr_thrds::Int=1: number of threads for parallel linear algebra.\nmax_nr_pairs::Int=0: maximal number of pairs per matrix, only bounded by minimal degree if 0.\nla_option::Int=2: linear algebra option: exact sparse-dense (1), exact sparse (2, default), probabilistic sparse-dense (42), probabilistic sparse(44).\neliminate::Int=0: size of first block of variables to be eliminated.\ncomplete_reduction::Bool=true: compute a reduced Gröbner basis for I\ninfo_level::Int=0: info level printout: off (0, default), summary (1), detailed (2).\n\nExamples\n\njulia> R,(x,y,z) = PolynomialRing(GF(101), [\"x\",\"y\",\"z\"], ordering=:degrevlex)\n(Multivariate Polynomial Ring in x, y, z over Galois field with characteristic 101, gfp_mpoly[x, y, z])\n\njulia> I = ideal(R, [x+2*y+2*z-1, x^2+2*y^2+2*z^2-x, 2*x*y+2*y*z-y])\nideal(x + 2*y + 2*z + 100, x^2 + 2*y^2 + 2*z^2 + 100*x, 2*x*y + 2*y*z + 100*y)\n\njulia> f4(I)\n4-element Vector{gfp_mpoly}:\n x + 2*y + 2*z + 100\n y*z + 82*z^2 + 10*y + 40*z\n y^2 + 60*z^2 + 20*y + 81*z\n z^3 + 28*z^2 + 64*y + 13*z\n\njulia> isdefined(I, :gb)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Leading-Ideals","page":"Ideals in Multivariate Rings","title":"Leading Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"leading_ideal(g::Vector{T}; ordering::MonomialOrdering) where { T <: MPolyElem }\nleading_ideal(I::MPolyIdeal; ordering::MonomialOrdering)","category":"page"},{"location":"CommutativeAlgebra/ideals/#leading_ideal-Union{Tuple{Vector{T}}, Tuple{T}} where T<:MPolyElem","page":"Ideals in Multivariate Rings","title":"leading_ideal","text":"leading_ideal(g::Vector{T}; ordering::MonomialOrdering) where { T <: MPolyElem }\n\nReturn the ideal generated by the leading monomials of the given polynomials w.r.t. the given monomial ordering.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> L = leading_ideal([x*y^2-3*x, x^3-14*y^5], ordering=degrevlex(gens(R)))\nideal(x*y^2, y^5)\n\njulia> L = leading_ideal([x*y^2-3*x, x^3-14*y^5], ordering=lex(gens(R)))\nideal(x*y^2, x^3)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#leading_ideal-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"leading_ideal","text":"leading_ideal(I::MPolyIdeal; ordering::MonomialOrdering)\n\nGiven a multivariate polynomial ideal Ì this function returns the leading ideal for I. This is done w.r.t. the given monomial ordering.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R,[x*y^2-3*x, x^3-14*y^5])\nideal(x*y^2 - 3*x, x^3 - 14*y^5)\n\njulia> L = leading_ideal(I, ordering=degrevlex(gens(R)))\nideal(x*y^2, x^4, y^5)\n\njulia> L = leading_ideal(I, ordering=lex(gens(R)))\nideal(y^7, x*y^2, x^3)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Gröbner-Bases-over-the-integers","page":"Ideals in Multivariate Rings","title":"Gröbner Bases over the integers","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Over the integers the coefficients of the polynomials  are not invertible, thus their handling when computing Gröbner bases and normal forms plays an important role. This is done when  computing strong Gröbner bases which ensure the following property:  For any element of an ideal its leading term is divisible by a leading term of an  element of a corresponding strong Gröbner basis.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"The textbook William W. Adams, Philippe Loustaunau (1994) provides details on theory and algorithms as well as references.","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"R, (x,y) = PolynomialRing(ZZ, [\"x\",\"y\"])\nI = ideal(R, [2x,3x,4y])\nH = groebner_basis(I)","category":"page"},{"location":"CommutativeAlgebra/ideals/#Syzygies","page":"Ideals in Multivariate Rings","title":"Syzygies","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Generators-of-syzygies","page":"Ideals in Multivariate Rings","title":"Generators of syzygies","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"syzygy_generators(a::Vector{<:MPolyElem})","category":"page"},{"location":"CommutativeAlgebra/ideals/#syzygy_generators-Tuple{Vector{var\"#s271\"} where var\"#s271\"<:MPolyElem}","page":"Ideals in Multivariate Rings","title":"syzygy_generators","text":"syzygy_generators(a::Vector{<:MPolyElem})\n\nReturn generators for the syzygies on the given polynomials.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> S = syzygy_generators([x^3+y+2,x*y^2-13*x^2,y-14])\n3-element Vector{FreeModElem{fmpq_mpoly}}:\n (-y + 14)*e[2] + (-13*x^2 + x*y^2)*e[3]\n (-169*y + 2366)*e[1] + (-13*x*y + 182*x - 196*y + 2744)*e[2] + (13*x^2*y^2 - 2548*x^2 + 196*x*y^2 + 169*y + 338)*e[3]\n (-13*x^2 + 196*x)*e[1] + (-x^3 - 16)*e[2] + (x^4*y + 14*x^4 + 13*x^2 + 16*x*y + 28*x)*e[3]\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Data-Associated-to-Ideals","page":"Ideals in Multivariate Rings","title":"Data Associated to Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Basic-Data","page":"Ideals in Multivariate Rings","title":"Basic Data","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"If I is an ideal of a multivariate polynomial ring  R, then","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"base_ring(I) refers to I,\ngens(I) to the generators of I,\nngens(I) to the number of these generators, and\ngen(I, k) as well as I[k] to the k-th such generator.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Examples-2","page":"Ideals in Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\nI = ideal(R, [x, y])^2\nbase_ring(I)\ngens(I)\nngens(I)\ngen(I, 2)\nx*y","category":"page"},{"location":"CommutativeAlgebra/ideals/#Dimension","page":"Ideals in Multivariate Rings","title":"Dimension","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"dim(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#dim-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"dim","text":"dim(I::MPolyIdeal)\n\nReturn the Krull dimension of I.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [y-x^2, x-z^3])\nideal(-x^2 + y, x - z^3)\n\njulia> dim(I)\n1\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Codimension","page":"Ideals in Multivariate Rings","title":"Codimension","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"codim(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#codim-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"codim","text":"codim(I::MPolyIdeal)\n\nReturn the codimension of I.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [y-x^2, x-z^3])\nideal(-x^2 + y, x - z^3)\n\njulia> codim(I)\n2\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Minimal-Sets-of-Generators","page":"Ideals in Multivariate Rings","title":"Minimal Sets of Generators","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"In the graded case, we have:","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"minimal_generating_set(I::MPolyIdeal{<:MPolyElem_dec})","category":"page"},{"location":"CommutativeAlgebra/ideals/#minimal_generating_set-Tuple{MPolyIdeal{var\"#s271\"} where var\"#s271\"<:MPolyElem_dec}","page":"Ideals in Multivariate Rings","title":"minimal_generating_set","text":"minimal_generating_set(I::MPolyIdeal{<:MPolyElem_dec})\n\nGiven a homogeneous ideal I in a graded multivariate polynomial ring over a field, return an array containing a minimal set of generators of I.\n\nExamples\n\njulia> R, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"]);\n\njulia> V = [x, z^2, x^3+y^3, y^4, y*z^5];\n\njulia> I = ideal(R, V)\nideal(x, z^2, x^3 + y^3, y^4, y*z^5)\n\njulia> minimal_generating_set(I)\n3-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n x\n z^2\n x^3 + y^3\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Operations-on-Ideals","page":"Ideals in Multivariate Rings","title":"Operations on Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Simple-Ideal-Operations","page":"Ideals in Multivariate Rings","title":"Simple Ideal Operations","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Powers-of-Ideal","page":"Ideals in Multivariate Rings","title":"Powers of Ideal","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":":^(I::MPolyIdeal, m::Int)","category":"page"},{"location":"CommutativeAlgebra/ideals/#^-Tuple{MPolyIdeal, Int64}","page":"Ideals in Multivariate Rings","title":"^","text":":^(I::MPolyIdeal, m::Int)\n\nReturn the m-th power of I. \n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [x, y])\nideal(x, y)\n\njulia> I^3\nideal(x^3, x^2*y, x*y^2, y^3)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Sum-of-Ideals","page":"Ideals in Multivariate Rings","title":"Sum of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":":+(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#+-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"+","text":":+(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn the sum of I and J.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [x, y])\nideal(x, y)\n\njulia> J = ideal(R, [z^2])\nideal(z^2)\n\njulia> I+J\nideal(x, y, z^2)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Product-of-Ideals","page":"Ideals in Multivariate Rings","title":"Product of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":":*(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#*-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"*","text":":*(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn the product of I and J.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [x, y])\nideal(x, y)\n\njulia> J = ideal(R, [z^2])\nideal(z^2)\n\njulia> I*J\nideal(x*z^2, y*z^2)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Intersection-of-Ideals","page":"Ideals in Multivariate Rings","title":"Intersection of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#intersect-Union{Tuple{T}, Tuple{MPolyIdeal{T}, Vararg{MPolyIdeal{T}, N} where N}} where T","page":"Ideals in Multivariate Rings","title":"intersect","text":"intersect(I::MPolyIdeal{T}, Js::MPolyIdeal{T}...) where T\n\nReturn the intersection of two or more ideals.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Ideal-Quotients","page":"Ideals in Multivariate Rings","title":"Ideal Quotients","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Given two ideals I J of a ring R, the ideal quotient of I by J is the ideal","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"IJ= biglf in Rbig f J subset Ibigrsubset R","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#quotient-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"quotient","text":"quotient(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn the ideal quotient of I by J. Alternatively, use I:J. \n\nquotient(I::MPolyIdeal{T}, f::MPolyElem{T}) where T\n\nReturn the ideal quotient of I by the ideal generated by f. Alternatively, use I:f. \n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [x^4+x^2*y*z+y^3*z, y^4+x^3*z+x*y^2*z, x^3*y+x*y^3])\nideal(x^4 + x^2*y*z + y^3*z, x^3*z + x*y^2*z + y^4, x^3*y + x*y^3)\n\njulia> J = ideal(R, [x, y, z])^2\nideal(x^2, x*y, x*z, y^2, y*z, z^2)\n\njulia> L = quotient(I, J)\nideal(x^3*z + x*y^2*z + y^4, x^3*y + x*y^3, x^4 + x^2*y*z + y^3*z, x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2, x^2*y^2*z - x^2*y*z^2 - y^3*z^2, x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2)\n\njulia> I:J\nideal(x^3*z + x*y^2*z + y^4, x^3*y + x*y^3, x^4 + x^2*y*z + y^3*z, x^3*z^2 - x^2*y*z^2 + x*y^2*z^2 - y^3*z^2, x^2*y^2*z - x^2*y*z^2 - y^3*z^2, x^3*z^2 + x^2*y^3 - x^2*y^2*z + x*y^2*z^2)\n\njulia> I:x\nideal(x^2*y + y^3, x^3*z + x*y^2*z + y^4, x^2*z^2 + x*y^3 - x*y^2*z + y^2*z^2, x^4, x^3*z^2 - x^2*z^3 + 2*x*y^2*z^2 - y^2*z^3, -x^2*z^4 + x*y^2*z^3 - y^2*z^4)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Saturation","page":"Ideals in Multivariate Rings","title":"Saturation","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Given two ideals I J of a ring R, the saturation of I with respect to J is the ideal","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"IJ^infty = bigl f in R big f J^k subset I text for some kgeq 1 bigr = textstylebigcuplimits_k=1^infty (IJ^k)","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"saturation(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\nsaturation_with_index(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#saturation-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"saturation","text":"saturation(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn the saturation of I with respect to J.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])\nideal(z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y)\n\njulia> J = ideal(R, [x, y, z])\nideal(x, y, z)\n\njulia> K = saturation(I, J)\nideal(z, x*y)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#saturation_with_index-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"saturation_with_index","text":"saturation_with_index(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn IJ^infty together with the smallest integer m such that IJ^m = IJ^infty.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> I = ideal(R, [z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y])\nideal(z^3, y*z^2, x*z^2, y^2*z, x*y*z, x^2*z, x*y^2, x^2*y)\n\njulia> J = ideal(R, [x, y, z])\nideal(x, y, z)\n\njulia> K, m = saturation_with_index(I, J)\n(ideal(z, x*y), 2)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Elimination","page":"Ideals in Multivariate Rings","title":"Elimination","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"eliminate(I::MPolyIdeal{T}, l::Vector{T}) where T <: MPolyElem","category":"page"},{"location":"CommutativeAlgebra/ideals/#eliminate-Union{Tuple{T}, Tuple{MPolyIdeal{T}, Vector{T}}} where T<:MPolyElem","page":"Ideals in Multivariate Rings","title":"eliminate","text":"eliminate(I::MPolyIdeal{T}, l::Vector{T}) where T <: MPolyElem\n\nGiven a vector l of polynomials which are variables, these variables are eliminated from I.  That is, return the ideal of all polynomials in I which only depend on the remaining variables.\n\neliminate(I::MPolyIdeal, l::AbstractVector{Int})\n\nGiven a vector l of indices which specify variables, these variables are eliminated from I.  That is, return the ideal of all polynomials in I which only depend on the remaining variables.\n\nExamples\n\njulia> R, (t, x, y, z) = PolynomialRing(QQ, [\"t\", \"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in t, x, y, z over Rational Field, fmpq_mpoly[t, x, y, z])\n\njulia> I = ideal(R, [t-x, t^2-y, t^3-z])\nideal(t - x, t^2 - y, t^3 - z)\n\njulia> A = [t]\n1-element Vector{fmpq_mpoly}:\n t\n\njulia> TC = eliminate(I, A)\nideal(-x*z + y^2, x*y - z, x^2 - y)\n\njulia> A = [1]\n1-element Vector{Int64}:\n 1\n\njulia> TC = eliminate(I, A)\nideal(-x*z + y^2, x*y - z, x^2 - y)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Tests-on-Ideals","page":"Ideals in Multivariate Rings","title":"Tests on Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/#Basic-Tests","page":"Ideals in Multivariate Rings","title":"Basic Tests","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"iszero(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#iszero-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"iszero","text":"iszero(I::MPolyIdeal)\n\nReturn true if I is the zero ideal, false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R, y-x^2)\nideal(-x^2 + y)\n\njulia> iszero(I)\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"isone(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#isone-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"isone","text":"isone(I::MPolyIdeal)\n\nReturn true if I is generated by 1, false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R, [x, x + y, y - 1])\nideal(x, x + y, y - 1)\n\njulia> isone(I)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"ismonomial(f::MPolyElem)","category":"page"},{"location":"CommutativeAlgebra/ideals/#ismonomial-Tuple{MPolyElem}","page":"Ideals in Multivariate Rings","title":"ismonomial","text":"ismonomial(f::MPolyElem)\n\nReturn true if f is a monomial, false otherwise.\n\nismonomial(I::MPolyIdeal)\n\nReturn true if I can be generated by monomials, false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> f = 2*x+y\n2*x + y\n\njulia> g = y\ny\n\njulia> ismonomial(f)\nfalse\n\njulia> ismonomial(g)\ntrue\n\njulia> ismonomial(ideal(R, [f, g]))\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Containment-of-Ideals","page":"Ideals in Multivariate Rings","title":"Containment of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"issubset(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#issubset-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"issubset","text":"issubset(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn true if I is contained in J, false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R, [x^2])\nideal(x^2)\n\njulia> J = ideal(R, [x, y])^2\nideal(x^2, x*y, y^2)\n\njulia> issubset(I, J)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Equality-of-Ideals","page":"Ideals in Multivariate Rings","title":"Equality of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"==(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#==-Union{Tuple{T}, Tuple{MPolyIdeal{T}, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"==","text":"==(I::MPolyIdeal{T}, J::MPolyIdeal{T}) where T\n\nReturn true if I is equal to J, false otherwise.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R, [x^2])\nideal(x^2)\n\njulia> J = ideal(R, [x, y])^2\nideal(x^2, x*y, y^2)\n\njulia> I == J\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Ideal-Membership","page":"Ideals in Multivariate Rings","title":"Ideal Membership","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"ideal_membership(f::T, I::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#ideal_membership-Union{Tuple{T}, Tuple{T, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"ideal_membership","text":"ideal_membership(f::T, I::MPolyIdeal{T}) where T\n\nReturn true if f is contained in I, false otherwise. Alternatively, use f in I. \n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> f = x^2\nx^2\n\njulia> I = ideal(R, [x, y])^2\nideal(x^2, x*y, y^2)\n\njulia> ideal_membership(f, I)\ntrue\n\njulia> g = x\nx\n\njulia> g in I\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Radical-Membership","page":"Ideals in Multivariate Rings","title":"Radical Membership","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"radical_membership(f::T, I::MPolyIdeal{T}) where T","category":"page"},{"location":"CommutativeAlgebra/ideals/#radical_membership-Union{Tuple{T}, Tuple{T, MPolyIdeal{T}}} where T","page":"Ideals in Multivariate Rings","title":"radical_membership","text":"radical_membership(f::T, I::MPolyIdeal{T}) where T\n\nReturn true if f is contained in the radical of I, false otherwise. Alternatively, use inradical(f, I).\n\nExamples\n\njulia> R, (x,) = PolynomialRing(QQ, [\"x\"])\n(Multivariate Polynomial Ring in x over Rational Field, fmpq_mpoly[x])\n\njulia> f = x\nx\n\njulia> I = ideal(R,  [x^2])\nideal(x^2)\n\njulia> radical_membership(f, I)\ntrue\n\njulia> g = x+1\nx + 1\n\njulia> inradical(g, I)\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Primality-Test","page":"Ideals in Multivariate Rings","title":"Primality Test","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"isprime(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#isprime-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"isprime","text":"isprime(I::MPolyIdeal)\n\nReturn true if I is prime, false otherwise. \n\nwarning: Warning\nThe function computes the minimal asscociated primes of I. This may take some time.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R, [x, y])^2\nideal(x^2, x*y, y^2)\n\njulia> isprime(I)\nfalse\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Primary-Test","page":"Ideals in Multivariate Rings","title":"Primary Test","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"isprimary(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#isprimary-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"isprimary","text":"isprimary(I::MPolyIdeal)\n\nReturn true if I is primary, false otherwise. \n\nwarning: Warning\nThe function computes a primary decomposition of I. This may take some time.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = ideal(R, [x, y])^2\nideal(x^2, x*y, y^2)\n\njulia> isprimary(I)\ntrue\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Decomposition-of-Ideals","page":"Ideals in Multivariate Rings","title":"Decomposition of Ideals","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"We discuss various decomposition techniques. They are implemented for polynomial rings over fields and, if explicitly mentioned, also for polynomial rings over the integers. See Wolfram Decker, Gert-Martin Greuel, Gerhard Pfister (1999) for a survey.","category":"page"},{"location":"CommutativeAlgebra/ideals/#Radical","page":"Ideals in Multivariate Rings","title":"Radical","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"radical(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#radical-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"radical","text":"radical(I::MPolyIdeal)\n\nReturn the radical of I. \n\nImplemented Algorithms\n\nIf the base ring of I is a polynomial ring over a field, a combination of the algorithms of Krick and Logar  (with modifications by Laplagne) and Kemper is used. For polynomial rings over the integers, the algorithm proceeds as suggested by  Pfister, Sadiq, and Steidel. See Teresa Krick, Alessandro Logar (1991), Gregor Kemper (2002), and Gerhard Pfister, Afshan Sadiq, Stefan Steidel (2011).\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)\n\njulia> RI = radical(I)\nideal(x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2)\n\njulia> R, (a, b, c, d) = PolynomialRing(ZZ, [\"a\", \"b\", \"c\", \"d\"])\n(Multivariate Polynomial Ring in a, b, c, d over Integer Ring, fmpz_mpoly[a, b, c, d])\n\njulia> I = intersect(ideal(R, [9,a,b]), ideal(R, [3,c]))\nideal(9, 3*b, 3*a, b*c, a*c)\n\njulia> I = intersect(I, ideal(R, [11,2a,7b]))\nideal(99, 3*b, 3*a, b*c, a*c)\n\njulia> I = intersect(I, ideal(R, [13a^2,17b^4]))\nideal(39*a^2, 13*a^2*c, 51*b^4, 17*b^4*c, 3*a^2*b^4, a^2*b^4*c)\n\njulia> I = intersect(I, ideal(R, [9c^5,6d^5]))\nideal(78*a^2*d^5, 117*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 6*a^2*b^4*d^5, 9*a^2*b^4*c^5, 39*a^2*c^5*d^5, 51*b^4*c^5*d^5, 3*a^2*b^4*c^5*d^5)\n\njulia> I = intersect(I, ideal(R, [17,a^15,b^15,c^15,d^15]))\nideal(1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15, 78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15, 39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5, 6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15, 3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5)\n\njulia> RI = radical(I)\nideal(102*b*d, 78*a*d, 51*b*c, 39*a*c, 6*a*b*d, 3*a*b*c)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Primary-Decomposition","page":"Ideals in Multivariate Rings","title":"Primary Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"primary_decomposition(I::MPolyIdeal; alg = :GTZ)","category":"page"},{"location":"CommutativeAlgebra/ideals/#primary_decomposition-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"primary_decomposition","text":"primary_decomposition(I::MPolyIdeal; alg = :GTZ)\n\nReturn a minimal primary decomposition of I. If I is the unit ideal, return [ideal(1)].\n\nThe decomposition is returned as a vector of tuples (Q_1 P_1) dots (Q_t P_t), say, where each Q_i is a primary ideal with associated prime P_i, and where the intersection of  the Q_i is I. \n\nImplemented Algorithms\n\nIf the base ring of I is a polynomial ring over a field, the algorithm of Gianni, Trager, and Zacharias  is used by default (alg = :GTZ). Alternatively, the algorithm by Shimoyama and Yokoyama can be used  by specifying alg = :SY.  For polynomial rings over the integers, the algorithm proceeds as suggested by  Pfister, Sadiq, and Steidel. See Patrizia Gianni, Barry Trager, Gail Zacharias (1988), Takeshi Shimoyama, Kazuhiro Yokoyama (1996), and Gerhard Pfister, Afshan Sadiq, Stefan Steidel (2011).\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)\n\njulia> L = primary_decomposition(I)\n3-element Vector{Tuple{MPolyIdeal{fmpq_mpoly}, MPolyIdeal{fmpq_mpoly}}}:\n (ideal(x^3 - x - y^2), ideal(x^3 - x - y^2))\n (ideal(x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), ideal(x - y - 1))\n (ideal(y, x^2), ideal(x, y))\n\njulia> L = primary_decomposition(I, alg = :SY)\n3-element Vector{Tuple{MPolyIdeal{fmpq_mpoly}, MPolyIdeal{fmpq_mpoly}}}:\n (ideal(x^3 - x - y^2), ideal(x^3 - x - y^2))\n (ideal(x^2 - 2*x*y - 2*x + y^2 + 2*y + 1), ideal(x - y - 1))\n (ideal(y, x^2), ideal(y, x))\n\njulia> R, (a, b, c, d) = PolynomialRing(ZZ, [\"a\", \"b\", \"c\", \"d\"])\n(Multivariate Polynomial Ring in a, b, c, d over Integer Ring, fmpz_mpoly[a, b, c, d])\n\njulia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,\n       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,\n       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,\n       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,\n       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,\n       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])\nideal(1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15, 78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15, 39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5, 6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15, 3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5)\n\njulia> L = primary_decomposition(I)\n8-element Vector{Tuple{MPolyIdeal{fmpz_mpoly}, MPolyIdeal{fmpz_mpoly}}}:\n (ideal(d^5, c^5), ideal(d, c))\n (ideal(a^2, b^4), ideal(b, a))\n (ideal(2, c^5), ideal(2, c))\n (ideal(3), ideal(3))\n (ideal(13, b^4), ideal(13, b))\n (ideal(17, a^2), ideal(17, a))\n (ideal(17, d^15, c^15, b^15, a^15), ideal(17, d, c, b, a))\n (ideal(9, 3*d^5, d^10), ideal(3, d))\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Absolute-Primary-Decomposition","page":"Ideals in Multivariate Rings","title":"Absolute Primary Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"absolute_primary_decomposition(I::MPolyIdeal{fmpq_mpoly})","category":"page"},{"location":"CommutativeAlgebra/ideals/#absolute_primary_decomposition-Tuple{MPolyIdeal{fmpq_mpoly}}","page":"Ideals in Multivariate Rings","title":"absolute_primary_decomposition","text":"absolute_primary_decomposition(I::MPolyIdeal{<:MPolyElem{fmpq}})\n\nIf I is an ideal in a multivariate polynomial ring over the rationals, return an absolute minimal primary decomposition of I. \n\nReturn the decomposition as a vector of tuples (Q_i P_i P_ij d_ij), say,  where (Q_i P_i) is a (primary, prime) tuple as returned by primary_decomposition(I),  and P_ij represents a corresponding class of conjugated absolute associated primes  defined over a number field of degree d_ij whose generator prints as _a.\n\nImplemented Algorithms\n\nThe implementation combines the algorithm of Gianni, Trager, and Zacharias for primary decomposition with absolute polynomial factorization.\n\nExamples\n\njulia> R, (y, z) = PolynomialRing(QQ, [\"y\", \"z\"])\n(Multivariate Polynomial Ring in y, z over Rational Field, fmpq_mpoly[y, z])\n\njulia> p = z^2+1\nz^2 + 1\n\njulia> q = z^3+2\nz^3 + 2\n\njulia> I = ideal(R, [p*q^2, y-z^2])\nideal(z^8 + z^6 + 4*z^5 + 4*z^3 + 4*z^2 + 4, y - z^2)\n\njulia> L = primary_decomposition(I)\n2-element Vector{Tuple{MPolyIdeal{fmpq_mpoly}, MPolyIdeal{fmpq_mpoly}}}:\n (ideal(z^2 + 1, y - z^2), ideal(z^2 + 1, y - z^2))\n (ideal(z^6 + 4*z^3 + 4, y - z^2), ideal(z^3 + 2, y - z^2))\n\njulia> AL = absolute_primary_decomposition(I)\n2-element Vector{Tuple{MPolyIdeal{fmpq_mpoly}, MPolyIdeal{fmpq_mpoly}, MPolyIdeal{AbstractAlgebra.Generic.MPoly{nf_elem}}, Int64}}:\n (ideal(z^2 + 1, y + 1), ideal(z^2 + 1, y + 1), ideal(z - _a, y + 1), 2)\n (ideal(z^6 + 4*z^3 + 4, y - z^2), ideal(z^3 + 2, y - z^2), ideal(z - _a, y - _a*z), 3)\n\njulia> AP = AL[1][3]\nideal(z - _a, y + 1)\n\njulia> RAP = base_ring(AP)\nMultivariate Polynomial Ring in y, z over Number field over Rational Field with defining polynomial x^2 + 1\n\njulia> NF = coefficient_ring(RAP)\nNumber field over Rational Field with defining polynomial x^2 + 1\n\njulia> a = gen(NF)\n_a\n\njulia> minpoly(a)\nx^2 + 1\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Minimal-Associated-Primes","page":"Ideals in Multivariate Rings","title":"Minimal Associated Primes","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"minimal_primes(I::MPolyIdeal; alg = :GTZ)","category":"page"},{"location":"CommutativeAlgebra/ideals/#minimal_primes-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"minimal_primes","text":"minimal_primes(I::MPolyIdeal; alg = :GTZ)\n\nReturn a vector containing the minimal associated prime ideals of I. If I is the unit ideal, return [ideal(1)].\n\nImplemented Algorithms\n\nIf the base ring of I is a polynomial ring over a field, the algorithm of Gianni, Trager, and Zacharias is used by default (alg = :GTZ). Alternatively, characteristic sets can be used by specifying alg = :charSets. For polynomial rings over the integers,  the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See Patrizia Gianni, Barry Trager, Gail Zacharias (1988) and Gerhard Pfister, Afshan Sadiq, Stefan Steidel (2011).\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)\n\njulia> L = minimal_primes(I)\n2-element Vector{MPolyIdeal{fmpq_mpoly}}:\n ideal(x - y - 1)\n ideal(x^3 - x - y^2)\n\njulia> L = minimal_primes(I, alg = :charSets)\n2-element Vector{MPolyIdeal{fmpq_mpoly}}:\n ideal(x - y - 1)\n ideal(x^3 - x - y^2)\n\njulia> R, (a, b, c, d) = PolynomialRing(ZZ, [\"a\", \"b\", \"c\", \"d\"])\n(Multivariate Polynomial Ring in a, b, c, d over Integer Ring, fmpz_mpoly[a, b, c, d])\n\njulia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,\n       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,\n       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,\n       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,\n       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,\n       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])\nideal(1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15, 78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15, 39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5, 6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15, 3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5)\n\njulia> L = minimal_primes(I)\n6-element Vector{MPolyIdeal{fmpz_mpoly}}:\n ideal(d, c)\n ideal(b, a)\n ideal(2, c)\n ideal(3)\n ideal(13, b)\n ideal(17, a)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Weak-Equidimensional-Decomposition","page":"Ideals in Multivariate Rings","title":"Weak Equidimensional Decomposition","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"equidimensional_decomposition_weak(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#equidimensional_decomposition_weak-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"equidimensional_decomposition_weak","text":"equidimensional_decomposition_weak(I::MPolyIdeal)\n\nReturn a vector of equidimensional ideals where the last entry is the equidimensional hull of I, that is, the intersection of the primary components of I of maximal dimension. Each of the previous entries is an ideal of lower dimension whose associated primes are exactly the associated primes of I of that dimension. If I is the unit ideal, return [ideal(1)].\n\nImplemented Algorithms\n\nThe implementation relies on ideas of Eisenbud, Huneke, and Vasconcelos. See David Eisenbud, Craig Huneke, Wolmer Vasconcelos (1992). \n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)\n\njulia> L = equidimensional_decomposition_weak(I)\n2-element Vector{MPolyIdeal{fmpq_mpoly}}:\n ideal(y, x)\n ideal(x^5 - 2*x^4*y - 2*x^4 + x^3*y^2 + 2*x^3*y - x^2*y^2 + 2*x^2*y + 2*x^2 + 2*x*y^3 + x*y^2 - 2*x*y - x - y^4 - 2*y^3 - y^2)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Equidimensional-Decomposition-of-radical","page":"Ideals in Multivariate Rings","title":"Equidimensional Decomposition of radical","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"equidimensional_decomposition_radical(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#equidimensional_decomposition_radical-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"equidimensional_decomposition_radical","text":"equidimensional_decomposition_radical(I::MPolyIdeal)\n\nReturn a vector of equidimensional radical ideals increasingly ordered by dimension. For each dimension, the returned radical ideal is the intersection of the associated primes  of I of that dimension. If I is the unit ideal, return [ideal(1)].\n\nImplemented Algorithms\n\nThe implementation combines the algorithms of Krick and Logar (with modifications by Laplagne) and Kemper. See Teresa Krick, Alessandro Logar (1991) and Gregor Kemper (2002).\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)\n\njulia> L = equidimensional_decomposition_radical(I)\n2-element Vector{MPolyIdeal{fmpq_mpoly}}:\n ideal(y, x)\n ideal(x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Equidimensional-Hull","page":"Ideals in Multivariate Rings","title":"Equidimensional Hull","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"equidimensional_hull(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#equidimensional_hull-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"equidimensional_hull","text":"equidimensional_hull(I::MPolyIdeal)\n\nIf the base ring of I is a polynomial ring over a field, return the intersection of the primary components of I of maximal dimension. In the case of polynomials over the integers, return the intersection of the primary components of I of minimal height.  If I is the unit ideal, return [ideal(1)]. \n\nImplemented Algorithms\n\nFor polynomial rings over a field, the implementation relies on ideas as used by Gianni, Trager, and Zacharias or Krick and Logar. For polynomial rings over the integers,  the algorithm proceeds as suggested by Pfister, Sadiq, and Steidel. See Patrizia Gianni, Barry Trager, Gail Zacharias (1988), Teresa Krick, Alessandro Logar (1991),  and Gerhard Pfister, Afshan Sadiq, Stefan Steidel (2011).\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)\n\njulia> L = equidimensional_hull(I)\nideal(x^5 - 2*x^4*y - 2*x^4 + x^3*y^2 + 2*x^3*y - x^2*y^2 + 2*x^2*y + 2*x^2 + 2*x*y^3 + x*y^2 - 2*x*y - x - y^4 - 2*y^3 - y^2)\n\njulia> R, (a, b, c, d) = PolynomialRing(ZZ, [\"a\", \"b\", \"c\", \"d\"])\n(Multivariate Polynomial Ring in a, b, c, d over Integer Ring, fmpz_mpoly[a, b, c, d])\n\njulia> I = ideal(R, [1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5,\n       663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15,\n       78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15,\n       39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5,\n       6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15,\n       3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5])\nideal(1326*a^2*d^5, 1989*a^2*c^5, 102*b^4*d^5, 153*b^4*c^5, 663*a^2*c^5*d^5, 51*b^4*c^5*d^5, 78*a^2*d^15, 117*a^2*c^15, 78*a^15*d^5, 117*a^15*c^5, 6*a^2*b^4*d^15, 9*a^2*b^4*c^15, 39*a^2*c^5*d^15, 39*a^2*c^15*d^5, 6*a^2*b^15*d^5, 9*a^2*b^15*c^5, 6*a^15*b^4*d^5, 9*a^15*b^4*c^5, 39*a^15*c^5*d^5, 3*a^2*b^4*c^5*d^15, 3*a^2*b^4*c^15*d^5, 3*a^2*b^15*c^5*d^5, 3*a^15*b^4*c^5*d^5)\n\njulia> L = equidimensional_hull(I)\nideal(3)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Radical-of-the-Equidimensional-Hull","page":"Ideals in Multivariate Rings","title":"Radical of the Equidimensional Hull","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"equidimensional_hull_radical(I::MPolyIdeal)","category":"page"},{"location":"CommutativeAlgebra/ideals/#equidimensional_hull_radical-Tuple{MPolyIdeal}","page":"Ideals in Multivariate Rings","title":"equidimensional_hull_radical","text":"equidimensional_hull_radical(I::MPolyIdeal)\n\nReturn the intersection of the associated primes of I of maximal dimension. If I is the unit ideal, return [ideal(1)]. \n\nImplemented Algorithms\n\nThe implementation relies on a combination of the algorithms of Krick and Logar  (with modifications by Laplagne) and Kemper. See Teresa Krick, Alessandro Logar (1991) and Gregor Kemper (2002).\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> I = intersect(ideal(R, [x, y])^2, ideal(R, [y^2-x^3+x]))\nideal(x^3*y - x*y - y^3, x^4 - x^2 - x*y^2)\n\njulia> I = intersect(I, ideal(R, [x-y-1])^2)\nideal(x^5*y - 2*x^4*y^2 - 2*x^4*y + x^3*y^3 + 2*x^3*y^2 - x^2*y^3 + 2*x^2*y^2 + 2*x^2*y + 2*x*y^4 + x*y^3 - 2*x*y^2 - x*y - y^5 - 2*y^4 - y^3, x^6 - 2*x^5 - 3*x^4*y^2 - 2*x^4*y + 2*x^3*y^3 + 3*x^3*y^2 + 2*x^3*y + 2*x^3 + 5*x^2*y^2 + 2*x^2*y - x^2 + 3*x*y^4 - 5*x*y^2 - 2*x*y - 2*y^5 - 4*y^4 - 2*y^3)\n\njulia> L = equidimensional_hull_radical(I)\nideal(x^4 - x^3*y - x^3 - x^2 - x*y^2 + x*y + x + y^3 + y^2)\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/ideals/#Homogenization-and-Dehomogenization","page":"Ideals in Multivariate Rings","title":"Homogenization and Dehomogenization","text":"","category":"section"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"Referring to Martin Kreuzer, Lorenzo Robbiano (2005) for definitions and technical details, we discuss homogenization and dehomogenization in the context of mathbb Z^m-gradings. ","category":"page"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"homogenization(f::MPolyElem, W::Union{fmpz_mat, Matrix{<:IntegerUnion}}, var::String, pos::Int = 1)","category":"page"},{"location":"CommutativeAlgebra/ideals/#homogenization","page":"Ideals in Multivariate Rings","title":"homogenization","text":"homogenization(f::MPolyElem, W::Union{fmpz_mat, Matrix{<:IntegerUnion}}, var::String, pos::Int = 1)\n\nIf m is the number of rows of W, extend the parent polynomial ring of f by inserting m extra variables, starting at position pos. Correspondingly, extend the integer matrix W by inserting the standard unit vectors of size m as new columns, starting at column pos. Grade the extended ring by converting the columns of the extended matrix to elements of the group mathbb Z^m and assigning these as weights to the variables. Homogenize f with respect to the induced mathbb Z^m-grading on the original ring, using the extra variables as homogenizing variables. Return the result as an element of the extended ring with its mathbb Z^m-grading. If m=1, the extra variable prints as var. Otherwise, the extra variables print as var[i], for i = 1 dots m.\n\nhomogenization(V::Vector{T},  W::Union{fmpz_mat, Matrix{<:IntegerUnion}}, var::String, pos::Int = 1) where {T <: MPolyElem}\n\nGiven a vector V of elements in a common polynomial ring, create an extended ring with mathbb Z^m-grading as above. Homogenize the elements of V correspondingly,  and return the vector of homogenized elements.\n\nhomogenization(I::MPolyIdeal{T},  W::Union{fmpz_mat, Matrix{<:IntegerUnion}}, var::String, pos::Int = 1; ordering::Symbol = :degrevlex) where {T <: MPolyElem}\n\nReturn the homogenization of I in an extended ring with mathbb Z^m-grading as above.\n\nnote: Note\nApplied to an ideal I, the function first homogenizes the generators of I in the extended ring. It then creates the ideal generated by these homogenizations, and saturates this ideal with respect to the ideal which is generated by the homogenizing variables.\n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> f = x^3+x^2*y+x*y^2+y^3\nx^3 + x^2*y + x*y^2 + y^3\n\njulia> W = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> F = homogenization(f, W, \"z\", 3)\nx^3*z[1]^3*z[2]^3 + x^2*y*z[1]^2*z[2]^2 + x*y^2*z[1]*z[2] + y^3\n\njulia> parent(F)\nMultivariate Polynomial Ring in x, y, z[1], z[2] over Rational Field graded by\n  x -> [1 3]\n  y -> [2 4]\n  z[1] -> [1 0]\n  z[2] -> [0 1]\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"homogenization(f::MPolyElem, var::String, pos::Int=1)","category":"page"},{"location":"CommutativeAlgebra/ideals/#homogenization-2","page":"Ideals in Multivariate Rings","title":"homogenization","text":"homogenization(f::MPolyElem, var::String, pos::Int = 1)\n\nhomogenization(V::Vector{T}, var::String, pos::Int = 1) where {T <: MPolyElem}\n\nhomogenization(I::MPolyIdeal{T}, var::String, pos::Int = 1; ordering::Symbol = :degrevlex) where {T <: MPolyElem}\n\nHomogenize f, V, or I with respect to the standard mathbb Z-grading using a homogenizing variable printing as var. Return the result as an element of a graded polynomial ring with the homogenizing variable at position pos.\n\nnote: Note\nApplied to an ideal I, the function proceeds by homogenizing the elements of a Gröbner basis of I with respect to a degree compatible monomial ordering such as degrevlex (default).  If a Gröbner basis with respect to the specified ordering has not yet been computed and, thus, not yet been cached, executing the homogenization function with argument I may take some time. The degree compatibility of the specified ordering is not checked by the function.\n\nExamples\n\njulia> R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field, fmpq_mpoly[x, y, z])\n\njulia> f = x^3-y^2-z\nx^3 - y^2 - z\n\njulia> F = homogenization(f, \"w\", 4)\nx^3 - y^2*w - z*w^2\n\njulia> parent(F)\nMultivariate Polynomial Ring in x, y, z, w over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1]\n  w -> [1]\n\njulia> V = [y-x^2, z-x^3]\n2-element Vector{fmpq_mpoly}:\n -x^2 + y\n -x^3 + z\n\njulia> homogenization(V, \"w\")\n2-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n w*y - x^2\n w^2*z - x^3\n\njulia> I = ideal(R, V)\nideal(-x^2 + y, -x^3 + z)\n\njulia> PTC = homogenization(I, \"w\")\nideal(-x*z + y^2, -w*z + x*y, -w*y + x^2)\n\njulia> parent(PTC[1])\nMultivariate Polynomial Ring in w, x, y, z over Rational Field graded by\n  w -> [1]\n  x -> [1]\n  y -> [1]\n  z -> [1]\n\njulia> homogenization(I, \"w\", ordering = deglex(gens(base_ring(I))))\nideal(x*z - y^2, -w*z + x*y, -w*y + x^2, -w*z^2 + y^3)\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/ideals/","page":"Ideals in Multivariate Rings","title":"Ideals in Multivariate Rings","text":"dehomogenization(F::MPolyElem_dec, pos::Int)","category":"page"},{"location":"CommutativeAlgebra/ideals/#dehomogenization-Tuple{MPolyElem_dec, Int64}","page":"Ideals in Multivariate Rings","title":"dehomogenization","text":"dehomogenization(F::MPolyElem_dec, pos::Int)\n\nGiven an element F of a mathbb Z^m-graded ring, where the generators of mathbb Z^m are the assigned weights to the variables at positions pos, dots, pos -1+m, dehomogenize F using the variables at these positions. Return the result as an element of a polynomial ring not depending on the variables at these positions.\n\ndehomogenization(V::Vector{T}, pos::Int) where {T <: MPolyElem_dec}\n\nGiven a vector V of elements in a common graded polynomial ring, create a polynomial ring not depending on the variables at positions pos, dots, pos -1+m. Dehomogenize the elements  of V correspondingly,  and return the vector of dehomogenized elements.  \n\ndehomogenization(I::MPolyIdeal{T}, pos::Int) where {T <: MPolyElem_dec}\n\nReturn the dehomogenization of I in a polynomial ring as above.\n\nExamples\n\njulia> S, (x, y, z) = GradedPolynomialRing(QQ, [\"x\", \"y\", \"z\"])\n(Multivariate Polynomial Ring in x, y, z over Rational Field graded by\n  x -> [1]\n  y -> [1]\n  z -> [1], MPolyElem_dec{fmpq, fmpq_mpoly}[x, y, z])\n\njulia> F = x^3-x^2*y-x*z^2\nx^3 - x^2*y - x*z^2\n\njulia> f = dehomogenization(F, 1)\n-y - z^2 + 1\n\njulia> parent(f)\nMultivariate Polynomial Ring in y, z over Rational Field\n\njulia> V = [x*y-z^2, x^2*z-x^3]\n2-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n x*y - z^2\n -x^3 + x^2*z\n\njulia> dehomogenization(V, 3)\n2-element Vector{fmpq_mpoly}:\n x*y - 1\n -x^3 + x^2\n\njulia> I = ideal(S, V)\nideal(x*y - z^2, -x^3 + x^2*z)\n\njulia> dehomogenization(I, 3)\nideal(x*y - 1, -x^3 + x^2)\n\njulia> W = [1 2 1 0; 3 4 0 1]\n2×4 Matrix{Int64}:\n 1  2  1  0\n 3  4  0  1\n\njulia> S, (w, x, y, z) = GradedPolynomialRing(QQ, [\"w\", \"x\", \"y\", \"z\"], W)\n(Multivariate Polynomial Ring in w, x, y, z over Rational Field graded by\n  w -> [1 3]\n  x -> [2 4]\n  y -> [1 0]\n  z -> [0 1], MPolyElem_dec{fmpq, fmpq_mpoly}[w, x, y, z])\n\njulia> F = w^3*y^3*z^3 + w^2*x*y^2*z^2 + w*x^2*y*z + x^3\nw^3*y^3*z^3 + w^2*x*y^2*z^2 + w*x^2*y*z + x^3\n\njulia> dehomogenization(F, 3)\nw^3 + w^2*x + w*x^2 + x^3\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-functionality","page":"Matrix functionality","title":"Matrix functionality","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"AbstractAlgebra.jl provides a module, implemented in src/Matrix.jl for matrices over any commutative ring belonging to the AbstractAlgebra abstract type hierarchy. This functionality will work for any matrix type which follows the Matrix interface.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Similarly, AbstractAlgebra.jl provides a module in src/MatrixAlgebra.jl for matrix algebras over a commutative ring.","category":"page"},{"location":"AbstractAlgebra/matrix/#Generic-matrix-types","page":"Matrix functionality","title":"Generic matrix types","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"AbstractAlgebra.jl allows the creation of dense matrices over any computable commutative ring R. Generic matrices over a commutative ring are implemented in src/generic/Matrix.jl.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Generic matrix algebras of mtimes m matrices are implemented in src/generic/MatrixAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Generic matrices in AbstractAlgebra.jl have type Generic.MatSpaceElem{T} for matrices in a matrix space, or Generic.MatAlgElem{T} for matrices in a matrix algebra, where T is the type of elements of the matrix. Internally, generic matrices are implemented using an object wrapping a Julia two dimensional array, though they are not themselves Julia arrays. See the file src/generic/GenericTypes.jl for details.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"For the most part, one doesn't want to work directly with the MatSpaceElem type though, but with an abstract type called Generic.Mat which includes MatSpaceElem and views thereof.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Parents of generic matrices (matrix spaces) have type Generic.MatSpace{T}. Parents of matrices in a matrix algebra have type Generic.MatAlgebra{T}.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"The dimensions and base ring R of a generic matrix are stored in its parent object, however to allow creation of matrices without first creating the matrix space parent, generic matrices in Julia do not contain a reference to their parent. They contain the row and column numbers (or degree, in the case of matrix algebras) and the base ring on a per matrix basis. The parent object can then be reconstructed from this data on demand.","category":"page"},{"location":"AbstractAlgebra/matrix/#Abstract-types","page":"Matrix functionality","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"The generic matrix types (matrix spaces) belong to the abstract type MatElem{T} and the matrix space parent types belong to MatSpace{T}. Similarly the generic matrix algebra matrix types belong to the abstract type MatAlgElem{T} and the parent types belong to  MatAlgebra{T} Note that both the concrete type of a matrix space parent object and the abstract class it belongs to have the name MatElem, therefore disambiguation is required to specify which is intended. The same is true for the abstract types for matrix spaces and their elements.","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-space-constructors","page":"Matrix functionality","title":"Matrix space constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"A matrix space in AbstractAlgebra.jl represents a collection of all matrices with given dimensions and base ring.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"In order to construct matrices in AbstractAlgebra.jl, one can first construct the matrix space itself. This is accomplished with the following constructor. We discuss creation of matrix algebras separately in a dedicated section elsewhere in the documentation.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"MatrixSpace(R::Ring, rows::Int, cols::Int; cache::Bool=true)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the space of matrices with the given number of rows and columns over the given base ring. By default such matrix spaces are cached based on the base ring and numbers of rows and columns. If the optional named parameter cached is set to false, no caching occurs.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Here are some examples of creating matrix spaces and making use of the resulting parent objects to coerce various elements into the matrix space.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S()\n[0   0   0]\n[0   0   0]\n[0   0   0]\n\njulia> B = S(12)\n[12    0    0]\n[ 0   12    0]\n[ 0    0   12]\n\njulia> C = S(R(11))\n[11    0    0]\n[ 0   11    0]\n[ 0    0   11]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-element-constructors","page":"Matrix functionality","title":"Matrix element constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"There are a few ways to construc matrices other than by coercing elements as shown above. The first method is from an array of elements.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"This can be done with either two or one dimensional arrays.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"(S::MatSpace{T})(A::Matrix{S}) where {S <: RingElement, T <: RingElement}\n(S::MatAlgebra{T})(A::Matrix{S}) where {S <: RingElement, T <: RingElement}","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Create the matrix in the given space/algebra whose (i j) entry is given by A[i, j], where S is the type of elements that can be coerced into the base ring of the matrix.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"(S::MyMatSpace{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}\n(S::MyMatAlgebra{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Create the matrix in the given space/algebra of matrices (with dimensions mtimes n say), whose (i j) entry is given by A[i*(n - 1) + j] and where S is the type of elements that can be coerced into the base ring of the matrix.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"We also provide the following syntax for constructing literal matrices (similar to how Julia arrays can be be constructed).","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"R[a b c...;...]","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Create the matrix over the base ring R consisting of the given rows (separated by semicolons). Each entry is coerced into R  automatically. Note that parentheses may be placed around individual entries if the lists would otherwise be ambiguous, e.g. R[1 2; 2 (- 3)].","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Also see the Matrix interface for a list of other ways to create matrices.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> S = MatrixSpace(QQ, 2, 3)\nMatrix Space of 2 rows and 3 columns over Rationals\n\njulia> T = MatrixAlgebra(QQ, 2)\nMatrix Algebra of degree 2 over Rationals\n\njulia> M1 = S(Rational{BigInt}[2 3 1; 1 0 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> M2 = S(BigInt[2 3 1; 1 0 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> M3 = S(BigInt[2, 3, 1, 1, 0, 4])\n[2//1   3//1   1//1]\n[1//1   0//1   4//1]\n\njulia> N1 = T(Rational{BigInt}[2 3; 1 0])\n[2//1   3//1]\n[1//1   0//1]\n\njulia> N2 = T(BigInt[2 3; 1 0])\n[2//1   3//1]\n[1//1   0//1]\n\njulia> N3 = T(BigInt[2, 3, 1, 1])\n[2//1   3//1]\n[1//1   1//1]\n\njulia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> M = R[t + 1 1; t^2 0]\n[t + 1   1]\n[  t^2   0]\n\njulia> N = R[t + 1 2 t] # create a row vector\n[t + 1   2   t]\n\njulia> P = R[1; 2; t] # create a column vector\n[1]\n[2]\n[t]","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"It is also possible to create matrices (in a matrix space only) directly, without first creating the corresponding matrix space (the inner constructor being called directly).","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"matrix(R::Ring, arr::Matrix{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Given an mtimes n Julia matrix of entries, construct the corresponding AbstractAlgebra.jl matrix over the given ring R, assuming all the entries can be coerced into R.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"matrix(R::Ring, r::Int, c::Int, A::Vector{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the given rtimes c AbstractAlgebra.jl matrix over the ring R whose (i j) entry is given by A[c*(i - 1) + j], assuming that all the entries can be coerced into R.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"zero_matrix(R::Ring, r::Int, c::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the rtimes c AbstractAlgebra.jl zero matrix over the ring R.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, BigInt[3 1 2; 2 0 1])\n[3   1   2]\n[2   0   1]\n\njulia> N = matrix(ZZ, 3, 2, BigInt[3, 1, 2, 2, 0, 1])\n[3   1]\n[2   2]\n[0   1]\n\njulia> P = zero_matrix(ZZ, 3, 2)\n[0   0]\n[0   0]\n[0   0]\n\njulia> R = MatrixAlgebra(ZZ, 2)\nMatrix Algebra of degree 2 over Integers\n\njulia> M = R()\n[0   0]\n[0   0]","category":"page"},{"location":"AbstractAlgebra/matrix/#Block-diagonal-matrix-constructors","page":"Matrix functionality","title":"Block diagonal matrix constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"It is also possible to create block diagonal matrices from a vector of existing matrices. It is also possible to construct them from Julia matrices if one supplies the base ring.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Note that if the input matrices are not square, the output matrix may not be square.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"block_diagonal_matrix(::Vector{<:MatElem{T}}) where T <: RingElement\nblock_diagonal_matrix(::Ring, ::Vector{<:Matrix{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#block_diagonal_matrix-Union{Tuple{Vector{var\"#s271\"} where var\"#s271\"<:MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"block_diagonal_matrix","text":"block_diagonal_matrix(V::Vector{<:MatElem{T}}) where T <: RingElement\n\nCreate the block diagonal matrix whose blocks are given by the matrices in V. There must be at least one matrix in V.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#block_diagonal_matrix-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring, Vector{var\"#s271\"} where var\"#s271\"<:Matrix{T}}} where T<:RingElement","page":"Matrix functionality","title":"block_diagonal_matrix","text":"block_diagonal_matrix(R::Ring, V::Vector{<:Matrix{T}}) where T <: RingElement\n\nCreate the block diagonal matrix over the ring R whose blocks are given by the matrices in V. Entries are coerced into R upon creation.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> block_diagonal_matrix(ZZ, [[1 2; 3 4], [4 5 6; 7 8 9]])\n[1   2   0   0   0]\n[3   4   0   0   0]\n[0   0   4   5   6]\n[0   0   7   8   9]\n\njulia> M = matrix(ZZ, [1 2; 3 4])\n[1   2]\n[3   4]\n\njulia> N = matrix(ZZ, [4 5 6; 7 8 9])\n[4   5   6]\n[7   8   9]\n\njulia> block_diagonal_matrix([M, N])\n[1   2   0   0   0]\n[3   4   0   0   0]\n[0   0   4   5   6]\n[0   0   7   8   9]","category":"page"},{"location":"AbstractAlgebra/matrix/#Conversion-to-Julia-matrices-and-iteration","page":"Matrix functionality","title":"Conversion to Julia matrices and iteration","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"While AbstractAlgebra matrices are not instances of AbstractArray, they are closely related to Julia matrices. For convenience, a Matrix and an Array constructors taking an AbstractAlgebra matrix as input are provided:","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Matrix(::MatrixElem)\nArray(::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-Tuple{MatrixElem{T} where T}","page":"Matrix functionality","title":"Matrix","text":"Matrix(A::MatrixElem)\n\nConvert A to a Julia Matrix of the same dimensions with the same elements.\n\nExamples\n\njulia> A = ZZ[1 2 3; 4 5 6]\n[1   2   3]\n[4   5   6]\n\njulia> Matrix(A)\n2×3 Matrix{BigInt}:\n 1  2  3\n 4  5  6\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#Array-Tuple{MatrixElem{T} where T}","page":"Matrix functionality","title":"Array","text":"Array(A::MatrixElem)\n\nConvert A to a Julia Matrix of the same dimensions with the same elements.\n\nExamples\n\njulia> R, x = ZZ[\"x\"]; A = R[x^0 x^1; x^2 x^3]\n[  1     x]\n[x^2   x^3]\n\njulia> Array(A)\n2×2 Matrix{AbstractAlgebra.Generic.Poly{BigInt}}:\n 1    x\n x^2  x^3\n\n\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Matrices also support iteration, and therefore functions accepting an iterator can be called on them, e.g.:","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = MatrixSpace(ZZ, 2, 3); x = M(1:6)\n[1   2   3]\n[4   5   6]\n\njulia> collect(x)\n2×3 Matrix{BigInt}:\n 1  2  3\n 4  5  6\n\njulia> Set(x)\nSet{BigInt} with 6 elements:\n  5\n  4\n  6\n  2\n  3\n  1","category":"page"},{"location":"AbstractAlgebra/matrix/#Views","page":"Matrix functionality","title":"Views","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"As per Julia, AbstractAlgebra supports the construction of matrix views.  These allow one to work with a submatrix of a given matrix. Modifying the submatrix also modifies the original matrix.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"The syntax for views is as for Julia's own views.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, 3, 3, BigInt[1, 2, 3, 2, 3, 4, 3, 4, 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N1 = @view M[1:2, :]\n[1   2   3]\n[2   3   4]\n\njulia> N2 = @view M[:, 1:2]\n[1   2]\n[2   3]\n[3   4]\n\njulia> R = N1*N2\n[14   20]\n[20   29]","category":"page"},{"location":"AbstractAlgebra/matrix/#Matrix-functionality-provided-by-AbstractAlgebra.jl","page":"Matrix functionality","title":"Matrix functionality provided by AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Most of the following generic functionality is available for both matrix spaces and matrix algebras. Exceptions include functions that do not return or accept square matrices or which cannot specify a parent. Such functions include solve, kernel, and nullspace which can't be provided for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"For details on functionality that is provided for matrix algebras only, see the dedicated section of the documentation.","category":"page"},{"location":"AbstractAlgebra/matrix/#Basic-matrix-functionality","page":"Matrix functionality","title":"Basic matrix functionality","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"As well as the Ring and Matrix interfaces, the following functions are provided to manipulate matrices and to set and retrieve entries and other basic data associated with the matrices.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"dense_matrix_type(::Ring)","category":"page"},{"location":"AbstractAlgebra/matrix/#dense_matrix_type-Tuple{AbstractAlgebra.Ring}","page":"Matrix functionality","title":"dense_matrix_type","text":"dense_matrix_type(R::Ring)\n\nReturn the type of matrices over the given ring.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"nrows(::MatSpace)\nncols(::MatSpace)","category":"page"},{"location":"AbstractAlgebra/matrix/#nrows-Tuple{MatSpace}","page":"Matrix functionality","title":"nrows","text":"nrows(a::MatSpace)\n\nReturn the number of rows of the given matrix space.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#ncols-Tuple{MatSpace}","page":"Matrix functionality","title":"ncols","text":"ncols(a::MatSpace)\n\nReturn the number of columns of the given matrix space.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"nrows(::MatrixElem)\nncols(::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#nrows-Tuple{MatrixElem{T} where T}","page":"Matrix functionality","title":"nrows","text":"nrows(a::MatrixElem)\n\nReturn the number of rows of the given matrix.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#ncols-Tuple{MatrixElem{T} where T}","page":"Matrix functionality","title":"ncols","text":"ncols(a::MatrixElem)\n\nReturn the number of columns of the given matrix.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"length(::MatElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#length-Tuple{MatElem}","page":"Matrix functionality","title":"length","text":"length(a::MatrixElem)\n\nReturn the number of entries in the given matrix.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"isempty(::MatElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#isempty-Tuple{MatElem}","page":"Matrix functionality","title":"isempty","text":"isempty(a::MatrixElem)\n\nReturn true if a does not contain any entry (i.e. length(a) == 0), and false otherwise.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"identity_matrix(::Ring, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#identity_matrix-Tuple{AbstractAlgebra.Ring, Int64}","page":"Matrix functionality","title":"identity_matrix","text":"identity_matrix(R::Ring, n::Int)\n\nReturn the n times n identity matrix over R.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"identity_matrix(::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#identity_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"identity_matrix","text":"identity_matrix(M::MatElem{T}) where T <: RingElement\n\nConstruct the identity matrix in the same matrix space as M, i.e. with ones down the diagonal and zeroes elsewhere. M must be square. This is an alias for one(M).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"diagonal_matrix(::RingElement, ::Int, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#diagonal_matrix-Tuple{RingElement, Int64, Int64}","page":"Matrix functionality","title":"diagonal_matrix","text":"diagonal_matrix(x::RingElement, m::Int, [n::Int])\n\nReturn the m times n matrix over R with x along the main diagonal and zeroes elsewhere. If n is not specified, it defaults to m.\n\nExamples\n\njulia> diagonal_matrix(ZZ(2), 2, 3)\n[2   0   0]\n[0   2   0]\n\njulia> diagonal_matrix(QQ(-1), 3)\n[-1//1    0//1    0//1]\n[ 0//1   -1//1    0//1]\n[ 0//1    0//1   -1//1]\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"zero(::MatSpace)\nzero(::MatrixElem, ::Ring)","category":"page"},{"location":"AbstractAlgebra/matrix/#zero-Tuple{MatSpace}","page":"Matrix functionality","title":"zero","text":"zero(a::MatSpace)\n\nReturn the zero matrix in the given matrix space.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#zero-Tuple{MatrixElem{T} where T, AbstractAlgebra.Ring}","page":"Matrix functionality","title":"zero","text":"zero(x::MatrixElem, R::Ring, r::Int, c::Int)\nzero(x::MatrixElem, R::Ring=base_ring(x))\nzero(x::MatrixElem, r::Int, c::Int)\n\nReturn a zero matrix similar to the given matrix, with optionally different base ring or dimensions.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"one(::MatSpace)\none(::MatElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#one-Tuple{MatSpace}","page":"Matrix functionality","title":"one","text":"one(a::MatSpace)\n\nReturn the identity matrix of given matrix space. The matrix space must contain square matrices or else an error is thrown.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#one-Tuple{MatElem}","page":"Matrix functionality","title":"one","text":"one(a::MatrixElem)\n\nReturn the identity matrix in the same matrix space as a. If the space does not contain square matrices, an error is thrown.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"istriu(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#istriu-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"istriu","text":"istriu(A::MatrixElem{T}) where T <: RingElement\n\nReturn true if A is an upper triangular matrix.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"change_base_ring(::Ring, ::MatElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#change_base_ring-Tuple{AbstractAlgebra.Ring, MatElem}","page":"Matrix functionality","title":"change_base_ring","text":"change_base_ring(R::Ring, M::MatrixElem)\n\nReturn the matrix obtained by coercing each entry into R.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Base.map(f, ::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#map-Tuple{Any, MatrixElem{T} where T}","page":"Matrix functionality","title":"map","text":"map(f, a::MatrixElem)\n\nTransform matrix a by applying f on each element. This is equivalent to map_entries(f, a).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Base.map!(f, ::MatrixElem, ::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#map!-Tuple{Any, MatrixElem{T} where T, MatrixElem{T} where T}","page":"Matrix functionality","title":"map!","text":"map!(f, dst::MatrixElem, src::MatrixElem)\n\nLike map, but stores the result in dst rather than a new matrix. This is equivalent to map_entries!(f, dst, src).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n[ 2       3       1]\n[ t   t + 1   t + 2]\n[-1     t^2     t^3]\n\njulia> T = dense_matrix_type(R)\nAbstractAlgebra.Generic.MatSpaceElem{AbstractAlgebra.Generic.Poly{Rational{BigInt}}}\n\njulia> r = nrows(B)\n3\n\njulia> c = ncols(B)\n3\n\njulia> length(B)\n9\n\njulia> isempty(B)\nfalse\n\njulia> M = A + B\n[  t + 3         t + 3                   2]\n[t^2 + t       2*t + 1             2*t + 2]\n[     -3   t^2 + t + 2   t^3 + t^2 + t + 1]\n\njulia> N = 2 + A\n[t + 3       t             1]\n[  t^2   t + 2             t]\n[   -2   t + 2   t^2 + t + 3]\n\njulia> M1 = deepcopy(A)\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> A != B\ntrue\n\njulia> isone(one(S))\ntrue\n\njulia> V = A[1:2, :]\n[t + 1   t   1]\n[  t^2   t   t]\n\njulia> W = A^3\n[    3*t^4 + 4*t^3 + t^2 - 3*t - 5            t^4 + 5*t^3 + 10*t^2 + 7*t + 4                 2*t^4 + 7*t^3 + 9*t^2 + 8*t + 1]\n[t^5 + 4*t^4 + 3*t^3 - 7*t^2 - 4*t               4*t^4 + 8*t^3 + 7*t^2 + 2*t                 t^5 + 5*t^4 + 9*t^3 + 7*t^2 - t]\n[  t^5 + 3*t^4 - 10*t^2 - 16*t - 2   t^5 + 6*t^4 + 12*t^3 + 11*t^2 + 5*t - 2   t^6 + 3*t^5 + 8*t^4 + 15*t^3 + 10*t^2 + t - 5]\n\njulia> Z = divexact(2*A, 2)\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> M = matrix(ZZ, BigInt[2 3 0; 1 1 1])\n[2   3   0]\n[1   1   1]\n\njulia> M[1, 2] = BigInt(4)\n4\n\njulia> c = M[1, 1]\n2\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Transpose","page":"Matrix functionality","title":"Transpose","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"transpose(::MatElem{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Return the transpose of the given matrix.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = transpose(A)\n[t + 1   t^2            -2]\n[    t     t         t + 2]\n[    1     t   t^2 + t + 1]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Submatrices","page":"Matrix functionality","title":"Submatrices","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Submatrices are only available for matrix spaces, not for matrix algebras and generally only available for generic matrices built on Julia arrays.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Submatrices return a new matrix with the same entries as the submatrix with the given range of rows and columns. They are best illustrated with examples.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N1 = M[1:2, :]\n[1   2   3]\n[2   3   4]\n\njulia> N2 = M[:, :]\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N3 = M[2:3, 2:3]\n[3   4]\n[4   5]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Elementary-row-and-column-operations","page":"Matrix functionality","title":"Elementary row and column operations","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"add_column(::MatElem, ::Int, ::Int, ::Int)\nadd_column!(::MatElem, ::Int, ::Int, ::Int)\nadd_row(::MatElem, ::Int, ::Int, ::Int)\nadd_row!(::MatElem, ::Int, ::Int, ::Int)\nmultiply_column(::MatElem, ::Int, ::Int)\nmultiply_column!(::MatElem, ::Int, ::Int)\nmultiply_row(::MatElem, ::Int, ::Int)\nmultiply_row!(::MatElem, ::Int, ::Int)\n","category":"page"},{"location":"AbstractAlgebra/matrix/#add_column-Tuple{MatElem, Int64, Int64, Int64}","page":"Matrix functionality","title":"add_column","text":"add_column(a::MatrixElem, s::RingElement, i::Int, j::Int, rows = 1:nrows(a))\n\nCreate a copy of a and add s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#add_column!-Tuple{MatElem, Int64, Int64, Int64}","page":"Matrix functionality","title":"add_column!","text":"add_column!(a::MatrixElem, s::RingElement, i::Int, j::Int, rows = 1:nrows(a))\n\nAdd s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#add_row-Tuple{MatElem, Int64, Int64, Int64}","page":"Matrix functionality","title":"add_row","text":"add_row(a::MatrixElem, s::RingElement, i::Int, j::Int, cols = 1:ncols(a))\n\nCreate a copy of a and add s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#add_row!-Tuple{MatElem, Int64, Int64, Int64}","page":"Matrix functionality","title":"add_row!","text":"add_row!(a::MatrixElem, s::RingElement, i::Int, j::Int, cols = 1:ncols(a))\n\nAdd s times the i-th row to the j-th row of a.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#multiply_column-Tuple{MatElem, Int64, Int64}","page":"Matrix functionality","title":"multiply_column","text":"multiply_column(a::MatrixElem, s::RingElement, i::Int, rows = 1:nrows(a))\n\nCreate a copy of a and multiply the ith column of a with s.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#multiply_column!-Tuple{MatElem, Int64, Int64}","page":"Matrix functionality","title":"multiply_column!","text":"multiply_column!(a::MatrixElem, s::RingElement, i::Int, rows = 1:nrows(a))\n\nMultiply the ith column of a with s.\n\nBy default, the transformation is applied to all rows of a. This can be changed using the optional rows argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#multiply_row-Tuple{MatElem, Int64, Int64}","page":"Matrix functionality","title":"multiply_row","text":"multiply_row(a::MatrixElem, s::RingElement, i::Int, cols = 1:ncols(a))\n\nCreate a copy of a and multiply  the ith row of a with s.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#multiply_row!-Tuple{MatElem, Int64, Int64}","page":"Matrix functionality","title":"multiply_row!","text":"multiply_row!(a::MatrixElem, s::RingElement, i::Int, cols = 1:ncols(a))\n\nMultiply the ith row of a with s.\n\nBy default, the transformation is applied to all columns of a. This can be changed using the optional cols argument.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = ZZ[1 2 3; 2 3 4; 4 5 5]\n[1   2   3]\n[2   3   4]\n[4   5   5]\n\njulia> add_column(M, 2, 3, 1)\n[ 7   2   3]\n[10   3   4]\n[14   5   5]\n\njulia> add_row(M, 1, 2, 3)\n[1   2   3]\n[2   3   4]\n[6   8   9]\n\njulia> multiply_column(M, 2, 3)\n[1   2    6]\n[2   3    8]\n[4   5   10]\n\njulia> multiply_row(M, 2, 3)\n[1    2    3]\n[2    3    4]\n[8   10   10]","category":"page"},{"location":"AbstractAlgebra/matrix/#Row-swapping","page":"Matrix functionality","title":"Row swapping","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"swap_rows!(M::MatElem, i::Int, j::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Swap the rows of M in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = identity_matrix(ZZ, 3)\n[1   0   0]\n[0   1   0]\n[0   0   1]\n\njulia> swap_rows!(M, 1, 2)\n[0   1   0]\n[1   0   0]\n[0   0   1]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Concatenation","page":"Matrix functionality","title":"Concatenation","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"The following are only available for matrix spaces, not for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"hcat(M::T, N::T) where T <: MatElem","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Return the horizontal concatenation of M and N. It is assumed that the number of rows of M and N are the same.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"vcat(M::T, N::T) where T <: MatElem","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Return the vertical concatenation of M and N. It is assumed that the number of columns of M and N are the same.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, BigInt[1 2 3; 2 3 4; 3 4 5])\n[1   2   3]\n[2   3   4]\n[3   4   5]\n\njulia> N = matrix(ZZ, BigInt[1 0 1; 0 1 0; 1 0 1])\n[1   0   1]\n[0   1   0]\n[1   0   1]\n\njulia> P = hcat(M, N)\n[1   2   3   1   0   1]\n[2   3   4   0   1   0]\n[3   4   5   1   0   1]\n\njulia> Q = vcat(M, N)\n[1   2   3]\n[2   3   4]\n[3   4   5]\n[1   0   1]\n[0   1   0]\n[1   0   1]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Similar-and-zero","page":"Matrix functionality","title":"Similar and zero","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Both similar and zero construct new matrices, but the entries are either undefined with similar or zero-initialized with zero.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"similar(x::MatElem, R::Ring=base_ring(x))\nzero(x::MatElem, R::Ring=base_ring(x))","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the matrix with the same dimensions as the given matrix, and the same base ring unless explicitly specified.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"similar(x::MatElem, R::Ring, r::Int, c::Int)\nsimilar(x::MatElem, r::Int, c::Int)\nzero(x::MatElem, R::Ring, r::Int, c::Int)\nzero(x::MatElem, r::Int, c::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Construct the rtimes c matrix with R as base ring (which defaults to the base ring of the the given matrix). If x belongs to a matrix algebra and r neq c, an exception is raised, and it's also possible to specify only one Int as the order (e.g. similar(x, n)).","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Base.isassigned(M::MatElem, i, j)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Test whether the given matrix has a value associated with indices i and j.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, BigInt[3 1 2; 2 0 1])\n[3   1   2]\n[2   0   1]\n\njulia> isassigned(M, 1, 2)\ntrue\n\njulia> isassigned(M, 4, 4)\nfalse\n\njulia> A = similar(M)\n[#undef   #undef   #undef]\n[#undef   #undef   #undef]\n\njulia> isassigned(A, 1, 2)\nfalse\n\njulia> B = zero(M)\n[0   0   0]\n[0   0   0]\n\njulia> C = similar(M, 4, 5)\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n[#undef   #undef   #undef   #undef   #undef]\n\njulia> base_ring(B)\nIntegers\n\njulia> D = zero(M, QQ, 2, 2)\n[0//1   0//1]\n[0//1   0//1]\n\njulia> base_ring(D)\nRationals","category":"page"},{"location":"AbstractAlgebra/matrix/#Symmetry-testing","page":"Matrix functionality","title":"Symmetry testing","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"LinearAlgebra.issymmetric(a::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Return true if the given matrix is symmetric with respect to its main diagonal, otherwise return false.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = matrix(ZZ, [1 2 3; 2 4 5; 3 5 6])\n[1   2   3]\n[2   4   5]\n[3   5   6]\n\njulia> issymmetric(M)\ntrue\n\njulia> N = matrix(ZZ, [1 2 3; 4 5 6; 7 8 9])\n[1   2   3]\n[4   5   6]\n[7   8   9]\n\njulia> issymmetric(N)\nfalse","category":"page"},{"location":"AbstractAlgebra/matrix/#Powering","page":"Matrix functionality","title":"Powering","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"powers(::MatElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#powers-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"powers","text":"powers(a::Union{NCRingElement, MatElem}, d::Int)\n\nReturn an array M of \"powers\" of a where Mi + 1 = a^i for i = 0d\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> M = ZZ[1 2 3; 2 3 4; 4 5 5]\n[1   2   3]\n[2   3   4]\n[4   5   5]\n\njulia> A = powers(M, 4)\n5-element Vector{AbstractAlgebra.Generic.MatSpaceElem{BigInt}}:\n [1 0 0; 0 1 0; 0 0 1]\n [1 2 3; 2 3 4; 4 5 5]\n [17 23 26; 24 33 38; 34 48 57]\n [167 233 273; 242 337 394; 358 497 579]\n [1725 2398 2798; 2492 3465 4044; 3668 5102 5957]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Gram-matrix","page":"Matrix functionality","title":"Gram matrix","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"gram(::MatElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#gram-Tuple{MatElem}","page":"Matrix functionality","title":"gram","text":"gram(x::MatElem)\n\nReturn the Gram matrix of x, i.e. if x is an rtimes c matrix return the rtimes r matrix whose entries i j are the dot products of the i-th and j-th rows, respectively.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> B = gram(A)\n[2*t^2 + 2*t + 2   t^3 + 2*t^2 + t                   2*t^2 + t - 1]\n[t^3 + 2*t^2 + t       t^4 + 2*t^2                       t^3 + 3*t]\n[  2*t^2 + t - 1         t^3 + 3*t   t^4 + 2*t^3 + 4*t^2 + 6*t + 9]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Trace","page":"Matrix functionality","title":"Trace","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"tr(::MatElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#tr-Tuple{MatElem}","page":"Matrix functionality","title":"tr","text":"tr(x::MatrixElem)\n\nReturn the trace of the matrix a, i.e. the sum of the diagonal elements. We require the matrix to be square.\n\n\n\ntr(x::AbsAlgAssElem{T}) where T -> T\n\nReturns the trace of x.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> b = tr(A)\nt^2 + 3*t + 2\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Content","page":"Matrix functionality","title":"Content","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"content(::MatElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#content-Tuple{MatElem}","page":"Matrix functionality","title":"content","text":"content(x::MatrixElem)\n\nReturn the content of the matrix a, i.e. the greatest common divisor of all its entries, assuming it exists.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> b = content(A)\n1\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Permutation","page":"Matrix functionality","title":"Permutation","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"*(::Perm, ::MatElem)","category":"page"},{"location":"AbstractAlgebra/matrix/#*-Tuple{Perm, MatElem}","page":"Matrix functionality","title":"*","text":"*(P::perm, x::MatrixElem)\n\nApply the pemutation P to the rows of the matrix x and return the result.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, t = PolynomialRing(QQ, \"t\")\n(Univariate Polynomial Ring in t over Rationals, t)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in t over Rationals\n\njulia> G = SymmetricGroup(3)\nFull symmetric group over 3 elements\n\njulia> A = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n[t + 1       t             1]\n[  t^2       t             t]\n[   -2   t + 2   t^2 + t + 1]\n\njulia> P = G([1, 3, 2])\n(2,3)\n\njulia> B = P*A\n[t + 1       t             1]\n[   -2   t + 2   t^2 + t + 1]\n[  t^2       t             t]\n","category":"page"},{"location":"AbstractAlgebra/matrix/#LU-factorisation","page":"Matrix functionality","title":"LU factorisation","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"lu{T <: FieldElem}(::MatElem{T}, ::SymmetricGroup)","category":"page"},{"location":"AbstractAlgebra/matrix/#lu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T<:FieldElem","page":"Matrix functionality","title":"lu","text":"lu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: FieldElement}\n\nReturn a tuple r p L U consisting of the rank of A, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"fflu{T <: RingElem}(::MatElem{T}, ::SymmetricGroup)","category":"page"},{"location":"AbstractAlgebra/matrix/#fflu-Union{Tuple{T}, Tuple{MatElem{T}, AbstractAlgebra.SymmetricGroup}} where T<:RingElem","page":"Matrix functionality","title":"fflu","text":"fflu(A::MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T <: RingElement}\n\nReturn a tuple r d p L U consisting of the rank of A, a denominator d, a permutation p of A belonging to P, a lower triangular matrix L and an upper triangular matrix U such that p(A) = LDU, where p(A) stands for the matrix whose rows are the given permutation p of the rows of A and such that D is the diagonal matrix diag(p_1 p_1p_2 ldots p_n-2p_n-1 p_n-1p_n) where the p_i are the inverses of the diagonal entries of L. The denominator d is set to pm mathrmdet(S) where S is an appropriate submatrix of A (S = A if A is square and nonsingular) and the sign is decided by the parity of the permutation.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 - 2 a - 1 2a])\n[      0   2*x + 3   x^2 + 1]\n[x^2 - 2     x - 1       2*x]\n[x^2 - 2     x - 1       2*x]\n\njulia> r, P, L, U = lu(A)\n(2, (1,2), [1 0 0; 0 1 0; 1 0 1], [x^2-2 x-1 2*x; 0 2*x+3 x^2+1; 0 0 0])\n\njulia> r, d, P, L, U = fflu(A)\n(2, 3*x^2 - 10*x - 8, (1,2), [x^2-2 0 0; 0 3*x^2-10*x-8 0; x^2-2 0 1], [x^2-2 x-1 2*x; 0 3*x^2-10*x-8 -4*x^2-x-2; 0 0 0])\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Reduced-row-echelon-form","page":"Matrix functionality","title":"Reduced row-echelon form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"rref_rational{T <: RingElem}(::MatElem{T})\nrref{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#rref_rational-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"rref_rational","text":"rref_rational(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn a tuple (r A d) consisting of the rank r of M and a denominator d in the base ring of M and a matrix A such that Ad is the reduced row echelon form of M. Note that the denominator is not usually minimal.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#rref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix functionality","title":"rref","text":"rref(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn a tuple (r A) consisting of the rank r of M and a reduced row echelon form A of M.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"isrref{T <: RingElem}(::MatElem{T})\nisrref{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#isrref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"isrref","text":"isrref(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#isrref-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix functionality","title":"isrref","text":"isrref(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\nisrref(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn true if M is in reduced row echelon form, otherwise return false.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> M = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> r, A = rref(M)\n(3, [1 0 0; 0 1 0; 0 0 1])\n\njulia> isrref(A)\ntrue\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in x over Integers\n\njulia> M = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> r, A, d = rref_rational(M)\n(3, [-x^5-2*x^4-15*x^3-18*x^2-8*x-7 0 0; 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7 0; 0 0 -x^5-2*x^4-15*x^3-18*x^2-8*x-7], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)\n\njulia> isrref(A)\ntrue","category":"page"},{"location":"AbstractAlgebra/matrix/#Determinant","page":"Matrix functionality","title":"Determinant","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"det{T <: RingElem}(::MatElem{T})\ndet{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#det-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"det","text":"det(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn the determinant of the matrix M. We assume M is square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#det-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix functionality","title":"det","text":"det(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn the determinant of the matrix M. We assume M is square.\n\n\n\ndet(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn the determinant of the matrix M. We assume M is square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> d = det(A)\n11*x^2 - 30*x - 5\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Rank","page":"Matrix functionality","title":"Rank","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"rank{T <: RingElem}(::MatElem{T})\nrank{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#rank-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"rank","text":"rank(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn the rank of the matrix M.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#rank-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix functionality","title":"rank","text":"rank(M::MatrixElem{T}) where {T <: RingElement}\n\nReturn the rank of the matrix M.\n\n\n\nrank(M::MatrixElem{T}) where {T <: FieldElement}\n\nReturn the rank of the matrix M.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> d = rank(A)\n3\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Minors","page":"Matrix functionality","title":"Minors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"minors(::MatElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#minors-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"minors","text":"minors(A::MatElem, k::Int)\n\nReturn an array consisting of the k-minors of A\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> A = ZZ[1 2 3; 4 5 6]\n[1   2   3]\n[4   5   6]\n\njulia> minors(A, 2)\n3-element Vector{BigInt}:\n -3\n -6\n -3\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Pfaffian","page":"Matrix functionality","title":"Pfaffian","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"pfaffian(::MatElem)\npfaffians(::MatElem, ::Int)","category":"page"},{"location":"AbstractAlgebra/matrix/#pfaffian-Tuple{MatElem}","page":"Matrix functionality","title":"pfaffian","text":"pfaffian(M::MatElem)\n\nReturn the Pfaffian of a skew-symmetric matrix M.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#pfaffians-Tuple{MatElem, Int64}","page":"Matrix functionality","title":"pfaffians","text":"pfaffians(M::MatElem, k::Int)\n\nReturn an array consisting of the k-Pfaffians of a skew-symmetric matrix M.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = PolynomialRing(QQ, [\"x$i\" for i in 1:6])\n(Multivariate Polynomial Ring in 6 variables x1, x2, x3, x4, ..., x6 over Rationals, AbstractAlgebra.Generic.MPoly{Rational{BigInt}}[x1, x2, x3, x4, x5, x6])\n\njulia> M = R[0 x[1] x[2] x[3]; -x[1] 0 x[4] x[5]; -x[2] -x[4] 0 x[6]; -x[3] -x[5] -x[6] 0]\n[  0    x1    x2   x3]\n[-x1     0    x4   x5]\n[-x2   -x4     0   x6]\n[-x3   -x5   -x6    0]\n\njulia> pfaffian(M)\nx1*x6 - x2*x5 + x3*x4\n\njulia> pfaffians(M, 2)\n6-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:\n x1\n x2\n x4\n x3\n x5\n x6\n ","category":"page"},{"location":"AbstractAlgebra/matrix/#Linear-solving","page":"Matrix functionality","title":"Linear solving","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"solve{T <: FieldElem}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#solve-Union{Tuple{T}, Tuple{MatElem{T}, MatElem{T}}} where T<:FieldElem","page":"Matrix functionality","title":"solve","text":"solve(a::MatElem{S}, b::MatElem{S}) where {S <: RingElement}\n\nGiven an mtimes r matrix a over a ring and an mtimes n matrix b over the same ring, return an rtimes n matrix x such that ax = b. If no such matrix exists, an exception is raised. See also solve_left.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"solve_rational{T <: RingElem}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#solve_rational-Union{Tuple{T}, Tuple{MatElem{T}, MatElem{T}}} where T<:RingElem","page":"Matrix functionality","title":"solve_rational","text":"solve_rational(M::MatElem{T}, b::MatElem{T}) where T <: RingElement\n\nGiven a non-singular ntimes n matrix over a ring and an ntimes m matrix over the same ring, return a tuple x d consisting of an ntimes m matrix x and a denominator d such that Ax = db. The denominator will be the determinant of A up to sign. If A is singular an exception is raised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"can_solve_with_solution{T <: RingElement}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#can_solve_with_solution-Union{Tuple{T}, Tuple{MatElem{T}, MatElem{T}}} where T<:RingElement","page":"Matrix functionality","title":"can_solve_with_solution","text":"can_solve_with_solution(a::MatElem{S}, b::MatElem{S}; side::Symbol = :right) where S <: RingElement\n\nGiven two matrices a and b over the same ring, try to solve ax = b if side is :right or xa = b if side is :left. In either case, return a tuple (flag, x). If a solution exists, flag is set to true and x is a solution. If no solution exists, flag is set to false and x is arbitrary. If the dimensions of a and b are incompatible, an exception is raised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"can_solve{T <: RingElement}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#can_solve-Union{Tuple{T}, Tuple{MatElem{T}, MatElem{T}}} where T<:RingElement","page":"Matrix functionality","title":"can_solve","text":"can_solve(a::MatElem{S}, b::MatElem{S}; side::Symbol = :right) where S <: RingElement\n\nGiven two matrices a and b over the same ring, check the solubility of ax = b if side is :right or xa = b if side is :left. Return true if a solution exists, false otherwise. If the dimensions of a and b are incompatible, an exception is raised. If a solution should be computed as well, use can_solve_with_solution instead.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"solve_left{T <: RingElem}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#solve_left-Union{Tuple{T}, Tuple{MatElem{T}, MatElem{T}}} where T<:RingElem","page":"Matrix functionality","title":"solve_left","text":"solve_left(a::MatElem{S}, b::MatElem{S}) where S <: RingElement\n\nGiven an rtimes n matrix a over a ring and an mtimes n matrix b over the same ring, return an mtimes r matrix x such that xa = b. If no such matrix exists, an exception is raised. See also solve.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"solve_triu{T <: FieldElem}(::MatElem{T}, ::MatElem{T}, ::Bool)","category":"page"},{"location":"AbstractAlgebra/matrix/#solve_triu-Union{Tuple{T}, Tuple{MatElem{T}, MatElem{T}, Bool}} where T<:FieldElem","page":"Matrix functionality","title":"solve_triu","text":"solve_triu(U::MatElem{T}, b::MatElem{T}, unit::Bool = false) where {T <: FieldElement}\n\nGiven a non-singular ntimes n matrix over a field which is upper triangular, and an ntimes m matrix over the same field, return an ntimes m matrix x such that Ax = b. If A is singular an exception is raised. If unit is true then U is assumed to have ones on its diagonal, and the diagonal will not be read.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"can_solve_left_reduced_triu{T <: RingElement}(::MatElem{T}, ::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#can_solve_left_reduced_triu-Union{Tuple{T}, Tuple{MatElem{T}, MatElem{T}}} where T<:RingElement","page":"Matrix functionality","title":"can_solve_left_reduced_triu","text":"can_solve_left_reduced_triu(r::MatElem{T},\n                      M::MatElem{T}) where T <: RingElement\n\nReturn a tuple flag, x where flag is set to true if xM = r has a solution, where M is an mtimes n matrix in (upper triangular) Hermite normal form or reduced row echelon form and r and x are row vectors with m columns. If there is no solution, flag is set to false and x is set to the zero row.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> U = MatrixSpace(K, 3, 1)\nMatrix Space of 3 rows and 1 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> b = U([2a, a + 1, (-a - 1)])\n[   2*x]\n[ x + 1]\n[-x - 1]\n\njulia> x = solve(A, b)\n[  1984//7817*x^2 + 1573//7817*x - 937//7817]\n[ -2085//7817*x^2 + 1692//7817*x + 965//7817]\n[-3198//7817*x^2 + 3540//7817*x - 3525//7817]\n\njulia> A = matrix(ZZ, 2, 2, [1, 2, 0, 2])\n[1   2]\n[0   2]\n\njulia> b = matrix(ZZ, 2, 1, [2, 1])\n[2]\n[1]\n\njulia> can_solve(A, b, side = :right)\nfalse\n\njulia> A = matrix(QQ, 2, 2, [3, 4, 5, 6])\n[3//1   4//1]\n[5//1   6//1]\n\njulia> b = matrix(QQ, 1, 2, [2, 1])\n[2//1   1//1]\n\njulia> can_solve_with_solution(A, b; side = :left)\n(true, [-7//2 5//2])\n\njulia> A = S([a + 1 2a + 3 a^2 + 1; K(0) a^2 - 1 2a; K(0) K(0) a])\n[x + 1   2*x + 3   x^2 + 1]\n[    0   x^2 - 1       2*x]\n[    0         0         x]\n\njulia> bb = U([2a, a + 1, (-a - 1)])\n[   2*x]\n[ x + 1]\n[-x - 1]\n\njulia> x = solve_triu(A, bb, false)\n[ 1//3*x^2 + 8//3*x + 13//3]\n[-3//5*x^2 - 3//5*x - 12//5]\n[                   x^2 + 2]\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in x over Integers\n\njulia> U = MatrixSpace(R, 3, 2)\nMatrix Space of 3 rows and 2 columns over Univariate Polynomial Ring in x over Integers\n\njulia> A = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> bbb = U(transpose([2x x + 1 (-x - 1); x + 1 (-x) x^2]))\n[   2*x   x + 1]\n[ x + 1      -x]\n[-x - 1     x^2]\n\njulia> x, d = solve_rational(A, bbb)\n([3*x^4-10*x^3-8*x^2-11*x-4 -x^5+3*x^4+x^3-2*x^2+3*x-1; -2*x^5-x^4+6*x^3+2*x+1 x^6+x^5+4*x^4+9*x^3+8*x^2+5*x+2; 6*x^4+12*x^3+15*x^2+6*x-3 -2*x^5-4*x^4-6*x^3-9*x^2-4*x+1], x^5 + 2*x^4 + 15*x^3 + 18*x^2 + 8*x + 7)\n\njulia> S = MatrixSpace(ZZ, 3, 3)\nMatrix Space of 3 rows and 3 columns over Integers\n\njulia> T = MatrixSpace(ZZ, 3, 1)\nMatrix Space of 3 rows and 1 columns over Integers\n\njulia> A = S([BigInt(2) 3 5; 1 4 7; 9 2 2])\n[2   3   5]\n[1   4   7]\n[9   2   2]\n\njulia> B = T([BigInt(4), 5, 7])\n[4]\n[5]\n[7]","category":"page"},{"location":"AbstractAlgebra/matrix/#Inverse","page":"Matrix functionality","title":"Inverse","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Base.inv{T <: RingElement}(::MatrixElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#inv-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"inv","text":"inv(M::MatrixElem{T}) where {T <: RingElement}\n\nGiven a non-singular ntimes n matrix over a ring, return an ntimes n matrix X such that MX = I_n, where I_n is the ntimes n identity matrix. If M is not invertible over the base ring an exception is raised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"isinvertible_with_inverse{T <: RingElement}(::MatrixElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#isinvertible_with_inverse-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"isinvertible_with_inverse","text":"isinvertible_with_inverse(A::MatrixElem{T}; side::Symbol = :left) where {T <: RingElement}\n\nGiven an ntimes m matrix A over a ring, return a tuple (flag, B). If side is :right and flag is true, B is the right inverse of A i.e. AB is the ntimes n unit matrix. If side is :left and flag is true, B is the left inverse of A i.e. BA is the mtimes m unit matrix. If flag is false, no right or left inverse exists.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"isinvertible{T <: RingElement}(::MatrixElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#isinvertible-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"isinvertible","text":"isinvertible(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if a given square matrix is invertible, false otherwise. If the inverse should also be computed, use isinvertible_with_inverse.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> S = MatrixSpace(K, 3, 3)\nMatrix Space of 3 rows and 3 columns over Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1\n\njulia> A = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> X = inv(A)\n[-343//7817*x^2 + 717//7817*x - 2072//7817   -4964//23451*x^2 + 2195//23451*x - 11162//23451    -232//23451*x^2 - 4187//23451*x - 1561//23451]\n[ 128//7817*x^2 - 655//7817*x + 2209//7817      599//23451*x^2 - 2027//23451*x - 1327//23451   -1805//23451*x^2 + 2702//23451*x - 7394//23451]\n[ 545//7817*x^2 + 570//7817*x + 2016//7817     -1297//23451*x^2 - 5516//23451*x - 337//23451   8254//23451*x^2 - 2053//23451*x + 16519//23451]\n\njulia> isinvertible(A)\ntrue\n\njulia> isinvertible_with_inverse(A)\n(true, [-343//7817*x^2+717//7817*x-2072//7817 -4964//23451*x^2+2195//23451*x-11162//23451 -232//23451*x^2-4187//23451*x-1561//23451; 128//7817*x^2-655//7817*x+2209//7817 599//23451*x^2-2027//23451*x-1327//23451 -1805//23451*x^2+2702//23451*x-7394//23451; 545//7817*x^2+570//7817*x+2016//7817 -1297//23451*x^2-5516//23451*x-337//23451 8254//23451*x^2-2053//23451*x+16519//23451])\n\njulia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = MatrixSpace(R, 3, 3)\nMatrix Space of 3 rows and 3 columns over Univariate Polynomial Ring in x over Integers\n\njulia> A = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n[            0   2*x + 3   x^2 + 1]\n[      x^2 - 2     x - 1       2*x]\n[x^2 + 3*x + 1       2*x         1]\n\njulia> X, d = pseudo_inv(A)\n([4*x^2-x+1 -2*x^3+3 x^3-5*x^2-5*x-1; -2*x^3-5*x^2-2*x-2 x^4+3*x^3+2*x^2+3*x+1 -x^4+x^2+2; -x^3+2*x^2+2*x-1 -2*x^3-9*x^2-11*x-3 2*x^3+3*x^2-4*x-6], -x^5 - 2*x^4 - 15*x^3 - 18*x^2 - 8*x - 7)\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Nullspace","page":"Matrix functionality","title":"Nullspace","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"nullspace{T <: FieldElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#nullspace-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix functionality","title":"nullspace","text":"nullspace(M::MatElem{T}) where {T <: RingElement}\n\nReturn a tuple (nu N) consisting of the nullity nu of M and a basis N (consisting of column vectors) for the right nullspace of M, i.e. such that MN is the zero matrix. If M is an mtimes n matrix N will be an ntimes nu matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In AbstractAlgebra we use the name \"kernel\" for a function to compute an integral kernel.\n\n\n\nnullspace(M::MatElem{T}) where {T <: FieldElement}\n\nReturn a tuple (nu N) consisting of the nullity nu of M and a basis N (consisting of column vectors) for the right nullspace of M, i.e. such that MN is the zero matrix. If M is an mtimes n matrix N will be an ntimes nu matrix.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = PolynomialRing(ZZ, \"x\")\n(Univariate Polynomial Ring in x over Integers, x)\n\njulia> S = MatrixSpace(R, 4, 4)\nMatrix Space of 4 rows and 4 columns over Univariate Polynomial Ring in x over Integers\n\njulia> M = S([-6*x^2+6*x+12 -12*x^2-21*x-15 -15*x^2+21*x+33 -21*x^2-9*x-9;\n              -8*x^2+8*x+16 -16*x^2+38*x-20 90*x^2-82*x-44 60*x^2+54*x-34;\n              -4*x^2+4*x+8 -8*x^2+13*x-10 35*x^2-31*x-14 22*x^2+21*x-15;\n              -10*x^2+10*x+20 -20*x^2+70*x-25 150*x^2-140*x-85 105*x^2+90*x-50])\n[  -6*x^2 + 6*x + 12   -12*x^2 - 21*x - 15    -15*x^2 + 21*x + 33     -21*x^2 - 9*x - 9]\n[  -8*x^2 + 8*x + 16   -16*x^2 + 38*x - 20     90*x^2 - 82*x - 44    60*x^2 + 54*x - 34]\n[   -4*x^2 + 4*x + 8    -8*x^2 + 13*x - 10     35*x^2 - 31*x - 14    22*x^2 + 21*x - 15]\n[-10*x^2 + 10*x + 20   -20*x^2 + 70*x - 25   150*x^2 - 140*x - 85   105*x^2 + 90*x - 50]\n\njulia> n, N = nullspace(M)\n(2, [1320*x^4-330*x^2-1320*x-1320 1056*x^4+1254*x^3+1848*x^2-66*x-330; -660*x^4+1320*x^3+1188*x^2-1848*x-1056 -528*x^4+132*x^3+1584*x^2+660*x-264; 396*x^3-396*x^2-792*x 0; 0 396*x^3-396*x^2-792*x])","category":"page"},{"location":"AbstractAlgebra/matrix/#Kernel","page":"Matrix functionality","title":"Kernel","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"kernel{T <: RingElem}(::MatElem{T})\nleft_kernel{T <: RingElem}(::MatElem{T})\nright_kernel{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#kernel-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"kernel","text":"kernel(a::MatElem{T}; side::Symbol = :right) where T <: RingElement\n\nReturn a tuple (n M), where n is the rank of the kernel and M is a basis for it. If side is right or not specified, the right kernel is computed, i.e. the matrix of columns whose span gives the right kernel space. If side is left, the left kernel is computed, i.e. the matrix of rows whose span is the left kernel space.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#left_kernel-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"left_kernel","text":"left_kernel(a::MatElem{T}) where T <: RingElement\n\nReturn a tuple n, M where M is a matrix whose rows generate the kernel of M and n is the rank of the kernel. The transpose of the output of this function is guaranteed to be in flipped upper triangular format (i.e. upper triangular format if columns and rows are reversed).\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#right_kernel-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"right_kernel","text":"right_kernel(a::MatElem{T}) where T <: RingElement\n\nReturn a tuple n, M where M is a matrix whose columns generate the kernel of M and n is the rank of the kernel.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> S = MatrixSpace(ZZ, 4, 4)\nMatrix Space of 4 rows and 4 columns over Integers\n\njulia> M = S([1 2 0 4;\n              2 0 1 1;\n              0 1 1 -1;\n              2 -1 0 2])\n[1    2   0    4]\n[2    0   1    1]\n[0    1   1   -1]\n[2   -1   0    2]\n\njulia> nr, Nr = kernel(M)\n(1, [-8; -6; 11; 5])\n\njulia> nl, Nl = left_kernel(M)\n(1, [0 -1 1 1])\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Hessenberg-form","page":"Matrix functionality","title":"Hessenberg form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"hessenberg{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#hessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"hessenberg","text":"hessenberg(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the Hessenberg form of M, i.e. an upper Hessenberg matrix which is similar to M. The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"ishessenberg{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#ishessenberg-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"ishessenberg","text":"ishessenberg(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn true if M is in Hessenberg form, otherwise returns false.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R = ResidueRing(ZZ, 7)\nResidue ring of Integers modulo 7\n\njulia> S = MatrixSpace(R, 4, 4)\nMatrix Space of 4 rows and 4 columns over Residue ring of Integers modulo 7\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = hessenberg(M)\n[1   5   5   3]\n[2   1   1   0]\n[0   1   3   2]\n[0   0   2   2]\n\njulia> ishessenberg(A)\ntrue\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Characteristic-polynomial","page":"Matrix functionality","title":"Characteristic polynomial","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"charpoly{T <: RingElem}(::Ring, ::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#charpoly-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring, MatElem{T}}} where T<:RingElem","page":"Matrix functionality","title":"charpoly","text":"charpoly(V::Ring, Y::MatrixElem{T}) where {T <: RingElement}\n\nReturn the characteristic polynomial p of the matrix M. The polynomial ring R of the resulting polynomial must be supplied and the matrix is assumed to be square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R = ResidueRing(ZZ, 7)\nResidue ring of Integers modulo 7\n\njulia> S = MatrixSpace(R, 4, 4)\nMatrix Space of 4 rows and 4 columns over Residue ring of Integers modulo 7\n\njulia> T, x = PolynomialRing(R, \"x\")\n(Univariate Polynomial Ring in x over Residue ring of Integers modulo 7, x)\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> A = charpoly(T, M)\nx^4 + 2*x^2 + 6*x + 2\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Minimal-polynomial","page":"Matrix functionality","title":"Minimal polynomial","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"minpoly{T <: RingElem}(::Ring, ::MatElem{T}, ::Bool)\nminpoly{T <: FieldElem}(::Ring, ::MatElem{T}, ::Bool)","category":"page"},{"location":"AbstractAlgebra/matrix/#minpoly-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring, MatElem{T}, Bool}} where T<:RingElem","page":"Matrix functionality","title":"minpoly","text":"minpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\n\nReturn the minimal polynomial p of the matrix M. The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#minpoly-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring, MatElem{T}, Bool}} where T<:FieldElem","page":"Matrix functionality","title":"minpoly","text":"minpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T <: FieldElement}\n\nReturn the minimal polynomial p of the matrix M. The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\nminpoly(S::Ring, M::MatElem{T}, charpoly_only::Bool = false) where {T <: RingElement}\n\nReturn the minimal polynomial p of the matrix M. The polynomial ring S of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R = GF(13)\nFinite field F_13\n\njulia> T, y = PolynomialRing(R, \"y\")\n(Univariate Polynomial Ring in y over Finite field F_13, y)\n\njulia> M = R[7 6 1;\n             7 7 5;\n             8 12 5]\n[7    6   1]\n[7    7   5]\n[8   12   5]\n\njulia> A = minpoly(T, M)\ny^2 + 10*y\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Transforms","page":"Matrix functionality","title":"Transforms","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"similarity!{T <: RingElem}(::MatElem{T}, ::Int, ::T)","category":"page"},{"location":"AbstractAlgebra/matrix/#similarity!-Union{Tuple{T}, Tuple{MatElem{T}, Int64, T}} where T<:RingElem","page":"Matrix functionality","title":"similarity!","text":"similarity!(A::MatrixElem{T}, r::Int, d::T) where {T <: RingElement}\n\nApplies a similarity transform to the ntimes n matrix M in-place. Let P be the ntimes n identity matrix that has had all zero entries of row r replaced with d, then the transform applied is equivalent to M = P^-1MP. We require M to be a square matrix. A similarity transform preserves the minimal and characteristic polynomials of a matrix.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R = ResidueRing(ZZ, 7)\nResidue ring of Integers modulo 7\n\njulia> S = MatrixSpace(R, 4, 4)\nMatrix Space of 4 rows and 4 columns over Residue ring of Integers modulo 7\n\njulia> M = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n              R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n[1   2   4   3]\n[2   5   1   0]\n[6   1   3   2]\n[1   1   3   5]\n\njulia> similarity!(M, 1, R(3))\n","category":"page"},{"location":"AbstractAlgebra/matrix/#Hermite-normal-form","page":"Matrix functionality","title":"Hermite normal form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"hnf{T <: RingElem}(::MatElem{T})\nhnf_with_transform{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#hnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"hnf","text":"hnf(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the upper right row Hermite normal form of A.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#hnf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"hnf_with_transform","text":"hnf_with_transform(A)\n\nReturn the tuple H U consisting of the upper right row Hermite normal form H of A together with invertible matrix U such that UA = H.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"ishnf{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#ishnf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"ishnf","text":"ishnf(M::MatrixElem{T}) where T <: RingElement\n\nReturn true if the matrix is in Hermite normal form.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])\n[ 2   3   -1]\n[ 3   5    7]\n[11   1   12]\n\njulia> H = hnf(A)\n[1   0   255]\n[0   1    17]\n[0   0   281]\n\njulia> ishnf(H)\ntrue\n\njulia> H, U = hnf_with_transform(A)\n([1 0 255; 0 1 17; 0 0 281], [-47 28 1; -3 2 0; -52 31 1])\n\njulia> U*A\n[1   0   255]\n[0   1    17]\n[0   0   281]","category":"page"},{"location":"AbstractAlgebra/matrix/#Smith-normal-form","page":"Matrix functionality","title":"Smith normal form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"issnf(::MatrixElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/matrix/#issnf-Union{Tuple{MatrixElem{T}}, Tuple{T}} where T<:RingElement","page":"Matrix functionality","title":"issnf","text":"issnf(A::MatrixElem{T}) where T <: RingElement\n\nReturn true if A is in Smith Normal Form.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"snf{T <: RingElem}(::MatElem{T})\nsnf_with_transform{T <: RingElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#snf-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"snf","text":"snf(A::MatrixElem{T}) where {T <: RingElement}\n\nReturn the Smith normal form of A.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#snf_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix functionality","title":"snf_with_transform","text":"snf_with_transform(A)\n\nReturn the tuple S T U consisting of the Smith normal form S of A together with invertible matrices T and U such that TAU = S.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> A = matrix(ZZ, [2 3 -1; 3 5 7; 11 1 12])\n[ 2   3   -1]\n[ 3   5    7]\n[11   1   12]\n\njulia> S = snf(A)\n[1   0     0]\n[0   1     0]\n[0   0   281]\n\njulia> S, T, U = snf_with_transform(A)\n([1 0 0; 0 1 0; 0 0 281], [1 0 0; 7 1 0; 229 31 1], [0 -3 26; 0 2 -17; -1 0 1])\n\njulia> T*A*U\n[1   0     0]\n[0   1     0]\n[0   0   281]","category":"page"},{"location":"AbstractAlgebra/matrix/#(Weak)-Popov-form","page":"Matrix functionality","title":"(Weak) Popov form","text":"","category":"section"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"AbstractAlgebra.jl provides algorithms for computing the (weak) Popov of a matrix with entries in a univariate polynomial ring over a field.","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"isweak_popov(P::MatrixElem{T}, rank::Int) where T <: Generic.Poly","category":"page"},{"location":"AbstractAlgebra/matrix/#isweak_popov-Union{Tuple{T}, Tuple{MatrixElem{T}, Int64}} where T<:AbstractAlgebra.Generic.Poly","page":"Matrix functionality","title":"isweak_popov","text":"isweak_popov(P::MatrixElem{T}, rank::Int) where T <: PolyElem\n\nReturn true if P is a matrix in weak Popov form of the given rank.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"weak_popov{T <: PolyElem}(::MatElem{T})\nweak_popov_with_transform{T <: PolyElem}(::MatElem{T})\npopov{T <: PolyElem}(::MatElem{T})\npopov_with_transform{T <: PolyElem}(::MatElem{T})","category":"page"},{"location":"AbstractAlgebra/matrix/#weak_popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyElem","page":"Matrix functionality","title":"weak_popov","text":"weak_popov(A::MatElem{T}) where {T <: PolyElem}\n\nReturn the weak Popov form of A.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#weak_popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyElem","page":"Matrix functionality","title":"weak_popov_with_transform","text":"weak_popov_with_transform(A::MatElem{T}) where {T <: PolyElem}\n\nCompute a tuple (P U) where P is the weak Popov form of A and U is a transformation matrix so that P = UA.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#popov-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyElem","page":"Matrix functionality","title":"popov","text":"popov(A::MatElem{T}) where {T <: PolyElem}\n\nReturn the Popov form of A.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/#popov_with_transform-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:PolyElem","page":"Matrix functionality","title":"popov_with_transform","text":"popov_with_transform(A::MatElem{T}) where {T <: PolyElem}\n\nCompute a tuple (P U) where P is the Popov form of A and U is a transformation matrix so that P = UA.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"Examples","category":"page"},{"location":"AbstractAlgebra/matrix/","page":"Matrix functionality","title":"Matrix functionality","text":"julia> R, x = PolynomialRing(QQ, \"x\");\n\njulia> A = matrix(R, map(R, Any[1 2 3 x; x 2*x 3*x x^2; x x^2+1 x^3+x^2 x^4+x^2+1]))\n[1         2           3               x]\n[x       2*x         3*x             x^2]\n[x   x^2 + 1   x^3 + x^2   x^4 + x^2 + 1]\n\njulia> P = weak_popov(A)\n[   1                        2                    3   x]\n[   0                        0                    0   0]\n[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]\n\njulia> P, U = weak_popov_with_transform(A)\n([1 2 3 x; 0 0 0 0; -x^3 -2*x^3+x^2-2*x+1 -2*x^3+x^2-3*x 1], [1 0 0; -x 1 0; -x^3-x 0 1])\n\njulia> U*A\n[   1                        2                    3   x]\n[   0                        0                    0   0]\n[-x^3   -2*x^3 + x^2 - 2*x + 1   -2*x^3 + x^2 - 3*x   1]","category":"page"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/numberfield/#Number-fields","page":"Number fields","title":"Number fields","text":"","category":"section"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"AbstractAlgebra.jl provides a very naive implementation of number fields. This allows arithmetic in algebraic number fields, which are currently modeled as mathbbQx modulo an irreducible polynomial, i.e. as a residue field.","category":"page"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"The definition of the number field constructor is given in src/generic/NumberField.jl but no type is defined for a number field. The definition mainly exists for testing purposes. It may later be replaced by a more standard implementation. For a more fully fleshed out number field implementation (based on a very high performance C library), see Nemo.jl.","category":"page"},{"location":"AbstractAlgebra/numberfield/#Number-field-constructors","page":"Number fields","title":"Number field constructors","text":"","category":"section"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"In order to construct number fields in AbstractAlgebra.jl, one must first construct the field itself. This is accomplished with the following constructor.","category":"page"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"NumberField(f::Generic.Poly{Rational{BigInt}}, s::AbstractString, t = \"\\$\"; cached = true)","category":"page"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"Given an irreducible defining polynomial f in mathbbQx, return a tuple (K x) consisting of the number field defined by that polynomial and a generator. The string fields are currently ignored, but are reserved for future use.","category":"page"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"Currently the generator of the number field prints the same way as the variable in mathbbQx.","category":"page"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"julia> R, x = PolynomialRing(QQ, \"x\")\n(Univariate Polynomial Ring in x over Rationals, x)\n\njulia> K, a = NumberField(x^3 + 3x + 1, \"a\")\n(Residue field of Univariate Polynomial Ring in x over Rationals modulo x^3 + 3*x + 1, x)\n\njulia> f = a^2 + 2a + 7\nx^2 + 2*x + 7\n","category":"page"},{"location":"AbstractAlgebra/numberfield/#Basic-field-functionality","page":"Number fields","title":"Basic field functionality","text":"","category":"section"},{"location":"AbstractAlgebra/numberfield/","page":"Number fields","title":"Number fields","text":"The number field module in AbstractAlgebra.jl implements the full Field and ResidueRing interfaces.","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"CurrentModule = Oscar","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"using Oscar","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"Pages = [\"simplicialcomplexes.md\"]","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#Simplicial-Complexes","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/#Introduction","page":"Simplicial Complexes","title":"Introduction","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"Abstract simplicial complexes provide a combinatorial way to define topological spaces. By no means every topological space arises in this way, but this is a (most) natural choice in a computational setup.","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"A simplicial complex K on a vertex set V is a nonempty subset of 2^V such that for each sigma in K and tau subsetsigma we have tauin K. Here V is usually n = 12dotsn for some ngeq 0.","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"General textbooks offering details on the theory include:","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"Dmitry Kozlov (2008)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#Construction","page":"Simplicial Complexes","title":"Construction","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"SimplicialComplex(K::Vector{Vector{Int}})","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#SimplicialComplex-Tuple{Vector{Vector{Int64}}}","page":"Simplicial Complexes","title":"SimplicialComplex","text":"SimplicialComplex(generators::Union{Vector{Vector{Int}}, Vector{Set{Int}}})\n\nConstruct an abstract simplicial complex from a set of faces. While arbitrary nonnegative integers are allowed as vertices, they will be relabeled to consecutive integers starting at 1.\n\nExamples\n\njulia> K = SimplicialComplex([[1,2,3],[2,3,4]])\nAbstract simplicial complex of dimension 2 on 4 vertices\n\nSimplicial complex comprising the empty set only:\n\njulia> empty = SimplicialComplex(Vector{Set{Int}}([]))\nAbstract simplicial complex of dimension -1 on 0 vertices\n\nThe original vertices can be recovered:\n\njulia> L = SimplicialComplex([[0,2,17],[2,17,90]]);\n\njulia> facets(L)\n2-element Vector{Set{Int64}}:\n Set([2, 3, 1])\n Set([4, 2, 3])\n\njulia> vertexindices(L)\n4-element Vector{Int64}:\n  0\n  2\n 17\n 90\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Subcomplexes","page":"Simplicial Complexes","title":"Subcomplexes","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"star_subcomplex(K::SimplicialComplex, sigma::Union{Vector{Int}, Set{Int}})\nlink_subcomplex(K::SimplicialComplex, sigma::Union{Vector{Int}, Set{Int}})","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#star_subcomplex-Tuple{SimplicialComplex, Union{Set{Int64}, Vector{Int64}}}","page":"Simplicial Complexes","title":"star_subcomplex","text":"star_subcomplex(K::SimplicialComplex, sigma::Union{Vector{Int}, Set{Int}})\n\nReturn the star of the face sigma in the abstract simplicial complex K.\n\nExamples\n\njulia> K = SimplicialComplex([[1,2,3],[2,3,4]]);\n\njulia> star_subcomplex(K,[1])\nAbstract simplicial complex of dimension 2 on 3 vertices\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#link_subcomplex-Tuple{SimplicialComplex, Union{Set{Int64}, Vector{Int64}}}","page":"Simplicial Complexes","title":"link_subcomplex","text":"link_subcomplex(K::SimplicialComplex, sigma::Union{Vector{Int}, Set{Int}})\n\nReturn the link of the face sigma in the abstract simplicial complex K.\n\nExamples\n\njulia> K = SimplicialComplex([[1,2,3],[2,3,4]]);\n\njulia> link_subcomplex(K,[2,3])\nAbstract simplicial complex of dimension 0 on 2 vertices\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Surface-examples","page":"Simplicial Complexes","title":"Surface examples","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"torus()\nklein_bottle()\nreal_projective_plane()","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#torus-Tuple{}","page":"Simplicial Complexes","title":"torus","text":"torus()\n\nConstruct Möbius' (vertex-minimal) 7-vertex triangulation of the torus (surface).\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#klein_bottle-Tuple{}","page":"Simplicial Complexes","title":"klein_bottle","text":"klein_bottle()\n\nConstruct a 9-vertex triangulation of the Klein bottle.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#real_projective_plane-Tuple{}","page":"Simplicial Complexes","title":"real_projective_plane","text":"real_projective_plane()\n\nConstruct the (vertex-minimal) 6-vertex triangulation of the real projective plane.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Other-examples","page":"Simplicial Complexes","title":"Other examples","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"complex_projective_plane()","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#complex_projective_plane-Tuple{}","page":"Simplicial Complexes","title":"complex_projective_plane","text":"complex_projective_plane()\n\nConstruct the (vertex-minimal) 9-vertex triangulation of the complex projective plane.\n\n\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Basic-properties","page":"Simplicial Complexes","title":"Basic properties","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"nvertices(K::SimplicialComplex)\ndim(K::SimplicialComplex)\nf_vector(K::SimplicialComplex)\nh_vector(K::SimplicialComplex)\neuler_characteristic(K::SimplicialComplex)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#nvertices-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"nvertices","text":"nvertices(K::SimplicialComplex)\n\nReturn the number of vertices of the abstract simplicial complex K.\n\nExamples\n\njulia> nvertices(torus())\n7\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#dim-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"dim","text":"dim(K::SimplicialComplex)\n\nReturn the dimension of the abstract simplicial complex K.\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#f_vector-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"f_vector","text":"f_vector(K::SimplicialComplex)\n\nReturn the face vector (number of faces per dimension) of the abstract simplicial complex K.\n\nExamples\n\njulia> f_vector(torus())\n3-element Vector{Int64}:\n  7\n 21\n 14\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#h_vector-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"h_vector","text":"h_vector(K::SimplicialComplex)\n\nReturn the h-vector of the abstract simplicial complex K.\n\nExamples\n\njulia> h_vector(torus())\n4-element Vector{Int64}:\n  1\n  4\n 10\n -1\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#euler_characteristic-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"euler_characteristic","text":"euler_characteristic(K::SimplicialComplex)\n\nReturn the reduced Euler characteristic of the abstract simplicial complex K.\n\nExamples\n\njulia> euler_characteristic(complex_projective_plane())\n2\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Homology-and-cohomology","page":"Simplicial Complexes","title":"Homology and cohomology","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"homology(K::SimplicialComplex, i::Int)\nbetti_numbers(K::SimplicialComplex)\ncohomology(K::SimplicialComplex, i::Int)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#homology-Tuple{SimplicialComplex, Int64}","page":"Simplicial Complexes","title":"homology","text":"homology(K::SimplicialComplex, i::Int)\n\nReturn i-th reduced integral homology group of K. Recall that the 0-th homology group is trivial if and only if K is connected.\n\nExamples\n\njulia> [ homology(real_projective_plane(), i) for i in [0,1,2] ]\n3-element Vector{GrpAbFinGen}:\n GrpAb: Z/1\n GrpAb: Z/2\n GrpAb: Z/1\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#betti_numbers-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"betti_numbers","text":"betti_numbers(K::SimplicialComplex)\n\nReturn the reduced rational Betti numbers of the abstract simplicial complex K.\n\nExamples\n\njulia> betti_numbers(klein_bottle())\n3-element Vector{Int64}:\n 0\n 1\n 0\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#cohomology-Tuple{SimplicialComplex, Int64}","page":"Simplicial Complexes","title":"cohomology","text":"cohomology(K::SimplicialComplex, i::Int)\n\nReturn i-th reduced integral cohomology group of K.\n\nExamples\n\njulia> K = SimplicialComplex([[0,1],[1,2],[0,2]]);\n\njulia> cohomology(K,1)\n(General) abelian group with relation matrix\n[1]\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Fundamental-group","page":"Simplicial Complexes","title":"Fundamental group","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"fundamental_group(K::SimplicialComplex)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#fundamental_group-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"fundamental_group","text":"fundamental_group(K::SimplicialComplex)\n\nReturn the fundamental group of the abstract simplicial complex K.\n\nExamples\n\njulia> pi_1 = fundamental_group(torus());\n\njulia> describe(pi_1)\n\"Z x Z\"\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Connection-to-commutative-algebra","page":"Simplicial Complexes","title":"Connection to commutative algebra","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"The complements of the minimal non-faces form the facets of the Alexander dual.","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"minimal_nonfaces(K::SimplicialComplex)\nalexander_dual(K::SimplicialComplex)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#minimal_nonfaces-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"minimal_nonfaces","text":"minimal_nonfaces(K::SimplicialComplex)\n\nReturn the minimal non-faces of the abstract simplicial complex K.\n\nExamples\n\njulia> K = SimplicialComplex([[1,2,3],[2,3,4]]);\n\njulia> minimal_nonfaces(K)\n1-element Vector{Set{Int64}}:\n Set([4, 1])\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#alexander_dual-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"alexander_dual","text":"alexander_dual(K::SimplicialComplex)\n\nReturn the Alexander dual of the abstract simplicial complex K.\n\nExamples\n\njulia> K = SimplicialComplex([[1,2,3],[2,3,4]]);\n\njulia> alexander_dual(K)\nAbstract simplicial complex of dimension 1 on 2 vertices\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"Let K be a simplicial complex on n vertices. The minimal non-faces of K generate a square-free monomial ideal, known as the Stanley-Reisner ideal of K. The quotient of the polynomial ring (in n variables, with integer coefficients) modulo that ideal is the Stanley-Reisner ring. For details see Chapter 5 of Winfried Bruns, Jürgen Herzog (2009).","category":"page"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"stanley_reisner_ideal(K::SimplicialComplex)\nstanley_reisner_ideal(R::MPolyRing, K::SimplicialComplex)\nstanley_reisner_ring(K::SimplicialComplex)\nstanley_reisner_ring(R::MPolyRing, K::SimplicialComplex)","category":"page"},{"location":"Combinatorics/simplicialcomplexes/#stanley_reisner_ideal-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"stanley_reisner_ideal","text":"stanley_reisner_ideal(K::SimplicialComplex)\n\nReturn the Stanley-Reisner ideal of the abstract simplicial complex K.\n\nExamples\n\njulia> stanley_reisner_ideal(real_projective_plane())\nideal(x1*x2*x3, x1*x2*x4, x1*x5*x6, x2*x5*x6, x1*x3*x6, x1*x4*x5, x3*x4*x5, x3*x4*x6, x2*x3*x5, x2*x4*x6)\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#stanley_reisner_ideal-Tuple{MPolyRing, SimplicialComplex}","page":"Simplicial Complexes","title":"stanley_reisner_ideal","text":"stanley_reisner_ideal(R::MPolyRing, K::SimplicialComplex)\n\nReturn the Stanley-Reisner ideal of the abstract simplicial complex K, in the given ring R.\n\nExamples\n\njulia> R, _ = QQ[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"];\n\njulia> stanley_reisner_ideal(R, real_projective_plane())\nideal(a*b*c, a*b*d, a*e*f, b*e*f, a*c*f, a*d*e, c*d*e, c*d*f, b*c*e, b*d*f)\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#stanley_reisner_ring-Tuple{SimplicialComplex}","page":"Simplicial Complexes","title":"stanley_reisner_ring","text":"stanley_reisner_ring(K::SimplicialComplex)\n\nReturn the Stanley-Reisner ring of the abstract simplicial complex K.\n\nExamples\n\njulia> K = SimplicialComplex([[1,2,3],[2,3,4]]);\n\njulia> stanley_reisner_ring(K)\n(Quotient of Multivariate Polynomial Ring in x1, x2, x3, x4 over Rational Field by ideal(x1*x4), Map from\nMultivariate Polynomial Ring in x1, x2, x3, x4 over Rational Field to Quotient of Multivariate Polynomial Ring in x1, x2, x3, x4 over Rational Field by ideal(x1*x4) defined by a julia-function with inverse)\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#stanley_reisner_ring-Tuple{MPolyRing, SimplicialComplex}","page":"Simplicial Complexes","title":"stanley_reisner_ring","text":"stanley_reisner_ring(R::MPolyRing, K::SimplicialComplex)\n\nReturn the Stanley-Reisner ring of the abstract simplicial complex K, as a quotient of a given ring R.\n\nExamples\n\njulia>  R, _ = ZZ[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"];\n\njulia> stanley_reisner_ring(R, real_projective_plane())\n(Quotient of Multivariate Polynomial Ring in 6 variables a, b, c, d, ..., f over Integer Ring by ideal(a*b*c, a*b*d, a*e*f, b*e*f, a*c*f, a*d*e, c*d*e, c*d*f, b*c*e, b*d*f), Map from\nMultivariate Polynomial Ring in 6 variables a, b, c, d, ..., f over Integer Ring to Quotient of Multivariate Polynomial Ring in 6 variables a, b, c, d, ..., f over Integer Ring by ideal(a*b*c, a*b*d, a*e*f, b*e*f, a*c*f, a*d*e, c*d*e, c*d*f, b*c*e, b*d*f) defined by a julia-function with inverse)\n\n\n\n","category":"method"},{"location":"Combinatorics/simplicialcomplexes/#Saving-and-loading","page":"Simplicial Complexes","title":"Saving and loading","text":"","category":"section"},{"location":"Combinatorics/simplicialcomplexes/","page":"Simplicial Complexes","title":"Simplicial Complexes","text":"Objects of type SimplicialComplex can be saved to a file and loaded with the two methods save and load.  The file is in JSON format and contains the underlying polymake object.  In particular, such a file can be read by both polymake and Oscar.","category":"page"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"CurrentModule = Oscar","category":"page"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"Pages = [\"ToricLineBundles.md\"]","category":"page"},{"location":"ToricVarieties/ToricLineBundles/#Toric-Line-Bundles","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"","category":"section"},{"location":"ToricVarieties/ToricLineBundles/#Constructors","page":"Toric Line Bundles","title":"Constructors","text":"","category":"section"},{"location":"ToricVarieties/ToricLineBundles/#Generic-constructors","page":"Toric Line Bundles","title":"Generic constructors","text":"","category":"section"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"ToricLineBundle(v::AbstractNormalToricVariety, c::Vector{fmpz})\nToricLineBundle(v::AbstractNormalToricVariety, c::Vector{Int})\nToricLineBundle(v::AbstractNormalToricVariety, d::ToricDivisor)","category":"page"},{"location":"ToricVarieties/ToricLineBundles/#ToricLineBundle-Tuple{Oscar.AbstractNormalToricVariety, Vector{fmpz}}","page":"Toric Line Bundles","title":"ToricLineBundle","text":"ToricLineBundle(v::AbstractNormalToricVariety, c::Vector{fmpz})\n\nConstruct the line bundle on the abstract normal toric variety v with class c.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(v, [fmpz(2)])\nA toric line bundle on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#ToricLineBundle-Tuple{Oscar.AbstractNormalToricVariety, Vector{Int64}}","page":"Toric Line Bundles","title":"ToricLineBundle","text":"ToricLineBundle(v::AbstractNormalToricVariety, c::Vector{Int})\n\nConvenience method for ToricLineBundle(v::AbstractNormalToricVariety, c::Vector{fmpz}).\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(v, [2])\nA toric line bundle on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#ToricLineBundle-Tuple{Oscar.AbstractNormalToricVariety, ToricDivisor}","page":"Toric Line Bundles","title":"ToricLineBundle","text":"ToricLineBundle(v::AbstractNormalToricVariety, d::ToricDivisor)\n\nConstruct the toric variety associated to a (Cartier) torus-invariant divisor d on the normal toric variety v.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(v, ToricDivisor(v,[1,2,3]))\nA toric line bundle on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#Tensor-products","page":"Toric Line Bundles","title":"Tensor products","text":"","category":"section"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"Toric line bundles l1 and l2 (on the same toric variety) can be tensored by l1*l2. We support the k-th tensor power by l1^k. k can be either an integer or valued in fmpz. The inverse of l1 is computed by inv(l1).","category":"page"},{"location":"ToricVarieties/ToricLineBundles/#Equality","page":"Toric Line Bundles","title":"Equality","text":"","category":"section"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"Equality of toric line bundles l1 and l2 (on the same toric variety) is implemented by l1 == l2.","category":"page"},{"location":"ToricVarieties/ToricLineBundles/#Properties","page":"Toric Line Bundles","title":"Properties","text":"","category":"section"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"To check if a line bundle l is trivial, one can invoke istrivial(l). Beyond this, we support the following properties of toric line bundles:","category":"page"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"is_basepoint_free(l::ToricLineBundle)\nisample(l::ToricLineBundle)\nis_very_ample(l::ToricLineBundle)","category":"page"},{"location":"ToricVarieties/ToricLineBundles/#is_basepoint_free-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"is_basepoint_free","text":"is_basepoint_free(l::ToricLineBundle)\n\nReturn true if the toric line bundle l is basepoint free and false otherwise.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> is_basepoint_free(ToricLineBundle(F4, [0,1]))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#isample-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"isample","text":"isample(l::ToricLineBundle)\n\nReturn true if the toric line bundle l is ample and false otherwise.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> isample(ToricLineBundle(F4, [1,0]))\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#is_very_ample-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"is_very_ample","text":"is_very_ample(l::ToricLineBundle)\n\nReturn true if the toric line bundle l is very ample and false otherwise.\n\nExamples\n\njulia> F4 = hirzebruch_surface(4)\nA normal, non-affine, smooth, projective, gorenstein, non-fano, 2-dimensional toric variety without torusfactor\n\njulia> is_very_ample(ToricLineBundle(F4, [1,0]))\nfalse\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#Attributes","page":"Toric Line Bundles","title":"Attributes","text":"","category":"section"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"degree(l::ToricLineBundle)\ndivisor_class(l::ToricLineBundle)\ntoric_divisor(l::ToricLineBundle)\ntoric_variety(l::ToricLineBundle)","category":"page"},{"location":"ToricVarieties/ToricLineBundles/#degree-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"degree","text":"degree(l::ToricLineBundle)\n\nReturn the degree of the toric line bundle l.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(v, [fmpz(2)])\nA toric line bundle on a normal toric variety\n\njulia> degree(l)\n2\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#divisor_class-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"divisor_class","text":"divisor_class(l::ToricLineBundle)\n\nReturn the divisor class which defines the toric line bundle l.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(v, [fmpz(2)])\nA toric line bundle on a normal toric variety\n\njulia> divisor_class(l)\nElement of\nGrpAb: Z\nwith components [2]\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#toric_divisor-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"toric_divisor","text":"toric_divisor(l::ToricLineBundle)\n\nReturn a divisor corresponding to the toric line bundle l.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(v, [fmpz(2)])\nA toric line bundle on a normal toric variety\n\njulia> toric_divisor(l)\nA torus-invariant, cartier, non-prime divisor on a normal toric variety\n\njulia> iscartier(toric_divisor(l))\ntrue\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#toric_variety-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"toric_variety","text":"toric_variety(l::ToricLineBundle)\n\nReturn the toric variety over which the toric line bundle l is defined.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(v, [fmpz(2)])\nA toric line bundle on a normal toric variety\n\njulia> toric_variety(l)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#Special-line-bundles","page":"Toric Line Bundles","title":"Special line bundles","text":"","category":"section"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"anticanonical_bundle(v::AbstractNormalToricVariety)\ncanonical_bundle(v::AbstractNormalToricVariety)\nstructure_sheaf(v::AbstractNormalToricVariety)","category":"page"},{"location":"ToricVarieties/ToricLineBundles/#anticanonical_bundle-Tuple{Oscar.AbstractNormalToricVariety}","page":"Toric Line Bundles","title":"anticanonical_bundle","text":"anticanonical_bundle(v::AbstractNormalToricVariety)\n\nConstruct the anticanonical bundle of a normal toric variety. For convenience, we also support anticanonical_bundle(variety).\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> anticanonical_bundle(v)\nA toric line bundle on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#canonical_bundle-Tuple{Oscar.AbstractNormalToricVariety}","page":"Toric Line Bundles","title":"canonical_bundle","text":"canonical_bundle(v::AbstractNormalToricVariety)\n\nConstruct the canonical bundle of a normal toric variety. For convenience, we also support canonical_bundle(variety).\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> canonical_bundle(v)\nA toric line bundle on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#structure_sheaf-Tuple{Oscar.AbstractNormalToricVariety}","page":"Toric Line Bundles","title":"structure_sheaf","text":"structure_sheaf(v::AbstractNormalToricVariety)\n\nConstruct the structure sheaf of a normal toric variety. For convenience, we also support structure_sheaf(variety).\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> structure_sheaf(v)\nA toric line bundle on a normal toric variety\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#Methods","page":"Toric Line Bundles","title":"Methods","text":"","category":"section"},{"location":"ToricVarieties/ToricLineBundles/","page":"Toric Line Bundles","title":"Toric Line Bundles","text":"basis_of_global_sections_via_rational_functions(l::ToricLineBundle)\nbasis_of_global_sections_via_homogeneous_component(l::ToricLineBundle)","category":"page"},{"location":"ToricVarieties/ToricLineBundles/#basis_of_global_sections_via_rational_functions-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"basis_of_global_sections_via_rational_functions","text":"basis_of_global_sections_via_rational_functions(l::ToricLineBundle)\n\nReturn a basis of the global sections of the toric line bundle l in terms of rational functions.\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(v, [fmpz(2)])\nA toric line bundle on a normal toric variety\n\njulia> basis_of_global_sections_via_rational_functions(l)\n6-element Vector{MPolyQuoElem{fmpq_mpoly}}:\n x1_^2\n x2*x1_^2\n x2^2*x1_^2\n x1_\n x2*x1_\n 1\n\n\n\n","category":"method"},{"location":"ToricVarieties/ToricLineBundles/#basis_of_global_sections_via_homogeneous_component-Tuple{ToricLineBundle}","page":"Toric Line Bundles","title":"basis_of_global_sections_via_homogeneous_component","text":"basis_of_global_sections_via_homogeneous_component(l::ToricLineBundle)\n\nReturn a basis of the global sections of the toric line bundle l in terms of a homogeneous component of the Cox ring of toric_variety(l). For convenience, this method can also be called via basis_of_global_sections(l::ToricLineBundle).\n\nExamples\n\njulia> v = projective_space(NormalToricVariety, 2)\nA normal, non-affine, smooth, projective, gorenstein, fano, 2-dimensional toric variety without torusfactor\n\njulia> l = ToricLineBundle(v, [fmpz(2)])\nA toric line bundle on a normal toric variety\n\njulia> basis_of_global_sections_via_homogeneous_component(l)\n6-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n x3^2\n x2*x3\n x2^2\n x1*x3\n x1*x2\n x1^2\n\njulia> basis_of_global_sections(l)\n6-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n x3^2\n x2*x3\n x2^2\n x1*x3\n x1*x2\n x1^2\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/series_interface/#Series-Ring-Interface","page":"Series Ring Interface","title":"Series Ring Interface","text":"","category":"section"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Univariate power series rings are supported in AbstractAlgebra in a variety of different forms, including absolute and relative precision models and Laurent series.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"In addition to the standard Ring interface, numerous additional functions are required to be present for power series rings.","category":"page"},{"location":"AbstractAlgebra/series_interface/#Types-and-parents","page":"Series Ring Interface","title":"Types and parents","text":"","category":"section"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"AbstractAlgebra provides two abstract types for power series rings and their elements:","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"SeriesRing{T} is the abstract type for all power series ring parent types\nSeriesElem{T} is the abstract type for all power series types","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"We have that SeriesRing{T} <: Ring and SeriesElem{T} <: RingElem.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Note that both abstract types are parameterised. The type T should usually be the type of elements of the coefficient ring of the power series ring. For example, in the case of mathbbZx the type T would be the type of an integer, e.g. BigInt.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Within the SeriesElem{T} abstract type is the abstract type RelSeriesElem{T} for relative power series, and AbsSeriesElem{T} for absolute power series.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Relative series are typically stored with a valuation and a series that is either zero or that has nonzero constant term. Absolute series are stored starting from the constant term, even if it is zero.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"If the parent object for a relative series ring over the bignum integers has type MySeriesRing and series in that ring have type MySeries then one would have:","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"MySeriesRing <: SeriesRing{BigInt}\nMySeries <: RelSeriesElem{BigInt}","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Series rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Series rings should at least be distinguished based on their base (coefficient) ring. But if they have the same base ring and symbol (for their variable/generator) and same default precision, they should certainly have the same parent object.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"AbstractAlgebra/series_interface/#Required-functionality-for-series","page":"Series Ring Interface","title":"Required functionality for series","text":"","category":"section"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"In addition to the required functionality for the Ring interface the Series Ring interface has the following required functions.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"We suppose that R is a fictitious base ring (coefficient ring) and that S is a series ring over R (e.g. S = Rx) with parent object S of type MySeriesRing{T}. We also assume the series in the ring have type MySeries{T}, where T is the type of elements of the base (coefficient) ring.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem.","category":"page"},{"location":"AbstractAlgebra/series_interface/#Constructors","page":"Series Ring Interface","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"In addition to the standard constructors, the following constructors, taking an array of coefficients, must be available.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"For relative power series and Laurent series we have:","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"(S::MySeriesRing{T})(A::Vector{T}, len::Int, prec::Int, val::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Create the series in the given ring whose valuation is val, whose absolute precision is given by prec and the coefficients of which are given by A, starting from the first nonzero term. Only len terms of the array are used, the remaining terms being ignored. The value len cannot exceed the length of the supplied array.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"It is permitted to have trailing zeros in the array, but it is not needed, even if the precision minus the valuation is bigger than the length of the array.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"(S::MySeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: RingElem}","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"As above, but where the array is an array of coefficient that can be coerced into the base ring of the series ring.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"(S::MySeriesRing{T})(A::Vector{U}, len::Int, prec::Int, val::Int) where {T <: RingElem, U <: Integer}","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"As above, but where the array is an array of integers that can be coerced into the base ring of the series ring.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"It may be desirable to implement an addition version which accepts an array of Julia Int values if this can be done more efficiently.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"For absolute power series we have:","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"(S::MySeriesRing{T})(A::Vector{T}, len::Int, prec::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Create the series in the given ring whose absolute precision is given by prec and the coefficients of which are given by A, starting from the constant term. Only len terms of the array are used, the remaining terms being ignored.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Note that len is usually maintained separately of any polynomial that is underlying the power series. This allows for easy trucation of a power series without actually modifying the polynomial underlying it.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"It is permitted to have trailing zeros in the array, but it is not needed, even if the precision is bigger than the length of the array.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"It is also possible to create series directly without having to create the corresponding series ring.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"abs_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, var::AbstractString=\"x\"; max_precision::Int=prec, cached::Bool=true) where T\nrel_series(R::Ring, arr::Vector{T}, len::Int, prec::Int, val::Int, var::AbstractString=\"x\"; max_precision::Int=prec, cached::Bool=true) where T","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Create the power series over the given base ring R with coefficients specified by arr with the given absolute precision prec and in the case of relative series with the given valuation val.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Note that more coefficients may be specified than are actually used. Only the first len coefficients are made part of the series, the remainder being stored internally but ignored.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"In the case of absolute series one must have prec >= len and in the case of relative series one must have prec >= len + val.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"By default the series are created in a ring with variable x and max_precision equal to prec, however one may specify these directly to override the defaults. Note that series are only compatible if they have the same coefficient ring R, max_precision and variable string var.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Also by default any parent ring created is cached. If this behaviour is not desired, set cached=false. However, this means that subsequent series created in the same way will not be compatible. Instead, one should use the parent object of the first series to create subsequent series instead of calling this function repeatedly with cached=false.","category":"page"},{"location":"AbstractAlgebra/series_interface/#Data-type-and-parent-object-methods","page":"Series Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"var(S::MySeriesRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return a Symbol representing the variable (generator) of the series ring. Note that this is a Symbol not a String, though its string value will usually be used when printing series.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Custom series types over a given ring should define one of the following functions which return the type of an absolute or relative series object over that ring.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"abs_series_type(::Type{T}) where T <: RingElement\nrel_series_type(::Type{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the type of a series whose coefficients have the given type.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This function is defined for generic series and only needs to be defined for custom series rings, e.g. ones defined by a C implementation.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"max_precision(S::MySeriesRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the (default) maximum precision of the power series ring. This is the precision that the output of an operation will be if it cannot be represented to full precision (e.g. because it mathematically has infinite precision).","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This value is usually supplied upon creation of the series ring and stored in the ring. It is independent of the precision which each series in the ring actually has. Those are stored on a per element basis in the actual series elements.","category":"page"},{"location":"AbstractAlgebra/series_interface/#Basic-manipulation-of-rings-and-elements","page":"Series Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"pol_length(f::MySeries{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the length of the polynomial underlying the given power series. This is not generally useful to the user, but is used internally.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"set_length!(f::MySeries{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This function sets the effective length of the polynomial underlying the given series. The function doesn't modify the actual polynomial, but simply changes the number of terms of the polynomial which are considered to belong to the power series. The remaining terms are ignored.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This function cannot set the length to a value greater than the length of any underlying polynomial.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"The function mutates the series in-place but does not return the mutated series.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"precision(f::MySeries{T})","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the absolute precision of f.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"set_precision!(f::MySeries{T}, prec::Int)","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Set the absolute precision of the given series to the given value.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This return the updated series.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"valuation(f::MySeries{T})","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the valuation of the given series.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"set_valuation!(f::MySeries{T}, val::Int)","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"For relative series and Laurent series only, this function alters the valuation of the given series to the given value.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"This function returns the updated series.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"polcoeff(f::MySeries{T}, n::Int)","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the coefficient of degree n of the polynomial underlying the series. If n is larger than the degree of this polynomial, zero is returned. This function is not generally of use to the user but is used internally.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"setcoeff!(f::MySeries{T}, n::Int, a::T) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Set the degree n coefficient of the polynomial underlying f to a. This mutates the polynomial in-place if possible and returns the mutated series (so that immutable types can also be supported). The function must not assume that the polynomial already has space for n + 1 coefficients. The polynomial must be resized if this is not the case.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"note: Note\nThis function is not required to normalise the polynomial and is not necessarily useful to the user, but is used extensively by the generic functionality in AbstractAlgebra.jl. It is for setting raw coefficients in the representation.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"normalise(f::MySeries{T}, n::Int)","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Given a series f represented by a polynomial of at least the given length, return the normalised length of the underlying polynomial assuming it has length at most n. This function does not actually normalise the polynomial and is not particularly useful to the user. It is used internally.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"renormalize!(f::MySeries{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Given a relative series or Laurent series whose underlying polynomial has zero constant term, say as the result of some internal computation, renormalise the series so that the polynomial has nonzero constant term. The precision and valuation of the series are adjusted to compensate. This function is not intended to be useful to the user, but is used internally.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"fit!(f::MySeries{T}, n::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Ensure that the polynomial underlying f internally has space for n coefficients. This function must mutate the series in-place if it is mutable. It does not return the mutated series. Immutable types can still be supported by defining this function to do nothing.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Some interfaces for C polynomial types automatically manage the internal allocation of polynomials in every function that can be called on them. Explicit adjustment by the generic code in AbstractAlgebra.jl is not required. In such cases, this function can also be defined to do nothing.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"gen(R::MySeriesRing{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Return the generator x of the series ring.","category":"page"},{"location":"AbstractAlgebra/series_interface/#Optional-functionality-for-series","page":"Series Ring Interface","title":"Optional functionality for series","text":"","category":"section"},{"location":"AbstractAlgebra/series_interface/#Similar-and-zero","page":"Series Ring Interface","title":"Similar and zero","text":"","category":"section"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"The following functions are available for all absolute and relative series types. The functions similar and zero do the same thing, but are provided for uniformity with other parts of the interface.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"similar(x::MySeries, R::Ring, max_prec::Int, var::Symbol=var(parent(x)); cached::Bool=true)\nzero(a::MySeries, R::Ring, max_prec::Int, var::Symbol=var(parent(a)); cached::Bool=true)","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Construct the zero series with the given variable (if specified), coefficients in the specified coefficient ring and with relative/absolute precision cap on its parent ring as given by max_prec.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"similar(x::MySeries, R::Ring, var::Symbol=var(parent(x)); cached::Bool=true)\nsimilar(x::MySeries, max_prec::Int, var::Symbol=var(parent(x)); cached::Bool=true)\nsimilar(x::MySeries, var::Symbol=var(parent(x)); cached::Bool=true)\nsimilar(x::MySeries, R::Ring, max_prec::Int, var::String; cached::Bool=true)\nsimilar(x::MySeries, R::Ring, var::String; cached::Bool=true)\nsimilar(x::MySeries, max_prec::Int, var::String; cached::Bool=true)\nsimilar(x::MySeries, var::String; cached::Bool=true)\nzero(x::MySeries, R::Ring, var::Symbol=var(parent(x)); cached::Bool=true)\nzero(x::MySeries, max_prec::Int, var::Symbol=var(parent(x)); cached::Bool=true)\nzero(x::MySeries, var::Symbol=var(parent(x)); cached::Bool=true)\nzero(x::MySeries, R::Ring, max_prec::Int, var::String; cached::Bool=true)\nzero(x::MySeries, R::Ring, var::String; cached::Bool=true)\nzero(x::MySeries, max_prec::Int, var::String; cached::Bool=true)\nzero(x::MySeries, var::String; cached::Bool=true)","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"As above, but use the precision cap of the parent ring of x and the base_ring of x if these are not specified.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"Custom series rings may choose which series type is best-suited to return for the given coefficient ring, precision cap and variable, however they should return a series with the same model as x, i.e. relative or series.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"If custom implementations don't specialise these function the default return type is a Generic.AbsSeries or Generic.RelSeries.","category":"page"},{"location":"AbstractAlgebra/series_interface/","page":"Series Ring Interface","title":"Series Ring Interface","text":"The default implementation of zero calls out to similar, so it's generally sufficient to specialise only similar. For both similar and zero only the most general method has to be implemented as all other methods call out to this more general method.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"CurrentModule = Oscar","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"using Oscar","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"Pages = [\"finite_groups.md\"]","category":"page"},{"location":"InvariantTheory/finite_groups/#Invariants-of-Finite-Groups","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"In this section, with notation as in the introduction to this chapter, G will be a finite group.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"note: Note\nThe ssumption that G is finite implies:By a result of Emmy Noether, KV is integral over KV^G. In particular,\n     dim KV^G = dim KV = n\nMoreover, KV^G is finitely generated as a K-algebra.If the group order G is invertible in K, then we have the explicit Reynolds operator\n     mathcal R KV to KV fmapsto frac1Gsum_piin G(f      pi)","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"note: Note\nWe speak of non-modular invariant theory if G is invertible in K, and of modular invariant theory otherwise.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"note: Note\nIn the non-modular case, using  Emmy Noether's result and the Reynolds operator, it is not too difficult to show that KV^G is a free module over any of its graded Noether normalizations. That is, KV^G is Cohen-Macaulay. In the modular case, KV^G may not be Cohen-Macaulay.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"note: Note\nIn the non-modular case, the Hilbert series of KV^G can be precomputed as its Molien series. See Harm Derksen, Gregor Kemper (2015) and Wolfram Decker, Theo de Jong (1998) for explicit formulas.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"Knowing the Hilbert series means to know the dimension of each graded piece KV^G_d. This information can often be used to speed up algorithms for finding invariants. The most basic task here is to compute the invariants of  some given degree d, that is, to find  an explicit K-basis of KV^G_d. There are two different approaches:","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"The Reynolds Operator Method, available in  the non-modular case, applies the Reynolds operator to sufficiently many monomials in Kx_1 dots x_n_dcong KV_d,  and extracts a K-basis from the resulting generating set.\nThe Linear Algebra Method, available in the non-modular and the modular case, finds the elements of a K-basis all at once by setting up and solving an appropriate K-linear system of equations.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"These methods are, in particular, crucial to the computation of primary and secondary invariants. Primary invariants and irreducible secondary invariants together generate KV^G as a K-algebra. Omitting redundant generators yields a system of fundamental invariants. In the non-modular case, an alternative and typically more effective way to compute generators of KV^G is King's algorithm which finds a system of fundamental invariants directly, without computing primary and secondary invariants. See Simon King (2013).","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"We discuss the relevant OSCAR functionality below.","category":"page"},{"location":"InvariantTheory/finite_groups/#Creating-Invariant-Rings","page":"Invariants of Finite Groups","title":"Creating Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"The invariant theory part of OSCAR  distinguishes two ways of how  finite groups and their actions on Kx_1 dots x_ncong KV are specified.","category":"page"},{"location":"InvariantTheory/finite_groups/#Matrix-Groups","page":"Invariants of Finite Groups","title":"Matrix Groups","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"Here, G will be explicitly given as a matrix group Gsubset textGL_n(K)cong textGL(V)  by (finitely many) generating matrices acting on Kx_1 dots x_ncong KV by linear substitution:","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"(f      pi)  (x_1 dots x_n)  = f((x_1 dots x_n) cdot rho(pi)) text for all  piin G","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"invariant_ring(G::MatrixGroup)","category":"page"},{"location":"InvariantTheory/finite_groups/#invariant_ring-Tuple{MatrixGroup}","page":"Invariants of Finite Groups","title":"invariant_ring","text":"invariant_ring(G::MatrixGroup)\n\nReturn the invariant ring of the finite matrix group G.\n\nnote: Note\nThe creation of invariant rings is lazy in the sense that no explicit computations are done until specifically invoked (for example, by the primary_invariants function).\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = MatrixGroup(3, K, [M1, M2]);\n\njulia> IR = invariant_ring(G)\nInvariant ring of\nMatrix group of degree 3 over Cyclotomic field of order 3\nwith generators\nAbstractAlgebra.Generic.MatSpaceElem{nf_elem}[[0 0 1; 1 0 0; 0 1 0], [1 0 0; 0 a 0; 0 0 -a-1]]\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Permutation-Groups","page":"Invariants of Finite Groups","title":"Permutation Groups","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"Taylor made functionality for handling invariant rings of permutation groups is not implemented yet.","category":"page"},{"location":"InvariantTheory/finite_groups/#Basic-Data-Associated-to-Invariant-Rings","page":"Invariants of Finite Groups","title":"Basic Data Associated to Invariant Rings","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"If IR is the invariant ring Kx_1 x_n^G of a finite matrix group G, then","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"group(IR) refers to G,\ncoefficient_ring(IR) to K, and\npolynomial_ring(IR) to Kx_1 x_n.","category":"page"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"Moreover, ismodular(IR) returns true in the modular case, and false otherwise.","category":"page"},{"location":"InvariantTheory/finite_groups/#Examples","page":"Invariants of Finite Groups","title":"Examples","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"K, a = CyclotomicField(3, \"a\")\nM1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\nM2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\nG = MatrixGroup(3, K, [ M1, M2 ])\nIR = invariant_ring(G)\ngroup(IR)\ncoefficient_ring(IR)\nR = polynomial_ring(IR)\nx = gens(R)\nismodular(IR)","category":"page"},{"location":"InvariantTheory/finite_groups/#The-Reynolds-Operator","page":"Invariants of Finite Groups","title":"The Reynolds Operator","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"reynolds_operator(IR::InvRing{FldT, GrpT, T}, f::T) where {FldT, GrpT, T <: MPolyElem}","category":"page"},{"location":"InvariantTheory/finite_groups/#reynolds_operator-Union{Tuple{T}, Tuple{GrpT}, Tuple{FldT}, Tuple{Oscar.InvRing{FldT, GrpT, T, PolyRingT, ActionT, SingularActionT} where {PolyRingT, ActionT, SingularActionT}, T}} where {FldT, GrpT, T<:MPolyElem}","page":"Invariants of Finite Groups","title":"reynolds_operator","text":" reynolds_operator(IR::InvRing{FldT, GrpT, T}, f::T) where {FldT, GrpT, T <: MPolyElem}\n\nIn the non-modular case, return the image of f under the Reynolds operator projecting onto IR.\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = MatrixGroup(3, K, [ M1, M2 ])\nMatrix group of degree 3 over Cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring of\nMatrix group of degree 3 over Cyclotomic field of order 3\nwith generators\nAbstractAlgebra.Generic.MatSpaceElem{nf_elem}[[0 0 1; 1 0 0; 0 1 0], [1 0 0; 0 a 0; 0 0 -a-1]]\n\njulia> R = polynomial_ring(IR)\nMultivariate Polynomial Ring in x[1], x[2], x[3] over Cyclotomic field of order 3 graded by\n  x[1] -> [1]\n  x[2] -> [1]\n  x[3] -> [1]\n\njulia> x = gens(R)\n3-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:\n x[1]\n x[2]\n x[3]\n\njulia> f = x[1]^3\nx[1]^3\n\njulia> reynolds_operator(IR, f)\n1//3*x[1]^3 + 1//3*x[2]^3 + 1//3*x[3]^3\n\njulia> M = matrix(GF(3), [0 1 0; -1 0 0; 0 0 -1])\n[0   1   0]\n[2   0   0]\n[0   0   2]\n\njulia> G = MatrixGroup(3, GF(3), [M])\nMatrix group of degree 3 over Galois field with characteristic 3\n\njulia> IR = invariant_ring(G)\nInvariant ring of\nMatrix group of degree 3 over Galois field with characteristic 3\nwith generators\ngfp_mat[[0 1 0; 2 0 0; 0 0 2]]\n\njulia> R = polynomial_ring(IR)\nMultivariate Polynomial Ring in x[1], x[2], x[3] over Galois field with characteristic 3 graded by\n  x[1] -> [1]\n  x[2] -> [1]\n  x[3] -> [1]\n\njulia> x = gens(R)\n3-element Vector{MPolyElem_dec{gfp_elem, gfp_mpoly}}:\n x[1]\n x[2]\n x[3]\n\njulia> f = x[1]^2\nx[1]^2\n\njulia> reynolds_operator(IR, f)\n2*x[1]^2 + 2*x[2]^2\n\njulia> f = x[1]^3\nx[1]^3\n\njulia> reynolds_operator(IR, f)\n0\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Invariants-of-a-Given-Degree","page":"Invariants of Finite Groups","title":"Invariants of a Given Degree","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"basis(IR::InvRing, d::Int, algo::Symbol = :default)","category":"page"},{"location":"InvariantTheory/finite_groups/#basis","page":"Invariants of Finite Groups","title":"basis","text":" basis(IR::InvRing, d::Int, algo::Symbol = :default)\n\nGiven an invariant ring IR and an integer d, return a basis for the invariants in degree d. The used algorithm can be specified using the optional argument algo. Possible values are :reynolds which uses the reynolds operator to construct the basis (only available in the non-modular case) and :linear_algebra which uses plain linear algebra. With the default value :default the heuristically best algorithm is selected.\n\nSee also iterate_basis.\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = MatrixGroup(3, K, [ M1, M2 ])\nMatrix group of degree 3 over Cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring of\nMatrix group of degree 3 over Cyclotomic field of order 3\nwith generators\nAbstractAlgebra.Generic.MatSpaceElem{nf_elem}[[0 0 1; 1 0 0; 0 1 0], [1 0 0; 0 a 0; 0 0 -a-1]]\n\njulia> basis(IR, 6)\n4-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:\n x[1]^2*x[2]^2*x[3]^2\n x[1]^4*x[2]*x[3] + x[1]*x[2]^4*x[3] + x[1]*x[2]*x[3]^4\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n x[1]^6 + x[2]^6 + x[3]^6\n\njulia> M = matrix(GF(3), [0 1 0; -1 0 0; 0 0 -1])\n[0   1   0]\n[2   0   0]\n[0   0   2]\n\njulia> G = MatrixGroup(3, GF(3), [M])\nMatrix group of degree 3 over Galois field with characteristic 3\n\njulia> IR = invariant_ring(G)\nInvariant ring of\nMatrix group of degree 3 over Galois field with characteristic 3\nwith generators\ngfp_mat[[0 1 0; 2 0 0; 0 0 2]]\n\njulia> basis(IR, 2)\n2-element Vector{MPolyElem_dec{gfp_elem, gfp_mpoly}}:\n x[1]^2 + x[2]^2\n x[3]^2\n\njulia> basis(IR, 3)\n2-element Vector{MPolyElem_dec{gfp_elem, gfp_mpoly}}:\n x[1]*x[2]*x[3]\n x[1]^2*x[3] + 2*x[2]^2*x[3]\n\n\n\n","category":"function"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"iterate_basis(IR::InvRing, d::Int, algo::Symbol = :default)","category":"page"},{"location":"InvariantTheory/finite_groups/#iterate_basis","page":"Invariants of Finite Groups","title":"iterate_basis","text":" iterate_basis(IR::InvRing, d::Int, algo::Symbol = :default)\n\nGiven an invariant ring IR and an integer d, return an iterator over a basis for the invariants in degree d. The used algorithm can be specified using the optional argument algo. Possible values are :reynolds which uses the reynolds operator to construct the basis (only available in the non-modular case) and :linear_algebra which uses plain linear algebra. With the default value :default the heuristically best algorithm is selected.\n\nWhen using the reynolds operator the basis is constructed element-by-element. With linear algebra this is not possible and the whole basis will be constructed directly when calling the function.\n\nSee also basis.\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = MatrixGroup(3, K, [ M1, M2 ])\nMatrix group of degree 3 over Cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring of\nMatrix group of degree 3 over Cyclotomic field of order 3\nwith generators\nAbstractAlgebra.Generic.MatSpaceElem{nf_elem}[[0 0 1; 1 0 0; 0 1 0], [1 0 0; 0 a 0; 0 0 -a-1]]\n\njulia> B = iterate_basis(IR, 6)\nIterator over a basis of the component of degree 6 of\nInvariant ring of\nMatrix group of degree 3 over Cyclotomic field of order 3\nwith generators\nAbstractAlgebra.Generic.MatSpaceElem{nf_elem}[[0 0 1; 1 0 0; 0 1 0], [1 0 0; 0 a 0; 0 0 -a-1]]\n\njulia> collect(B)\n4-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:\n x[1]^2*x[2]^2*x[3]^2\n x[1]^4*x[2]*x[3] + x[1]*x[2]^4*x[3] + x[1]*x[2]*x[3]^4\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n x[1]^6 + x[2]^6 + x[3]^6\n\njulia> M = matrix(GF(3), [0 1 0; -1 0 0; 0 0 -1])\n[0   1   0]\n[2   0   0]\n[0   0   2]\n\njulia> G = MatrixGroup(3, GF(3), [M])\nMatrix group of degree 3 over Galois field with characteristic 3\n\njulia> IR = invariant_ring(G)\nInvariant ring of\nMatrix group of degree 3 over Galois field with characteristic 3\nwith generators\ngfp_mat[[0 1 0; 2 0 0; 0 0 2]]\n\njulia> B = iterate_basis(IR, 2)\nIterator over a basis of the component of degree 2 of\nInvariant ring of\nMatrix group of degree 3 over Galois field with characteristic 3\nwith generators\ngfp_mat[[0 1 0; 2 0 0; 0 0 2]]\n\njulia> collect(B)\n2-element Vector{MPolyElem_dec{gfp_elem, gfp_mpoly}}:\n x[1]^2 + x[2]^2\n x[3]^2\n\n\n\n","category":"function"},{"location":"InvariantTheory/finite_groups/#The-Molien-Series","page":"Invariants of Finite Groups","title":"The Molien Series","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":" molien_series([S::PolyRing], I::InvRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#molien_series-Tuple{PolyRing, Oscar.InvRing}","page":"Invariants of Finite Groups","title":"molien_series","text":"molien_series([S::PolyRing], I::InvRing)\n\nIn the non-modular case, return the Molien series of I as a rational function.\n\nIf a univariate polynomial ring with rational coefficients is specified by the optional argument S::PolyRing, then the Molien series is returned as an element of the fraction field of that ring.\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = MatrixGroup(3, K, [M1, M2]);\n\njulia> IR = invariant_ring(G);\n\njulia> molien_series(IR)\n(-t^6 + t^3 - 1)//(t^9 - 3*t^6 + 3*t^3 - 1)\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Primary-Invariants","page":"Invariants of Finite Groups","title":"Primary Invariants","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"primary_invariants(IR::InvRing, algo::Symbol = :optimal_hsop)","category":"page"},{"location":"InvariantTheory/finite_groups/#primary_invariants","page":"Invariants of Finite Groups","title":"primary_invariants","text":"primary_invariants(IR::InvRing, algo::Symbol = :optimal_hsop)\n\nReturn a system of primary invariants for IR as a Vector sorted by increasing degree. The result is cached, so calling this function again with argument IR  will be fast and give the same result.\n\nThe used algorithm can be specified with the optional argument algo. Possible values are :optimal_hsop which uses the algorithm in Gregor Kemper (1999) or :successive_algo which uses the algorithm from Wolfram Decker, Agnes Eileen Heydtmann, Frank-Olaf Schreyer (1998). The default option is :optimal_hsop which is in general expected to be the faster algorithm.\n\nSee also primary_invariants_via_optimal_hsop and primary_invariants_via_successive_algo for more options.\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = MatrixGroup(3, K, [M1, M2]);\n\njulia> IR = invariant_ring(G);\n\njulia> primary_invariants(IR)\n3-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:\n x[1]*x[2]*x[3]\n x[1]^3 + x[2]^3 + x[3]^3\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n\n\n\n","category":"function"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"primary_invariants_via_optimal_hsop(IR::InvRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#primary_invariants_via_optimal_hsop-Tuple{Oscar.InvRing}","page":"Invariants of Finite Groups","title":"primary_invariants_via_optimal_hsop","text":"primary_invariants_via_optimal_hsop(IR::InvRing;\n  ensure_minimality::Int = 0, degree_bound::Int = 1,\n  primary_degrees::Vector{Int} = Int[])\n\nReturn a system of primary invariants for IR using the algorithm in Gregor Kemper (1999).\n\nThe product of the degrees d_1dots d_n of the returned primary invariants is guaranteed to be minimal among all possible sets of primary invariants.\n\nExpert users (or users happy to experiment) may enter the following keyword arguments to  speed up the computation. If admissible degrees d_1dots d_n for a system of primary  invariants are known a priori, these degrees can be specified by primary_degrees = [d_1, ..., d_n].  Note that an error is raised if in fact no primary invariants of the given degrees exist. An a priori known number k geq 1 with d_1cdots d_n geq k cdot G, where  G is the underlying group, can be specified by degree_bound = k. The default value is degree_bound = 1. In some situations, the runtime of the algorithm might be improved by assigning a positive integer to ensure_minimality. This leads to an early cancellation of loops in the algorithm and the described minimality of the degrees is not guaranteed anymore. A smaller (positive) value of ensure_minimality corresponds to an earlier cancellation. However, the default value ensure_minimality = 0 corresponds to no cancellation.\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = MatrixGroup(3, K, [M1, M2]);\n\njulia> IR = invariant_ring(G);\n\njulia> primary_invariants_via_optimal_hsop(IR)\n3-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:\n x[1]*x[2]*x[3]\n x[1]^3 + x[2]^3 + x[3]^3\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n\njulia> primary_invariants_via_optimal_hsop(IR, primary_degrees = [ 3, 6, 6 ])\n3-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:\n x[1]*x[2]*x[3]\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n x[1]^6 + x[2]^6 + x[3]^6\n\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"primary_invariants_via_successive_algo(IR::InvRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#primary_invariants_via_successive_algo-Tuple{Oscar.InvRing}","page":"Invariants of Finite Groups","title":"primary_invariants_via_successive_algo","text":"primary_invariants_via_successive_algo(IR::InvRing)\n\nReturn a system of primary invariants for IR using the algorithm in Wolfram Decker, Agnes Eileen Heydtmann, Frank-Olaf Schreyer (1998).\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = MatrixGroup(3, K, [M1, M2]);\n\njulia> IR = invariant_ring(G);\n\njulia> primary_invariants_via_successive_algo(IR)\n3-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:\n x[1]*x[2]*x[3]\n x[1]^3 + x[2]^3 + x[3]^3\n x[1]^3*x[2]^3 + x[1]^3*x[3]^3 + x[2]^3*x[3]^3\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Secondary-Invariants","page":"Invariants of Finite Groups","title":"Secondary Invariants","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"secondary_invariants(IR::InvRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#secondary_invariants-Tuple{Oscar.InvRing}","page":"Invariants of Finite Groups","title":"secondary_invariants","text":"secondary_invariants(IR::InvRing)\n\nReturn a system of secondary invariants for IR as a Vector sorted by increasing degree. The result is cached, so calling this function again  with argument IR will be fast and give the same result. Note that the secondary invariants are defined with respect to the currently cached system of primary invariants for IR (if no system of primary invariants for IR is cached, such a system is computed and cached first).\n\nThe implemented algorithms are Algorithm 3.7.5 in Harm Derksen, Gregor Kemper (2015) for the modular case and Algorithm 3.7.2 in Harm Derksen, Gregor Kemper (2015) for the non-modular case.\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\");\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0]);\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1]);\n\njulia> G = MatrixGroup(3, K, [M1, M2]);\n\njulia> IR = invariant_ring(G);\n\njulia> secondary_invariants(IR)\n2-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:\n 1\n x[1]^6*x[3]^3 + x[1]^3*x[2]^6 + x[2]^3*x[3]^6\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"irreducible_secondary_invariants(IR::InvRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#irreducible_secondary_invariants-Tuple{Oscar.InvRing}","page":"Invariants of Finite Groups","title":"irreducible_secondary_invariants","text":"irreducible_secondary_invariants(IR::InvRing)\n\nReturn a system of irreducible secondary invariants for IR as a Vector sorted by increasing degree. The result is cached, so calling this function again will be fast and give the same result. Here, a secondary invariant is called irreducible, if it cannot be written as a polynomial expression in the primary invariants and the other secondary invariants.\n\nNote that the secondary invariants and hence the irreducible secondary invariants are defined with respect to the currently cached system of primary invariants for IR (if no system of primary invariants for IR is cached, such a system is  computed and cached first).\n\nExamples\n\njulia> M = matrix(QQ, [0 -1 0 0 0; 1 -1 0 0 0; 0 0 0 0 1; 0 0 1 0 0; 0 0 0 1 0]);\n\njulia> G = MatrixGroup(5, QQ, [M]);\n\njulia> IR = invariant_ring(G);\n\njulia> secondary_invariants(IR)\n12-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n 1\n x[1]*x[3] - x[1]*x[5] - x[2]*x[3] + x[2]*x[4]\n x[3]^2 + x[4]^2 + x[5]^2\n x[1]^3 - 3*x[1]*x[2]^2 + x[2]^3\n x[1]^2*x[3] - x[1]*x[2]*x[3] - x[1]*x[2]*x[4] + x[1]*x[2]*x[5] + x[2]^2*x[4]\n x[1]*x[3]^2 - x[1]*x[5]^2 - x[2]*x[3]^2 + x[2]*x[4]^2\n x[1]^2*x[3] + x[1]^2*x[4] - 2*x[1]*x[2]*x[4] + x[2]^2*x[4] + x[2]^2*x[5]\n x[1]*x[3]*x[4] - x[1]*x[3]*x[5] - x[2]*x[3]*x[4] + x[2]*x[4]*x[5]\n x[3]^2*x[5] + x[3]*x[4]^2 + x[4]*x[5]^2\n x[1]*x[3]^3 - x[1]*x[3]^2*x[5] + x[1]*x[3]*x[4]^2 + x[1]*x[3]*x[5]^2 - x[1]*x[4]^2*x[5] - x[1]*x[5]^3 - x[2]*x[3]^3 + x[2]*x[3]^2*x[4] - x[2]*x[3]*x[4]^2 - x[2]*x[3]*x[5]^2 + x[2]*x[4]^3 + x[2]*x[4]*x[5]^2\n x[3]^4 + 2*x[3]^2*x[4]^2 + 2*x[3]^2*x[5]^2 + x[4]^4 + 2*x[4]^2*x[5]^2 + x[5]^4\n x[1]*x[3]^5 - x[1]*x[3]^4*x[5] + 2*x[1]*x[3]^3*x[4]^2 + 2*x[1]*x[3]^3*x[5]^2 - 2*x[1]*x[3]^2*x[4]^2*x[5] - 2*x[1]*x[3]^2*x[5]^3 + x[1]*x[3]*x[4]^4 + 2*x[1]*x[3]*x[4]^2*x[5]^2 + x[1]*x[3]*x[5]^4 - x[1]*x[4]^4*x[5] - 2*x[1]*x[4]^2*x[5]^3 - x[1]*x[5]^5 - x[2]*x[3]^5 + x[2]*x[3]^4*x[4] - 2*x[2]*x[3]^3*x[4]^2 - 2*x[2]*x[3]^3*x[5]^2 + 2*x[2]*x[3]^2*x[4]^3 + 2*x[2]*x[3]^2*x[4]*x[5]^2 - x[2]*x[3]*x[4]^4 - 2*x[2]*x[3]*x[4]^2*x[5]^2 - x[2]*x[3]*x[5]^4 + x[2]*x[4]^5 + 2*x[2]*x[4]^3*x[5]^2 + x[2]*x[4]*x[5]^4\n\njulia> irreducible_secondary_invariants(IR)\n8-element Vector{MPolyElem_dec{fmpq, fmpq_mpoly}}:\n x[1]*x[3] - x[1]*x[5] - x[2]*x[3] + x[2]*x[4]\n x[3]^2 + x[4]^2 + x[5]^2\n x[1]^3 - 3*x[1]*x[2]^2 + x[2]^3\n x[1]^2*x[3] - x[1]*x[2]*x[3] - x[1]*x[2]*x[4] + x[1]*x[2]*x[5] + x[2]^2*x[4]\n x[1]*x[3]^2 - x[1]*x[5]^2 - x[2]*x[3]^2 + x[2]*x[4]^2\n x[1]^2*x[3] + x[1]^2*x[4] - 2*x[1]*x[2]*x[4] + x[2]^2*x[4] + x[2]^2*x[5]\n x[1]*x[3]*x[4] - x[1]*x[3]*x[5] - x[2]*x[3]*x[4] + x[2]*x[4]*x[5]\n x[3]^2*x[5] + x[3]*x[4]^2 + x[4]*x[5]^2\n\n\n\n","category":"method"},{"location":"InvariantTheory/finite_groups/#Fundamental-Systems-of-Invariants","page":"Invariants of Finite Groups","title":"Fundamental Systems of Invariants","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"fundamental_invariants(IR::InvRing, algo::Symbol = :king)","category":"page"},{"location":"InvariantTheory/finite_groups/#fundamental_invariants","page":"Invariants of Finite Groups","title":"fundamental_invariants","text":"fundamental_invariants(IR::InvRing, algo::Symbol = :king)\n\nReturn a system of fundamental invariants for IR.\n\nThe result is cached, so calling this function again with argument IR  will be fast and give the same result.\n\nImplemented Algorithms\n\nBy default, the function relies on King's algorithm which finds a system of fundamental invariants directly, without computing primary and secondary invariants.\n\nAlternatively, if specified by algo = :minimal_subalgebra, the function computes fundamental invariants from a collection of primary and irreducible secondary invariants using the function minimal_subalgebra_generators.\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = MatrixGroup(3, K, [ M1, M2 ])\nMatrix group of degree 3 over Cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring of\nMatrix group of degree 3 over Cyclotomic field of order 3\nwith generators\nAbstractAlgebra.Generic.MatSpaceElem{nf_elem}[[0 0 1; 1 0 0; 0 1 0], [1 0 0; 0 a 0; 0 0 -a-1]]\n\njulia> fundamental_invariants(IR)\n4-element Vector{MPolyElem_dec{nf_elem, AbstractAlgebra.Generic.MPoly{nf_elem}}}:\n x[1]^3 + x[2]^3 + x[3]^3\n x[1]*x[2]*x[3]\n x[1]^6 + x[2]^6 + x[3]^6\n x[1]^6*x[3]^3 + x[1]^3*x[2]^6 + x[2]^3*x[3]^6\n\n\n\n","category":"function"},{"location":"InvariantTheory/finite_groups/#Invariant-Rings-as-Affine-Algebras","page":"Invariants of Finite Groups","title":"Invariant Rings as Affine Algebras","text":"","category":"section"},{"location":"InvariantTheory/finite_groups/","page":"Invariants of Finite Groups","title":"Invariants of Finite Groups","text":"affine_algebra(IR::InvRing)","category":"page"},{"location":"InvariantTheory/finite_groups/#affine_algebra-Tuple{Oscar.InvRing}","page":"Invariants of Finite Groups","title":"affine_algebra","text":"affine_algebra(IR::InvRing)\n\nGiven an invariant ring IR with underlying graded polynomial ring, say R, return a graded affine algebra, say A, together with a graded algebra homomomorphism A rightarrow R which maps A isomorphically onto IR.\n\nnote: Note\nIf a system of fundamental invariants for IR is already cached, the function makes use of that system. Otherwise, such a system is computed and cached first. The algebra A is graded according to the degrees of the fundamental invariants, the modulus of A is generated by the algebra relations on these invariants, and the algebra homomomorphism A rightarrow R is defined by sending the i-th generator of A to the i-th fundamental invariant.\n\nExamples\n\njulia> K, a = CyclotomicField(3, \"a\")\n(Cyclotomic field of order 3, a)\n\njulia> M1 = matrix(K, [0 0 1; 1 0 0; 0 1 0])\n[0   0   1]\n[1   0   0]\n[0   1   0]\n\njulia> M2 = matrix(K, [1 0 0; 0 a 0; 0 0 -a-1])\n[1   0        0]\n[0   a        0]\n[0   0   -a - 1]\n\njulia> G = MatrixGroup(3, K, [ M1, M2 ])\nMatrix group of degree 3 over Cyclotomic field of order 3\n\njulia> IR = invariant_ring(G)\nInvariant ring of\nMatrix group of degree 3 over Cyclotomic field of order 3\nwith generators\nAbstractAlgebra.Generic.MatSpaceElem{nf_elem}[[0 0 1; 1 0 0; 0 1 0], [1 0 0; 0 a 0; 0 0 -a-1]]\n\njulia> affine_algebra(IR)\n(Quotient of Multivariate Polynomial Ring in y[1], y[2], y[3], y[4] over Cyclotomic field of order 3 graded by\n  y[1] -> [3]\n  y[2] -> [3]\n  y[3] -> [6]\n  y[4] -> [9] by ideal(y[1]^6 - 3*y[1]^4*y[3] - 16*y[1]^3*y[2]^3 - 4*y[1]^3*y[4] + 3*y[1]^2*y[3]^2 + 24*y[1]*y[2]^3*y[3] + 4*y[1]*y[3]*y[4] + 72*y[2]^6 + 24*y[2]^3*y[4] - y[3]^3 + 8*y[4]^2), Map with following data\nDomain:\n=======\nQuotient of Multivariate Polynomial Ring in y[1], y[2], y[3], y[4] over Cyclotomic field of order 3 graded by\n  y[1] -> [3]\n  y[2] -> [3]\n  y[3] -> [6]\n  y[4] -> [9] by ideal(y[1]^6 - 3*y[1]^4*y[3] - 16*y[1]^3*y[2]^3 - 4*y[1]^3*y[4] + 3*y[1]^2*y[3]^2 + 24*y[1]*y[2]^3*y[3] + 4*y[1]*y[3]*y[4] + 72*y[2]^6 + 24*y[2]^3*y[4] - y[3]^3 + 8*y[4]^2)\nCodomain:\n=========\nMultivariate Polynomial Ring in x[1], x[2], x[3] over Cyclotomic field of order 3 graded by\n  x[1] -> [1]\n  x[2] -> [1]\n  x[3] -> [1])\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/finitefield/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Finite fields are provided in Nemo by Flint. This allows construction of finite fields of any characteristic and degree for which there are Conway polynomials. It is also possible for the user to specify their own irreducible polynomial generating a finite field.","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Finite fields are constructed using the FlintFiniteField function. However, for convenience we define","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"FiniteField = FlintFiniteField","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"so that finite fields can be constructed using FiniteField rather than FlintFiniteField. Note that this is the name of the constructor, but not of finite field type.","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"The types of finite field elements in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Library Field Element type Parent type\nFlint mathbbF_p^n (small p) fq_nmod FqNmodFiniteField\nFlint mathbbF_p^n (large p) fq FqFiniteField","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"The only difference between the fq and fq_nmod types is the representation. The former is for finite fields with multiprecision characteristic and the latter is for characteristics that fit into a single unsigned machine word. The FlintFiniteField constructor automatically picks the correct representation for the user, and so the average user doesn't need to know about the actual types.","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"All the finite field types belong to the FinField abstract type and the finite field element types belong to the FinFieldElem abstract type.","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Since all the functionality for the fq finite field type is identical to that provided for the fq_nmod finite field type, we simply document the former.","category":"page"},{"location":"Nemo/finitefield/#Finite-field-functionality","page":"Finite fields","title":"Finite field functionality","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Finite fields in Nemo provide all the field functionality described in AbstractAlgebra:","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Below we describe the functionality that is provided in addition to this.","category":"page"},{"location":"Nemo/finitefield/#Constructors","page":"Finite fields","title":"Constructors","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"In order to construct finite field elements in Nemo, one must first construct the finite field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"FlintFiniteField","category":"page"},{"location":"Nemo/finitefield/#FlintFiniteField","page":"Finite fields","title":"FlintFiniteField","text":"FlintFiniteField(char::fmpz, deg::Int, s::AbstractString; cached = true)\n\nReturns a tuple S x consisting of a finite field parent object S and generator x for the finite field of the given characteristic and degree. The string s is used to designate how the finite field generator will be printed. The characteristic must be prime. When a Conway polynomial is known, the field is generated using the Conway polynomial. Otherwise a random sparse, irreducible polynomial is used. The generator of the field is guaranteed to be a multiplicative generator only if the field is generated by a Conway polynomial. We require the degree to be positive.\n\n\n\nFlintFiniteField(pol::Union{fmpz_mod_poly, gfp_fmpz_poly}, s::Union{AbstractString,Symbol}; cached = true, check = true)\n\nReturns a tuple S x consisting of a finite field parent object S and generator x for the finite field over F_p defined by the given polynomial, i.e. mathbbF_pt(pol). The characteristic is specified by the modulus of pol. The polynomial is required to be irreducible, but this is not checked. The base ring of the polynomial is required to be a field, which is checked by default. Use check = false to disable the check. The string s is used to designate how the finite field generator will be printed. The generator will not be multiplicative in general.\n\n\n\nFlintFiniteField(F::FqFiniteField, deg::Int, s::AbstractString; cached = true)\n\nReturn a finite field with the same type as F but with a possibly different degree deg over the prime subfield.\n\n\n\n","category":"function"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Here are some examples of creating finite fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"R, x = FiniteField(7, 3, \"x\")\nS, y = FiniteField(ZZ(12431351431561), 2, \"y\")\nT, t = PolynomialRing(ResidueRing(ZZ, 12431351431561), \"t\")\nU, z = FiniteField(t^2 + 7, \"z\")\n\na = R(5)\nb = R(x)\nc = S(ZZ(11))\nd = U(7)","category":"page"},{"location":"Nemo/finitefield/#Basic-manipulation","page":"Finite fields","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"gen(::FqFiniteField)","category":"page"},{"location":"Nemo/finitefield/#gen-Tuple{FqFiniteField}","page":"Finite fields","title":"gen","text":"gen(a::FqFiniteField)\n\nReturn the generator of the finite field. Note that this is only guaranteed to be a multiplicative generator if the finite field is generated by a Conway polynomial automatically.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"isgen(::fq)","category":"page"},{"location":"Nemo/finitefield/#isgen-Tuple{fq}","page":"Finite fields","title":"isgen","text":"isgen(a::fq)\n\nReturn true if the given finite field element is the generator of the finite field, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"coeff(::fq, ::Int)","category":"page"},{"location":"Nemo/finitefield/#coeff-Tuple{fq, Int64}","page":"Finite fields","title":"coeff","text":"coeff(x::fq, n::Int)\n\nReturn the degree n coefficient of the polynomial representing the given finite field element.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"degree(::FqFiniteField)","category":"page"},{"location":"Nemo/finitefield/#degree-Tuple{FqFiniteField}","page":"Finite fields","title":"degree","text":"degree(a::FqFiniteField)\n\nReturn the degree of the given finite field.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"modulus(::FqFiniteField)","category":"page"},{"location":"Nemo/finitefield/#modulus-Tuple{FqFiniteField}","page":"Finite fields","title":"modulus","text":"modulus(k::FqFiniteField, var::String=\"T\")\n\nReturn the modulus defining the finite field k.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"R, x = FiniteField(ZZ(7), 5, \"x\")\n\nc = gen(R)\nd = characteristic(R)\nf = order(R)\ng = degree(R)\nn = isgen(x)","category":"page"},{"location":"Nemo/finitefield/#Special-functions","page":"Finite fields","title":"Special functions","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Various special functions with finite field specific behaviour are defined.","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"tr(::fq)","category":"page"},{"location":"Nemo/finitefield/#tr-Tuple{fq}","page":"Finite fields","title":"tr","text":"tr(x::fq)\n\nReturn the trace of x. This is an element of mathbbF_p, but the value returned is this value embedded in the original finite field.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"norm(::fq)","category":"page"},{"location":"Nemo/finitefield/#norm-Tuple{fq}","page":"Finite fields","title":"norm","text":"norm(x::fq)\n\nReturn the norm of x. This is an element of mathbbF_p, but the value returned is this value embedded in the original finite field.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"frobenius(::fq, ::Int)","category":"page"},{"location":"Nemo/finitefield/#frobenius-Tuple{fq, Int64}","page":"Finite fields","title":"frobenius","text":"frobenius(x::fq, n = 1)\n\nReturn the iterated Frobenius sigma_p^n(x) where sigma_p is the Frobenius map sending the element a to a^p in the finite field of characteristic p. By default the Frobenius map is applied n = 1 times if n is not specified.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"pth_root(::fq)","category":"page"},{"location":"Nemo/finitefield/#pth_root-Tuple{fq}","page":"Finite fields","title":"pth_root","text":"pth_root(x::fq)\n\nReturn the p-th root of x in the finite field of characteristic p. This is the inverse operation to the Frobenius map sigma_p.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"R, x = FiniteField(ZZ(7), 5, \"x\")\n\na = x^4 + 3x^2 + 6x + 1\n\nb = tr(a)\nc = norm(a)\nd = frobenius(a)\nf = frobenius(a, 3)\ng = pth_root(a)","category":"page"},{"location":"Nemo/finitefield/#Lift","page":"Finite fields","title":"Lift","text":"","category":"section"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"lift(::GFPFmpzPolyRing, ::fq)","category":"page"},{"location":"Nemo/finitefield/#lift-Tuple{GFPFmpzPolyRing, fq}","page":"Finite fields","title":"lift","text":"lift(R::GFPFmpzPolyRing, x::fq)\n\nLift the finite field element x to a polynomial over the prime field.\n\n\n\n","category":"method"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"R, x = FiniteField(23, 2, \"x\")\nS, y = PolynomialRing(GF(23), \"y\")\n\nf = 8x + 9\n\nlift(S, f)","category":"page"},{"location":"Nemo/finitefield/","page":"Finite fields","title":"Finite fields","text":"```","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"LinearAlgebra/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"The linear algebra part of OSCAR provides functionality for handling","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"vectors and matrices\nmodules and vector spaces,\nvector spaces over fields\nmatrix spaces and matrix algebras","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"LinearAlgebra/intro/","page":"Introduction","title":"Introduction","text":"...","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Matrix-Interface","page":"Matrix Interface","title":"Matrix Interface","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Generic matrices are supported in AbstractAlgebra.jl. Both the space of mtimes n matrices and the algebra (ring) of mtimes m matrices are supported.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"As the space of mtimes n matrices over a commutative ring is not itself a commutative ring, not all of the Ring interface needs to be implemented for such matrices in.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"In particular, the following functions do not need to be implemented: isdomain_type, and divexact. The canonical_unit function should be implemented, but simply needs to return the corresponding value for entry 1 1 (the function is never called on empty matrices).","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"For matrix algebras, all of the ring interface must be implemented.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"note: Note\nAbstractAlgebra.jl matrices are not the same as Julia matrices. We store a base ring in our matrix and matrices are row major instead of column major in order to support the numerous large C libraries that use this convention.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"All AbstractAlgebra.jl matrices are assumed to be mutable. This is usually critical to performance.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Types-and-parents","page":"Matrix Interface","title":"Types and parents","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"AbstractAlgebra provides two abstract types for matrix spaces and their elements:","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"MatSpace{T} is the abstract type for matrix space parent types\nMatElem{T} is the abstract type for matrix types belonging to a matrix space","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"It also provides two abstract types for matrix algebras and their elements:","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"MatAlgebra{T} is the abstract type for matrix algebra parent types\nMatAlgElem{T} is the abstract type for matrix types belonging to a matrix algebra","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Note that these abstract types are parameterised. The type T should usually be the type of elements of the matrices.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Matrix spaces and matrix algebras should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Matrix spaces and algebras should at least be distinguished based on their base (coefficient) ring and the dimensions of the matrices in the space.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Required-functionality-for-matrices","page":"Matrix Interface","title":"Required functionality for matrices","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"In addition to the required (relevant) functionality for the Ring interface (see above), the following functionality is required for the Matrix interface.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"We suppose that R is a fictitious base ring (coefficient ring) and that S is a space of mtimes n matrices over R, or algebra of mtimes m matrices with parent object S of type MyMatSpace{T} or MyMatAlgebra{T}, respectively. We also assume the matrices in the space have type MyMat{T}, where T is the type of elements of the base (element) ring.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Currently only matrices over commutative rings are supported.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Constructors","page":"Matrix Interface","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"In addition to the standard constructors, the following constructors, taking an array of elements, must be available.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"(S::MyMatSpace{T})(A::Matrix{T}) where T <: RingElem\n(S::MyMatAlgebra{T})(A::Matrix{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Create the matrix in the given space/algebra whose (i j) entry is given by A[i, j].","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"(S::MyMatSpace{T})(A::Matrix{S}) where {S <: RingElem, T <: RingElem}\n(S::MyMatAlgebra{T})(A::Matrix{S}) where {S <: RingElem, T <: RingElem}","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Create the matrix in the given space/algebra whose (i j) entry is given by A[i, j], where S is the type of elements that can be coerced into the base ring of the matrix.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"(S::MyMatSpace{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}\n(S::MyMatAlgebra{T})(A::Vector{S}) where {S <: RingElem, T <: RingElem}","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Create the matrix in the given space/algebra of matrices (with dimensions mtimes n say), whose (i j) entry is given by A[i*(n - 1) + j] and where S is the type of elements that can be coerced into the base ring of the matrix.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"It is also possible to create matrices (in a matrix space only) directly, without first creating the corresponding matrix space (the inner constructor being called directly). Note that to support this, matrix space parent objects don't contain a reference to their parent. Instead, parents are constructed on-the-fly if requested. (The same strategy is used for matrix algebras.)","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"matrix(R::Ring, arr::Matrix{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Given an mtimes n Julia matrix of entries, construct the corresponding AbstractAlgebra.jl matrix over the given ring R, assuming all the entries can be coerced into R.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"matrix(R::Ring, r::Int, c::Int, A::Vector{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Construct the given rtimes c AbstractAlgebra.jl matrix over the ring R whose (i j) entry is given by A[c*(i - 1) + j], assuming that all the entries can be coerced into R.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"zero_matrix(R::Ring, r::Int, c::Int)","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Construct the rtimes c AbstractAlgebra.jl zero matrix over the ring R.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Views","page":"Matrix Interface","title":"Views","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Just as Julia supports views of matrices, AbstractAlgebra requires all matrix types to support views. These allow one to work with a submatrix of a given matrix. Modifying the submatrix also modifies the original matrix.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Note that deepcopy of a view type must return the same type, but it should return a view into a deepcopy of the original matrix. Julia enforces this for consistency.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"To support views, generic matrices in AbstractAlgebra of type Generic.MatSpaceElem have an associated Generic.MatSpaceView type. Both belong to the Generic.Mat abstract type, so that one can work with that in functions that can accept both views and actual matrices.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"The syntax for views is as for Julia's own views.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Note that the parent_type function returns the same type for a view as for the original matrix type. This could potentially cause a problem if the elem_type function is applied to the return value of parent_type and then used in a type assertion. For this reason, there may be some limitations on the use of views.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"The similar function also returns a matrix of type MatSpaceElem when applied to a view, rather than another view.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Basic-manipulation-of-matrices","page":"Matrix Interface","title":"Basic manipulation of matrices","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"dense_matrix_type(::Type{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the type of dense matrices whose entries have the given type. E.g. in Nemo, which depends on AbstractAlgebra, we define dense_matrix_type(::Type{fmpz}) = fmpz_mat.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"nrows(M::MyMatSpace{T}) where T <: RingElem\nnrows(M::MyMatAlgebra{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the number of rows of matrices in the matrix space.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"ncols(M:MyMatSpace{T}) where T <: RingElem\nncols(M:MyMatAlgebra{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the number of columns of matrices in the matrix space.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"nrows(f::MyMat{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the number of rows of the given matrix.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"ncols(f::MyMat{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the number of columns of the given matrix.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"getindex(M::MyMat{T}, r::Int, c::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the (i j)-th entry of the matrix M.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"setindex!(M::MyMat{T}, d::T, r::Int, c::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Set the (i j)-th entry of the matrix M to d, which is assumed to be in the base ring of the matrix. The matrix must have such an entry and the matrix is mutated in place and not returned from the function.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Transpose","page":"Matrix Interface","title":"Transpose","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"transpose(::MyMat{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the transpose of the given matrix.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Optional-functionality-for-matrices","page":"Matrix Interface","title":"Optional functionality for matrices","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Especially when wrapping C libraries, some functions are best implemented directly, rather than relying on the generic functionality. The following are all provided by the AbstractAlgebra.jl generic code, but can optionally be implemented directly for performance reasons.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Optional-submatrices","page":"Matrix Interface","title":"Optional submatrices","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"The following are only available for matrix spaces, not for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Base.getindex(M::MyMat, rows::AbstractVector{Int}, cols::AbstractVector{Int})","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return a new matrix with the same entries as the submatrix with the given range of rows and columns.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Optional-row-swapping","page":"Matrix Interface","title":"Optional row swapping","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"swap_rows!(M::MyMat{T}, i::Int, j::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Swap the rows of M in place. The function returns the mutated matrix (since matrices are assumed to be mutable in AbstractAlgebra.jl).","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Optional-concatenation","page":"Matrix Interface","title":"Optional concatenation","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"The following are only available for matrix spaces, not for matrix algebras.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"hcat(M::MyMat{T}, N::MyMat{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the horizontal concatenation of M and N. It is assumed that the number of rows of M and N are the same.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"vcat(M::MyMat{T}, N::MyMat{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return the vertical concatenation of M and N. It is assumed that the number of columns of M and N are the same.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Optional-similar-and-zero","page":"Matrix Interface","title":"Optional similar and zero","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"The following functions are available for matrices in both matrix algebras and matrix spaces. Both similar and zero construct new matrices, with the same methods, but the entries are either undefined with similar or zero-initialized with zero.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"similar(x::MyMat{T}, R::Ring=base_ring(x)) where T <: RingElem\nzero(x::MyMat{T}, R::Ring=base_ring(x)) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Construct the matrix with the same dimensions as the given matrix, and the same base ring unless explicitly specified.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"similar(x::MyMat{T}, R::Ring, r::Int, c::Int) where T <: RingElem\nsimilar(x::MyMat{T}, r::Int, c::Int) where T <: RingElem\nzero(x::MyMat{T}, R::Ring, r::Int, c::Int) where T <: RingElem\nzero(x::MyMat{T}, r::Int, c::Int) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Construct the rtimes c matrix with R as base ring (which defaults to the base ring of the the given matrix). If x belongs to a matrix algebra and r neq c, an exception is raised, and it's also possible to specify only one Int as the order (e.g. similar(x, n)).","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Custom matrices and rings may choose which specific matrix type is best-suited to return for the given ring and dimensionality. If they do not specialize these functions, the default is a Generic.MatSpaceElem matrix, or Generic.MatAlgElem for matrix algebras. The default implementation of zero calls out to similar, so it's generally sufficient to specialize only similar. For both similar and zero, only the most general method has to be implemented (e.g. similar(x::MyMat, R::Ring, r::Int, c::Int), as all other methods (which have defaults) call out to this more general method.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Base.isassigned(M::MyMat, i, j)","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Test whether the given matrix has a value associated with indices i and j. It is recommended to overload this method for custom matrices.","category":"page"},{"location":"AbstractAlgebra/matrix_interface/#Optional-symmetry-test","page":"Matrix Interface","title":"Optional symmetry test","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"LinearAlgebra.issymmetric(a::MatrixElem)","category":"page"},{"location":"AbstractAlgebra/matrix_interface/","page":"Matrix Interface","title":"Matrix Interface","text":"Return true if the given matrix is symmetric with respect to its main diagonal, otherwise return false.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"CurrentModule = Oscar\nDocTestSetup = quote\n   using Oscar\nend","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"Pages = [\"constructions.md\"]","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Constructions","page":"Constructions","title":"Constructions","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"The standard way to define a polyhedron is by either giving a V-representation or an H-representation.  But polyhedra may also be constructed through other means: by name, via operations on other polyhedra, or from other objects in Oscar.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#H-and-V-representations","page":"Constructions","title":"H- and V-representations","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Intersecting-halfspaces:-H-representation","page":"Constructions","title":"Intersecting halfspaces: H-representation","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"Polyhedron(A::Union{Oscar.MatElem,AbstractMatrix}, b)","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Polyhedron-Tuple{Union{MatElem, AbstractMatrix{T} where T}, Any}","page":"Constructions","title":"Polyhedron","text":"Polyhedron{T}(A::Union{Oscar.MatElem,AbstractMatrix}, b) where T<:scalar_types\n\nThe (convex) polyhedron defined by\n\nP(Ab) =  x   Ax  b \n\nsee Def. 3.35 and Section 4.1. of Michael Joswig, Thorsten Theobald (2013)\n\nExamples\n\nThe following lines define the square 01^2 subset mathbbR^2:\n\njulia> A = [1 0; 0 1; -1 0 ; 0 -1];\n\njulia> b = [1, 1, 0, 0];\n\njulia> Polyhedron(A,b)\nA polyhedron in ambient dimension 2\n\nAs an example for a polyhedron constructed from both inequalities and equations, we construct the polytope 01times0subsetmathbbR^2\n\njulia> P = Polyhedron(([-1 0; 1 0], [0,1]), ([0 1], [0]))\nA polyhedron in ambient dimension 2\n\njulia> isfeasible(P)\ntrue\n\njulia> dim(P)\n1\n\njulia> vertices(P)\n2-element SubObjectIterator{PointVector{fmpq}}:\n [1, 0]\n [0, 0]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"The complete H-representation can be retrieved using facets and affine_hull:","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"julia> P = Polyhedron(([-1 0; 1 0], [0,1]), ([0 1], [0]))\nA polyhedron in ambient dimension 2\n\njulia> facets(P)\n2-element SubObjectIterator{AffineHalfspace{fmpq}} over the Halfspaces of R^2 described by:\n-x₁ ≦ 0\nx₁ ≦ 1\n\n\njulia> affine_hull(P)\n1-element SubObjectIterator{AffineHyperplane{fmpq}} over the Hyperplanes of R^2 described by:\nx₂ = 0\n\n\njulia> Q0 = Polyhedron(facets(P))\nA polyhedron in ambient dimension 2\n\njulia> P == Q0\nfalse\n\njulia> Q1 = Polyhedron(facets(P), affine_hull(P))\nA polyhedron in ambient dimension 2\n\njulia> P == Q1\ntrue","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Computing-convex-hulls:-V-representation","page":"Constructions","title":"Computing convex hulls: V-representation","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"convex_hull(::Type{T}, ::AnyVecOrMat; non_redundant::Bool=false) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#convex_hull-Union{Tuple{T}, Tuple{Type{T}, Union{MatElem, AbstractVecOrMat{T} where T}}} where T<:Union{Float64, fmpq, nf_elem}","page":"Constructions","title":"convex_hull","text":"convex_hull([::Type{T} = fmpq,] V [, R [, L]]; non_redundant::Bool = false)\n\nConstruct the convex hull of the vertices V, rays R, and lineality L. If R or L are omitted, then they are assumed to be zero.\n\nArguments\n\nV::Union{Matrix, SubObjectIterator}: Points whose convex hull is to be computed.\nR::Union{Matrix, SubObjectIterator}: Rays completing the set of points.\nL::Union{Matrix, SubObjectIterator}: Generators of the Lineality space.\n\nIf an argument is given as a matrix, its content has to be encoded row-wise.\n\nR can be given as an empty matrix or as nothing if the user wants to compute the convex hull only from V and L.\n\nIf it is known that V and R only contain extremal points and that the description of the lineality space is complete, set non_redundant = true to avoid unnecessary redundancy checks.\n\nSee Def. 2.11 and Def. 3.1  of Michael Joswig, Thorsten Theobald (2013).\n\nExamples\n\nThe following lines define the square 01^2 subset mathbbR^2:\n\njulia> Square = convex_hull([0 0; 0 1; 1 0; 1 1])\nA polyhedron in ambient dimension 2\n\nTo construct the positive orthant, rays have to be passed:\n\njulia> V = [0 0];\n\njulia> R = [1 0; 0 1];\n\njulia> PO = convex_hull(V, R)\nA polyhedron in ambient dimension 2\n\nThe closed-upper half plane can be constructed by passing rays and a lineality space:\n\njulia> V = [0 0];\n\njulia> R = [0 1];\n\njulia> L = [1 0];\n\njulia> UH = convex_hull(V, R, L)\nA polyhedron in ambient dimension 2\n\nTo obtain the x-axis in mathbbR^2:\n\njulia> V = [0 0];\n\njulia> R = nothing;\n\njulia> L = [1 0];\n\njulia> XA = convex_hull(V, R, L)\nA polyhedron in ambient dimension 2\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"This is a standard triangle, defined via a (redundant) V-representation  and its unique minimal H-representation:","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"T = convex_hull([ 0 0 ; 1 0 ; 0 1; 0 1/2 ])\nhalfspace_matrix_pair(facets(T))","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"The complete V-representation can be retrieved using vertices, rays and lineality_space:","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"julia> P = convex_hull([0 0], [1 0], [0 1])\nA polyhedron in ambient dimension 2\n\njulia> Q0 = convex_hull(vertices(P))\nA polyhedron in ambient dimension 2\n\njulia> P == Q0\nfalse\n\njulia> Q1 = convex_hull(vertices(P), rays(P))\nA polyhedron in ambient dimension 2\n\njulia> P == Q1\nfalse\n\njulia> Q0 == Q1\nfalse\n\njulia> Q2 = convex_hull(vertices(P), rays(P), lineality_space(P))\nA polyhedron in ambient dimension 2\n\njulia> P == Q2\ntrue","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Named-polyhedra","page":"Constructions","title":"Named polyhedra","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"archimedean_solid\nbirkhoff\ncatalan_solid\ncross\ncube\ncyclic_polytope\ndelpezzo\nfano_simplex\nfractional_cut_polytope\nfractional_matching_polytope\ngelfand_tsetlin\nsimplex","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#archimedean_solid","page":"Constructions","title":"archimedean_solid","text":"archimedean_solid(s)\n\nConstruct an Archimedean solid with the name given by String s from the list below.  The polytopes are realized with floating point numbers and thus not exact; Vertex-facet-incidences are correct in all cases.\n\nArguments\n\ns::String: The name of the desired Archimedean solid.   Possible values:\n\"truncated_tetrahedron\" : Truncated tetrahedron.     Regular polytope with four triangular and four hexagonal facets.\n\"cuboctahedron\" : Cuboctahedron.     Regular polytope with eight triangular and six square facets.\n\"truncated_cube\" : Truncated cube.     Regular polytope with eight triangular and six octagonal facets.\n\"truncated_octahedron\" : Truncated Octahedron.     Regular polytope with six square and eight hexagonal facets.\n\"rhombicuboctahedron\" : Rhombicuboctahedron.     Regular polytope with eight triangular and 18 square facets.\n\"truncated_cuboctahedron\" : Truncated Cuboctahedron.     Regular polytope with 12 square, eight hexagonal and six octagonal     facets.\n\"snub_cube\" : Snub Cube.     Regular polytope with 32 triangular and six square facets.     The vertices are realized as floating point numbers.     This is a chiral polytope.\n\"icosidodecahedron\" : Icosidodecahedon.     Regular polytope with 20 triangular and 12 pentagonal facets.\n\"truncated_dodecahedron\" : Truncated Dodecahedron.     Regular polytope with 20 triangular and 12 decagonal facets.\n\"truncated_icosahedron\" : Truncated Icosahedron.     Regular polytope with 12 pentagonal and 20 hexagonal facets.\n\"rhombicosidodecahedron\" : Rhombicosidodecahedron.     Regular polytope with 20 triangular, 30 square and 12 pentagonal     facets.\n\"truncated_icosidodecahedron\" : Truncated Icosidodecahedron.     Regular polytope with 30 square, 20 hexagonal and 12 decagonal     facets.\n\"snub_dodecahedron\" : Snub Dodecahedron.     Regular polytope with 80 triangular and 12 pentagonal facets.     The vertices are realized as floating point numbers.     This is a chiral polytope.\n\nExamples\n\njulia> T = archimedean_solid(\"cuboctahedron\")\nA polyhedron in ambient dimension 3\n\njulia> sum([nvertices(F) for F in faces(T, 2)] .== 3)\n8\n\njulia> sum([nvertices(F) for F in faces(T, 2)] .== 4)\n6\n\njulia> nfacets(T)\n14\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#birkhoff","page":"Constructions","title":"birkhoff","text":"birkhoff(n::Integer, even::Bool = false)\n\nConstruct the Birkhoff polytope of dimension n^2.\n\nThis is the polytope of n times n stochastic matrices (encoded as row vectors of length n^2), i.e., the matrices with non-negative real entries whose row and column entries sum up to one. Its vertices are the permutation matrices.\n\nUse even = true to get the vertices only for the even permutation matrices.\n\nExamples\n\njulia> b = birkhoff(3)\nA polyhedron in ambient dimension 9\n\njulia> vertices(b)\n6-element SubObjectIterator{PointVector{fmpq}}:\n [1, 0, 0, 0, 1, 0, 0, 0, 1]\n [0, 1, 0, 1, 0, 0, 0, 0, 1]\n [0, 0, 1, 1, 0, 0, 0, 1, 0]\n [1, 0, 0, 0, 0, 1, 0, 1, 0]\n [0, 1, 0, 0, 0, 1, 1, 0, 0]\n [0, 0, 1, 0, 1, 0, 1, 0, 0]\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#catalan_solid","page":"Constructions","title":"catalan_solid","text":"catalan_solid(s::String)\n\nConstruct a Catalan solid with the name s from the list below.  The polytopes are realized with floating point coordinates and thus are not exact. However, vertex-facet-incidences are correct in all cases.\n\nArguments\n\ns::String: The name of the desired Archimedean solid.   Possible values:\n\"triakis_tetrahedron\" : Triakis Tetrahedron.     Dual polytope to the Truncated Tetrahedron, made of 12 isosceles     triangular facets.\n\"triakis_octahedron\" : Triakis Octahedron.     Dual polytope to the Truncated Cube, made of 24 isosceles triangular     facets.\n\"rhombic_dodecahedron\" : Rhombic dodecahedron.     Dual polytope to the cuboctahedron, made of 12 rhombic facets.\n\"tetrakis_hexahedron\" : Tetrakis hexahedron.     Dual polytope to the truncated octahedron, made of 24 isosceles     triangluar facets.\n\"disdyakis_dodecahedron\" : Disdyakis dodecahedron.     Dual polytope to the truncated cuboctahedron, made of 48 scalene     triangular facets.\n\"pentagonal_icositetrahedron\" : Pentagonal Icositetrahedron.     Dual polytope to the snub cube, made of 24 irregular pentagonal facets.     The vertices are realized as floating point numbers.\n\"pentagonal_hexecontahedron\" : Pentagonal Hexecontahedron.     Dual polytope to the snub dodecahedron, made of 60 irregular pentagonal     facets. The vertices are realized as floating point numbers.\n\"rhombic_triacontahedron\" : Rhombic triacontahedron.     Dual polytope to the icosidodecahedron, made of 30 rhombic facets.\n\"triakis_icosahedron\" : Triakis icosahedron.     Dual polytope to the icosidodecahedron, made of 30 rhombic facets.\n\"deltoidal_icositetrahedron\" : Deltoidal Icositetrahedron.     Dual polytope to the rhombicubaoctahedron, made of 24 kite facets.\n\"pentakis_dodecahedron\" : Pentakis dodecahedron.     Dual polytope to the truncated icosahedron, made of 60 isosceles     triangular facets.\n\"deltoidal_hexecontahedron\" : Deltoidal hexecontahedron.     Dual polytope to the rhombicosidodecahedron, made of 60 kite facets.\n\"disdyakis_triacontahedron\" : Disdyakis triacontahedron.     Dual polytope to the truncated icosidodecahedron, made of 120 scalene     triangular facets.\n\nExamples\n\njulia> T = catalan_solid(\"triakis_tetrahedron\");\n\njulia> count(F -> nvertices(F) == 3, faces(T, 2))\n12\n\njulia> nfacets(T)\n12\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#cross","page":"Constructions","title":"cross","text":"cross([::Type{T} = fmpq,] d::Int [,n::Rational])\n\nConstruct a d-dimensional cross polytope around origin with vertices located at pm e_i for each unit vector e_i of R^d, scaled by n.\n\nExamples\n\nHere we print the facets of a non-scaled and a scaled 3-dimensional cross polytope:\n\njulia> C = cross(3)\nA polyhedron in ambient dimension 3\n\njulia> facets(C)\n8-element SubObjectIterator{AffineHalfspace{fmpq}} over the Halfspaces of R^3 described by:\nx₁ + x₂ + x₃ ≦ 1\n-x₁ + x₂ + x₃ ≦ 1\nx₁ - x₂ + x₃ ≦ 1\n-x₁ - x₂ + x₃ ≦ 1\nx₁ + x₂ - x₃ ≦ 1\n-x₁ + x₂ - x₃ ≦ 1\nx₁ - x₂ - x₃ ≦ 1\n-x₁ - x₂ - x₃ ≦ 1\n\njulia> D = cross(3, 2)\nA polyhedron in ambient dimension 3\n\njulia> facets(D)\n8-element SubObjectIterator{AffineHalfspace{fmpq}} over the Halfspaces of R^3 described by:\nx₁ + x₂ + x₃ ≦ 2\n-x₁ + x₂ + x₃ ≦ 2\nx₁ - x₂ + x₃ ≦ 2\n-x₁ - x₂ + x₃ ≦ 2\nx₁ + x₂ - x₃ ≦ 2\n-x₁ + x₂ - x₃ ≦ 2\nx₁ - x₂ - x₃ ≦ 2\n-x₁ - x₂ - x₃ ≦ 2\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#cube","page":"Constructions","title":"cube","text":"cube([::Type{T} = fmpq,] d::Int , [l::Rational = -1, u::Rational = 1])\n\nConstruct the lu-cube in dimension d.\n\nExamples\n\nIn this example the 5-dimensional unit cube is constructed to ask for one of its properties:\n\njulia> C = cube(5,0,1);\n\njulia> normalized_volume(C)\n120\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#cyclic_polytope","page":"Constructions","title":"cyclic_polytope","text":"cyclic_polytope(d::Int, n::Int)\n\nConstruct the cyclic polytope that is the convex hull of n points on the moment curve in dimension d.\n\nExamples\n\njulia> cp = cyclic_polytope(3, 20)\nA polyhedron in ambient dimension 3\n\njulia> nvertices(cp)\n20\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#delpezzo","page":"Constructions","title":"delpezzo","text":"delpezzo(d::Int)\n\nProduce the d-dimensional del-Pezzo polytope, which is the convex hull of the cross polytope together with the all-ones and minus all-ones vector.\n\njulia> DP = delpezzo(4)\nA polyhedron in ambient dimension 4\n\njulia> f_vector(DP)\n4-element Vector{fmpz}:\n 10\n 40\n 60\n 30\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#fano_simplex","page":"Constructions","title":"fano_simplex","text":"fano_simplex(d::Int)\n\nConstruct a lattice simplex such that the origin is the unique interior lattice point. The normal toric variety associated with its face fan is smooth.\n\njulia> S = fano_simplex(3)\nA polyhedron in ambient dimension 3\n\njulia> X = NormalToricVariety(face_fan(S))\nA normal toric variety\n\njulia> issmooth(X)\ntrue\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#fractional_cut_polytope","page":"Constructions","title":"fractional_cut_polytope","text":"fractional_cut_polytope(G::Graphs.Graph{Graphs.Undirected})\n\nConstruct the fractional cut polytope of the graph G.\n\nExamples\n\njulia> G = Graphs.complete_graph(4);\n\njulia> fractional_cut_polytope(G)\nA polyhedron in ambient dimension 6\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#fractional_matching_polytope","page":"Constructions","title":"fractional_matching_polytope","text":"fractional_matching_polytope(G::Graphs.Graph{Graphs.Undirected})\n\nConstruct the fractional matching polytope of the graph G.\n\nExamples\n\njulia> G = Graphs.complete_graph(4);\n\njulia> fractional_matching_polytope(G)\nA polyhedron in ambient dimension 6\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#gelfand_tsetlin","page":"Constructions","title":"gelfand_tsetlin","text":"gelfand_tsetlin(lambda::AbstractVector)\n\nConstruct the Gelfand Tsetlin polytope indexed by a weakly decreasing vector lambda.\n\njulia> P = gelfand_tsetlin([5,3,2])\nA polyhedron in ambient dimension 6\n\njulia> isfulldimensional(P)\nfalse\n\njulia> p = project_full(P)\nA polyhedron in ambient dimension 3\n\njulia> isfulldimensional(p)\ntrue\n\njulia> volume(p)\n3\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#simplex","page":"Constructions","title":"simplex","text":"simplex([::Type{T} = fmpq,] d::Int [,n::Rational])\n\nConstruct the simplex which is the convex hull of the standard basis vectors along with the origin in mathbbR^d, scaled by n.\n\nExamples\n\nHere we take a look at the facets of the 7-simplex and a scaled 7-simplex:\n\njulia> s = simplex(7)\nA polyhedron in ambient dimension 7\n\njulia> facets(s)\n8-element SubObjectIterator{AffineHalfspace{fmpq}} over the Halfspaces of R^7 described by:\n-x₁ ≦ 0\n-x₂ ≦ 0\n-x₃ ≦ 0\n-x₄ ≦ 0\n-x₅ ≦ 0\n-x₆ ≦ 0\n-x₇ ≦ 0\nx₁ + x₂ + x₃ + x₄ + x₅ + x₆ + x₇ ≦ 1\n\njulia> t = simplex(7, 5)\nA polyhedron in ambient dimension 7\n\njulia> facets(t)\n8-element SubObjectIterator{AffineHalfspace{fmpq}} over the Halfspaces of R^7 described by:\n-x₁ ≦ 0\n-x₂ ≦ 0\n-x₃ ≦ 0\n-x₄ ≦ 0\n-x₅ ≦ 0\n-x₆ ≦ 0\n-x₇ ≦ 0\nx₁ + x₂ + x₃ + x₄ + x₅ + x₆ + x₇ ≦ 5\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Operations-on-polyhedra","page":"Constructions","title":"Operations on polyhedra","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"Polyhedra can be produced through operations on other polyhedra. For example, they can be added using Minkowski addition or scaled; each of which results in a new polyhedron.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"+(::Polyhedron{T}, ::Polyhedron{T}) where T<:scalar_types\n*(::Int, ::Polyhedron{T}) where T<:scalar_types\n*(::Polyhedron{T}, ::Polyhedron{T})  where T<:scalar_types\nbipyramid\nintersect(::Polyhedron{T}, ::Polyhedron{T}) where T<:scalar_types\npyramid","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#+-Union{Tuple{T}, Tuple{Polyhedron{T}, Polyhedron{T}}} where T<:Union{Float64, fmpq, nf_elem}","page":"Constructions","title":"+","text":"+(P::Polyhedron, Q::Polyhedron)\n\nReturn the Minkowski sum P + Q =  x+y  xP yQ of P and Q (see also minkowski_sum).\n\nExamples\n\nThe Minkowski sum of a square and the 2-dimensional cross-polytope is an octagon:\n\njulia> P = cube(2);\n\njulia> Q = cross(2);\n\njulia> M = minkowski_sum(P, Q)\nA polyhedron in ambient dimension 2\n\njulia> nvertices(M)\n8\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#*-Union{Tuple{T}, Tuple{Int64, Polyhedron{T}}} where T<:Union{Float64, fmpq, nf_elem}","page":"Constructions","title":"*","text":"*(k::Int, Q::Polyhedron)\n\nReturn the scaled polyhedron kQ =  kx  xQ.\n\nNote that k*Q = Q*k.\n\nExamples\n\nScaling an n-dimensional bounded polyhedron by the factor k results in the volume being scaled by k^n. This example confirms the statement for the 6-dimensional cube and k = 2.\n\njulia> C = cube(6);\n\njulia> SC = 2*C\nA polyhedron in ambient dimension 6\n\njulia> volume(SC)//volume(C)\n64\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#*-Union{Tuple{T}, Tuple{Polyhedron{T}, Polyhedron{T}}} where T<:Union{Float64, fmpq, nf_elem}","page":"Constructions","title":"*","text":"*(P::Polyhedron, Q::Polyhedron)\n\nReturn the Cartesian product of P and Q (see also product).\n\nExamples\n\nThe Cartesian product of a triangle and a line segment is a triangular prism.\n\njulia> T=simplex(2)\nA polyhedron in ambient dimension 2\n\njulia> S=cube(1)\nA polyhedron in ambient dimension 1\n\njulia> length(vertices(T*S))\n6\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#bipyramid","page":"Constructions","title":"bipyramid","text":"bipyramid(P::Polyhedron, z::Number = 1, z_prime::Number = -z)\n\nMake a bipyramid over a pointed polyhedron P.\n\nThe bipyramid is the convex hull of the input polyhedron P and two apexes (v, z), (v, z_prime) on both sides of the affine span of P. For bounded polyhedra, the projections of the apexes v to the affine span of P is the vertex barycenter of P.\n\nExamples\n\njulia> c = cube(2)\nA polyhedron in ambient dimension 2\n\njulia> vertices(bipyramid(c,2))\n6-element SubObjectIterator{PointVector{fmpq}}:\n [-1, -1, 0]\n [1, -1, 0]\n [-1, 1, 0]\n [1, 1, 0]\n [0, 0, 2]\n [0, 0, -2]\n\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#intersect-Union{Tuple{T}, Tuple{Polyhedron{T}, Polyhedron{T}}} where T<:Union{Float64, fmpq, nf_elem}","page":"Constructions","title":"intersect","text":"intersect(P::Polyhedron, Q::Polyhedron)\n\nReturn the intersection P cap Q of P and Q.\n\nExamples\n\nThe positive orthant of the plane is the intersection of the two halfspaces with x0 and y0 respectively.\n\njulia> UH1 = convex_hull([0 0],[1 0],[0 1]);\n\njulia> UH2 = convex_hull([0 0],[0 1],[1 0]);\n\njulia> PO = intersect(UH1, UH2)\nA polyhedron in ambient dimension 2\n\njulia> rays(PO)\n2-element SubObjectIterator{RayVector{fmpq}}:\n [1, 0]\n [0, 1]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#pyramid","page":"Constructions","title":"pyramid","text":"pyramid(P::Polyhedron, z::Number = 1)\n\nMake a pyramid over the given polyhedron P.\n\nThe pyramid is the convex hull of the input polyhedron P and a point v outside the affine span of P. For bounded polyhedra, the projection of v to the affine span of P coincides with the vertex barycenter of P. The scalar z is the distance between the vertex barycenter and v.\n\nExamples\n\njulia> c = cube(2)\nA polyhedron in ambient dimension 2\n\njulia> vertices(pyramid(c,5))\n5-element SubObjectIterator{PointVector{fmpq}}:\n [-1, -1, 0]\n [1, -1, 0]\n [-1, 1, 0]\n [1, 1, 0]\n [0, 0, 5]\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"The convex hull of two polytopes can be computed via convex_hull.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"convex_hull(::Polyhedron{T},::Polyhedron{T}) where T<:scalar_types","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#convex_hull-Union{Tuple{T}, Tuple{Polyhedron{T}, Polyhedron{T}}} where T<:Union{Float64, fmpq, nf_elem}","page":"Constructions","title":"convex_hull","text":"convex_hull(P::Polyhedron, Q::Polyhedron)\n\nReturn the convex_hull of P and Q.\n\nExamples\n\nThe convex hull of the following two line segments in R^3 is a tetrahedron.\n\njulia> L₁ = convex_hull([-1 0 0; 1 0 0])\nA polyhedron in ambient dimension 3\n\njulia> L₂ = convex_hull([0 -1 0; 0 1 0])\nA polyhedron in ambient dimension 3\n\njulia> T=convex_hull(L₁,L₂);\n\njulia> f_vector(T)\n2-element Vector{fmpz}:\n 4\n 4\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#Polyhedra-from-other-mathematical-objects","page":"Constructions","title":"Polyhedra from other mathematical objects","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/constructions/","page":"Constructions","title":"Constructions","text":"orbit_polytope\nnewton_polytope","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#orbit_polytope","page":"Constructions","title":"orbit_polytope","text":"orbit_polytope(V::AbstractVecOrMat, G::PermGroup)\n\nConstruct the convex hull of the orbit of one or several points (given row-wise in V) under the action of G.\n\nExamples\n\nThis will construct the 3-dimensional permutahedron:\n\njulia> V = [1 2 3];\n\njulia> G = symmetric_group(3);\n\njulia> P = orbit_polytope(V, G)\nA polyhedron in ambient dimension 3\n\njulia> vertices(P)\n6-element SubObjectIterator{PointVector{fmpq}}:\n [1, 2, 3]\n [1, 3, 2]\n [2, 1, 3]\n [2, 3, 1]\n [3, 1, 2]\n [3, 2, 1]\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/Polyhedra/constructions/#newton_polytope","page":"Constructions","title":"newton_polytope","text":"newton_polytope(poly::Polynomial)\n\nCompute the Newton polytope of the multivariate polynomial poly.\n\nExamples\n\njulia> S, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Integer Ring, fmpz_mpoly[x, y])\n\njulia> f = x^3*y + 3x*y^2 + 1\nx^3*y + 3*x*y^2 + 1\n\njulia> NP = newton_polytope(f)\nA polyhedron in ambient dimension 2\n\njulia> vertices(NP)\n3-element SubObjectIterator{PointVector{fmpq}}:\n [3, 1]\n [1, 2]\n [0, 0]\n\n\n\n\n\n","category":"function"},{"location":"StraightLinePrograms/gapslps/#GAP's-SLPs","page":"GAP's SLPs","title":"GAP's SLPs","text":"","category":"section"},{"location":"StraightLinePrograms/gapslps/","page":"GAP's SLPs","title":"GAP's SLPs","text":"There are two other available SLP types: GAPSLProgram and AtlasSLProgram, and related GAPSLDecision and AtlasSLDecision, which are constructed similarly as in GAP:","category":"page"},{"location":"StraightLinePrograms/gapslps/","page":"GAP's SLPs","title":"GAP's SLPs","text":"julia> prg = GAPSLProgram( [ [1,2,2,3], [3,-1] ], 2 )\n# input:\nr = [ g1, g2 ]\n# program:\nr[3] = r[1]^2*r[2]^3\nr[4] = r[3]^-1\n# return value:\nr[4]\n\njulia> SLP.evaluate(prg, [perm1, perm2])\n(1,3,4,2)\n\njulia> SLP.evaluate(prg, [x, y])\n#1 = ^  x  2  ==>  x^2\n#2 = ^  y  3  ==>  y^3\n#3 = * #1 #2  ==>  (x^2y^3)\n#4 = ^ #3 -1  ==>  (x^2y^3)^-1\nreturn: #4\n\njulia> SLProgram(prg) # direct compilation (with room for optimizations obviously)\n#1 =    x     ==>  x\n#2 =    y     ==>  y\n#3 = ^ #1  2  ==>  x^2\n#4 = ^ #2  3  ==>  y^3\n#5 = * #3 #4  ==>  (x^2y^3)\n#3 =   #5     ==>  (x^2y^3)\nkeep: #1..#3\n#4 = ^ #3 -1  ==>  (x^2y^3)^-1\nkeep: #1..#4\nreturn: #4\n\njulia> GAPSLProgram( [ [2,3], [ [3,1,1,4], [1,2,3,1] ] ], 2 )\n# input:\nr = [ g1, g2 ]\n# program:\nr[3] = r[2]^3\n# return values:\n[ r[3]*r[1]^4, r[1]^2*r[3] ]\n\njulia> GAPSLDecision([ [ [ 1, 1, 2, 1 ], 3 ], [ \"Order\", 1, 2 ], [ \"Order\", 2, 3 ], [ \"Order\", 3, 5 ] ] )\n# input:\nr = [ g1, g2 ]\n# program:\nr[3] = r[1]*r[2]\norder( r[1] ) == 2 || return false\norder( r[2] ) == 3 || return false\norder( r[3] ) == 5 || return false\n# return value:\ntrue\n\njulia> SLProgram(ans)\n#1 =    x     ==>  x\n#2 =    y     ==>  y\n#3 = * #1 #2  ==>  (xy)\nkeep: #1..#3\ntest: order(#1) == 2 || return false\ntest: order(#2) == 3 || return false\ntest: order(#3) == 5 || return false\nreturn: true\n\njulia> d = AtlasSLDecision(\"inp 2\\nchor 1 2\\nchor 2 3\\nmu 1 2 3\\nchor 3 5\")\ninp 2\nchor 1 2\nchor 2 3\nmu 1 2 3\nchor 3 5\n\n376> SLP.evaluate(d, [perm1, perm2])\nfalse\n\njulia> GAPSLDecision(d)\n# input:\nr = [ g1, g2 ]\n# program:\norder( r[1] ) == 2 || return false\norder( r[2] ) == 3 || return false\nr[3] = r[1]*r[2]\norder( r[3] ) == 5 || return false\n# return value:\ntrue\n\njulia> SLProgram(d)\n#1 =    x     ==>  x\n#2 =    y     ==>  y\ntest: order(#1) == 2 || return false\ntest: order(#2) == 3 || return false\n#3 = * #1 #2  ==>  (xy)\nkeep: #1..#3\ntest: order(#3) == 5 || return false\nreturn: true","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\n  end","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/#Complex-embedding","page":"Complex embedding","title":"Complex embedding","text":"","category":"section"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"Functionality for working with complex embeddings of a number field L, that is, with ring morphisms L to mathbfC is provided for all possible number field types.","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/#Construction-of-complex-embeddings","page":"Complex embedding","title":"Construction of complex embeddings","text":"","category":"section"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"complex_embeddings(::NumField)\nreal_embeddings(::NumField)","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/#complex_embeddings-Tuple{NumField}","page":"Complex embedding","title":"complex_embeddings","text":"complex_embeddings(K::NumField; conjugates::Bool = true) -> Vector{NumFieldEmb}\n\nReturn the complex embeddings of K. If conjugates is false, only one imaginary embedding per conjugated pairs is returned.\n\nExamples\n\njulia> K, a = quadratic_field(-3);\n\njulia> complex_embeddings(K)\n2-element Vector{Hecke.NumFieldEmbNfAbs}:\n Embedding corresponding to ≈ 0.00 + 1.73 * i\n Embedding corresponding to ≈ 0.00 - 1.73 * i\n\njulia> complex_embeddings(K, conjugates = false)\n1-element Vector{Hecke.NumFieldEmbNfAbs}:\n Embedding corresponding to ≈ 0.00 + 1.73 * i\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#real_embeddings-Tuple{NumField}","page":"Complex embedding","title":"real_embeddings","text":"real_embeddings(K::NumField) -> Vector{NumFieldEmb}\n\nReturn the real embeddings of K.\n\nExamples\n\njulia> K, a = quadratic_field(3);\n\njulia> real_embeddings(K)\n2-element Vector{Hecke.NumFieldEmbNfAbs}:\n Embedding corresponding to ≈ -1.73\n Embedding corresponding to ≈ 1.73\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#Properties","page":"Complex embedding","title":"Properties","text":"","category":"section"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"number_field(::NumFieldEmb)\nisreal(::NumFieldEmb)\nisimaginary(::NumFieldEmb)","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/#number_field-Tuple{Hecke.NumFieldEmb}","page":"Complex embedding","title":"number_field","text":"number_field(f::NumFieldEmb) -> NumField\n\nReturn the corresponding number field of the embedding f.\n\nExamples\n\njulia> K, a = quadratic_field(-3); e = complex_embeddings(K)[1];\n\njulia> number_field(e)\nImaginary quadratic field defined by x^2 + 3\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#isreal-Tuple{Hecke.NumFieldEmb}","page":"Complex embedding","title":"isreal","text":"isreal(f::NumFieldEmb) -> Bool\n\nReturn true if the embedding is real.\n\nExamples\n\njulia> K, a = quadratic_field(3); e = complex_embeddings(K)[1];\n\njulia> isreal(e)\ntrue\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#isimaginary-Tuple{Hecke.NumFieldEmb}","page":"Complex embedding","title":"isimaginary","text":"isimaginary(f::NumFieldEmb) -> Bool\n\nReturns true if the embedding is imaginary, that is, not real.\n\nExamples\n\njulia> K, a = quadratic_field(-3); e = complex_embeddings(K)[1];\n\njulia> isimaginary(e)\ntrue\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#Conjugated-embedding","page":"Complex embedding","title":"Conjugated embedding","text":"","category":"section"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"conj(::NumFieldEmb)","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/#conj-Tuple{Hecke.NumFieldEmb}","page":"Complex embedding","title":"conj","text":"conj(f::NumFieldEmb) -> NumFieldEmb\n\nReturns the conjugate embedding of f.\n\nExamples\n\njulia> K, a = quadratic_field(-3); e = complex_embeddings(K);\n\njulia> conj(e[1]) == e[2]\ntrue\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#Evaluating-elements-at-complex-embeddings","page":"Complex embedding","title":"Evaluating elements at complex embeddings","text":"","category":"section"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"Given an embedding f colon K to mathbfC and an element x of K, the image f(x) of x under f can be constructed as follows.","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"    (f::NumFieldEmb)(x::NumFieldElem, prec::Int = 32) -> acb","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"Note that the return type will be a complex ball of type acb. The radius r of the ball is guarenteed to satisfy r < 2^(-prec).\nIf the embedding is real, then the value c will satisfy isreal(c) == true.","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"For convenience, we also provide the following function to quickly create a corresponding anonymous function:","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"evaluation_function(e::NumFieldEmb, prec::Int)","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/#evaluation_function-Tuple{Hecke.NumFieldEmb, Int64}","page":"Complex embedding","title":"evaluation_function","text":"evaluation_function(e::NumFieldEmb, prec::Int) -> Function\n\nReturn the anonymous function x -> e(x, prec).\n\nExamples\n\njulia> K, a = quadratic_field(-3);\n\njulia> e = complex_embeddings(K)[1];\n\njulia> fn = evaluation_function(e, 64);\n\njulia> fn(a)\n[+/- 3.99e-77] + [1.73205080756887729353 +/- 5.41e-21]*im\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#Restriction","page":"Complex embedding","title":"Restriction","text":"","category":"section"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"Given a subfield iota colon k to K, any embedding f colon K to mathbfC naturally restricts to a complex embedding of K. Computing this restriction is supported in case k appears as a base field of (a base field) of K or iota is provided:","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"restrict(::NumFieldEmb, ::NumField)\nrestrict(::NumFieldEmb, ::NumFieldMor)","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/#restrict-Tuple{Hecke.NumFieldEmb, NumField}","page":"Complex embedding","title":"restrict","text":"restrict(f::NumFieldEmb, K::NumField)\n\nGiven an embedding f of a number field L and a number field K appearing as a base field of L, return the restriction of f to L.\n\nExamples\n\njulia> K, a = quadratic_field(3);\n\njulia> L, b = NumberField(polynomial(K, [1, 0, 1]), \"b\");\n\njulia> e = complex_embeddings(L);\n\njulia> restrict(e[1], K)\nEmbedding of\nReal quadratic field defined by x^2 - 3\ncorresponding to ≈ -1.73\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#restrict-Tuple{Hecke.NumFieldEmb, Hecke.NumFieldMor}","page":"Complex embedding","title":"restrict","text":"restrict(f::NumFieldEmb, g::NumFieldMor)\n\nGiven an embedding f of a number field L and a morphism g colon K to L, return the embedding g circ f of K.\n\nThis is the same as g * f.\n\nExamples\n\njulia> K, a = CyclotomicField(5, \"a\");\n\njulia> k, ktoK = Hecke.subfield(K, [a + inv(a)]);\n\njulia> e = complex_embeddings(K);\n\njulia> restrict(e[1], ktoK)\nEmbedding of\nNumber field over Rational Field with defining polynomial x^2 + x - 1\ncorresponding to ≈ 0.62\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#Extension","page":"Complex embedding","title":"Extension","text":"","category":"section"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"Given a complex embedding f colon k to mathbfC and a morphism iota colon k to K, an embedding g colon K to mathbfC is extension of f, if g restricts to f. Given an embedding and a morphism, all extensions can be computed as follows:","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"extend(::NumFieldEmb, ::NumFieldMor)","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/#extend-Tuple{Hecke.NumFieldEmb, Hecke.NumFieldMor}","page":"Complex embedding","title":"extend","text":"extend(e::NumFieldEmb, f::NumFieldMor)\n\nGiven an embedding e of k and a morphism f colon k to K, determine all embedings of K which restrict to e along f.\n\nExample\n\njulia> K, a = CyclotomicField(5, \"a\");\n\njulia> k, ktoK = Hecke.subfield(K, [a + inv(a)]);\n\njulia> e = complex_embeddings(k)[1];\n\njulia> extend(e, ktoK)\n2-element Vector{Hecke.NumFieldEmbNfAbs}:\n Embedding corresponding to ≈ 0.31 + 0.95 * i\n Embedding corresponding to ≈ 0.31 - 0.95 * i\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/complex_embeddings/#Example","page":"Complex embedding","title":"Example","text":"","category":"section"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"As mentioned, this functionality works for all types of number fields. Here is an example of an absolute non-simple number field.","category":"page"},{"location":"Hecke/number_fields/complex_embeddings/","page":"Complex embedding","title":"Complex embedding","text":"julia> Qx, x = QQ[\"x\"];\n\njulia> K, a = number_field([x^2 + 1, x^3 + 2], \"a\");\n\njulia> emb = complex_embeddings(K)\n6-element Vector{Hecke.NumFieldEmbNfAbsNS}:\n Embedding corresponding to ≈ [ 1.00 * i, -1.26]\n Embedding corresponding to ≈ [ 1.00 * i, 0.63 + 1.09 * i]\n Embedding corresponding to ≈ [ -1.00 * i, 0.63 + 1.09 * i]\n Embedding corresponding to ≈ [ -1.00 * i, -1.26]\n Embedding corresponding to ≈ [ -1.00 * i, 0.63 - 1.09 * i]\n Embedding corresponding to ≈ [ 1.00 * i, 0.63 - 1.09 * i]\n\njulia> k, b = quadratic_field(-1);\n\njulia> i = hom(k, K, a[1]);\n\njulia> restrict(emb[1], i)\nEmbedding of\nImaginary quadratic field defined by x^2 + 1\ncorresponding to ≈ 1.00 * i\n\njulia> restrict(emb[3], i)\nEmbedding of\nImaginary quadratic field defined by x^2 + 1\ncorresponding to ≈ -1.00 * i","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/functional_map/#Functional-maps","page":"Functional maps","title":"Functional maps","text":"","category":"section"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"A functional map in AbstractAlgebra is a map which can be applied by evaluating a Julia function or closure. It is represented by a map object that contains such a function/closure, usually in a field called image_fn.","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"All functional maps belong to the map class FunctionalMap.","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"A generic concrete type Generic.FunctionalMap is provided by the Generic module to implement a generic functional map type. This allows for functional maps that contain no extra data, other than a Julia function/closure.","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"Custom map types can also be defined which have map class FunctionalMap.","category":"page"},{"location":"AbstractAlgebra/functional_map/#Functional-map-interface","page":"Functional maps","title":"Functional map interface","text":"","category":"section"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"All functional map types must define their supertypes as in the following example:","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"mutable struct MyFunctionalMap{D, C} <: Map{D, C, FunctionalMap, MyFunctionalMap}\n   # some fields\n   image_fn::Function\nend","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"Of course MyFunctionalMap need not be parameterised if the types D and C of the domain and codomain objects are known.","category":"page"},{"location":"AbstractAlgebra/functional_map/#Required-functions-for-functional-maps","page":"Functional maps","title":"Required functions for functional maps","text":"","category":"section"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"The following functions must be defined for all functional map types or classes:","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"image_fn(M::Map(MyFunctionalMap))","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"Return the Julia function or closure that corresponds to application of the map M. This function only needs to be provided if this function is not stored in an image_fn field of the MyFunctionalMap type.","category":"page"},{"location":"AbstractAlgebra/functional_map/#Generic-functional-maps","page":"Functional maps","title":"Generic functional maps","text":"","category":"section"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"The Generic module provides a concrete type FunctionalMap which merely keeps track of a Julia function/closure implementing the map.","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"Such maps can be constructed using the following function:","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"map_from_func(f::Function, R, S)","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"Construct the generic functional map with domain and codomain given by the parent objects R and S corresponding to the Julia function f.","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"Examples","category":"page"},{"location":"AbstractAlgebra/functional_map/","page":"Functional maps","title":"Functional maps","text":"julia> f = map_from_func(x -> x + 1, ZZ, ZZ)\nMap with the following data\n\nDomain:\n=======\nIntegers\n\nCodomain:\n========\nIntegers\n\njulia> f(ZZ(2))\n3","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"TropicalGeometry/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"This page lists the Oscar features for tropical geometry, which are still at the very beginning of their development. For notation we refer to Diane Maclagan, Bernd Sturmfels (2015) and Michael Joswig (2021).","category":"page"},{"location":"TropicalGeometry/intro/#Tropical-semirings","page":"Introduction","title":"Tropical semirings","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"TropicalSemiring\nTropicalSemiringMap\ntropical_polynomial","category":"page"},{"location":"TropicalGeometry/intro/#TropicalSemiring","page":"Introduction","title":"TropicalSemiring","text":"TropicalSemiring(M::Union{typeof(min),typeof(max)}=min)\n\nThe tropical semiring with min (default) or max.\n\nwarning: Warning\nThere is no substraction in the tropical semiring. Any substraction of two tropical numbers will yield an error.\n\nExamples (basic arithmetic)\n\njulia> T = TropicalSemiring() # = TropicalSemiring(min)\nTropical semiring (min)\n\njulia> T = TropicalSemiring(max)\nTropical semiring (max)\n\njulia> 0*T(3) + 1*T(1)^2 + inf(T) # = max(0+3,1+2*1,-∞)\n(3)\n\njulia> T(0) == 0    # checks whether the tropical number is 0\ntrue\n\njulia> iszero(T(0)) # checks whether the tropical number is neutral element of addition\nfalse\n\nExamples (polynomials)\n\njulia> T = TropicalSemiring()\nTropical semiring (min)\n\njulia> Tx,(x1,x2) = PolynomialRing(T,3)\n(Multivariate Polynomial Ring in x1, x2, x3 over Tropical semiring (min), AbstractAlgebra.Generic.MPoly{Oscar.TropicalSemiringElem{typeof(min)}}[x1, x2, x3])\n\njulia> f = x1 + -1*x2 + 0\nx1 + (-1)*x2 + (0)\n\njulia> evaluate(f,[T(-1//2),T(1//2)]) # warning: omitting T(0) gives an error\n(-1//2)\n\nExamples (matrices)\n\njulia> T = TropicalSemiring()\nTropical semiring (min)\n\njulia> A = [T(0) inf(T); inf(T) T(0)] # = tropical identity matrix\n2×2 Matrix{Oscar.TropicalSemiringElem{typeof(min)}}:\n (0)  ∞\n ∞    (0)\n\njulia> 2*A\n2×2 Matrix{Oscar.TropicalSemiringElem{typeof(min)}}:\n (2)  ∞\n ∞    (2)\n\njulia> A*A\n2×2 Matrix{Oscar.TropicalSemiringElem{typeof(min)}}:\n (0)  ∞\n ∞    (0)\n\njulia> det(A)\n(0)\n\n\n\n","category":"type"},{"location":"TropicalGeometry/intro/#TropicalSemiringMap","page":"Introduction","title":"TropicalSemiringMap","text":"TropicalSemiringMap(K,p,M::Union{typeof(min),typeof(max)}=min)\n\nConstructs a map val from K to the min tropical semiring T (default) or the max tropical semiring that:\n\nis a semigroup homomorphism (K,*) -> (T,+),\npreserves the ordering on both sides.\n\nIn other words, val is either a valuation on K with image in TropicalSemiring(min) or the negative of a valuation on K with image in TropicalSemiring(max).\n\nThe role of val is to encode with respect to which valuation on K and under which convention (min or max) tropical computations should take place.\n\nCurrently, the only supported valuations are:\n\nt-adic valuation on QQ(t)\np-adic valuations on QQ\ntrivial valuation on any field\n\nExample (p-adic valuation on QQ)\n\njulia> val_2 = TropicalSemiringMap(QQ,2); # = TropicalSemiringMap(QQ,2,min)\n\njulia> val_2(4)\n(2)\njulia> val_2(1//4)\n(-2)\njulia> val_2 = TropicalSemiringMap(QQ,2,max);\n\njulia> val_2(4)\n(-2)\njulia> val_2(1//4)\n(2)\n\nExample (t-adic valuation on QQ(t))\n\njulia> Kt,t = RationalFunctionField(QQ,\"t\");\n\njulia> val_t = TropicalSemiringMap(Kt,t);\n\njulia> val_t(t^2)\n(2)\njulia> val_t(1//t^2)\n(-2)\n\nExample (trivial valuation on QQ)\n\njulia> val = TropicalSemiringMap(QQ);\n\njulia> val(4)\n(0)\njulia> val(1//4)\n(0)\njulia> val(0)\n∞\n\n\n\n","category":"type"},{"location":"TropicalGeometry/intro/#tropical_polynomial","page":"Introduction","title":"tropical_polynomial","text":"tropical_polynomial(f::MPolyElem,M::Union{typeof(min),typeof(max)}=min)\n\nGiven a polynomial f over a field with an intrinsic valuation (i.e., a field on which a function valuation is defined such as PadicField(7,2)), returns the tropicalization of f as a polynomial over the min tropical semiring (default) or the max tropical semiring.\n\nExamples\n\njulia> K = PadicField(7, 2)\nField of 7-adic numbers\n\njulia> Kxy, (x,y) = K[\"x\", \"y\"]\n(Multivariate Polynomial Ring in x, y over Field of 7-adic numbers, AbstractAlgebra.Generic.MPoly{padic}[x, y])\n\njulia> f = 7*x+y+49\n(7^1 + O(7^3))*x + y + 7^2 + O(7^4)\n\njulia> tropical_polynomial(f,min)\n(1)*x + y + (2)\n\njulia> tropical_polynomial(f,max)\n(-1)*x + y + (-2)\n\n\n\ntropical_polynomial(f::MPolyElem,val::TropicalSemiringMap)\n\nGiven a polynomial f and a tropical semiring map val, returns the tropicalization of f as a polynomial over the tropical semiring.\n\nExamples\n\njulia> R, (x,y) = PolynomialRing(QQ,[\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> val = TropicalSemiringMap(QQ,7)\nThe 7-adic valuation on Rational Field\n\njulia> f = 7*x+y+49\n7*x + y + 49\n\njulia> tropical_polynomial(f,val)\n(1)*x + y + (2)\n\n\n\n","category":"function"},{"location":"TropicalGeometry/intro/#Tropical-curves","page":"Introduction","title":"Tropical curves","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"(no functions yet, under active development)","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"TropicalCurve","category":"page"},{"location":"TropicalGeometry/intro/#TropicalCurve","page":"Introduction","title":"TropicalCurve","text":"TropicalCurve(PC::PolyhedralComplex)\n\nConstruct a tropical curve from a polyhedral complex. If the curve is embedded, vertices must are points in mathbb R^n. If the curve is abstract, the polyhedral complex is empty, vertices must be 1, ..., n, and the graph is given as attribute.\n\nExamples\n\njulia> IM = IncidenceMatrix([[1,2],[1,3],[1,4]])\n3×4 IncidenceMatrix\n[1, 2]\n[1, 3]\n[1, 4]\n\n\njulia> VR = [0 0; 1 0; -1 0; 0 1]\n4×2 Matrix{Int64}:\n  0  0\n  1  0\n -1  0\n  0  1\n\njulia> PC = PolyhedralComplex{fmpq}(IM, VR)\nA polyhedral complex in ambient dimension 2\n\njulia> TC = TropicalCurve(PC)\nA min tropical curve in 2-dimensional Euclidean space\n\njulia> abs_TC = TropicalCurve(IM)\nAn abstract min tropical curve\n\n\n\n","category":"type"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"in work: chip firing, jacobians.","category":"page"},{"location":"TropicalGeometry/intro/#Tropical-hypersurfaces","page":"Introduction","title":"Tropical hypersurfaces","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"TropicalHypersurface\ndual_subdivision(TH::TropicalHypersurface{M, EMB}) where {M, EMB}","category":"page"},{"location":"TropicalGeometry/intro/#TropicalHypersurface","page":"Introduction","title":"TropicalHypersurface","text":"TropicalHypersurface(f::AbstractAlgebra.Generic.MPoly{Oscar.TropicalSemiringElem{T}})\n\nReturn the tropical hypersurface defined by a tropical polynomial.\n\nExamples\n\njulia> T = TropicalSemiring(min)\nTropical semiring (min)\n\njulia> Txy,(x,y) = T[\"x\",\"y\"]\n(Multivariate Polynomial Ring in x, y over Tropical semiring (min), AbstractAlgebra.Generic.MPoly{Oscar.TropicalSemiringElem{typeof(min)}}[x, y])\n\njulia> f = x+y+1\nx + y + (1)\n\njulia> Tf = TropicalHypersurface(f)\nA min tropical hypersurface embedded in 2-dimensional Euclidian space\n\n\n\nTropicalHypersurface{M}(f::MPolyElem,M::Union{typeof(min),typeof(max)}=min)\n\nReturn the tropical hypersurface defined by the tropicalization of an algebraic polynomial. If M=min, the tropical hypersurface will obey the min-convention. If M=max, the tropical hypersurface will obey the max-convention. If coefficient ring has a valuation, the tropical hypersurface will be constructed with respect to it. If coefficient ring has no valuation, the tropical hypersurface will be constructed with respect to the trivial valuation.\n\nExamples\n\njulia> K = PadicField(7, 2);\n\njulia> Kxy, (x,y) = K[\"x\", \"y\"]\n(Multivariate Polynomial Ring in x, y over Field of 7-adic numbers, AbstractAlgebra.Generic.MPoly{padic}[x, y])\n\njulia> f = 7*x+y+49;\n\njulia> TropicalHypersurface(f, min)\nA min tropical hypersurface embedded in 2-dimensional Euclidian space\n\njulia> TropicalHypersurface(f, max)\nA max tropical hypersurface embedded in 2-dimensional Euclidian space\n\n\n\n","category":"type"},{"location":"TropicalGeometry/intro/#dual_subdivision-Union{Tuple{TropicalHypersurface{M, EMB}}, Tuple{EMB}, Tuple{M}} where {M, EMB}","page":"Introduction","title":"dual_subdivision","text":"dual_subdivision(TH::TropicalHypersurface{M, EMB})\n\nReturn the dual subdivision of TH if it is embedded. Otherwise an error is thrown.\n\nExamples\n\nA tropical hypersurface in mathbbR^n is always of dimension n-1.\n\njulia> T = TropicalSemiring(min);\n\njulia> Txy,(x,y) = T[\"x\",\"y\"];\n\njulia> f = x+y+1;\n\njulia> tropicalLine = TropicalHypersurface(f);\n\njulia> dual_subdivision(tropicalLine)\nA subdivision of points in ambient dimension 3\n\n\n\n","category":"method"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"in work: minimal tropical polynomials of a hypersurface.","category":"page"},{"location":"TropicalGeometry/intro/#Tropical-linear-spaces","page":"Introduction","title":"Tropical linear spaces","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"(no functions yet, under active development)","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"TropicalLinearSpace","category":"page"},{"location":"TropicalGeometry/intro/#TropicalLinearSpace","page":"Introduction","title":"TropicalLinearSpace","text":"TropicalLinearSpace(ideal::MPolyIdeal{fmpq_poly})\n\nConstruct a tropical linear space from a degree 1 polynomial ideal.\n\nExamples\n\njulia> R,(x_0,x_1,x_2,x_3,x_4,x_5)=PolynomialRing(ZZ,[\"x_0\",\"x_1\",\"x_2\",\"x_3\",\"x_4\",\"x_5\"])\n(Multivariate Polynomial Ring in 6 variables x_0, x_1, x_2, x_3, ..., x_5 over Integer Ring, fmpz_mpoly[x_0, x_1, x_2, x_3, x_4, x_5])\n\njulia> I=ideal(R,[-x_0+x_2+x_3,-x_1+x_2+x_4,-x_0+x_1+x_5])\nideal(-x_0 + x_2 + x_3, -x_1 + x_2 + x_4, -x_0 + x_1 + x_5)\n\njulia> val = TropicalSemiringMap(QQ)\nThe trivial valuation on Rational Field\n\njulia> TropicalLinearSpace(I,val)\nVector{Oscar.TropicalSemiringElem{typeof(min)}}\nTropicalLinearSpace{min, true}(A polyhedral complex in ambient dimension 6, #undef)\n\n\n\nTropicalLinearSpace()\n\nConstruct a tropical linear space from a matrix generating it. Requires the matrix input to be of Type MatElem.\n\nExamples\n\njulia> Kt, t = RationalFunctionField(QQ,\"t\");\n\njulia> val = TropicalSemiringMap(Kt,t);\n\njulia> A = matrix(Kt,[[t,4*t,0,2],[1,4,1,t^2]]);\n\njulia> TropicalLinearSpace(A, val)\nVector{Oscar.TropicalSemiringElem{typeof(min)}}\nTropicalLinearSpace{min, true}(A polyhedral complex in ambient dimension 4, #undef)\n \njulia> p = 3;\n\njulia> val = TropicalSemiringMap(QQ, p);\n\njulia> A = matrix(QQ, [[3,7,5,1], [9,7,1,2]])\n[3   7   5   1]\n[9   7   1   2]\n\njulia> TropicalLinearSpace(A,val)\nVector{Oscar.TropicalSemiringElem{typeof(min)}}\nTropicalLinearSpace{min, true}(A polyhedral complex in ambient dimension 4, #undef)\n\n\n\n","category":"type"},{"location":"TropicalGeometry/intro/#Tropical-varieties","page":"Introduction","title":"Tropical varieties","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"(no functions yet, under active development)","category":"page"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"in work: tropical_variety(I::MPolyIdeal,val::TropicalSemiringMap)","category":"page"},{"location":"TropicalGeometry/intro/#Groebner-bases-and-Groebner-polyhedra","page":"Introduction","title":"Groebner bases and Groebner polyhedra","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"groebner_basis(I::MPolyIdeal,val::TropicalSemiringMap,w::Vector{<: Union{Int,Rational{Int}} }; complete_reduction::Bool=false, return_lead::Bool=false)","category":"page"},{"location":"TropicalGeometry/intro/#groebner_basis-Tuple{MPolyIdeal, TropicalSemiringMap, Vector{var\"#s271\"} where var\"#s271\"<:Union{Rational{Int64}, Int64}}","page":"Introduction","title":"groebner_basis","text":"groebner_basis(I::Ideal, val::TropicalSemiringMap, w::Vector; complete_reduction::Bool, return_lead::Bool)\n\nCompute a Groebner basis of I over a field with valuation val with respect to weight vector w, that is a finite generating set of I whose initial forms generate the initial ideal with respect to w.\n\nFor the definitions of initial form, initial ideal and Groebner basis see Section 2.4 of Diane Maclagan, Bernd Sturmfels (2015).\n\nwarning: Warning\nGroebner bases over fields with valuation are still in an experimental stage. I must be generated by homogeneous polynomials and val must be non-trivial.\n\nExamples\n\njulia> R,(x,y) = PolynomialRing(QQ,[\"x\",\"y\"]);\n\njulia> I = ideal([x^3-5*x^2*y,3*y^3-2*x^2*y])\nideal(x^3 - 5*x^2*y, -2*x^2*y + 3*y^3)\n\njulia> val_2 = TropicalSemiringMap(QQ,2);\n\njulia> w = [0,0];\n\njulia> groebner_basis(I,val_2,w)\n5-element Vector{fmpq_mpoly}:\n 2*x^2*y - 3*y^3\n x^3 - 5*x^2*y\n x*y^3 - 5*y^4\n y^5\n x^2*y^3 + 69*y^5\n\n\n\n","category":"method"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"in work: groebner_polyhedron(I::MPolyIdeal,val::TropicalSemiringMap,w::Vector{<: Union{Int,Rational{Int}})","category":"page"},{"location":"TropicalGeometry/intro/#Intersections-and-stable-intersections","page":"Introduction","title":"Intersections and stable intersections","text":"","category":"section"},{"location":"TropicalGeometry/intro/","page":"Introduction","title":"Introduction","text":"intersect(T1::TropicalVarietySupertype{M, EMB}, T2::TropicalVarietySupertype{M, EMB}) where {M, EMB}\nstably_intersect(T1::TropicalVarietySupertype{M, EMB}, T2::TropicalVarietySupertype{M, EMB}) where {M, EMB}","category":"page"},{"location":"TropicalGeometry/intro/#intersect-Union{Tuple{EMB}, Tuple{M}, Tuple{Oscar.TropicalVarietySupertype{M, EMB}, Oscar.TropicalVarietySupertype{M, EMB}}} where {M, EMB}","page":"Introduction","title":"intersect","text":"intersect(T1, T2)\n\nIntersect two tropical varieties.\n\nExamples\n\njulia> RR = TropicalSemiring(min)\nTropical semiring (min)\n\njulia> S,(x,y) = RR[\"x\",\"y\"]\n(Multivariate Polynomial Ring in x, y over Tropical semiring (min), AbstractAlgebra.Generic.MPoly{Oscar.TropicalSemiringElem{typeof(min)}}[x, y])\n\njulia> f1 = x+y+1\nx + y + (1)\n\njulia> f2 = x^2+y^2+RR(-6)\nx^2 + y^2 + (-6)\n\njulia> hyp1 = TropicalHypersurface(f1)\nA min tropical hypersurface embedded in 2-dimensional Euclidian space\n\njulia> hyp2 = TropicalHypersurface(f2)\nA min tropical hypersurface embedded in 2-dimensional Euclidian space\n\njulia> tv12 = intersect(hyp1, hyp2)\nA min tropical variety of dimension 1 embedded in 2-dimensional Euclidian space\n\n\n\n","category":"method"},{"location":"TropicalGeometry/intro/#stably_intersect-Union{Tuple{EMB}, Tuple{M}, Tuple{Oscar.TropicalVarietySupertype{M, EMB}, Oscar.TropicalVarietySupertype{M, EMB}}} where {M, EMB}","page":"Introduction","title":"stably_intersect","text":"intersect_stably(T1, T2)\n\nExamples\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend\nDocTestFilters = r\"[0-9\\.]+ seconds \\(.*\\)\"","category":"page"},{"location":"AbstractAlgebra/ytabs/#Partitions-and-Young-tableaux","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"AbstractAlgebra.jl provides basic support for computations with Young tableaux, skew diagrams and the characters of permutation groups (implemented src/generic/YoungTabs.jl). All functionality of permutations is accesible in the Generic submodule.","category":"page"},{"location":"AbstractAlgebra/ytabs/#Partitions","page":"Partitions and Young tableaux","title":"Partitions","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The basic underlying object for those concepts is Partition of a number n, i.e. a sequence of positive integers n_1 ldots n_k which sum to n. Partitions in AbstractAlgebra.jl are represented internally by non-increasing Vectors of Ints. Partitions are printed using the standard notation, i.e. 9 = 4 + 2 + 1 + 1 + 1 is shown as 4_1 2_1 1_3 with the subscript indicating the count of a summand in the partition.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.Partition","category":"page"},{"location":"AbstractAlgebra/ytabs/#Partition","page":"Partitions and Young tableaux","title":"Partition","text":"Partition(part::Vector{<:Integer}[, check::Bool=true]) <: AbstractVector{Int}\n\nRepresent integer partition in the non-increasing order.\n\npart will be sorted, if necessary. Checks for validity of input can be skipped by calling the (inner) constructor with false as the second argument.\n\nFunctionally Partition is a thin wrapper over Vector{Int}.\n\nFieldnames:\n\nn::Int - the partitioned number\npart::Vector{Int} - a non-increasing sequence of summands of n.\n\nExamples:\n\njulia> p = Partition([4,2,1,1,1])\n4₁2₁1₃\n\njulia> p.n == sum(p.part)\ntrue\n\n\n\n","category":"type"},{"location":"AbstractAlgebra/ytabs/#Array-interface","page":"Partitions and Young tableaux","title":"Array interface","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Partition is a concrete (immutable) subtype of AbstractVector{Integer} and implements the standard Array interface.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"size(::Generic.Partition)\ngetindex(::Generic.Partition, i::Integer)","category":"page"},{"location":"AbstractAlgebra/ytabs/#size-Tuple{AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"size","text":"size(p::Partition)\n\nReturn the size of the vector which represents the partition.\n\nExamples:\n\njulia> p = Partition([4,3,1]); size(p)\n(3,)\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#getindex-Tuple{AbstractAlgebra.Generic.Partition, Integer}","page":"Partitions and Young tableaux","title":"getindex","text":"getindex(p::Partition, i::Integer)\n\nReturn the i-th part (in non-increasing order) of the partition.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"These functions work on the level of p.part vector.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"One can easily iterate over all partitions of n using the Generic.partitions function.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.partitions","category":"page"},{"location":"AbstractAlgebra/ytabs/#partitions","page":"Partitions and Young tableaux","title":"partitions","text":"partitions(n::Integer)\n\nReturn the vector of all permutations of n. For an unsafe generator version see partitions!.\n\nExamples:\n\n```jldoctest; setup = :(using AbstractAlgebra) julia> Generic.partitions(5) 7-element Vector{AbstractAlgebra.Generic.Partition{Int64}}:  1₅  2₁1₃  3₁1₂  2₂1₁  4₁1₁  3₁2₁  5₁\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"You may also have a look at JuLie.jl package for more utilities related to partitions.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The number of all partitions can be computed by the hidden function _numpart. Much faster implementation is available in Nemo.jl.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic._numpart","category":"page"},{"location":"AbstractAlgebra/ytabs/#_numpart","page":"Partitions and Young tableaux","title":"_numpart","text":"_numpart(n::Integer)\n\nReturn the number of all distinct integer partitions of n. The function uses Euler pentagonal number theorem for recursive formula. For more details see OEIS sequence A000041. Note that _numpart(0) = 1 by convention.\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Since Partition is a subtype of AbstractVector generic functions which operate on vectors should work in general. However the meaning of conj has been changed to agree with the traditional understanding of conjugation of Partitions:","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"conj(::Generic.Partition)\nconj(::Generic.Partition, v::Vector)","category":"page"},{"location":"AbstractAlgebra/ytabs/#conj-Tuple{AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"conj","text":"conj(part::Partition)\n\nReturn the conjugated partition of part, i.e. the partition corresponding to the Young diagram of part reflected through the main diagonal.\n\nExamples:\n\njulia> p = Partition([4,2,1,1,1])\n4₁2₁1₃\n\njulia> conj(p)\n5₁2₁1₂\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#conj-Tuple{AbstractAlgebra.Generic.Partition, Vector{T} where T}","page":"Partitions and Young tableaux","title":"conj","text":"conj(part::Partition, v::Vector)\n\nReturn the conjugated partition of part together with permuted vector v.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#Young-Diagrams-and-Young-Tableaux","page":"Partitions and Young tableaux","title":"Young Diagrams and Young Tableaux","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Mathematicaly speaking Young diagram is a diagram which consists of rows of square boxes such that the number of boxes in each row is no less than the number of boxes in the previous row. For example partition 4_1 3_2 1 represents the following diagram.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"┌───┬───┬───┬───┐\n│   │   │   │   │\n├───┼───┼───┼───┘\n│   │   │   │\n├───┼───┼───┤\n│   │   │   │\n├───┼───┴───┘\n│   │\n└───┘","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Young Tableau is formally a bijection between the set of boxes of a Young Diagram and the set 1 ldots n. If a bijection is increasing along rows and columns of the diagram it is referred to as standard. For example","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┼───┤\n│ 8 │ 9 │10 │\n├───┼───┴───┘\n│11 │\n└───┘","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"is a standard Young tableau of 4_1 3_2 1 where the bijection assigns consecutive natural numbers to consecutive (row-major) cells.","category":"page"},{"location":"AbstractAlgebra/ytabs/#Constructors","page":"Partitions and Young tableaux","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"In AbstractAlgebra.jl Young tableau are implemented as essentially row-major sparse matrices, i.e. YoungTableau <: AbstractMatrix{Int} but only the defining Partition and the (row-major) fill-vector is stored.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.YoungTableau","category":"page"},{"location":"AbstractAlgebra/ytabs/#YoungTableau","page":"Partitions and Young tableaux","title":"YoungTableau","text":"YoungTableau(part::Partition[, fill::Vector{Int}=collect(1:sum(part))])  <: AbstractMatrix{Int}\n\nReturn the Young tableaux of partition part, filled linearly by fill vector. Note that fill vector is in row-major format.\n\nFields:\n\npart - the partition defining Young diagram\nfill - the row-major fill vector: the entries of the diagram.\n\nExamples:\n\njulia> p = Partition([4,3,1]); y = YoungTableau(p)\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> y.part\n4₁3₁1₁\n\njulia> y.fill\n8-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n\n\n\n","category":"type"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"For convenience there exists an alternative constructor of YoungTableau, which accepts a vector of integers and constructs Partition internally.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"YoungTableau(p::Vector{Integer}[, fill=collect(1:sum(p))])","category":"page"},{"location":"AbstractAlgebra/ytabs/#Array-interface-2","page":"Partitions and Young tableaux","title":"Array interface","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"To make YoungTableaux array-like we implement the following functions:","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"size(::Generic.YoungTableau)\ngetindex(::Generic.YoungTableau, n::Integer)","category":"page"},{"location":"AbstractAlgebra/ytabs/#size-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"size","text":"size(Y::YoungTableau)\n\nReturn size of the smallest array containing Y, i.e. the tuple of the number of rows and the number of columns of Y.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1]); size(y)\n(3, 4)\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#getindex-Tuple{AbstractAlgebra.Generic.YoungTableau, Integer}","page":"Partitions and Young tableaux","title":"getindex","text":"getindex(Y::YoungTableau, n::Integer)\n\nReturn the column-major linear index into the size(Y)-array. If a box is outside of the array return 0.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> y[1]\n1\n\njulia> y[2]\n5\n\njulia> y[4]\n2\n\njulia> y[6]\n0\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Also the double-indexing corresponds to (row, column) access to an abstract array.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"julia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> y[1,2]\n2\n\njulia> y[2,3]\n7\n\njulia> y[3,2]\n0","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Functions defined for AbstractArray type based on those (e.g. length) should work. Again, as in the case of Partition the meaning of conj is altered to reflect the usual meaning for Young tableaux:","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"conj(::Generic.YoungTableau)","category":"page"},{"location":"AbstractAlgebra/ytabs/#conj-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"conj","text":"conj(Y::YoungTableau)\n\nReturn the conjugated tableau, i.e. the tableau reflected through the main diagonal.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> conj(y)\n┌───┬───┬───┐\n│ 1 │ 5 │ 8 │\n├───┼───┼───┘\n│ 2 │ 6 │\n├───┼───┤\n│ 3 │ 7 │\n├───┼───┘\n│ 4 │\n└───┘\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#Pretty-printing","page":"Partitions and Young tableaux","title":"Pretty-printing","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Similarly to permutations we have two methods of displaying Young Diagrams:","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.setyoungtabstyle","category":"page"},{"location":"AbstractAlgebra/ytabs/#setyoungtabstyle","page":"Partitions and Young tableaux","title":"setyoungtabstyle","text":"setyoungtabstyle(format::Symbol)\n\nSelect the style in which Young tableaux are displayed (in REPL or in general as string). This can be either\n\n:array - as matrices of integers, or\n:diagram - as filled Young diagrams (the default).\n\nThe difference is purely esthetical.\n\nExamples:\n\njulia> Generic.setyoungtabstyle(:array)\n:array\n\njulia> p = Partition([4,3,1]); YoungTableau(p)\n 1  2  3  4\n 5  6  7\n 8\n\njulia> Generic.setyoungtabstyle(:diagram)\n:diagram\n\njulia> YoungTableau(p)\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ytabs/#Ulitility-functions","page":"Partitions and Young tableaux","title":"Ulitility functions","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"matrix_repr(::Generic.YoungTableau)\nfill!(::Generic.YoungTableau, ::AbstractVector{<:Integer})","category":"page"},{"location":"AbstractAlgebra/ytabs/#matrix_repr-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"matrix_repr","text":"matrix_repr(a::Perm)\n\nReturn the permutation matrix as a sparse matrix representing a via natural embedding of the permutation group into the general linear group over mathbbZ.\n\nExamples:\n\njulia> p = Perm([2,3,1])\n(1,2,3)\n\njulia> matrix_repr(p)\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 3 stored entries:\n ⋅  1  ⋅\n ⋅  ⋅  1\n 1  ⋅  ⋅\n\njulia> Array(ans)\n3×3 Matrix{Int64}:\n 0  1  0\n 0  0  1\n 1  0  0\n\n\n\nmatrix_repr(Y::YoungTableau)\n\nConstruct sparse integer matrix representing the tableau.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1]);\n\n\njulia> matrix_repr(y)\n3×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 8 stored entries:\n 1  2  3  4\n 5  6  7  ⋅\n 8  ⋅  ⋅  ⋅\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#fill!-Tuple{AbstractAlgebra.Generic.YoungTableau, AbstractVector{var\"#s271\"} where var\"#s271\"<:Integer}","page":"Partitions and Young tableaux","title":"fill!","text":"fill!(Y::YoungTableaux, V::Vector{<:Integer})\n\nReplace the fill vector Y.fill by V. No check if the resulting tableau is standard (i.e. increasing along rows and columns) is performed.\n\nExamples:\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> fill!(y, [2:9...])\n┌───┬───┬───┬───┐\n│ 2 │ 3 │ 4 │ 5 │\n├───┼───┼───┼───┘\n│ 6 │ 7 │ 8 │\n├───┼───┴───┘\n│ 9 │\n└───┘\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#Characters-of-permutation-groups","page":"Partitions and Young tableaux","title":"Characters of permutation groups","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Irreducible characters (at least over field of characteristic 0) of the full group of permutations S_n correspond via Specht modules to partitions of n.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"character(::Generic.Partition)\ncharacter(lambda::Generic.Partition, p::Generic.Perm)\ncharacter(lambda::Generic.Partition, mu::Generic.Partition)","category":"page"},{"location":"AbstractAlgebra/ytabs/#character-Tuple{AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"character","text":"character(lambda::Partition)\n\nReturn the lambda-th irreducible character of permutation group on sum(lambda) symbols. The returned character function is of the following signature:\n\nchi(p::Perm[, check::Bool=true]) -> BigInt\n\nThe function checks (if p belongs to the appropriate group) can be switched off by calling chi(p, false). The values computed by chi are cached in look-up table.\n\nThe computation follows the Murnaghan-Nakayama formula: chi_lambda(sigma) = sum_textrimhook xisubset lambda(-1)^ll(lambdabackslashxi) chi_lambda backslashxi(tildesigma) where lambdabackslashxi denotes the skew diagram of lambda with xi removed, ll denotes the leg-length (i.e. number of rows - 1) and tildesigma is permutation obtained from sigma by the removal of the longest cycle.\n\nFor more details see e.g. Chapter 2.8 of Group Theory and Physics by S.Sternberg.\n\nExamples\n\njulia> G = SymmetricGroup(4)\nFull symmetric group over 4 elements\n\njulia> chi = character(Partition([3,1])); # character of the regular representation\n\n\njulia> chi(one(G))\n3\n\njulia> chi(perm\"(1,3)(2,4)\")\n-1\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#character-Tuple{AbstractAlgebra.Generic.Partition, Perm}","page":"Partitions and Young tableaux","title":"character","text":"character(lambda::Partition, p::Perm, check::Bool=true) -> BigInt\n\nReturn the value of lambda-th irreducible character of the permutation group on permutation p.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#character-Tuple{AbstractAlgebra.Generic.Partition, AbstractAlgebra.Generic.Partition}","page":"Partitions and Young tableaux","title":"character","text":"character(lambda::Partition, mu::Partition, check::Bool=true) -> BigInt\n\nReturn the value of lambda-th irreducible character on the conjugacy class represented by partition mu.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The values computed by characters are cached in an internal dictionary Dict{Tuple{BitVector,Vector{Int}}, BigInt}. Note that all of the above functions return BigInts. If you are sure that the computations do not overflow, variants of the last two functions using Int are available:","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"character(::Type{Int}, lambda::Partition, p::Perm[, check::Bool=true])\ncharacter(::Type{Int}, lambda::Partition, mu::Partition[, check::Bool=true])","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The dimension dim lambda of the irreducible module corresponding to partition lambda can be computed using Hook length formula","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.rowlength\nGeneric.collength\nhooklength\ndim(::Generic.YoungTableau)","category":"page"},{"location":"AbstractAlgebra/ytabs/#rowlength","page":"Partitions and Young tableaux","title":"rowlength","text":"rowlength(Y::YoungTableau, i, j)\n\nReturn the row length of Y at box (i,j), i.e. the number of boxes in the i-th row of the diagram of Y located to the right of the (i,j)-th box.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> Generic.rowlength(y, 1,2)\n2\n\njulia> Generic.rowlength(y, 2,3)\n0\n\njulia> Generic.rowlength(y, 3,3)\n0\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ytabs/#collength","page":"Partitions and Young tableaux","title":"collength","text":"collength(Y::YoungTableau, i, j)\n\nReturn the column length of Y at box (i,j), i.e. the number of boxes in the j-th column of the diagram of Y located below of the (i,j)-th box.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> Generic.collength(y, 1,1)\n2\n\njulia> Generic.collength(y, 1,3)\n1\n\njulia> Generic.collength(y, 2,4)\n0\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ytabs/#hooklength","page":"Partitions and Young tableaux","title":"hooklength","text":"hooklength(Y::YoungTableau, i, j)\n\nReturn the hook-length of an element in Y at position (i,j), i.e the number of cells in the i-th row to the right of (i,j)-th box, plus the number of cells in the j-th column below the (i,j)-th box, plus 1.\n\nReturn 0 for (i,j) not in the tableau Y.\n\nExamples\n\njulia> y = YoungTableau([4,3,1])\n┌───┬───┬───┬───┐\n│ 1 │ 2 │ 3 │ 4 │\n├───┼───┼───┼───┘\n│ 5 │ 6 │ 7 │\n├───┼───┴───┘\n│ 8 │\n└───┘\n\njulia> hooklength(y, 1,1)\n6\n\njulia> hooklength(y, 1,3)\n3\n\njulia> hooklength(y, 2,4)\n0\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ytabs/#dim-Tuple{AbstractAlgebra.Generic.YoungTableau}","page":"Partitions and Young tableaux","title":"dim","text":"dim(Y::YoungTableau) -> BigInt\n\nReturn the dimension (using hook-length formula) of the irreducible representation of permutation group S_n associated the partition Y.part.\n\nSince the computation overflows easily BigInt is returned. You may perform the computation of the dimension in different type by calling dim(Int, Y).\n\nExamples\n\njulia> dim(YoungTableau([4,3,1]))\n70\n\njulia> dim(YoungTableau([3,1])) # the regular representation of S_4\n3\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The character associated with Y.part can also be used to compute the dimension, but as it is expected the Murnaghan-Nakayama is much slower even though (due to caching) consecutive calls are fast:","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"julia> λ = Partition(collect(12:-1:1))\n12₁11₁10₁9₁8₁7₁6₁5₁4₁3₁2₁1₁\n\njulia> @time dim(YoungTableau(λ))\n  0.224430 seconds (155.77 k allocations: 7.990 MiB)\n9079590132732747656880081324531330222983622187548672000\n\njulia> @time dim(YoungTableau(λ))\n  0.000038 seconds (335 allocations: 10.734 KiB)\n9079590132732747656880081324531330222983622187548672000\n\njulia> G = SymmetricGroup(sum(λ))\nFull symmetric group over 78 elements\n\njulia> @time character(λ, one(G))\n  0.000046 seconds (115 allocations: 16.391 KiB)\n9079590132732747656880081324531330222983622187548672000\n\njulia> @time character(λ, one(G))\n  0.001439 seconds (195 allocations: 24.453 KiB)\n9079590132732747656880081324531330222983622187548672000","category":"page"},{"location":"AbstractAlgebra/ytabs/#Low-level-functions-and-characters","page":"Partitions and Young tableaux","title":"Low-level functions and characters","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"As mentioned above character functions use the Murnaghan-Nakayama rule for evaluation. The implementation follows","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Dan Bernstein, The computational complexity of rules for the character table of S_n Journal of Symbolic Computation, 37 (6), 2004, p. 727-748,","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"implementing the following functions. For precise definitions and meaning please consult the paper cited.","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.partitionseq\nisrimhook(::BitVector, ::Int, ::Int)\nGeneric.MN1inner","category":"page"},{"location":"AbstractAlgebra/ytabs/#partitionseq","page":"Partitions and Young tableaux","title":"partitionseq","text":"partitionseq(lambda::Partition)\n\nReturn a sequence (as BitVector) of falses and trues constructed from lambda: tracing the lower contour of the Young Diagram associated to lambda from left to right a true is inserted for every horizontal and false for every vertical step. The sequence always starts with true and ends with false.\n\n\n\npartitionseq(seq::BitVector)\n\nReturn the essential part of the sequence seq, i.e. a subsequence starting at first true and ending at last false.\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ytabs/#isrimhook-Tuple{BitVector, Int64, Int64}","page":"Partitions and Young tableaux","title":"isrimhook","text":"isrimhook(R::BitVector, idx::Integer, len::Integer)\n\nR[idx:idx+len] forms a rim hook in the Young Diagram of partition corresponding to R iff R[idx] == true and R[idx+len] == false.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#MN1inner","page":"Partitions and Young tableaux","title":"MN1inner","text":"MN1inner(R::BitVector, mu::Partition, t::Integer, charvals)\n\nReturn the value of lambda-th irreducible character on conjugacy class of permutations represented by partition mu, where R is the (binary) partition sequence representing lambda. Values already computed are stored in charvals::Dict{Tuple{BitVector,Vector{Int}}, Int}. This is an implementation (with slight modifications) of the Murnaghan-Nakayama formula as described in\n\nDan Bernstein,\n\"The computational complexity of rules for the character table of Sn\"\n_Journal of Symbolic Computation_, 37(6), 2004, p. 727-748.\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ytabs/#Skew-Diagrams","page":"Partitions and Young tableaux","title":"Skew Diagrams","text":"","category":"section"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Skew diagrams are formally differences of two Young diagrams. Given lambda and mu, two partitions of n+m and m (respectively). Suppose that each of cells of mu is a cell of lambda (i.e. parts of mu are no greater than the corresponding parts of lambda). Then the skew diagram denoted by lambdamu is the set theoretic difference the of sets of boxes, i.e. is a diagram with exactly n boxes:","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"Generic.SkewDiagram","category":"page"},{"location":"AbstractAlgebra/ytabs/#SkewDiagram","page":"Partitions and Young tableaux","title":"SkewDiagram","text":"SkewDiagram(lambda::Partition, mu::Partition) <: AbstractMatrix{Int}\n\nImplements a skew diagram, i.e. a difference of two Young diagrams represented by partitions lambda and mu. (below dots symbolise the removed entries)\n\nExamples\n\njulia> l = Partition([4,3,2])\n4₁3₁2₁\n\njulia> m = Partition([3,1,1])\n3₁1₂\n\njulia> xi = SkewDiagram(l,m)\n3×4 AbstractAlgebra.Generic.SkewDiagram{Int64}:\n ⋅  ⋅  ⋅  1\n ⋅  1  1\n ⋅  1\n\n\n\n\n","category":"type"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"SkewDiagram implements array interface with the following functions:","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"size(xi::Generic.SkewDiagram)\nin(t::Tuple{Integer,Integer}, xi::Generic.SkewDiagram)\ngetindex(xi::Generic.SkewDiagram, n::Integer)","category":"page"},{"location":"AbstractAlgebra/ytabs/#size-Tuple{AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"size","text":"size(xi::SkewDiagram)\n\nReturn the size of array where xi is minimally contained. See size(Y::YoungTableau) for more details.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#in-Tuple{Tuple{Integer, Integer}, AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"in","text":"in(t::Tuple{Integer,Integer}, xi::SkewDiagram)\n\nCheck if box at position (i,j) belongs to the skew diagram xi.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#getindex-Tuple{AbstractAlgebra.Generic.SkewDiagram, Integer}","page":"Partitions and Young tableaux","title":"getindex","text":"getindex(xi::SkewDiagram, n::Integer)\n\nReturn 1 if linear index n corresponds to (column-major) entry in xi.lam which is not contained in xi.mu. Otherwise return 0.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"The support for skew diagrams is very rudimentary. The following functions are available:","category":"page"},{"location":"AbstractAlgebra/ytabs/","page":"Partitions and Young tableaux","title":"Partitions and Young tableaux","text":"isrimhook(::Generic.SkewDiagram)\nleglength\nmatrix_repr(::Generic.SkewDiagram)","category":"page"},{"location":"AbstractAlgebra/ytabs/#isrimhook-Tuple{AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"isrimhook","text":"isrimhook(xi::SkewDiagram)\n\nCheck if xi represents a rim-hook diagram, i.e. its diagram is edge-connected and contains no 2times 2 squares.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ytabs/#leglength","page":"Partitions and Young tableaux","title":"leglength","text":"leglength(xi::SkewDiagram[, check::Bool=true])\n\nCompute the leglength of a rim-hook xi, i.e. the number of rows with non-zero entries minus one. If check is false function will not check whether xi is actually a rim-hook.\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/ytabs/#matrix_repr-Tuple{AbstractAlgebra.Generic.SkewDiagram}","page":"Partitions and Young tableaux","title":"matrix_repr","text":"matrix_repr(xi::SkewDiagram)\n\nReturn a sparse representation of the diagram xi, i.e. a sparse array A where A[i,j] == 1 if and only if (i,j) is in xi.lam but not in xi.mu.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/visualizing_types/#Visualization-of-the-types-of-AbstractAlgebra.jl","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"AbstractAlgebra.jl implements a couple of abstract types which can be extended.","category":"page"},{"location":"AbstractAlgebra/visualizing_types/#Abstract-parents","page":"Visualization of the types of AbstractAlgebra.jl","title":"Abstract parents","text":"","category":"section"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"The following diagram shows a complete list of all abstract types in AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"(Image: Diagram of parent types)","category":"page"},{"location":"AbstractAlgebra/visualizing_types/#Abstract-elements","page":"Visualization of the types of AbstractAlgebra.jl","title":"Abstract elements","text":"","category":"section"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"Similarly the following diagram shows a complete list of all abstract types in AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"(Image: Diagram of element types)","category":"page"},{"location":"AbstractAlgebra/visualizing_types/#Concrete-types-in-AbstractAlgebra.jl","page":"Visualization of the types of AbstractAlgebra.jl","title":"Concrete types in AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"Until now we have discussed the abstract types of AbstractAlgebra.jl. Under this subsection we will instead give some examples of concrete types in AbstractAlgebra.jl.","category":"page"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"In parentheses we put the types of the corresponding parent objects.","category":"page"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"Perm{<:Integer} (SymmetricGroup{<:Integer})\nGFElem{<:Integer} (GFField{<:Integer})","category":"page"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"We also think of various Julia types as though they were AbstractAlgebra.jl types:","category":"page"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"BigInt (Integers{BigInt})\nRational{BigInt} (Rationals{BigInt})","category":"page"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"Then there are various types for generic constructions over a base ring. They are all parameterised by a type T which is the type of the elements of the base ring they are defined over.","category":"page"},{"location":"AbstractAlgebra/visualizing_types/","page":"Visualization of the types of AbstractAlgebra.jl","title":"Visualization of the types of AbstractAlgebra.jl","text":"Generic.Poly{T} (Generic.PolyRing{T})\nGeneric.MPoly{T} (Generic.MPolyRing{T})\nGeneric.RelSeries{T} (Generic.RelSeriesRing{T})\nGeneric.AbsSeries{T} (Generic.AbsSeriesRing{T})\nGeneric.LaurentSeriesRingElem{T} (Generic.LaurentSeriesRing{T})\nGeneric.LaurentSeriesFieldElem{T} (Generic.LaurentSeriesField{T})\nGeneric.Res{T} (Generic.ResRing{T})\nGeneric.Frac{T} (Generic.FracField{T})\nGeneric.Mat{T} (Generic.MatSpace{T})","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"CommutativeAlgebra/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"The commutative algebra part of OSCAR provides functionality for handling","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"ideals of multivariate polynomial rings,\nquotients of multivariate polynomial rings modulo ideals, as well as ideals of such quotients, and \nmodules over the above rings.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"In describing this functionality, we will refer to quotients of multivariate polynomial rings also as affine algebras.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nMost functions discussed here rely on Gröbner basis techniques. They either execute corresponding Singular functionality, or are written as pieces of OSCAR code which rely on Singular for Gröbner basis computations. The functions are  implemented for multivariate polynomial rings over fields (exact fields supported by OSCAR) and, if not indicated otherwise, for multivariate polynomial rings over the integers.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"note: Note\nMultivariate polynomial rings may or may not carry a distinguished (multi)grading. If not mentioned otherwise, the discussed functions apply to both the ungraded and graded case.  For simplicity of the presentation, such functions are often only illustrated by examples with focus on the former case, but work similarly for homogeneous ideals and graded modules in the former case.","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include: ","category":"page"},{"location":"CommutativeAlgebra/intro/","page":"Introduction","title":"Introduction","text":"Gert-Martin Greuel, Gerhard Pfister (2008)\nWolfram Decker, Christoph Lossen (2006)\nWolfram Decker, Gerhard Pfister (2013)","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = :(using AbstractAlgebra)","category":"page"},{"location":"AbstractAlgebra/map_interface/#Map-Interface","page":"Map Interface","title":"Map Interface","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Maps in AbstractAlgebra can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"In the following, we will always use the word \"function\" to mean a Julia function, and reserve the word \"map\" for a map on sets, whether mathematically, or as an object in the system.","category":"page"},{"location":"AbstractAlgebra/map_interface/#Parent-objects","page":"Map Interface","title":"Parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Maps in AbstractAlgebra currently don't have parents. This will change later when AbstractAlgebra has a category system, so that the parent of a map can be some sort of Hom set.","category":"page"},{"location":"AbstractAlgebra/map_interface/#Map-classes","page":"Map Interface","title":"Map classes","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"All maps in AbstractAlgebra belong to a class of maps. The classes are modeled as abstract types that lie in a hierarchy, inheriting from SetMap at the top of the hierarchy. Other classes that inherit from SetMap are FunctionalMap for maps that are constructed from a Julia function (or closure), and IdentityMap for the class of the identity maps within the system.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"One might naturally assume that map types belong directly to these classes in the way that types of other objects in the system belong to abstract types in the AbstractAlgebra type hierarchy. However, in order to provide an extensible system, this is not the case.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Instead, a map type MyMap will belong to an abstract type of the form Map{D, C, T, MyMap}, where D is the type of the object representing the domain of the map type (this can also be an abstract type, such as Group), C is the type of the object representing the codomain of the map type and T is the map class that MyMap belongs to, e.g. SetMap or FunctionalMap.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Because a four parameter type system becomes quite cumbersome to use, we provide a number of functions for referring to collections of map types.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"If writing a function that accepts any map type, one makes the type of its argument belong to Map. For example f(M::Map) = 1.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"If writing a function that accepts any map from a domain of type D to a codomain of type C, one makes writes for example f(M::Map{D, C}) = 2. Note that D and C can be abstract types, such as Group, but otherwise must be the types of the parent objects representing the domain and codomain.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"A function that accepts any map belonging to a given map class might be written as f(M::Map(FunctionalMap)) = 3 or f(M::Map(FunctionalMap){D, C}) = 4 for example, where D and C are the types of the parent objects for the domain and codomain.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Finally, if a function should only work for a map of a given map type MyMap, say, one writes this f(M::Map(MyMap)) or f(M::Map(MyMap){D, C}, where as usual D and C are the types of the domain and codomain parent objects.","category":"page"},{"location":"AbstractAlgebra/map_interface/#Implementing-new-map-types","page":"Map Interface","title":"Implementing new map types","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"There are two common kinds of map type that developers will need to write. The first has a fixed domain and codomain, and the second is a type parameterised by the types of the domain and codomain. We give two simple examples here of how this might look.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"In the case of fixed domain and codomain, e.g. Integers{BigInt}, we would write it as follows:","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"mutable struct MyMap <: Map{Integers{BigInt}, Integers{BigInt}, SetMap, MyMap}\n   # some data fields\nend","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"In the case of parameterisation by the type of the domain and codomain:","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"mutable struct MyMap{D, C} <: Map{D, C, SetMap, MyMap}\n   # some data fields\nend","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"As mentioned above, to write a function that only accepts maps of type MyMap, one writes the functions as follows:","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"function my_fun(M::Map(MyMap))","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"The Map function then computes the correct type to use, which is actually not MyMap if all features of the generic Map infrastructure are required. It is bad practice to write functions for MyMap directly instead of Map(MyMap), since other users will be unable to use generic constructions over the map type MyMap.","category":"page"},{"location":"AbstractAlgebra/map_interface/#Getters-and-setters","page":"Map Interface","title":"Getters and setters","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"When writing new map types, it is very important to define getters and setters of the fields of the new map type, rather than to access them directly.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Let us suppose that the MyMap type has a field called foo. Rather than access this field by writing M.foo, one must access it using foo(M) (at least until Julia 1.1).","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"If such a getter only needs to access the field foo of M, there is a standard way of defining such a getter and setter when defining a new map type.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"foo(M::Map(MyMap)) = get_field(M, :foo)","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"To set a field of a map, one needs a setter, which can be implemented as follows:","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"set_foo!(M::Map(MyMap), a) = set_field(M, :foo, a)","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"In general, setters should be used rarely for map types.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"note: Note\nBy providing getter and setter functions, map types need not even contain fields with the given name. For example, for a MyMap map type for maps between integers, one does not wish to explicitly store the domain and codomain in MyMap. Instead, we can define the getter functions domain and codomain to return JuliaZZ for any MyMap object.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"domain(M::Map(MyMap)) = JuliaZZ\ncodomain(M::Map(MyMap)) = JuliaZZ","category":"page"},{"location":"AbstractAlgebra/map_interface/#Required-functionality-for-maps","page":"Map Interface","title":"Required functionality for maps","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"All map types must implement a standard interface, which we specify here.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"We will define this interface for a custom map type MyMap belonging to Map(SetMap), SetMap being the map class that all maps types belong to.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Note that map types do not need to contain any specific fields, but must provide accessor functions (getters and setters) in the manner described above.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"The required accessors for map types of class SetMap are as follows.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"domain(M::Map(MyMap))\ncodomain(M::Map(MyMap))","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Return the domain and codomain parent objects respectively, for the map M. It is only necessary to define these functions if the map type MyMap does not contain fields domain and codomain containing these parent objects.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"It is also necessary to be able to apply a map. This amounts to overloading the call method for objects belonging to Map(MyMap).","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"(M::Map(MyMap)(a))","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Apply the map M to the element a of the domain of M. Note that it is usual to add a type assertion to the return value of this function, asserting that the return value has type elem_type(C) where C is the type of the codomain parent object.","category":"page"},{"location":"AbstractAlgebra/map_interface/#Optional-functionality-for-maps","page":"Map Interface","title":"Optional functionality for maps","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"The Generic module in AbstractAlgebra automatically provides certain functionality for map types, assuming that they satisfy the full interface described above.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"However, certain map types or map classes might like to provide their own implementation of this functionality, overriding the generic functionality.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"We describe this optional functionality here.","category":"page"},{"location":"AbstractAlgebra/map_interface/#Show-method","page":"Map Interface","title":"Show method","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Custom map types may like to provide a custom show method if the default of displaying the domain and codomain of the map is not sufficient.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"show(io::IO, M::Map(MyMap))","category":"page"},{"location":"AbstractAlgebra/map_interface/#Identity-maps","page":"Map Interface","title":"Identity maps","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"There is a concrete map type Generic.IdentityMap{D} for the identity map on a given domain. Here D is the type of the object representing that domain.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Generic.IdentityMap belongs to the supertype Map{D, C, AbstractAlgebra.IdentityMap, IdentityMap}.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Note that the map class is also called IdentityMap. It is an abstract type, whereas Generic.IdentityMap is a concrete type in the Generic module.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"An identity map has the property that when composed with any map whose domain or codomain is compatible, that map will be returned as the composition. Identity maps can therefore serve as a starting point when building up a composition of maps, starting an identity map.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"We do not cached identity maps in the system, so that if more than one is created on the same domain, there will be more than one such map in the system. This underscores the fact that there is in general no way for the system to know if two maps compose to give an identity map, and therefore the only two maps that can be composed to give an identity map are identity maps on the same domain.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"To construct an identity map for a given domain, specified by a parent object R, say, we have the following function.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"identity_map(R::Set)","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Return an identity map on the domain R.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Of course there is nothing stopping a map type or class from implementing its own identity map type, and defining composition of maps of the same kind with such an identity map. In such a case, the class of such an identity map type must belong to IdentityMap so that composition with other map types still works.","category":"page"},{"location":"AbstractAlgebra/map_interface/#Composition-of-maps","page":"Map Interface","title":"Composition of maps","text":"","category":"section"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Any two compatible maps in AbstractAlgebra can be composed and any composition can be applied.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"In order to facilitate this, the Generic module provides a type Generic.CompositeMap{D, C}, which contains two maps map1 and map2, corresponding to the two maps to be applied in a composition, in the order they should be applied.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"To construct a composition map from two existing maps, we have the following function:","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"compose(f::Map{D, U}, g::Map{U, C}) where {D, U, C}","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Compose the two maps f and g, i.e. return the map h such that h(x) = g(f(x)).","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"As a shortcut for this function we have the following operator:","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"*(f::Map{D, U}, g::Map{U, C}) where {D, U, C} = compose(f, g)","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Note the order of composition. If we have maps f  X to Y, g  Y to Z the correct order of the maps in this operator is f*g, so that (f*g)(x) = g(f(x)).","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"This is chosen so that for left R-module morphisms represented by a matrix, the order of matrix multiplication will match the order of composition of the corresponding morphisms.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Of course, a custom map type or class of maps can implement its own composition type and compose function.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"This is the case with the FunctionalMap class for example, which caches the Julia function/closure corresponding to the composition of two functional maps. As this cached function needs to be stored inside the composition, a special type is necessary for the composition of two functional maps.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"By default, compose will check that the two maps are composable, i.e. the codomain of the first map matches the domain of the second map. This is implemented by the following function:","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"check_composable(f::Map{D, U}, g::Map{U, C})","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Raise an exception if the codomain of f doesn't match the domain of g.","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Note that composite maps should keep track of the two maps they were constructed from. To access these maps, the following functions are provided:","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"map1(f::CompositeMap)\nmap2(f::CompositeMap)","category":"page"},{"location":"AbstractAlgebra/map_interface/","page":"Map Interface","title":"Map Interface","text":"Any custom composite map type must also provide these functions for that map type, even if there exist fields with those names. This is because there is no common map class for all composite map types. Therefore the Generic system cannot provide fallbacks for all such composite map types.","category":"page"},{"location":"AbstractAlgebra/matrix_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"AbstractAlgebra/matrix_introduction/","page":"Introduction","title":"Introduction","text":"AbstractAlgebra provides matrix spaces (mxn matrices) and matrix algebras (nxn matrices) over a commutative ring. Whilst both types of matrix provide matrix multiplication for matrices whose dimensions are compatible for multiplication, only the latter kind of matrices form rings in the system.","category":"page"},{"location":"AbstractAlgebra/matrix_introduction/","page":"Introduction","title":"Introduction","text":"Matrix spaces provide a large number of linear algebra operations, including linear solving, elementary row operations, various canonical forms. The system also provides characteristic and minimal polynomial computations, LU decomposition, determinant, matrix inverse, kernel computations.","category":"page"},{"location":"AbstractAlgebra/matrix_introduction/","page":"Introduction","title":"Introduction","text":"There is also code for computation of the Hermite and Smith normal forms over Euclidean domains and Popov form for matrices over polynomial rings over a field.","category":"page"},{"location":"AbstractAlgebra/matrix_introduction/","page":"Introduction","title":"Introduction","text":"Most of this generic functionality is provided for arbitrary matrix types that satisfy the AbstractAlgebra matrix interface.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/#Noncommutative-ring-Interface","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"","category":"section"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"AbstractAlgebra.jl supports commutative rings through its Ring interface. In this section we describe the corresponding interface for noncommutative rings. The two interfaces are very similar in terms of required functionality, and so we mainly document the differences here.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Noncommutative rings can be supported through the abstract types NCRing and NCRingElem. Note that we have Ring <: NCRing, etc., so the interface here should more correctly be called the Not-necessarily-Commutative-ring interface.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"However, the fact remains that if one wishes to implement a noncommutative ring, one should make its type belong to NCRing but not to Ring. Therefore it is not too much of a mistake to think of the NCRing interface as being for noncommutative rings.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/#Types","page":"Noncommutative ring Interface","title":"Types","text":"","category":"section"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"As for the Ring interface, most noncommutative rings must supply two types:","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"a type for the parent object (representing the ring itself)\na type for elements of that ring","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"The parent type must belong to NCRing and the element type must belong to NCRingElem. Of course, the types may belong to these abstract types transitively via an intermediate abstract type.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Also as for the Ring interface, it is advised to make the types of generic parameterised rings that belong to NCRing and NCRingElem depend on the type of the elements of that parameter ring.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/#NCRingElement-type-union","page":"Noncommutative ring Interface","title":"NCRingElement type union","text":"","category":"section"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"As for the Ring interface, the NCRing interface provides a union type NCRingElement in src/julia/JuliaTypes.jl which is a union of NCRingElem and the Julia types Integer, Rational and AbstractFloat.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Most of the generic code in AbstractAlgebra for general rings makes use of the union type NCRingElement instead of NCRingElem so that the generic functions also accept the Julia Base ring types.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"As per usual, one may need to implement one ad hoc binary operation for each concrete type belonging to NCRingElement to avoid ambiguity warnings.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/#Parent-object-caches","page":"Noncommutative ring Interface","title":"Parent object caches","text":"","category":"section"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Parent object caches for the NCRing interface operate as per the Ring interface.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/#Required-functions-for-all-rings","page":"Noncommutative ring Interface","title":"Required functions for all rings","text":"","category":"section"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Generic functions may only rely on required functionality for the NCRing interface, which must be implemented by all noncommutative rings.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"Most of this required functionality is the same as for the Ring interface, so we refer the reader there for details, with the following modifications.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"We give this interface for fictitious types MyParent for the type of the ring parent object R and MyElem for the type of the elements of the ring.","category":"page"},{"location":"AbstractAlgebra/ncring_interface/#Exact-division","page":"Noncommutative ring Interface","title":"Exact division","text":"","category":"section"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"divexact_left(f::MyElem, g::MyElem)\ndivexact_right(f::MyElem, g::MyElem)","category":"page"},{"location":"AbstractAlgebra/ncring_interface/","page":"Noncommutative ring Interface","title":"Noncommutative ring Interface","text":"If f = ga for some a in the ring, the function divexact_left(f, g) returns a. If f = ag then divexact_right(f, g) returns a. A DivideError() should be thrown if division is by zero. If no exact quotient exists or an impossible inverse is unavoidably encountered, an error should be thrown.","category":"page"},{"location":"Nemo/about/#About-Nemo","page":"About Nemo","title":"About Nemo","text":"","category":"section"},{"location":"Nemo/about/","page":"About Nemo","title":"About Nemo","text":"Nemo is a library for fast basic arithmetic in various commonly used rings, for the Julia programming language. Our aim is to provide a highly performant package covering","category":"page"},{"location":"Nemo/about/","page":"About Nemo","title":"About Nemo","text":"Commutative Algebra\nNumber Theory\nGroup Theory","category":"page"},{"location":"Nemo/about/","page":"About Nemo","title":"About Nemo","text":"Nemo consists of wrappers of specialised C/C++ libraries:","category":"page"},{"location":"Nemo/about/","page":"About Nemo","title":"About Nemo","text":"Flint    http://flintlib.org/\nArb      https://arblib.org/\nAntic    https://github.com/wbhart/antic/\nCalcium  https://fredrikj.net/calcium/","category":"page"},{"location":"Nemo/about/","page":"About Nemo","title":"About Nemo","text":"Nemo also uses AbstractAlgebra.jl to provide generic constructions over the basic rings provided by the above packages.","category":"page"},{"location":"Nemo/about/#Why-Julia?","page":"About Nemo","title":"Why Julia?","text":"","category":"section"},{"location":"Nemo/about/","page":"About Nemo","title":"About Nemo","text":"Julia is a sophisticated, modern programming language which is designed to be both performant and flexible. It was written by mathematicians, for mathematicians.","category":"page"},{"location":"Nemo/about/","page":"About Nemo","title":"About Nemo","text":"The benefits of Julia include","category":"page"},{"location":"Nemo/about/","page":"About Nemo","title":"About Nemo","text":"Familiar imperative syntax\nJIT compilation (provides near native performance, even for highly generic code)\nREPL console (cuts down on development time)\nParametric types (allows for fast generic constructions over other data types)\nPowerful metaprogramming facilities\nOperator overloading\nMultiple dispatch (dispatch on every argument of a function)\nEfficient native C interface (little or no wrapper overhead)\nExperimental C++ interface\nDynamic type inference\nBuilt-in bignums\nAble to be embedded in C programs\nHigh performance collection types (dictionaries, iterators, arrays, etc.)\nJupyter support (for web based notebooks)","category":"page"},{"location":"Nemo/about/","page":"About Nemo","title":"About Nemo","text":"The main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to model many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter speeds up the runtime performance, even of highly generic mathematical procedures.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/complex/#Exact-real-and-complex-numbers","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"","category":"section"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Exact real and complex numbers are provided by Calcium. Internally, a number z is represented as an element of an extension field of the rational numbers. That is,","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"z in mathbbQ(a_1ldotsa_n)","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"where a_1 ldots a_n are symbolically defined algebraic or transcendental real or complex numbers such as pi, sqrt2 or e^sqrt2 pi i. The user does not normally need to worry about the details of the internal representation; Calcium constructs extension numbers and fields automatically as needed to perform operations.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The user must create a CalciumField instance which represents the mathematical domain mathbbC. This parent object holds a cache of extension numbers and fields used to represent individual elements. It also stores various options for evaluation (documented further below).","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Library Element type Parent type\nCalcium ca CalciumField","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Please note the following:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"It is in the nature of exact complex arithmetic that some operations must be implemented using incomplete heuristics. For example, testing whether an element is zero will not always succeed. When Calcium is unable to perform a task, Nemo will throw an exception. This ensures that Calcium fields behave exactly and never silently return wrong results.\nCalcium elements can optionally hold special non-numerical values:\nUnsigned infinity hat infty\nSigned infinities (pm infty, pm i infty, and more generally e^i theta cdot infty)\nUndefined\nUnknown\nBy default, such special values are disallowed so that a CalciumField represents the mathematical field mathbbC, and any operation that would result in a special value (for example, 1  0 = hat infty) will throw an exception. To allow special values, pass extended=true to the CalciumField constructor.\nCalciumField instances only support single-threaded use. You must create a separate parent object for each thread to do parallel computation.\nWhen performing an operation involving two ca operands with different parent objects, Nemo will arbitrarily coerce the operands (and hence the result) to one of the parents.","category":"page"},{"location":"Nemo/complex/#Calcium-field-options","page":"Exact real and complex numbers","title":"Calcium field options","text":"","category":"section"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The CalciumField parent stores various options that affect simplification power, performance, or appearance. The user can override any of the default values using C = CalciumField(options=dict) where dict is a dictionary with Symbol => Int pairs. To retrieve the option values as a dictionary (including any default values not set by the user), call options(C).","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The following options are supported:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Option Explanation\n:verbose Enable debug output\n:print_flags Flags controlling print style\n:mpoly_ord Monomial order for polynomials\n:prec_limit Precision limit for numerical evaluation\n:qqbar_deg_limit Degree limit for algebraic numbers\n:low_prec Initial precision for numerical evaluation\n:smooth_limit Factor size limit for smooth integer factorization\n:lll_prec Precision for integer relation detection\n:pow_limit Maximum exponent for in-field powering\n:use_gb Enable Gröbner basis computation\n:gb_length_limit Maximum ideal basis length during Gröbner basis computation\n:gb_poly_length_limit Maximum polynomial length during Gröbner basis computation\n:gb_poly_bits_limit Maximum bit size during Gröbner basis computation\n:gb_vieta_limit Maximum degree to use Vieta's formulas\n:trig_form Default form of trigonometric functions","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"An important function of these options is to control how hard Calcium will try to find an answer before it gives up. For example:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Setting :prec_limit => 65536 will allow Calcium to use up to 65536 bits of precision (instead of the default 4096) to prove inequalities.\nSetting :qqbar_deg_limit => typemax(Int) (instead of the default 120) will force most calculations involving algebraic numbers to run to completion, no matter how long this will take.\nSetting :use_gb => 0 (instead of the default 1) disables use of Gröbner bases. In general, this will negatively impact Calcium's ability to simplify field elements and prove equalities, but it can speed up calculations where Gröbner bases are unnecessary.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"For a detailed explanation, refer to the following section in the Calcium documentation: https://fredrikj.net/calcium/ca.html#context-options","category":"page"},{"location":"Nemo/complex/#Basic-examples","page":"Exact real and complex numbers","title":"Basic examples","text":"","category":"section"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> C = CalciumField()\nExact Complex Field\n\njulia> exp(C(pi) * C(1im)) + 1\n0\n\njulia> log(C(-1))\n3.14159*I {a*b where a = 3.14159 [Pi], b = I [b^2+1=0]}\n\njulia> log(C(-1)) ^ 2\n-9.86960 {-a^2 where a = 3.14159 [Pi], b = I [b^2+1=0]}\n\njulia> log(C(10)^23) // log(C(100))\n11.5000 {23/2}\n\njulia> 4*atan(C(1)//5) - atan(C(1)//239) == C(pi)//4\ntrue\n\njulia> Cx, x = PolynomialRing(C, \"x\")\n(Univariate Polynomial Ring in x over Exact Complex Field, x)\n\njulia> (a, b) = (sqrt(C(2)), sqrt(C(3)))\n(1.41421 {a where a = 1.41421 [a^2-2=0]}, 1.73205 {a where a = 1.73205 [a^2-3=0]})\n\njulia> (x-a-b)*(x-a+b)*(x+a-b)*(x+a+b)\nx^4 + (-10)*x^2 + 1","category":"page"},{"location":"Nemo/complex/#Conversions-and-numerical-evaluation","page":"Exact real and complex numbers","title":"Conversions and numerical evaluation","text":"","category":"section"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Calcium numbers can created from integers (ZZ), rationals (QQ) and algebraic numbers (QQbar), and through the application of arithmetic operations and transcendental functions.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Calcium numbers can be converted to integers, rational and algebraic fields provided that the values are integer, rational or algebraic. An exception is thrown if the value does not belong to the target domain, if Calcium is unable to prove that the value belongs to the target domain, or if Calcium is unable to compute the explicit value because of evaluation limits.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> QQ(C(1))\n1\n\njulia> QQBar(sqrt(C(2)) // 2)\nRoot 0.707107 of 2x^2 - 1\n\njulia> QQ(C(pi))\nERROR: unable to convert to a rational number\n\njulia> QQ(C(10) ^ C(10^9))\nERROR: unable to convert to a rational number","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"To compute arbitrary-precision numerical enclosures, convert to ArbField or AcbField:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> CC = AcbField(64);\n\njulia> CC(exp(C(1im)))\n[0.54030230586813971740 +/- 9.37e-22] + [0.84147098480789650665 +/- 2.51e-21]*im","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The constructor","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"(R::AcbField)(a::ca; parts::Bool=false)","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"returns an enclosure of the complex number a. It attempts to obtain a relative accuracy of prec bits where prec is the precision of the target field, but it is not guaranteed that this goal is achieved.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"If parts is set to true, it attempts to achieve the target accuracy for both real and imaginary parts. This can be significantly more expensive if one part is smaller than the other, or if the number is nontrivially purely real or purely imaginary (in which case an exact proof attempt is made).","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> x = sin(C(1), form=:exponential)\n0.841471 + 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}\n\njulia> AcbField(64)(x)\n[0.84147098480789650665 +/- 2.51e-21] + [+/- 4.77e-29]*im\n\njulia> AcbField(64)(x, parts=true)\n[0.84147098480789650665 +/- 2.51e-21]","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The constructor","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"(R::ArbField)(a::ca; check::Bool=true)","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"returns a real enclosure. If check is set to true (default), the number a is verified to be real, and an exception is thrown if this cannot be determined. With check set to false, this function returns an enclosure of the real part of a without checking that the imaginary part is zero. This can be significantly faster.","category":"page"},{"location":"Nemo/complex/#Comparisons-and-properties","page":"Exact real and complex numbers","title":"Comparisons and properties","text":"","category":"section"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Except where otherwise noted, predicate functions such as iszero, ==, < and isreal act on the mathematical values of Calcium field elements. For example, although evaluating x = sqrt2 sqrt3 and y = sqrt6 results in different internal representations (x in mathbbQ(sqrt3 sqrt2) and y in mathbbQ(sqrt6)), the numbers compare as equal:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> x = sqrt(C(2)) * sqrt(C(3))\n2.44949 {a*b where a = 1.73205 [a^2-3=0], b = 1.41421 [b^2-2=0]}\n\njulia> y = sqrt(C(6))\n2.44949 {a where a = 2.44949 [a^2-6=0]}\n\njulia> x == y\ntrue\n\njulia> iszero(x - y)\ntrue\n\njulia> isinteger(x - y)\ntrue","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Predicate functions return true if the property is provably true and false if the property if provably false. If Calcium is unable to prove the truth value, an exception is thrown. For example, with default settings, Calcium is currently able to prove that e^e^-1000 ne 1, but it fails to prove e^e^-3000 ne 1:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> x = exp(exp(C(-1000)))\n1.00000 {a where a = 1.00000 [Exp(5.07596e-435 {b})], b = 5.07596e-435 [Exp(-1000)]}\n\njulia> x == 1\nfalse\n\njulia> x = exp(exp(C(-3000)))\n1.00000 {a where a = 1.00000 [Exp(1.30784e-1303 {b})], b = 1.30784e-1303 [Exp(-3000)]}\n\njulia> x == 1\nERROR: Unable to perform operation (failed deciding truth of a predicate): isequal\n...","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"In this case, we can get an answer by allowing a higher working precision:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> C2 = CalciumField(options=Dict(:prec_limit => 10^5));\n\njulia> exp(exp(C2(-3000))) == 1\nfalse","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Real numbers can be ordered and sorted the usual way. We illustrate finding square roots that are well-approximated by integers:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> sort([sqrt(C(n)) for n=0:10], by=x -> abs(x - floor(x + C(1)//2)))\n11-element Vector{ca}:\n 0\n 1\n 2\n 3\n 3.16228 {a where a = 3.16228 [a^2-10=0]}\n 2.82843 {2*a where a = 1.41421 [a^2-2=0]}\n 2.23607 {a where a = 2.23607 [a^2-5=0]}\n 1.73205 {a where a = 1.73205 [a^2-3=0]}\n 2.64575 {a where a = 2.64575 [a^2-7=0]}\n 1.41421 {a where a = 1.41421 [a^2-2=0]}\n 2.44949 {a where a = 2.44949 [a^2-6=0]}","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"As currently implemented, order comparisons involving nonreal numbers yield false (in both directions) rather than throwing an exception:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> C(1im) < C(1im)\nfalse\n\njulia> C(1im) > C(1im)\nfalse","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"This behavior may be changed or may become configurable in the future.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Interface","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"iszero(a::ca)\nisone(a::ca)\nisalgebraic(a::ca)\nisrational(a::ca)\nisinteger(a::ca)\nisreal(a::ca)\nisimaginary(a::ca)","category":"page"},{"location":"Nemo/complex/#iszero-Tuple{ca}","page":"Exact real and complex numbers","title":"iszero","text":"iszero(a::ca)\n\nReturn whether a is the number 0.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isone-Tuple{ca}","page":"Exact real and complex numbers","title":"isone","text":"isone(a::ca)\n\nReturn whether a is the number 1.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isalgebraic-Tuple{ca}","page":"Exact real and complex numbers","title":"isalgebraic","text":"isalgebraic(a::ca)\n\nReturn whether a is an algebraic number.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isrational-Tuple{ca}","page":"Exact real and complex numbers","title":"isrational","text":"isrational(a::ca)\n\nReturn whether a is a rational number.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isinteger-Tuple{ca}","page":"Exact real and complex numbers","title":"isinteger","text":"isinteger(a::ca)\n\nReturn whether a is an integer.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isreal-Tuple{ca}","page":"Exact real and complex numbers","title":"isreal","text":"isreal(a::ca)\n\nReturn whether a is a real number. This returns false if a is a pure real infinity.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isimaginary-Tuple{ca}","page":"Exact real and complex numbers","title":"isimaginary","text":"isimaginary(a::ca)\n\nReturn whether a is an imaginary number. This returns false if a is a pure imaginary infinity.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#Infinities-and-special-values","page":"Exact real and complex numbers","title":"Infinities and special values","text":"","category":"section"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"By default, CalciumField does not permit creating values that are not numbers, and any non-number value (unsigned infinity, signed infinity, Undefined) will result in an exception. This also applies to the special value Unknown, used in situations where Calcium is unable to prove that a value is a number. To enable special values, use extended=true.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> C = CalciumField()\nExact Complex Field\n\njulia> 1 // C(0)\nERROR: DomainError with UnsignedInfinity:\nNon-number result\n...\n\njulia> Cext = CalciumField(extended=true)\nExact Complex Field (Extended)\n\njulia> 1 // Cext(0)\nUnsignedInfinity","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Note that special values do not satisfy the properties of a mathematical ring or field. You will likely get meaningless results if you put infinities in matrices or polynomials.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"unsigned_infinity(C::CalciumField)\ninfinity(C::CalciumField)\ninfinity(a::ca)\nundefined(C::CalciumField)\nunknown(C::CalciumField)\nisnumber(a::ca)\nisundefined(a::ca)\nisinf(a::ca)\nisuinf(a::ca)\nissigned_inf(a::ca)\nisunknown(a::ca)","category":"page"},{"location":"Nemo/complex/#unsigned_infinity-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"unsigned_infinity","text":"unsigned_infinity(C::CalciumField)\n\nReturn unsigned infinity (hat infty) as an element of C. This throws an exception if C does not allow special values.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#infinity-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"infinity","text":"infinity(C::CalciumField)\n\nReturn positive infinity (+infty) as an element of C. This throws an exception if C does not allow special values.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#infinity-Tuple{ca}","page":"Exact real and complex numbers","title":"infinity","text":"infinity(a::ca)\n\nReturn the signed infinity (a cdot infty). This throws an exception if the parent of a does not allow special values.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#undefined-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"undefined","text":"undefined(C::CalciumField)\n\nReturn the special value Undefined as an element of C. This throws an exception if C does not allow special values.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#unknown-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"unknown","text":"unknown(C::CalciumField)\n\nReturn the special meta-value Unknown as an element of C. This throws an exception if C does not allow special values.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isnumber-Tuple{ca}","page":"Exact real and complex numbers","title":"isnumber","text":"isnumber(a::ca)\n\nReturn whether a is a number, i.e. not an infinity or undefined.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isundefined-Tuple{ca}","page":"Exact real and complex numbers","title":"isundefined","text":"isundefined(a::ca)\n\nReturn whether a is the special value Undefined.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isinf-Tuple{ca}","page":"Exact real and complex numbers","title":"isinf","text":"isinf(a::ca)\n\nReturn whether a is any infinity (signed or unsigned).\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isuinf-Tuple{ca}","page":"Exact real and complex numbers","title":"isuinf","text":"isuinf(a::ca)\n\nReturn whether a is unsigned infinity.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#issigned_inf-Tuple{ca}","page":"Exact real and complex numbers","title":"issigned_inf","text":"issigned_inf(a::ca)\n\nReturn whether a is any signed infinity.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#isunknown-Tuple{ca}","page":"Exact real and complex numbers","title":"isunknown","text":"isunknown(a::ca)\n\nReturn whether a is the special value Unknown. This is a representation property and not a mathematical predicate.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#Complex-parts","page":"Exact real and complex numbers","title":"Complex parts","text":"","category":"section"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Functions for computing components of real and complex numbers will perform automatic symbolic simplifications in special cases. In general, such operations will introduce new extension numbers.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> real(C(2+3im))\n2\n\njulia> sign(C(2im))\n1.00000*I {a where a = I [a^2+1=0]}\n\njulia> sign(C(2+3im))\n0.554700 + 0.832050*I {a where a = 0.554700 + 0.832050*I [13*a^4+10*a^2+13=0]}\n\njulia> angle(C(2+2im))\n0.785398 {(a)/4 where a = 3.14159 [Pi]}\n\njulia> angle(C(2+3im))\n0.982794 {a where a = 0.982794 [Arg(2.00000 + 3.00000*I {3*b+2})], b = I [b^2+1=0]}\n\njulia> angle(C(2+3im)) == atan(C(3)//2)\ntrue\n\njulia> floor(C(pi) ^ 100)\n5.18785e+49 {51878483143196131920862615246303013562686760680405}\n\njulia> ZZ(floor(C(pi) ^ 100))\n51878483143196131920862615246303013562686760680405","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Interface","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"real(a::ca)\nimag(a::ca)\nangle(a::ca)\ncsgn(a::ca)\nsign(a::ca)\nabs(a::ca)\nconj(a::ca; form::Symbol=:default)\nfloor(a::ca)\nceil(a::ca)","category":"page"},{"location":"Nemo/complex/#real-Tuple{ca}","page":"Exact real and complex numbers","title":"real","text":"real(a::ca)\n\nReturn the real part of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#imag-Tuple{ca}","page":"Exact real and complex numbers","title":"imag","text":"imag(a::ca)\n\nReturn the imaginary part of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#angle-Tuple{ca}","page":"Exact real and complex numbers","title":"angle","text":"angle(a::ca)\n\nReturn the complex argument of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#csgn-Tuple{ca}","page":"Exact real and complex numbers","title":"csgn","text":"csgn(a::ca)\n\nReturn the extension of the real sign function taking the value 1 strictly in the right half plane, -1 strictly in the left half plane, and the sign of the imaginary part when on the imaginary axis. Equivalently, operatornamecsgn(x) = x  sqrtx^2 except that the value is 0 at zero.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#sign-Tuple{ca}","page":"Exact real and complex numbers","title":"sign","text":"sign(a::ca)\n\nReturn the complex sign of a, defined as zero if a is zero and as a  a for any other complex number. This function also extracts the sign when a is a signed infinity.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#abs-Tuple{ca}","page":"Exact real and complex numbers","title":"abs","text":"abs(a::ca)\n\nReturn the absolute value of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#conj-Tuple{ca}","page":"Exact real and complex numbers","title":"conj","text":"conj(a::ca; form::Symbol=:default)\n\nReturn the complex conjugate of a. The optional form argument allows specifying the representation. In :shallow form, overlinea is introduced as a new extension number if it no straightforward simplifications are possible. In :deep form, complex conjugation is performed recursively.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#floor-Tuple{ca}","page":"Exact real and complex numbers","title":"floor","text":"floor(a::ca)\n\nReturn the floor function of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#ceil-Tuple{ca}","page":"Exact real and complex numbers","title":"ceil","text":"ceil(a::ca)\n\nReturn the ceiling function of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#Elementary-and-special-functions","page":"Exact real and complex numbers","title":"Elementary and special functions","text":"","category":"section"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Elementary and special functions generally create new extension numbers. In special cases, simplifications occur automatically.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> exp(C(1))\n2.71828 {a where a = 2.71828 [Exp(1)]}\n\njulia> exp(C(0))\n1\n\njulia> atan(C(1))\n0.785398 {(a)/4 where a = 3.14159 [Pi]}\n\njulia> cos(C(1))^2 + sin(C(1))^2\n1\n\njulia> log(1 // exp(sqrt(C(2))+1)) == -sqrt(C(2)) - 1\ntrue\n\njulia> gamma(C(2+3im))\n-0.0823953 + 0.0917743*I {a where a = -0.0823953 + 0.0917743*I [Gamma(2.00000 + 3.00000*I {3*b+2})], b = I [b^2+1=0]}\n\njulia> gamma(C(5) // 2)\n1.32934 {(3*a)/4 where a = 1.77245 [Sqrt(3.14159 {b})], b = 3.14159 [Pi]}\n\njulia> erf(C(1))\n0.842701 {a where a = 0.842701 [Erf(1)]}\n\njulia> erf(C(1)) + erfc(C(1))\n1","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Some functions allow representing the result in different forms:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> s1 = sin(C(1))\n0.841471 - 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}\n\njulia> s2 = sin(C(1), form=:direct)\n0.841471 {a where a = 0.841471 [Sin(1)]}\n\njulia> s3 = sin(C(1), form=:exponential)\n0.841471 - 0e-24*I {(-a^2*b+b)/(2*a) where a = 0.540302 + 0.841471*I [Exp(1.00000*I {b})], b = I [b^2+1=0]}\n\njulia> s4 = sin(C(1), form=:tangent)\n0.841471 {(2*a)/(a^2+1) where a = 0.546302 [Tan(0.500000 {1/2})]}\n\njulia> s1 == s2 == s3 == s4\ntrue\n\njulia> isreal(s1) && isreal(s2) && isreal(s3) && isreal(s4)\ntrue","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"The exponential form is currently used by default since it tends to be the most useful for symbolic simplification. The :direct and :tangent forms are likely to be better for numerical evaluation. The default behavior of trigonometric functions can be changed using the :trig_form option of CalciumField.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Proving equalities involving transcendental function values is a difficult problem in general. Calcium will sometimes fail even in elementary cases. Here is an example of two constant trigonometric identities where the first succeeds and the second fails:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> a = sqrt(C(2)) + 1;\n\njulia> cos(a) + cos(2*a) + cos(3*a) == sin(7*a//2)//(2*sin(a//2)) - C(1)//2\ntrue\n\njulia> sin(3*a) == 4 * sin(a) * sin(C(pi)//3 - a) * sin(C(pi)//3 + a)\nERROR: Unable to perform operation (failed deciding truth of a predicate): isequal","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"A possible workaround is to fall back on a numerical comparison:","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"julia> abs(cos(a) + cos(2*a) + cos(3*a) - (sin(7*a//2)//(2*sin(a//2)) - C(1)//2)) <= C(10)^-100\ntrue","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Of course, this is not a rigorous proof that the numbers are equal, and CalciumField is overkill here; it would be far more efficient to use ArbField directly to check that the numbers are approximately equal.","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"Interface","category":"page"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"const_pi(C::CalciumField)\nconst_euler(C::CalciumField)\nonei(C::CalciumField)\nsqrt(a::ca)\nexp(a::ca)\nlog(a::ca)\npow(a::ca, b::Int; form::Symbol=:default)\nsin(a::ca; form::Symbol=:default)\ncos(a::ca; form::Symbol=:default)\ntan(a::ca; form::Symbol=:default)\natan(a::ca; form::Symbol=:default)\nasin(a::ca; form::Symbol=:default)\nacos(a::ca; form::Symbol=:default)\ngamma(a::ca)\nerf(a::ca)\nerfi(a::ca)\nerfc(a::ca)","category":"page"},{"location":"Nemo/complex/#const_pi-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"const_pi","text":"const_pi(C::CalciumField)\n\nReturn the constant pi as an element of C.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#const_euler-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"const_euler","text":"const_euler(C::CalciumField)\n\nReturn Euler's constant gamma as an element of C.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#onei-Tuple{CalciumField}","page":"Exact real and complex numbers","title":"onei","text":"onei(C::CalciumField)\n\nReturn the imaginary unit i as an element of C.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#sqrt-Tuple{ca}","page":"Exact real and complex numbers","title":"sqrt","text":"Base.sqrt(a::ca; check::Bool=true)\n\nReturn the principal square root of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#exp-Tuple{ca}","page":"Exact real and complex numbers","title":"exp","text":"exp(a::ca)\n\nReturn the exponential function of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#log-Tuple{ca}","page":"Exact real and complex numbers","title":"log","text":"log(a::ca)\n\nReturn the natural logarithm of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#pow-Tuple{ca, Int64}","page":"Exact real and complex numbers","title":"pow","text":"pow(a::ca, b::Int; form::Symbol=:default)\n\nReturn a raised to the integer power b. The optional form argument allows specifying the representation. In :default form, this is equivalent to a ^ b, which may create a new extension number a^b if the exponent b is too large (as determined by the parent option :pow_limit or :prec_limit depending on the case). In :arithmetic form, the exponentiation is performed arithmetically in the field of a, regardless of the size of the exponent b.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#sin-Tuple{ca}","page":"Exact real and complex numbers","title":"sin","text":"sin(a::ca; form::Symbol=:default)\n\nReturn the sine of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :exponential form, the value is represented using complex exponentials. In :tangent form, the value is represented using tangents. In :direct form, the value is represented directly using a sine or cosine.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#cos-Tuple{ca}","page":"Exact real and complex numbers","title":"cos","text":"cos(a::ca; form::Symbol=:default)\n\nReturn the cosine of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :exponential form, the value is represented using complex exponentials. In :tangent form, the value is represented using tangents. In :direct form, the value is represented directly using a sine or cosine.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#tan-Tuple{ca}","page":"Exact real and complex numbers","title":"tan","text":"tan(a::ca; form::Symbol=:default)\n\nReturn the tangent of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :exponential form, the value is represented using complex exponentials. In :direct or :tangent form, the value is represented directly using tangents. In :sine_cosine form, the value is represented using sines or cosines.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#atan-Tuple{ca}","page":"Exact real and complex numbers","title":"atan","text":"atan(a::ca; form::Symbol=:default)\n\nReturn the inverse tangent of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :logarithm form, the value is represented using complex logarithms. In :direct or :arctangent form, the value is represented directly using arctangents.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#asin-Tuple{ca}","page":"Exact real and complex numbers","title":"asin","text":"asin(a::ca; form::Symbol=:default)\n\nReturn the inverse sine of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :logarithm form, the value is represented using complex logarithms. In :direct form, the value is represented directly using an inverse sine or cosine.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#acos-Tuple{ca}","page":"Exact real and complex numbers","title":"acos","text":"acos(a::ca; form::Symbol=:default)\n\nReturn the inverse cosine of a. The optional form argument allows specifying the representation. In :default form, the result is determined by the :trig_form option of the parent object. In :logarithm form, the value is represented using complex logarithms. In :direct form, the value is represented directly using an inverse sine or cosine.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#gamma-Tuple{ca}","page":"Exact real and complex numbers","title":"gamma","text":"gamma(a::ca)\n\nReturn the gamma function of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#erf-Tuple{ca}","page":"Exact real and complex numbers","title":"erf","text":"erf(a::ca)\n\nReturn the error function of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#erfi-Tuple{ca}","page":"Exact real and complex numbers","title":"erfi","text":"erfi(a::ca)\n\nReturn the imaginary error function of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#erfc-Tuple{ca}","page":"Exact real and complex numbers","title":"erfc","text":"erfc(a::ca)\n\nReturn the complementary error function of a.\n\n\n\n","category":"method"},{"location":"Nemo/complex/#Rewriting-and-simplification","page":"Exact real and complex numbers","title":"Rewriting and simplification","text":"","category":"section"},{"location":"Nemo/complex/","page":"Exact real and complex numbers","title":"Exact real and complex numbers","text":"complex_normal_form(a::ca; deep::Bool=true)","category":"page"},{"location":"Nemo/complex/#complex_normal_form-Tuple{ca}","page":"Exact real and complex numbers","title":"complex_normal_form","text":"complex_normal_form(a::ca, deep::Bool=true)\n\nReturns the input rewritten using standardizing transformations over the complex numbers:\n\nElementary functions are rewritten in terms of exponentials, roots and logarithms.\nComplex parts are rewritten using logarithms, square roots, and (deep) complex conjugates.\nAlgebraic numbers are rewritten in terms of cyclotomic fields where applicable.\n\nIf deep is set, the rewriting is applied recursively to the tower of extension numbers; otherwise, the rewriting is only applied to the top-level extension numbers.\n\nThe result is not a normal form in the strong sense (the same number can have many possible representations even after applying this transformation), but this transformation can nevertheless be a useful heuristic for simplification.\n\n\n\n","category":"method"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"Rings/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"The rings part of OSCAR provides functionality for handling various kinds of rings: ","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"the ring of integers\npolynomial rings (univariate and multivariate, see Generic univariate polynomial types and Generic sparse distributed multivariable polynomial types),\norders in number fields\nseries rings","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"Rings/intro/","page":"Introduction","title":"Introduction","text":"...","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"PolyhedralGeometry/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"The polyhedral geometry part of OSCAR provides functionality for handling","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"convex polytopes, unbounded polyhedra and cones\npolyhedral fans\nlinear programs","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Michael Joswig, Thorsten Theobald (2013)\nGünter M. Ziegler (1995)","category":"page"},{"location":"PolyhedralGeometry/intro/#Serialization","page":"Introduction","title":"Serialization","text":"","category":"section"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"Most objects from the polyhedral geometry section can be saved through the polymake interface in the background. These functions are documented in the subsections on the different objects. The format of the files is JSON and you can find details of the specification here.","category":"page"},{"location":"PolyhedralGeometry/intro/","page":"Introduction","title":"Introduction","text":"More details on the serialization, albeit concerning the older XML format, can be found in Ewgenij Gawrilow, Simon Hampe, Michael Joswig (2016). Even though the underlying format changed to JSON, the abstract mathematical structure of the data files is still the same.","category":"page"},{"location":"#Welcome-to-Oscar","page":"Welcome to Oscar","title":"Welcome to Oscar","text":"","category":"section"},{"location":"","page":"Welcome to Oscar","title":"Welcome to Oscar","text":"Oscar is a new computer algebra system. Oscar features functions for groups, rings, and fields as well as linear and commutative algebra, number theory, algebraic and polyhedral geometry, and more. It is built upon several well established systems for mathematical research joined via the Julia programming language. Have a look at our Architecture page for a detailed overview and at our installation instructions for installing Oscar.","category":"page"},{"location":"","page":"Welcome to Oscar","title":"Welcome to Oscar","text":"If you have questions about Oscar, please have a look at our Frequently Asked Questions and feel free to contact us under the channels mentioned on our community page. Our main communication channels are Slack and Github.","category":"page"},{"location":"","page":"Welcome to Oscar","title":"Welcome to Oscar","text":"If you are a new developer or interested in developing Oscar, have a look at our Introduction for new developers.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"Pages = [\"subdivision_of_points.md\"]","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#Subdivisions-of-Points","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"","category":"section"},{"location":"PolyhedralGeometry/subdivisions_of_points/#Introduction","page":"Subdivisions of Points","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers and other fields are not yet supported everywhere in the implementation.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"A subdivision of points consists of","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"a finite set mathcalPsubseteqmathbbF^n of points; and\na finite set of cells mathcalSsubseteq 2^mathcalP.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"The cells are only allowed to intersect in common faces. In contrast to the maximal cones of a polyhedral fan or the maximal polytopes of a polyhedral complex, cells are allowed to have interior points here, i.e. they are not given in terms of their vertices.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#Construction","page":"Subdivisions of Points","title":"Construction","text":"","category":"section"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"There are two ways to construct a subdivision of points. First, one can specify the cells directly. Second, one can assign a weight or height to every point, take the convex hull and take the cells corresponding to facets visible from below (\"lower envelope\"). Not every subdivision of points comes from a weight vector, but if it does, it is called regular.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"SubdivisionOfPoints(Points::Union{Oscar.MatElem,AbstractMatrix}, Incidence::IncidenceMatrix)\nSubdivisionOfPoints(Points::Union{Oscar.MatElem,AbstractMatrix}, Weights::AbstractVector)","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#SubdivisionOfPoints-Tuple{Union{MatElem, AbstractMatrix{T} where T}, IncidenceMatrix}","page":"Subdivisions of Points","title":"SubdivisionOfPoints","text":"SubdivisionOfPoints(points::Union{Oscar.MatElem,AbstractMatrix}, cells::IncidenceMatrix)\n\nArguments\n\npoints::Matrix: Points generating the cells of the subdivision; encoded row-wise as representative vectors.\ncells::IncidenceMatrix: An incidence matrix; there is a 1 at position (i,j) if cell i contains point j, and 0 otherwise.\n\nA subdivision of points formed from points and cells made of these points. The cells are given as an IncidenceMatrix, where the columns represent the points and the rows represent the cells.\n\nExamples\n\nThe following is the famous \"mother of all examples\" (moae) non-regular triangulation.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = IncidenceMatrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = SubdivisionOfPoints(moaepts, moaeimnonreg0)\nA subdivision of points in ambient dimension 3\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#SubdivisionOfPoints-Tuple{Union{MatElem, AbstractMatrix{T} where T}, AbstractVector{T} where T}","page":"Subdivisions of Points","title":"SubdivisionOfPoints","text":"SubdivisionOfPoints(points::Union{Oscar.MatElem,AbstractMatrix}, weights::AbstractVector)\n\nArguments\n\npoints::Matrix: Points generating the cells of the subdivision; encoded row-wise as representative vectors.\nweights::AbstractVector: A vector with one entry for every point indicating the height of this point.\n\nA subdivision of points formed by placing every point at the corresponding height, then taking the convex hull and then only considering those cells corresponding to faces visible from below (\"lower envelope\").\n\nExamples\n\nWe use the MOAE points, but give a weight vector instead of cells:\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> SOP = SubdivisionOfPoints(moaepts, [1,1,1,1,1,1])\nA subdivision of points in ambient dimension 3\n\njulia> n_maximal_cells(SOP)\n1\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"From a subdivision of points one can construct the secondary_cone(SOP::SubdivisionOfPoints), i.e. the cone that is the closure of the set of all weight vectors realizing that subdivision.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#Saving-and-loading","page":"Subdivisions of Points","title":"Saving and loading","text":"","category":"section"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"Objects of type SubdivisionsOfPoints can be saved to a file and loaded from a file in the following way:","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2]\nmoaeincidence = IncidenceMatrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]])\nMOAE = SubdivisionOfPoints(moaepts, moaeincidence)\nsave(MOAE, \"moae.sop\");\nSOP = load(\"moae.sop\");\nisregular(SOP)","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"The file is in JSON format and contains all previously gathered data belonging to the underlying polymake object. In particular, this file can now be read by both polymake and Oscar.","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#Auxiliary-functions","page":"Subdivisions of Points","title":"Auxiliary functions","text":"","category":"section"},{"location":"PolyhedralGeometry/subdivisions_of_points/","page":"Subdivisions of Points","title":"Subdivisions of Points","text":"ambient_dim(SOP::SubdivisionOfPoints)\nisregular(SOP::SubdivisionOfPoints)\nmaximal_cells\nmin_weights\nn_maximal_cells(SOP::SubdivisionOfPoints)\npoints(SOP::SubdivisionOfPoints)\nsecondary_cone","category":"page"},{"location":"PolyhedralGeometry/subdivisions_of_points/#ambient_dim-Tuple{SubdivisionOfPoints}","page":"Subdivisions of Points","title":"ambient_dim","text":"ambient_dim(SOP::SubdivisionOfPoints)\n\nReturn the ambient dimension SOP, which is the dimension of the embedding space.\n\nExamples\n\nThe ambient dimension of the MOAE is 3, independent of the subdivision chosen.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> SOP = SubdivisionOfPoints(moaepts, [1,1,1,1,1,1]);\n\njulia> ambient_dim(SOP)\n3\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#isregular-Tuple{SubdivisionOfPoints}","page":"Subdivisions of Points","title":"isregular","text":"isregular(SOP::SubdivisionOfPoints)\n\nDetermine whether SOP is regular, i.e. can be given via a height function.\n\nExamples\n\nThis is the so-called \"mother of all examples\", a very famous non-regular triangulation of six points.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = IncidenceMatrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = SubdivisionOfPoints(moaepts, moaeimnonreg0);\n\njulia> isregular(MOAE)\nfalse\n\njulia> SOP = SubdivisionOfPoints(moaepts, [1,1,1,1,1,1]);\n\njulia> isregular(SOP)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#maximal_cells","page":"Subdivisions of Points","title":"maximal_cells","text":"maximal_cells(SOP::SubdivisionOfPoints)\n\nReturn an iterator over the maximal cells of SOP.\n\nExamples\n\nDisplay the cells of the \"mother of all examples\" non-regular triangulation.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2]\n6×3 Matrix{Int64}:\n 4  0  0\n 0  4  0\n 0  0  4\n 2  1  1\n 1  2  1\n 1  1  2\n\njulia> moaeimnonreg0 = IncidenceMatrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]])\n7×6 IncidenceMatrix\n[4, 5, 6]\n[1, 2, 4]\n[2, 4, 5]\n[2, 3, 5]\n[3, 5, 6]\n[1, 3, 6]\n[1, 4, 6]\n\n\njulia> MOAE = SubdivisionOfPoints(moaepts, moaeimnonreg0);\n\njulia> maximal_cells(MOAE)\n7-element SubObjectIterator{Vector{Int64}}:\n [4, 5, 6]\n [1, 2, 4]\n [2, 4, 5]\n [2, 3, 5]\n [3, 5, 6]\n [1, 3, 6]\n [1, 4, 6]\n\n\n\nmaximal_cells(IncidenceMatrix, SOP::SubdivisionOfPoints)\n\nReturn the maximal cells of SOP as an incidence matrix.\n\nThe rows of the output correspond to the maximal cells and the columns correspond to the cells.\n\nExamples\n\nIf we give all points the same weight there is only one cell containing all points.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2]\n6×3 Matrix{Int64}:\n 4  0  0\n 0  4  0\n 0  0  4\n 2  1  1\n 1  2  1\n 1  1  2\n\njulia> SOP = SubdivisionOfPoints(moaepts, [1,1,1,1,1,1])\nA subdivision of points in ambient dimension 3\n\njulia> maximal_cells(IncidenceMatrix, SOP)\n1×6 IncidenceMatrix\n[1, 2, 3, 4, 5, 6]\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/subdivisions_of_points/#min_weights","page":"Subdivisions of Points","title":"min_weights","text":"min_weights(SOP::SubdivisionOfPoints)\n\nReturn the minimal weights inducing a subdivision of points. This method will give an error if the input subdivision is non-regular.\n\nExamples\n\nIf all points have the same weight, then the 0-vector is minimal.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> SOP = SubdivisionOfPoints(moaepts, [1,1,1,1,1,1]);\n\njulia> min_weights(SOP)\npm::Vector<long>\n0 0 0 0 0 0\n\n\n\n","category":"function"},{"location":"PolyhedralGeometry/subdivisions_of_points/#n_maximal_cells-Tuple{SubdivisionOfPoints}","page":"Subdivisions of Points","title":"n_maximal_cells","text":"n_maximal_cells(SOP::SubdivisionOfPoints)\n\nReturn the number of maximal cells of SOP.\n\nExamples\n\nIf all points have the same weight, there is only one cell.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> SOP = SubdivisionOfPoints(moaepts, [1,1,1,1,1,1]);\n\njulia> n_maximal_cells(SOP)\n1\n\n\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#points-Tuple{SubdivisionOfPoints}","page":"Subdivisions of Points","title":"points","text":"points(SOP::SubdivisionOfPoints)\n\nReturn the points of the subdivision of points, SOP.\n\nExamples\n\nDisplay the points of the \"mother of all examples\" non-regular triangulation. ```jldoctest julia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = IncidenceMatrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = SubdivisionOfPoints(moaepts, moaeimnonreg0);\n\njulia> points(MOAE) 6-element SubObjectIterator{PointVector{fmpq}}:  [4, 0, 0]  [0, 4, 0]  [0, 0, 4]  [2, 1, 1]  [1, 2, 1]  [1, 1, 2]\n\n\n\n","category":"method"},{"location":"PolyhedralGeometry/subdivisions_of_points/#secondary_cone","page":"Subdivisions of Points","title":"secondary_cone","text":"secondary_cone(SOP::SubdivisionOfPoints)\n\nReturn the secondary cone of a subdivision of points, the closure of all the weight vectors inducing the given subdivision of points.\n\nExamples\n\nFor a non-regular subdivision, the secondary cone can still contain non-trivial weights, but it will not be full-dimensional.\n\njulia> moaepts = [4 0 0; 0 4 0; 0 0 4; 2 1 1; 1 2 1; 1 1 2];\n\njulia> moaeimnonreg0 = IncidenceMatrix([[4,5,6],[1,4,2],[2,4,5],[2,3,5],[3,5,6],[1,3,6],[1,4,6]]);\n\njulia> MOAE = SubdivisionOfPoints(moaepts, moaeimnonreg0)\nA subdivision of points in ambient dimension 3\n\njulia> C = secondary_cone(MOAE)\nA polyhedral cone in ambient dimension 6\n\njulia> dim(C)\n4\n\n\n\n","category":"function"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"CurrentModule = Oscar","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"using Oscar","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Pages = [\"rational.md\"]","category":"page"},{"location":"Rings/rational/#Rationals","page":"Rationals","title":"Rationals","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Fractions are created in Julia with the double slash operator //. If a fraction is created from Julia integers, a Julia fraction results, and if either the numerator or denominator is an Oscar integer of type fmpz, an Oscar fraction of type fmpq results.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Julia has its own parameterised type Rational{T} for its own fractions, where T is the integer type of the numerator and denominator, e.g. Rational{Int} and Rational{BigInt}. Unlike with Int, all of the basic arithmetic operations on Julia's Rational{Int} are checked for overflow in the numerator and denominator.","category":"page"},{"location":"Rings/rational/#The-field-of-rationals","page":"Rationals","title":"The field of rationals","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"The parent of an Oscar rational number is the field of rationals. It can be constructed from the ring of integers ZZ using the FractionField constructor.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"For convenience, QQ is already defined to be the field of rational numbers.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"S = FractionField(ZZ)\nQQ","category":"page"},{"location":"Rings/rational/#Integer-constructors","page":"Rationals","title":"Integer constructors","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Oscar rationals can be created using QQ. Two arguments can be passed to specify numerator and denominator. If a single argument is passed, the denominator is set to 1.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"For convenience, QQ also accepts Julia integers and rationals, but will always construct an Oscar rational.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Naturally, Julia's double slash operator can also be used to construct fractions. However, unlike QQ, the double slash operator only constructs an Oscar rational if either the numerator or denominator is an Oscar integer.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"An exception is raised if a fraction is constructed with denominator zero.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"QQ(1, 2)\nQQ(5)\nZZ(3)//5\n1//ZZ(7)\nQQ(2//3)\nZZ(3)//0","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"One can also construct the rational number 0 with the empty constructor:","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"QQ()","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"The following special constructors are also provided:","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"zero(QQ)\none(QQ)","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"zero(QQ)\none(QQ)","category":"page"},{"location":"Rings/rational/#Predicates","page":"Rationals","title":"Predicates","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"iszero(n::fmpq) -> Bool\nisone(n::fmpq) -> Bool\nisunit(n::fmpq) -> Bool","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"The isunit function will return true iff n neq 0.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"iszero(QQ())\nisone(one(QQ))\nisunit(QQ(-2, 3))","category":"page"},{"location":"Rings/rational/#Properties","page":"Rationals","title":"Properties","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"numerator(n::fmpq) -> fmpz\ndenominator(n::fmpq) -> fmpz","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the numerator and denominator respectively, of n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"sign(n::fmpq) -> fmpq","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the sign of n, i.e. nn if n neq 0, or 0 otherwise.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"sign(QQ(2, 3))\nsign(QQ())\nsign(QQ(-1))","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"abs(n::fmpq) -> fmpq","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the absolute value of n, i.e. n if n geq 0 and -n otherwise.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"abs(QQ(-3, 2))","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"height(n::fmpq) -> fmpz","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the maximum of the absolute values of the numerator and denominator of n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"height(QQ(324987329, -8372492324))","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"floor(n::fmpq) -> fmpq","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the greatest integer m (as a rational number) such that m leq n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"ceil(n::fmpq) -> fmpq","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the least integer m (as a rational number) such that m geq n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"floor(QQ(-2, 3))\nceil(QQ(7, 2))\ntypeof(ans)\nceil(QQ(5))","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"floor(fmpz, n::fmpq) -> fmpz","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the greatest integer m such that m leq n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"ceil(fmpz, n::fmpq) -> fmpz","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the least integer m such that m geq n.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"floor(fmpz, QQ(-2, 3))\nceil(fmpz, QQ(7, 2))\ntypeof(ans)\nceil(fmpz, QQ(5))","category":"page"},{"location":"Rings/rational/#Basic-arithmetic","page":"Rationals","title":"Basic arithmetic","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Oscar provides the basic arithmetic operations +, - and * and comparison operators ==, !=, <, <=, >, >=, including mixed operations between Julia and Oscar rationals and integers.","category":"page"},{"location":"Rings/rational/#[Exact-Division]","page":"Rationals","title":"[Exact Division]","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"divexact(a::fmpq, b::fmpq) -> fmpq\ndivexact(a::fmpq, b::Union{fmpz,Base.Integer,Base.Rational}) -> fmpq\ndivexact(a::Union{fmpz,Base.Integer,Base.Rational}, b::fmpq) -> fmpq","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the quotient of a by b. Exact division raises an exception if division by zero is attempted.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"divexact(QQ(2, 3), QQ(3, 5))\ndivexact(QQ(1, 3), ZZ(0))\ndivexact(QQ(3, 4), ZZ(5))\ndivexact(ZZ(6), QQ(2, 3))\ndivexact(QQ(1, 3), 5)","category":"page"},{"location":"Rings/rational/#Powering","page":"Rationals","title":"Powering","text":"","category":"section"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"^(a::fmpq, b::Int) -> fmpq","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Return the result of powering a by b.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"QQ(5, 7)^32\nQQ(1, 2)^(-2)","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"The following is allowed for convenience.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"QQ(0)^0","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"note: Note\nIn Julia, the rational number 01 when raised to a negative power returns 10 to indicate that the value is undefined. Oscar raises an exception.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"QQ(0)^-2","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"ispower(a::fmpq, b::Int) -> Bool, fmpq","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Test if a is an n-th power. If so, return true and the root, false and any rational otherwise.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"ispower(a::fmpq) -> Int, fmpq","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Find the largest n such that a is an n-th power. Return n and the root.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"root(a::fmpq, b::Int) -> fmpq","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"Compute an n-th root of a, raises an error if a is not an n-th power.","category":"page"},{"location":"Rings/rational/","page":"Rationals","title":"Rationals","text":"ispower(QQ(8), 3)\nispower(QQ(8), 2)\nispower(QQ(9//16))\nroot(QQ(25//9), 2)","category":"page"},{"location":"AbstractAlgebra/ring/#Ring-functionality","page":"Ring functionality","title":"Ring functionality","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"AbstractAlgebra has both commutative and noncommutative rings. Together we refer to them below as rings.","category":"page"},{"location":"AbstractAlgebra/ring/#Abstract-types-for-rings","page":"Ring functionality","title":"Abstract types for rings","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"All commutative ring types in AbstractAlgebra belong to the Ring abstract type and commutative ring elements belong to the RingElem abstract type.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Noncommutative ring types belong to the NCRing abstract type and their elements to NCRingElem.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"As Julia types cannot belong to our RingElem type hierarchy, we also provide the union type RingElement which includes RingElem in union with the Julia types Integer, Rational and AbstractFloat.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Similarly NCRingElement includes the Julia types just mentioned in union with NCRingElem.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Note that","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Ring <: NCRing\nRingElem <: NCRingElem\nRingElement <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring/#Functions-for-types-and-parents-of-rings","page":"Ring functionality","title":"Functions for types and parents of rings","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"parent_type(::Type{T}) where T <: NCRingElement\nelem_type(::Type{T}) where T <: NCRing","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return the type of the parent (resp. element) type corresponding to the given ring element (resp. parent) type.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"base_ring(R::NCRing)\nbase_ring(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"For generic ring constructions over a base ring (e.g. polynomials over a coefficient ring), return the parent object of that base ring.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"parent(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return the parent of the given ring element.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"isdomain_type(::Type{T}) where T <: NCRingElement\nisexact_type(::Type{T}) where T <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return true if the given ring element type can only belong to elements of an integral domain or exact ring respectively. (An exact ring is one whose elements are represented exactly in the system without approximation.)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"The following function is implemented where mathematically and algorithmically possible.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"characteristic(R::NCRing)","category":"page"},{"location":"AbstractAlgebra/ring/#Constructors","page":"Ring functionality","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"If R is a parent object of a ring in AbstractAlgebra, it can always be used to construct certain objects in that ring.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"(R::NCRing)() # constructs zero\n(R::NCRing)(c::Integer)\n(R::NCRing)(c::elem_type(R))\n(R::NCRing{T})(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/#Basic-functions","page":"Ring functionality","title":"Basic functions","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"All rings in AbstractAlgebra are expected to implement basic ring operations, unary minus, binary addition, subtraction and multiplication, equality testing, powering.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"In addition, the following are implemented for parents/elements just as they would be in Julia for types/objects.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"zero(R::NCRing)\none(R::NCRing)\niszero(a::NCRingElement)\nisone(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"In addition, the following is implemented where it is mathematically/algorithmically viable to do so.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"isunit(a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"The following standard Julia functions are also implemented for all ring elements.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"hash(f::RingElement, h::UInt)\ndeepcopy_internal(a::RingElement, dict::ObjectIdDict)\nshow(io::IO, R::NCRing)\nshow(io::IO, a::NCRingElement)","category":"page"},{"location":"AbstractAlgebra/ring/#Basic-functionality-for-inexact-rings-only","page":"Ring functionality","title":"Basic functionality for inexact rings only","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"By default, inexact ring elements in AbstractAlgebra compare equal if they are the same to the minimum precision of the two elements. However, we also provide the following more strict notion of equality, which also requires the precisions to be the same.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"isequal(a::T, b::T) where T <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"For floating point and ball arithmetic it is sometimes useful to be able to check if two elements are approximately equal, e.g. to suppress numerical noise in comparisons. For this, the following are provided.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"isapprox(a::T, b::T; atol::Real=sqrt(eps())) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Similarly, for a parameterised ring with type MyElem{T} over such an inexact ring we have the following.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"isapprox(a::MyElem{T}, b::T; atol::Real=sqrt(eps())) where T <: RingElement\nisapprox(a::T, b::MyElem{T}; atol::Real=sqrt(eps())) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"These notionally perform a coercion into the parameterised ring before doing the approximate equality test.","category":"page"},{"location":"AbstractAlgebra/ring/#Basic-functionality-for-commutative-rings-only","page":"Ring functionality","title":"Basic functionality for commutative rings only","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"divexact(a::T, b::T) where T <: RingElement\ninv(a::T)","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return a/b or 1/a respectively, where the slash here refers to the mathematical notion of division in the ring, not Julia's floating point division operator.","category":"page"},{"location":"AbstractAlgebra/ring/#Basic-functionality-for-noncommutative-rings-only","page":"Ring functionality","title":"Basic functionality for noncommutative rings only","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"divexact_left(a::T, b::T) where T <: NCRingElement\ndivexact_right(a::T, b::T) where T <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"As per divexact above, except that division by b happens on the left or right, respectively, of a.","category":"page"},{"location":"AbstractAlgebra/ring/#Unsafe-ring-operators","page":"Ring functionality","title":"Unsafe ring operators","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"To speed up polynomial arithmetic, various unsafe operators are provided, which mutate the output rather than create a new object.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"zero!(a::NCRingElement)\nmul!(a::T, b::T, c::T) where T <: NCRingElement\nadd!(a::T, b::T, c::T) where T <: NCRingElement\naddeq!(a::T, b::T) where T <: NCRingElement\naddmul!(a::T, b::T, c::T, t::T) where T <: NCRingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"In each case the mutated object is the leftmost parameter.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"The addeq!(a, b) operation does the same thing as add!(a, a, b). The optional addmul!(a, b, c, t) operation does the same thing as mul!(t, b, c); addeq!(a, t) where t is a temporary which can be mutated so that an addition allocation is not needed.","category":"page"},{"location":"AbstractAlgebra/ring/#Random-generation","page":"Ring functionality","title":"Random generation","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"The Julia random interface is implemented for all ring parents (instead of for types). The exact interface differs depending on the ring, but the parameters supplied are usually ranges, e.g. -1:10 for the range of allowed degrees for a univariate polynomial.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"rand(R::NCRing, v...)","category":"page"},{"location":"AbstractAlgebra/ring/#Factorization","page":"Ring functionality","title":"Factorization","text":"","category":"section"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"For commutative rings supporting factorization and irreducibility testing, the following optional functions may be implemented.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"isirreducible(a::T) where T <: RingElement\nissquarefree(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Decide whether a is irreducible or squarefree, respectively.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"factor(a::T) where T <: RingElement\nfactor_squarefree(a::T) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Return a factorization into irreducible or squarefree elements, respectively. The return is an object of type Fac{T}.","category":"page"},{"location":"AbstractAlgebra/ring/","page":"Ring functionality","title":"Ring functionality","text":"Fac\nunit(a::Fac)\nevaluate(a::Fac)\ngetindex(a::Fac, b)\nsetindex!(a::Fac{Int}, c::Int, b::Int)","category":"page"},{"location":"AbstractAlgebra/ring/#Fac","page":"Ring functionality","title":"Fac","text":"Fac{T <: RingElement}\n\nType for factored ring elements. The structure holds a unit of type T and is an iterable collection of T => Int pairs for the factors and exponents.\n\n\n\n","category":"type"},{"location":"AbstractAlgebra/ring/#unit-Tuple{Fac}","page":"Ring functionality","title":"unit","text":"unit(a::Fac{T}) -> T\n\nReturn the unit of the factorization.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ring/#evaluate-Tuple{Fac}","page":"Ring functionality","title":"evaluate","text":"evaluate(a::Fac{T}) -> T\n\nMultiply out the factorization into a single element.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ring/#getindex-Tuple{Fac, Any}","page":"Ring functionality","title":"getindex","text":"getindex(a::Fac, b) -> Int\n\nIf b is a factor of a, the corresponding exponent is returned. Otherwise an error is thrown.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/ring/#setindex!-Tuple{Fac{Int64}, Int64, Int64}","page":"Ring functionality","title":"setindex!","text":"setindex!(a::Fac{T}, c::Int, b::T)\n\nIf b is a factor of a, the corresponding entry is set to c.\n\n\n\n","category":"method"},{"location":"DeveloperDocumentation/styleguide/#Developer-Style-Guide","page":"Developer Style Guide","title":"Developer Style Guide","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"In general we aim to follow the Julia Style Guide but there are some exceptions due to our specific needs and a different background.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"The content of this page are merely guidelines. There may be good reasons to deviate from them in some cases; in that case just do so.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Naming-conventions","page":"Developer Style Guide","title":"Naming conventions","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"The usual Julia naming conventions apply to Oscar, too (that said, for various reasons our code still violates quite some of them; but in general we strive to reduce these). Here is a summary of the naming convention followed in Oscar:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Use CamelCase for types and snake_case for everything else. (Internal functions do not have to follow these rules.)\nNoteworthy difference to Julia base is that we do not have exceptions is* or has*. It is is_foo instead of isfoo and has_bar instead of hasbar.\nFor generic concepts choose generic names, based on general algebraic concepts, preferably not special names from your area of speciality.\nUse Julia conventions where applicable.\nIn Julia we have multiple dispatch, so we do not need functions like point_from_matrix as the \"from\" part is clear by the type of the argument. It should be called points(T::Matrix) in some variation. Similarly for matrix_to_points. Of course it is fine to use them internally, where useful.\nFollow the mathematics. If your function needs a list of points, you should create a point-type (or use the one already there) and then use this. For user-facing functions, please do not use re-purposed lists, arrays, matrices...\nIf already existing types in Oscar are almost what you need, consider improving them instead of writing your own. While it might be tempting to create a new polynomial ring type for the new application because some feature is missing, it causes a lot of work and compatibility issues: Will the new type support\nnormal functions (gcd, factor),\nquotient fields,\nmodules and residue rings,\nconversion to and from other already existing types?","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Code-formatting","page":"Developer Style Guide","title":"Code formatting","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/#Unicode","page":"Developer Style Guide","title":"Unicode","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"As most modern programming languages, Julia allows the use of Unicode, e.g., α, in the REPL as well as in source code. As this reduces accessibility to various groups of users and developers, the use of Unicode should be kept to a minimum. Here is a general principle:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Do not use Unicode characters inside functions. See below for the exception concerning printing.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Per default output should be ANSI only (no Unicode). Implementors of Base.show and related functions can branch on the output of Oscar.is_unicode_allowed() to display objects using non-ASCII characters. This will then be used for users which enabled Unicode using allow_unicode(true). Note that","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"there must be a default ANSI only output, since this is the default setting for new users, and\nOSCAR library code is not allowed to call Oscar.allow_unicode.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Here is an example with and without output using Unicode:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"  struct AtoB\n  end\n\n  function Base.show(io::IO, ::AtoB)\n    if Oscar.is_unicode_allowed()\n      print(io, \"A→B\")\n    else\n      print(io, \"A->B\")\n    end\n  end","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Whitespace","page":"Developer Style Guide","title":"Whitespace","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Do not use tabs.\nDo not put spaces \"inside\" parenthesis.\nDo put spaces after commas.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Good example:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"f(x, y) = x + 1\nprint(f(1, 2))","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Bad example:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"f( x,y ) = x + 1\nprint( f ( 1,2 ) )","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Loops-and-other-control-structures","page":"Developer Style Guide","title":"Loops and other control structures","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"for loops should use in not =\ndon't put spaces around the : in a range","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Good example:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"for i in 1:3\n  println(i)\nend","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"Bad example:","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"for i = 1 : 3\n  println(i)\nend","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Code-structure","page":"Developer Style Guide","title":"Code structure","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"do not nest loops and if clauses too deeply; if you are using 5 or more levels, then in general that's a hint that you should refactor; e.g.\nby moving parts of the code into a separate function\nby replacing guard constructs like\nfor i in A\n  if flag\n    ...\n  end\nend\nby\nfor i in A\n  if !flag\n    continue\n  end\n  ...\nend\nor\nfor i in A\n  flag ||continue\n  ...\nend\nby merging loops: you can replace\nfor i in A\n  for j in B\n    ...\n  end\nend\nby\nfor i in A, j in B\n  ...\nend\nFunctions should not have too many arguments. If you need a bunch arguments, chances are that introducing a new type makes it more readable.\nFunctions should not be too long; very long functions are in general harder to understand; it is also more difficult to see all the code at once. Consider splitting the function into multiple ones, if it is sensibly possible.","category":"page"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"However, as always, rules sometimes should be broken.","category":"page"},{"location":"DeveloperDocumentation/styleguide/#Documentation","page":"Developer Style Guide","title":"Documentation","text":"","category":"section"},{"location":"DeveloperDocumentation/styleguide/","page":"Developer Style Guide","title":"Developer Style Guide","text":"In general we try to follow the list of recommendations in the Documentation section of the Julia manual.\nVia the MathJax integration it is possible to use LaTeX code, and this is the preferred way to denote the mathematical symbols in the docstrings.","category":"page"},{"location":"AbstractAlgebra/module_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"AbstractAlgebra/module_introduction/","page":"Introduction","title":"Introduction","text":"As with many generic constructions in AbstractAlgebra, the modules that are provided in AbstractAlgebra itself work over a Euclidean domain. Moreover, they are limited to finitely presented modules.","category":"page"},{"location":"AbstractAlgebra/module_introduction/","page":"Introduction","title":"Introduction","text":"Free modules and vector spaces are provided over Euclidean domains and fields respectively and then submodule, quotient module and direct sum module constructions are possible recursively over these.","category":"page"},{"location":"AbstractAlgebra/module_introduction/","page":"Introduction","title":"Introduction","text":"It's also possible to compute an invariant decomposition using the Smith Normal Form.","category":"page"},{"location":"AbstractAlgebra/module_introduction/","page":"Introduction","title":"Introduction","text":"The system also provides module homomorphisms and isomorphisms, building on top of the map interface.","category":"page"},{"location":"AbstractAlgebra/module_introduction/","page":"Introduction","title":"Introduction","text":"As for rings and fields, modules follow an interface which other modules are expected to follow. However, very little generic functionality is provided automatically once this interface is implemented by a new module type.","category":"page"},{"location":"AbstractAlgebra/module_introduction/","page":"Introduction","title":"Introduction","text":"The purpose of the module interface is simply to encourage uniformity in the module interfaces of systems that build on AbstractAlgebra. Of course modules are so diverse that this is a very loosely defined interface to accommodate the diversity of possible representations and implementations.","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"Groups/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"The groups part of OSCAR provides functionality for handling","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"Permutation groups\nMatrix groups\nFinitely presented groups\nPolycyclic groups\nProducts of groups\nGroups of automorphisms","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"General textbooks offering details on theory and algorithms include:","category":"page"},{"location":"Groups/intro/","page":"Introduction","title":"Introduction","text":"B. Huppert (1967)\nDerek F. Holt, Bettina Eick, Eamonn A. O'Brien (2005)","category":"page"},{"location":"Nemo/types/#Types-in-Nemo","page":"Types in Nemo","title":"Types in Nemo","text":"","category":"section"},{"location":"Nemo/types/","page":"Types in Nemo","title":"Types in Nemo","text":"Nemo is fully compatible with AbstractAlgebra.jl, but specialises implementations of various commonly used rings with a highly optimised C implementation, provided by the C libraries wrapped by Nemo.","category":"page"},{"location":"Nemo/types/","page":"Types in Nemo","title":"Types in Nemo","text":"Below, we give a list of all of the specialised types available in Nemo that implement rings using a specialised C library. The types of elements of the respective rings and other mathematical structures are given, and in parentheses we list the types of the parent objects of the given rings and structures.","category":"page"},{"location":"Nemo/types/","page":"Types in Nemo","title":"Types in Nemo","text":"Flint\nfmpz (FlintIntegerRing)\nfmpq (FlintRationalField)\nnmod (NmodRing)\nfmpz_mod (FmpzModRing`)\nfq_nmod (FqNmodFiniteField)\ngfp_elem (GaloisField)\ngfp_fmpz_elem (GaloisFmpzField)\nfq (FqFiniteField)\npadic (FlintPadicField)\nqadic (FlintQadicField)\nfmpz_poly (FmpzPolyRing)\nfmpq_poly (FmpqPolyRing)\nnmod_poly (NmodPolyRing)\nfmpz_mod_poly (FmpzModPolyRing)\nfq_poly (FqPolyRing)\nfq_nmod_poly (FqNmodPolyRing)\nfmpz_mpoly (FmpzMPolyRing)\nfmpq_mpoly (FmpqMPolyRing)\nnmod_mpoly (NmodMPolyRing)\nfq_nmod_mpoly (FqNmodMPolyRing`)\ngfp_poly (GFPPolyRing)\ngfp_fmpz_poly (GFPFmpzPolyRing)\nfmpz_rel_series (FmpzRelSeriesRing)\nfmpz_abs_series (FmpzAbsSeriesRing)\nfmpq_rel_series (FmpqRelSeriesRing)\nfmpq_abs_series (FmpqAbsSeriesRing)\nfmpz_mod_rel_series (FmpzModRelSeriesRing)\nfmpz_mod_abs_series (FmpzModAbsSeriesRing)\nnmod_rel_series (NmodRelSeriesRing)\nnmod_abs_series (NmodAbsSeriesRing)\ngfp_rel_series (GFPRelSeriesRing)\ngfp_abs_series (GFPAbsSeriesRing)\ngfp_fmpz_rel_series (GFPFmpzRelSeriesRing)\ngfp_fmpz_abs_series (GFPFmpzAbsSeriesRing)\nfq_nmod_rel_series (FqNmodRelSeriesRing)\nfq_nmod_abs_series (FqNmodAbsSeriesRing)\nfq_rel_series (FqRelSeriesRing)\nfq_abs_series (FqAbsSeriesRing)\nfmpz_mat (FmpzMatSpace)\nfmpq_mat (FmpqMatSpace)\nnmod_mat (NmodMatSpace)\nfmpz_mod_mat (FmpzModMatSpace`)\nfq_nmod_mat (FqNmodMatSpace)\nfq_mat (FqMatSpace)\ngfp_mat (GFPMatSpace)\nperm (SymmetricGroup)\nAntic\nnf_elem (AnticNumberField)\nArb\narb (ArbField)\nacb (AcbField)\narb_poly (ArbPolyRing)\nacb_poly (AcbPolyRing)\narb_mat (ArbMatSpace)\nacb_mat (AcbMatSpace)\nCalcium\nqqbar (CalciumQQBarField)\nca (CalciumField)","category":"page"},{"location":"AbstractAlgebra/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"AbstractAlgebra/misc/#Printing-options","page":"Miscellaneous","title":"Printing options","text":"","category":"section"},{"location":"AbstractAlgebra/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"AbstractAlgebra supports printing to LaTeX using the MIME type \"text/latex\". To enable LaTeX rendering in Jupyter notebooks and query for the current state, use the following functions:","category":"page"},{"location":"AbstractAlgebra/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"set_html_as_latex\nget_html_as_latex","category":"page"},{"location":"AbstractAlgebra/misc/#set_html_as_latex","page":"Miscellaneous","title":"set_html_as_latex","text":"set_html_as_latex(fl::Bool)\n\nToggles whether MIME type text/html should be printed as text/latex. Note that this is a global option. The return value is the old value.\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/misc/#get_html_as_latex","page":"Miscellaneous","title":"get_html_as_latex","text":"get_html_as_latex()\n\nReturns whether MIME type text/html is printed as text/latex.\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/misc/#Updating-the-type-diagrams","page":"Miscellaneous","title":"Updating the type diagrams","text":"","category":"section"},{"location":"AbstractAlgebra/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Updating the diagrams of the documentation can be done by modifying and running the script docs/create_type_diagrams.jl. Note that this requires the package Kroki.","category":"page"},{"location":"AbstractAlgebra/misc/#Attributes","page":"Miscellaneous","title":"Attributes","text":"","category":"section"},{"location":"AbstractAlgebra/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Often it is desirable to have a flexible way to attach additional data to mathematical structures such as groups, rings, fields, etc. beyond what the original implementation covers. To facilitate this, we provide an attributes system: for objects of suitable types, one may use set_attribute! to attach key-value pairs to the object, and query them using has_attribute, get_attribute and get_attribute!.","category":"page"},{"location":"AbstractAlgebra/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Attributes are supported for all singletons (i.e., instances of an empty struct type), as well as for instances of mutable struct type for which attribute storage was enabled. There are two ways to enable attribute storage for such types:","category":"page"},{"location":"AbstractAlgebra/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"By applying @attributes to a mutable struct declaration, storage is reserved inside that struct type itself (this increases the size of each struct by 8 bytes if no attributes are set).\nBy applying @attributes to the name of a mutable struct type, methods are installed which store attributes to instances of the type in a WeakKeyDict outside the struct.","category":"page"},{"location":"AbstractAlgebra/misc/","page":"Miscellaneous","title":"Miscellaneous","text":"@attributes\nhas_attribute\nget_attribute\nget_attribute!\nset_attribute!","category":"page"},{"location":"AbstractAlgebra/misc/#@attributes","page":"Miscellaneous","title":"@attributes","text":"@attributes typedef\n\nThis is a helper macro that ensures that there is storage for attributes in the type declared in the expression typedef, which must be either a mutable struct definition expression, or the name of a mutable struct type.\n\nThe latter variant is useful to enable attribute storage for types defined in other packages. Note that @attributes is idempotent: when applied to a type for which attribute storage is already available, it does nothing.\n\nFor singleton types, attribute storage is also supported, and in fact always enabled. Thus it is not necessary to apply this macro to such a type.\n\nnote: Note\nWhen applied to a struct definition this macro adds a new field to the struct. For structs without constructor, this will change the signature of the default inner constructor, which requires explicit values for every field, including the attribute storage field this macro adds. Usually it is thus preferable to add an explicit default constructor, as in the example below.\n\nExamples\n\nApplying the macro to a struct definition results in internal storage of the attributes:\n\njulia> @attributes mutable struct MyGroup\n           order::Int\n           MyGroup(order::Int) = new(order)\n       end\n\njulia> G = MyGroup(5)\nMyGroup(5, #undef)\n\njulia> set_attribute!(G, :isfinite, :true)\n\njulia> get_attribute(G, :isfinite)\ntrue\n\nApplying the macro to a typename results in external storage of the attributes:\n\njulia> mutable struct MyOtherGroup\n           order::Int\n           MyOtherGroup(order::Int) = new(order)\n       end\n\njulia> @attributes MyOtherGroup\n\njulia> G = MyOtherGroup(5)\nMyOtherGroup(5)\n\njulia> set_attribute!(G, :isfinite, :true)\n\njulia> get_attribute(G, :isfinite)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"AbstractAlgebra/misc/#has_attribute","page":"Miscellaneous","title":"has_attribute","text":"has_attribute(G::Any, attr::Symbol)\n\nReturn a boolean indicating whether G has a value stored for the attribute attr.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/misc/#get_attribute","page":"Miscellaneous","title":"get_attribute","text":"get_attribute(f::Function, G::Any, attr::Symbol)\n\nReturn the value stored for the attribute attr, or if no value has been set, return f().\n\nThis is intended to be called using do block syntax.\n\nget_attribute(obj, attr) do\n    # default value calculated here if needed\n    ...\nend\n\n\n\n\n\nget_attribute(G::Any, attr::Symbol, default::Any = nothing)\n\nReturn the value stored for the attribute attr, or if no value has been set, return default.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/misc/#get_attribute!","page":"Miscellaneous","title":"get_attribute!","text":"get_attribute!(f::Function, G::Any, attr::Symbol)\n\nReturn the value stored for the attribute attr of G, or if no value has been set, store key => f() and return f().\n\nThis is intended to be called using do block syntax.\n\nget_attribute!(obj, attr) do\n    # default value calculated here if needed\n    ...\nend\n\n\n\n\n\nget_attribute!(G::Any, attr::Symbol, default::Any)\n\nReturn the value stored for the attribute attr of G, or if no value has been set, store key => default, and return default.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/misc/#set_attribute!","page":"Miscellaneous","title":"set_attribute!","text":"set_attribute!(G::Any, data::Pair{Symbol, <:Any}...)\n\nAttach the given sequence of key=>value pairs as attributes of G.\n\n\n\n\n\nset_attribute!(G::Any, attr::Symbol, value::Any)\n\nAttach the given value as attribute attr of G.\n\n\n\n\n\n","category":"function"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/finfield/#Finite-fields","page":"Finite fields","title":"Finite fields","text":"","category":"section"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"AbstractAlgebra.jl provides a module, implemented in src/julia/GF.jl for finite fields. The module is a naive implementation that supports only fields of degree 1 (prime fields). They are modelled as mathbbZpmathbbZ for p a prime.","category":"page"},{"location":"AbstractAlgebra/finfield/#Types-and-parent-objects","page":"Finite fields","title":"Types and parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"Finite fields have type GFField{T} where T is either Int or BigInt.","category":"page"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"Elements of such a finite field have type GFElem{T}.","category":"page"},{"location":"AbstractAlgebra/finfield/#Finite-field-constructors","page":"Finite fields","title":"Finite field constructors","text":"","category":"section"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"In order to construct finite fields in AbstractAlgebra.jl, one must first construct the field itself. This is accomplished with the following constructors.","category":"page"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"GF(p::T) where T <: Integer","category":"page"},{"location":"AbstractAlgebra/finfield/#GF-Tuple{T} where T<:Integer","page":"Finite fields","title":"GF","text":"GF(p::T; check::Bool=true) where T <: Integer\n\nReturn the finite field mathbbF_p, where p is a prime. By default, the integer p is checked with a probabilistic algorithm for primality. When check == false, no check is made, but the behaviour of the resulting object is undefined if p is composite.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"Here are some examples of creating a finite field and making use of the resulting parent object to coerce various elements into the field.","category":"page"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"julia> F = GF(13)\nFinite field F_13\n\njulia> g = F(3)\n3\n\njulia> h = F(g)\n3\n\njulia> GF(4)\nERROR: DomainError with 4:\nCharacteristic is not prime in GF(p)\nStacktrace:\n[...]","category":"page"},{"location":"AbstractAlgebra/finfield/#Basic-field-functionality","page":"Finite fields","title":"Basic field functionality","text":"","category":"section"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"The finite field module in AbstractAlgebra.jl implements the full Field interface.","category":"page"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"We give some examples of such functionality.","category":"page"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"julia> F = GF(13)\nFinite field F_13\n\njulia> f = F(7)\n7\n\njulia> h = zero(F)\n0\n\njulia> k = one(F)\n1\n\njulia> isone(k)\ntrue\n\njulia> iszero(h)\ntrue\n\njulia> T = parent(h)\nFinite field F_13\n\njulia> h == deepcopy(h)\ntrue\n\njulia> h = h + 2\n2\n\njulia> m = inv(k)\n1\n","category":"page"},{"location":"AbstractAlgebra/finfield/#Basic-manipulation-of-fields-and-elements","page":"Finite fields","title":"Basic manipulation of fields and elements","text":"","category":"section"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"data(::GFElem)\nlift(::GFElem)","category":"page"},{"location":"AbstractAlgebra/finfield/#data-Tuple{AbstractAlgebra.GFElem}","page":"Finite fields","title":"data","text":"data(R::GFElem)\n\nReturn the internal data used to represent the finite field element. This coincides with lift except where the internal data ids a machine integer.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/finfield/#lift-Tuple{AbstractAlgebra.GFElem}","page":"Finite fields","title":"lift","text":"data(R::GFElem)\n\nLift the finite field element to the integers. The result will be a multiprecision integer regardless of how the field element is represented internally.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"gen{T <: Integer}(F::GFField{T})","category":"page"},{"location":"AbstractAlgebra/finfield/#gen-Union{Tuple{AbstractAlgebra.GFField{T}}, Tuple{T}} where T<:Integer","page":"Finite fields","title":"gen","text":"gen(R::GFField{T}) where T <: Integer\n\nReturn a generator of the field. Currently this returns 1.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"order(F::GFField)","category":"page"},{"location":"AbstractAlgebra/finfield/#order-Tuple{AbstractAlgebra.GFField}","page":"Finite fields","title":"order","text":"order(R::GFField)\n\nReturn the order, i.e. the number of element in the given finite field.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"degree(F::GFField)","category":"page"},{"location":"AbstractAlgebra/finfield/#degree-Tuple{AbstractAlgebra.GFField}","page":"Finite fields","title":"degree","text":"degree(R::GFField)\n\nReturn the degree of the given finite field.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"Examples","category":"page"},{"location":"AbstractAlgebra/finfield/","page":"Finite fields","title":"Finite fields","text":"julia> F = GF(13)\nFinite field F_13\n\njulia> d = degree(F)\n1\n\njulia> n = order(F)\n13\n\njulia> g = gen(F)\n1\n","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/developer/interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"Nemo/developer/interfaces/#Functionality-for-Generic-and-Abstract-Types","page":"Interfaces","title":"Functionality for Generic and Abstract Types","text":"","category":"section"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"As previously mentioned, Nemo provides various generic types, e.g. Poly{T} for generic univariate polynomials and Mat{T} for generic matrices over a base ring. These and other polynomial and matrix types belong in turn to abstract types or unions thereof, e.g. PolyElem{T} is an abstract type representing all univariate polynomial types and MatrixElem{T} is a union of all Nemo matrix types.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"When implementing generic functionality, one should usually implement it for the abstract types and unions thereof, since the new functionality will then work for all types of the specified kind, instead of just the generic types.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"In order for this to work in practice, such implementations can only use functions in the relevant official interface. These are the functions required to be implemented by all types of that kind. For example, matrix implementations make heavy use of addeq! and mul! to accumulate entries, but they cannot make use of functions such as subeq! as it is not part of the official interface.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"In addition to implementations for abstract types and their unions, one may also like to provide specialised implementations for the generic types e.g. Poly{T} and Mat{T} as one would for other specialised types. The generic types are based on Julia arrays internally, and so it makes perfect sense to implement lower level functionality for these types specifically, as this may lead to performance gains. Such specialised implementations can make use of any functions provided for the generic types, whether in the interface or not.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"For convenience we list the most important abstract types and their unions for which one should usually prefer to write generic implementations.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"PolyElem{T} : all univariate polynomial types\nMPolyElem{T} : all multivariate polynomial types (see note below)\nMatrixElem{T} : union of all matrix types including matrix algebras\nMatElem{T} : all matrix types not including matrix algebras\nAbsSeriesElem{T} : all abstract series types\nRelSeriesElem{T} : all relative series types\nLaurentSeriesElem{T} : union of all Laurent series over rings and fields\nPuiseuxSeriesElem{T} : union of all Puiseux series over rings and fields\nFPModule{T} : all finitely presented modules over a Euclidean domain\nFPModuleElem{T} : all elems of fin. presented modules over a Euc. domain\nFracElem{T} : all fractions\nResElem{T} : all elements of a residue ring\nResFieldElem{T} : all elements of a residue field\nMap{D, C} : all maps (see Maps developer docs for a description)","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"N.B: inside the Generic submodule of AbstractAlgebra some abstract types Blah are only accessible by writing AbstractAlgebra.Blah. The unions are directly accessible. There may be generic types and abstract types with the same name, so this is more than just a convention.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Note that multivariate polynomials tend to require very specialised implementations depending heavily on implementation details of the specific multivariate type. Therefore it is rare to write implementations for the abstract type MPolyElem{T}. Instead, implementations tend to be done for each concrete multivariate type separately.","category":"page"},{"location":"Nemo/developer/interfaces/#Generic-interfaces","page":"Interfaces","title":"Generic interfaces","text":"","category":"section"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"As mentioned above, the generic implementations in Nemo depend on carefully written interfaces for each of the abstract types provided by the system.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"These interfaces are spelled out in the AbstractAlgebra documentation. Note that a generic implementation may depend on functions in both the required and optional interfaces as the optional functions are all implemented with generic fallbacks in terms of the required functions.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"For convenience we provide here a list of interfaces that can be relied on in generic implementations, along with a description.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Ring : all commutative rings in the system\nField : all fields in the system\nNCRing : all rings in the system (not necessarily commutative)\nEuclidean Ring : Euclidean rings (see notes below)\nUnivariate Polynomial Ring : all dense univariate polynomials\nMultivariate Polynomial Ring : all sparse distributed multivariate polys.\nSeries Ring : all series, relative and absolute\nResidue Ring : all quotients of gcd domains with gcdx by a principal ideal\nFraction Field : all fractions over a gcd domain with gcdx\nModule : all finitely presented modules over a Euclidean domain\nMatrix : all matrices over a commutative ring\nMap : all (set) maps in the system","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Although we allow Z/nZ in our definition of Euclidean ring, much of the functionality in Nemo can be expected to misbehave (impossible inverses, etc.) when working with Euclidean rings that are not domains. In some cases the algorithms just don't exist, and in other cases we simply haven't implemented the required functionality to support all Euclidean rings for which computations can be done.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Whether a ring is a Euclidean domain or not cannot be encoded in the type. Thus there is no abstract type for Euclidean domains or their elements. Instead, generic functions rely on the existence of certain functions such as gcdx to implement functionality for Euclidean domains.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"There is also currently no way to define a Euclidean function for a given ring (which is known to be Euclidean) and have the system recognise the ring as such. This kind of Euclidean interface may be provided in a future version of Nemo.","category":"page"},{"location":"Nemo/developer/interfaces/#Julia-interfaces-we-support","page":"Interfaces","title":"Julia interfaces we support","text":"","category":"section"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Many Julia interfaces rely on being able to create zero and one elements given the type only. As we use the parent/element model (see developer notes on this topic) we cannot support all Julia interfaces fully.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"We do however partially implement some Julia interfaces.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Iteration : iterators are currently provided for multivariate polynomials to iterate over the coefficients, terms and monomials. Nemo matrices can also be iterated over. Iteration proceeds down each column in turn. One can also iterate over all permutations and partitions. Finally, all finite field types can be iterated over.\nViews : because C libraries cannot be expected to implement the full range of Julia view types, views of matrices in Nemo can only be constructed for submatrices consisting of contiguous blocks in the original matrix.\nmap and similar : we implement the map and similar interfaces with the caveat that we generally use parent objects where Julia would use types. See the specific documentation for the module of interest to see details.\nzero and one : these are implemented for parent types, which is not what Julia typically expects. Exceptions include the Flint fmpz and fmpq types, as their parents are not parameterised, which makes it possible to implement these functions for the types as well as the parents.\nrand : we have a Nemo specific rand interface, which passes the tail of a given rand invocation to the rand function for the base ring, e.g. to create random matrix elements or polynomial coefficients and so on. In addition to this custom rand interface, we also support much of the Julia rand interface, with the usual caveat that we use parent objects instead of types where necessary.\nserialisation : unfortunately this is currently NOT implemented by Nemo, but we would certainly like to see that done in the future. It's not automatic because of the C objects that underly many of our constructions.\nNumber : Nemo number types do NOT belong to Julia's Number hierarchy, as we must make all our ring element types belong to our RingElem abstract type. To make some Julia Number types cooperate with Nemo, we define the unions RingElement and FieldElement which include some Julia types, such as BigInt and Rational{BigInt}, etc. Note that fixed precision integer types cannot be expected to be well-behaved when they overflow. We recommend using Nemo integer types if one wants good performance for small machine word sized integers, but no overflow when the integer becomes large (Nemo integers are based on Flint's multiprecision fmpz type).\nhash : we implement hash functions for all major element types in Nemo.\ngetindex/setindex!/typed_hvcat : we implement these to access elements of Nemo matrices, however see the note below on row major representation. In  addition, we allow creation of matrices using the notation R[a b; c d] etc. This is done by overloading typed_hvcat for the parent object R instead of a type as Julia would normally expect. This produces a Nemo matrix rather than a Julia one. Note that when passed a type, Julia's typed_hvcat can only construct Julia matrices for Nemo types such as fmpz and fmpq where elements can be constructed from types alone.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Many other Julia interfaces are either not yet implemented or only very partially implemented.","category":"page"},{"location":"Nemo/developer/interfaces/#Column-major-vs-row-major-matrices","page":"Interfaces","title":"Column major vs row major matrices","text":"","category":"section"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"Whereas Julia uses column major representation for its matrices, Nemo follows the convention of the C libraries it wraps and uses row major representation. Although Julia 2-D arrays are used internally in Nemo's generic matrix type, the interface from the perspective of the user is still the Nemo row major convention, not the Julia column major convention.","category":"page"},{"location":"Nemo/developer/interfaces/","page":"Interfaces","title":"Interfaces","text":"In row major representation, some row operations may be able to be performed more cheaply than similar column operations. In column major representation the converse is true. This may mean that some Julia matrix implementations may perform more slowly if naively ported to Nemo matrices, unless suitably modified.","category":"page"},{"location":"AbstractAlgebra/field/#Field-functionality","page":"Field functionality","title":"Field functionality","text":"","category":"section"},{"location":"AbstractAlgebra/field/#Abstract-types-for-rings","page":"Field functionality","title":"Abstract types for rings","text":"","category":"section"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"All field types in AbstractAlgebra belong to the Field abstract type and field elements belong to the FieldElem abstract type.","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"As Julia types cannot belong to our FieldElem type hierarchy, we also provide the union type FieldElement which includes FieldElem in union with the Julia types Rational and AbstractFloat.","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Note that","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Field <: Ring\nFieldElem <: RingElem\nFieldElement <: RingElement","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Of course all Ring functionality is available for AbstractAlgebra fields and their elements.","category":"page"},{"location":"AbstractAlgebra/field/#Functions-for-types-and-parents-of-fields","page":"Field functionality","title":"Functions for types and parents of fields","text":"","category":"section"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"characteristic(R::MyParent)","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Return the characteristic of the field. If the characteristic is not known, an exception is raised.","category":"page"},{"location":"AbstractAlgebra/field/#Basic-functions","page":"Field functionality","title":"Basic functions","text":"","category":"section"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"isunit(f::MyElem)","category":"page"},{"location":"AbstractAlgebra/field/","page":"Field functionality","title":"Field functionality","text":"Return true if the given element is invertible, i.e. nonzero in the field.","category":"page"},{"location":"Hecke/#Hecke","page":"Hecke","title":"Hecke","text":"","category":"section"},{"location":"Hecke/#About","page":"Hecke","title":"About","text":"","category":"section"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"Hecke is a software package for algebraic number theory maintained by Claus Fieker, Carlo Sircana and Tommy Hofmann. It is written in julia and is based on the computer algebra package Nemo.","category":"page"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"https://github.com/thofma/Hecke.jl (Source code)\nhttps://thofma.github.io/Hecke.jl/dev/ (Online documentation)","category":"page"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"So far, Hecke provides the following features:","category":"page"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"Orders (including element and ideal arithmetic) in number fields\nComputation of maximal orders\nVerified residue computations of Dedekind zeta functions\nClass and Unit group computation, S-units, PID testing\nLattice enumeration\nSparse linear algebra\nNormal forms for modules over maximal orders\nExtensions of number fields, non-simple extensions of number fields\nOrders and ideals in extensions of fields\nAbelian groups\nRay class groups, quotients of ray class groups\nInvariant subgroups\nClass Field Theory\nAssociative Algebras","category":"page"},{"location":"Hecke/#Installation","page":"Hecke","title":"Installation","text":"","category":"section"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"To use Hecke, a julia version of 1.6 is necessary (the latest stable julia version will do). Please see https://julialang.org/downloads/ for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:","category":"page"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"julia> using Pkg\njulia> Pkg.add(\"Hecke\")","category":"page"},{"location":"Hecke/#Quick-start","page":"Hecke","title":"Quick start","text":"","category":"section"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"Here is a quick example of using Hecke:","category":"page"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"julia> using Hecke\n...\n\nWelcome to\n\n  _    _           _\n | |  | |         | |\n | |__| | ___  ___| | _____\n |  __  |/ _ \\/ __| |/ / _ \\\n | |  | |  __/ (__|   <  __/\n |_|  |_|\\___|\\___|_|\\_\\___|\n\nVersion 0.9.0 ...\n ... which comes with absolutely no warranty whatsoever\n(c) 2015-2018 by Claus Fieker, Tommy Hofmann and Carlo Sircana\n\njulia> Qx, x = PolynomialRing(FlintQQ, \"x\");\njulia> f = x^3 + 2;\njulia> K, a = NumberField(f, \"a\");\njulia> O = maximal_order(K);\njulia> O\nMaximal order of Number field over Rational Field with defining polynomial x^3 + 2\nwith basis [1,a,a^2]","category":"page"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"The documentation of the single functions can also be accessed at the julia prompt. Here is an example:","category":"page"},{"location":"Hecke/","page":"Hecke","title":"Hecke","text":"help?> signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -> Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"CurrentModule = Oscar","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"using Oscar","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"Pages = [\"free_modules.md\"]","category":"page"},{"location":"CommutativeAlgebra/free_modules/#Free-Modules-Over-Multivariate-Rings","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"In this section, the expression free module  refers to a free module of finite rank over a multivariate polynomial ring. More concretely, given a multivariate polynomial ring R,  the free R-modules considered are of type R^p, where we think of R^p as a free module with a given basis, namely the basis of standard unit vectors. Accordingly, elements of free modules are represented by coordinate vectors, and homomorphisms between free modules by matrices.","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"note: Note\nBy convention, vectors are row vectors, and matrices operate by multiplication on the right.","category":"page"},{"location":"CommutativeAlgebra/free_modules/#Types","page":"Free Modules Over Multivariate Rings","title":"Types","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"All OSCAR types for finitely presented modules over multivariate polynomial rings belong to the abstract type ModuleFP{T}. For free modules, OSCAR provides the abstract subtype AbstractFreeMod{T} <: ModuleFP{T} and its concrete descendant FreeMod{T <: RingElem}.","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"note: Note\nCanonical maps such us the canonical projection onto a quotient module arise in many  constructions in commutative algebra. The FreeMod type is designed so that it allows for the caching of such maps when executing functions. The direct_sum function discussed in this section provides an example.","category":"page"},{"location":"CommutativeAlgebra/free_modules/#Constructor","page":"Free Modules Over Multivariate Rings","title":"Constructor","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"free_module(R::MPolyRing, n::Int, name::String = \"e\"; cached::Bool = false)","category":"page"},{"location":"CommutativeAlgebra/free_modules/#free_module","page":"Free Modules Over Multivariate Rings","title":"free_module","text":"free_module(R::MPolyRing, p::Int, name::String = \"e\"; cached::Bool = false)\n\nReturn the free module R^p, created with its basis of standard unit vectors.\n\nThe string name specifies how the basis vectors are printed. \n\nExamples\n\njulia> R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\n(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])\n\njulia> F = free_module(R, 3)\nFree module of rank 3 over Multivariate Polynomial Ring in x, y over Rational Field\n\njulia> F[2]\ne[2]\n\njulia> typeof(F)\nFreeMod{fmpq_mpoly}\n\n\n\n","category":"function"},{"location":"CommutativeAlgebra/free_modules/#Data-Associated-to-Free-Modules","page":"Free Modules Over Multivariate Rings","title":"Data Associated to Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"If F is a free R-module, then","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"base_ring(F) refers to R,\nbasis(F), gens(F) to the basis vectors of F, \nrank(F), ngens(F), dim(F) to the number of these vectors, and\nF[i], basis(F, i), gen(F, i) to the i-th such vector.","category":"page"},{"location":"CommutativeAlgebra/free_modules/#Examples","page":"Free Modules Over Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\nF = free_module(R, 3)\nbasis(F)\nrank(F)","category":"page"},{"location":"CommutativeAlgebra/free_modules/#Elements-of-Free-Modules","page":"Free Modules Over Multivariate Rings","title":"Elements of Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"All OSCAR types for elements of finitely presented modules over multivariate polynomial rings belong to the abstract type ModuleElemFP{T}. For elements of free modules, there are the abstract subtype AbstractFreeModElem{T} <: ModuleFPElem{T} and its concrete descendant FreeModElem{T} which implements an element f of a free module F as a sparse row, that is, as an object of type SRow{T}. This object specifies the coordinates of f with respect to the basis of standard unit vectors of F. To create an element, enter its coordinates as a sparse row or a vector: ","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"(F::FreeMod{T})(c::SRow{T}) where T","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"(F::FreeMod{T})(c::Vector{T}) where T","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"Alternatively, directly write the element as a linear combination of basis vectors of F:","category":"page"},{"location":"CommutativeAlgebra/free_modules/#Examples-2","page":"Free Modules Over Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\nF = free_module(R, 3)\nf = F(sparse_row(R, [(1,x),(3,y)]))\ng = F( [x, zero(R), y])\nh = x*F[1] + y*F[3]\nf == g == h","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"Given an element f  of a free module F,","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"parent(f) refers to F, and\ncoefficients(f) to the coordinate vector of f, returned as an object of type SRow{T}.","category":"page"},{"location":"CommutativeAlgebra/free_modules/#Examples-3","page":"Free Modules Over Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\nF = free_module(R, 3)\nf = x*F[1] + y*F[3]\nparent(f)\ncoefficients(f)","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"The zero element of a free module is obtained as follows:","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"zero(F::AbstractFreeMod)","category":"page"},{"location":"CommutativeAlgebra/free_modules/#zero-Tuple{Oscar.AbstractFreeMod}","page":"Free Modules Over Multivariate Rings","title":"zero","text":"zero(F::AbstractFreeMod)\n\nReturn the zero element of  F.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"Whether a given element of a free module is zero can be tested as follows:","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"iszero(f::AbstractFreeModElem)","category":"page"},{"location":"CommutativeAlgebra/free_modules/#iszero-Tuple{Oscar.AbstractFreeModElem}","page":"Free Modules Over Multivariate Rings","title":"iszero","text":"iszero(f::AbstractFreeModElem)\n\nReturn true if f is zero, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/free_modules/#Tests-on-Free-Modules","page":"Free Modules Over Multivariate Rings","title":"Tests on Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"==(F::FreeMod, G::FreeMod)","category":"page"},{"location":"CommutativeAlgebra/free_modules/#==-Tuple{FreeMod, FreeMod}","page":"Free Modules Over Multivariate Rings","title":"==","text":"==(F::FreeMod, G::FreeMod)\n\nReturn  true if F and G are equal, false otherwise.\n\nHere, F and G are equal iff their base rings, ranks, and names for printing the basis elements are equal.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"iszero(F::AbstractFreeMod)","category":"page"},{"location":"CommutativeAlgebra/free_modules/#iszero-Tuple{Oscar.AbstractFreeMod}","page":"Free Modules Over Multivariate Rings","title":"iszero","text":"iszero(F::AbstractFreeMod)\n\nReturn true if F is the zero module, false otherwise.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/free_modules/#Homomorphisms-From-Free-Modules","page":"Free Modules Over Multivariate Rings","title":"Homomorphisms From Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"A homomorphism Frightarrow M from a free module F is determined by specifying the images of the basis vectors of F in M. In OSCAR, such homomorphisms have type FreeModuleHom{T1, T2}, where T1 and T2 are the element types of the domain and codomain, respectively. They are created by using one of the following constructors:","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"hom(F::FreeMod{T}, G::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}) where T","category":"page"},{"location":"CommutativeAlgebra/free_modules/#hom-Union{Tuple{T}, Tuple{FreeMod{T}, ModuleFP{T}, Vector{var\"#s271\"} where var\"#s271\"<:ModuleFPElem{T}}} where T","page":"Free Modules Over Multivariate Rings","title":"hom","text":"hom(F::FreeMod{T}, M::ModuleFP{T}, V::Vector{<:ModuleFPElem{T}}) where T\n\nGiven a vector V of rank(F) elements of M,  return the homomorphism F to M which sends the i-th basis vector of F to the i-th entry of V.\n\nhom(F::FreeMod{T}, M::ModuleFP{T}, A::MatElem{T}) where T\n\nGiven a matrix A with rank(F) rows and ngens(M) columns, return the homomorphism F to M which sends the i-th basis vector of F to  the linear combination sum_j Aij*Mj of the generators M[j] of M.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"Given a homomorphism of type FreeModuleHom, a matrix A as above is recovered by the following function:","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"matrix(a::FreeModuleHom)","category":"page"},{"location":"CommutativeAlgebra/free_modules/#matrix-Tuple{FreeModuleHom}","page":"Free Modules Over Multivariate Rings","title":"matrix","text":"matrix(a::FreeModuleHom)\n\nGiven a homomorphism a of type  FreeModuleHom with domain F and codomain M, return a matrix A with rank(F) rows and  ngens(M) columns such that a == hom(F, M, A).\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/free_modules/#Examples-4","page":"Free Modules Over Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"R, (x, y, z) = PolynomialRing(QQ, [\"x\", \"y\", \"z\"])\nF = free_module(R, 3)\nG = free_module(R, 2)\nV = [y*G[1], x*G[1]+y*G[2], z*G[2]]\na = hom(F, G, V)\nA = matrix(a)\na(F[2])","category":"page"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"The domain and codomain of a homomorphism a  of type FreeModuleHom can be recovered by entering domain(a) and codomain(a), respectively.","category":"page"},{"location":"CommutativeAlgebra/free_modules/#Operations-on-Free-Modules","page":"Free Modules Over Multivariate Rings","title":"Operations on Free Modules","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"direct_sum(F::FreeMod{T}...; task::Symbol = :none) where T","category":"page"},{"location":"CommutativeAlgebra/free_modules/#direct_sum-Union{Tuple{Vararg{FreeMod{T}, N} where N}, Tuple{T}} where T","page":"Free Modules Over Multivariate Rings","title":"direct_sum","text":"direct_sum(F::FreeMod{T}...; task::Symbol = :sum) where T\n\nGiven free modules F_1dots F_n, say, return the direct sum bigoplus_i=1^n F_i.\n\nAdditionally, return \n\na vector containing the canonical injections  F_irightarrowbigoplus_i=1^n F_i if task = :sum (default),\na vector containing the canonical projections  bigoplus_i=1^n F_irightarrow F_i if task = :prod,\ntwo vectors containing the canonical injections and projections, respectively, if task = :both,\nnone of the above if task = :none.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"direct_product(F::FreeMod{T}...; task::Symbol = :none) where T","category":"page"},{"location":"CommutativeAlgebra/free_modules/#direct_product-Union{Tuple{Vararg{FreeMod{T}, N} where N}, Tuple{T}} where T","page":"Free Modules Over Multivariate Rings","title":"direct_product","text":"direct_product(F::FreeMod{T}...; task::Symbol = :prod) where T\n\nGiven free modules F_1dots F_n, say, return the direct product prod_i=1^n F_i.\n\nAdditionally, return a vector containing\n\na vector containing the canonical projections  prod_i=1^n F_irightarrow F_i if task = :prod (default),\na vector containing the canonical injections  F_irightarrowprod_i=1^n F_i if task = :sum,\ntwo vectors containing the canonical projections and injections, respectively, if task = :both,\nnone of the above if task = :none.\n\n\n\n","category":"method"},{"location":"CommutativeAlgebra/free_modules/#Examples-5","page":"Free Modules Over Multivariate Rings","title":"Examples","text":"","category":"section"},{"location":"CommutativeAlgebra/free_modules/","page":"Free Modules Over Multivariate Rings","title":"Free Modules Over Multivariate Rings","text":"R, (x, y) = PolynomialRing(QQ, [\"x\", \"y\"])\nF = free_module(R, 2)\nG = free_module(R, 3, \"f\")\nL = direct_product(F, G, task = :both)\nbasis(L[1])\nL[3][2]","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/serialization/","page":"Saving and loading","title":"Saving and loading","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/serialization/","page":"Saving and loading","title":"Saving and loading","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/serialization/","page":"Saving and loading","title":"Saving and loading","text":"Pages = [\"serialization.md\"]","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/serialization/#Saving-and-loading","page":"Saving and loading","title":"Saving and loading","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/serialization/","page":"Saving and loading","title":"Saving and loading","text":"Objects of type Polyhedron can be saved to a file and loaded from a file in the following way:","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/serialization/","page":"Saving and loading","title":"Saving and loading","text":"square = cube(2)\nsave(square, \"square.poly\")\ns = load(\"square.poly\")\ns == square","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/serialization/","page":"Saving and loading","title":"Saving and loading","text":"The file is in JSON format and contains all previously gathered data belonging to the underlying polymake object. In particular, this file can now be read by both polymake and Oscar.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/padic/#Padics","page":"Padics","title":"Padics","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"P-adic fields are provided in Nemo by Flint. This allows construction of p-adic fields for any prime p.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"P-adic fields are constructed using the FlintPadicField function. However, for convenience we define","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"PadicField = FlintPadicField","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"so that p-adic fields can be constructed using PadicField rather than FlintPadicField. Note that this is the name of the constructor, but not of padic field type.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"The types of p-adic fields in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Library Field Element type Parent type\nFlint mathbbQ_p padic PadicField","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"All the p-adic field types belong to the Field abstract type and the p-adic field element types belong to the FieldElem abstract type.","category":"page"},{"location":"Nemo/padic/#P-adic-functionality","page":"Padics","title":"P-adic functionality","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"P-adic fields in Nemo implement all the AbstractAlgebra field functionality:.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/field","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Below, we document all the additional function that is provide by Nemo for p-adic fields.","category":"page"},{"location":"Nemo/padic/#Constructors","page":"Padics","title":"Constructors","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"In order to construct p-adic field elements in Nemo, one must first construct the p-adic field itself. This is accomplished with one of the following constructors.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"FlintPadicField(::Integer, ::Int)","category":"page"},{"location":"Nemo/padic/#FlintPadicField-Tuple{Integer, Int64}","page":"Padics","title":"FlintPadicField","text":"FlintPadicField(p::Integer, prec::Int; kw...)\n\nReturns the parent object for the p-adic field for given prime p, where the default absolute precision of elements of the field is given by prec.\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"It is also possible to call the inner constructor directly. It has the following form.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"FlintPadicField(p::fmpz, prec::Int)","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Returns the parent object for the p-adic field for given prime p, where the default absolute precision of elements of the field is given by prec.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Here are some examples of creating p-adic fields and making use of the resulting parent objects to coerce various elements into those fields.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\nS = PadicField(ZZ(65537), 30)\n\na = R()\nb = S(1)\nc = S(ZZ(123))\nd = R(ZZ(1)//7^2)","category":"page"},{"location":"Nemo/padic/#Big-oh-notation","page":"Padics","title":"Big-oh notation","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Elements of p-adic fields can  be constructed using the big-oh notation. For this purpose we define the following functions.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"O(::FlintPadicField, ::Integer)\nO(::FlintPadicField, ::fmpz)\nO(::FlintPadicField, ::fmpq)","category":"page"},{"location":"Nemo/padic/#O-Tuple{FlintPadicField, Integer}","page":"Padics","title":"O","text":"O(R::FlintPadicField, m::Integer)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"Nemo/padic/#O-Tuple{FlintPadicField, fmpz}","page":"Padics","title":"O","text":"O(R::FlintPadicField, m::fmpz)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"Nemo/padic/#O-Tuple{FlintPadicField, fmpq}","page":"Padics","title":"O","text":"O(R::FlintPadicField, m::fmpq)\n\nConstruct the value 0 + O(p^n) given m = p^n. An exception results if m is not found to be a power of p = prime(R).\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"The O(p^n) construction can be used to construct p-adic values of precision n by adding it to integer values representing the p-adic value modulo p^n as in the examples.","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\nS = PadicField(ZZ(65537), 30)\n\nc = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nd = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)\nf = ZZ(1)//7^2 + ZZ(2)//7 + 3 + 4*7 + O(R, 7^2)","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Beware that the expression 1 + 2*p + 3*p^2 + O(R, p^n) is actually computed as a normal Julia expression. Therefore if {Int} values are used instead of Flint integers or Julia bignums, overflow may result in evaluating the value.","category":"page"},{"location":"Nemo/padic/#Basic-manipulation","page":"Padics","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"prime(::FlintPadicField)","category":"page"},{"location":"Nemo/padic/#prime-Tuple{FlintPadicField}","page":"Padics","title":"prime","text":"prime(R::FlintPadicField)\n\nReturn the prime p for the given p-adic field.\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"precision(::padic)","category":"page"},{"location":"Nemo/padic/#precision-Tuple{padic}","page":"Padics","title":"precision","text":"precision(a::padic)\n\nReturn the precision of the given p-adic field element, i.e. if the element is known to O(p^n) this function will return n.\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"valuation(::padic)","category":"page"},{"location":"Nemo/padic/#valuation-Tuple{padic}","page":"Padics","title":"valuation","text":"valuation(a::padic)\n\nReturn the valuation of the given p-adic field element, i.e. if the given element is divisible by p^n but not a higher power of p then the function will return n.\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"lift(::FlintIntegerRing, ::padic)\nlift(::FlintRationalField, ::padic)","category":"page"},{"location":"Nemo/padic/#lift-Tuple{FlintIntegerRing, padic}","page":"Padics","title":"lift","text":"lift(R::FlintIntegerRing, a::padic)\n\nReturn a lift of the given p-adic field element to mathbbZ.\n\n\n\n","category":"method"},{"location":"Nemo/padic/#lift-Tuple{FlintRationalField, padic}","page":"Padics","title":"lift","text":"lift(R::FlintRationalField, a::padic)\n\nReturn a lift of the given p-adic field element to mathbbQ.\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 7^2 + 3*7^3 + O(R, 7^5)\nc = R(2)\n\nk = precision(a)\nm = prime(R)\nn = valuation(b)\np = lift(FlintZZ, a)\nq = lift(FlintQQ, divexact(a, b))","category":"page"},{"location":"Nemo/padic/#Square-root","page":"Padics","title":"Square root","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Base.sqrt(::padic)","category":"page"},{"location":"Nemo/padic/#sqrt-Tuple{padic}","page":"Padics","title":"sqrt","text":"Base.sqrt(f::PolyElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of f. By default the function checks the input is square and raises an exception if not. If check=false this check is omitted.\n\n\n\nBase.sqrt(a::FracElem{T}; check::Bool=true) where T <: RingElem\n\nReturn the square root of a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\nsqrt(a::FieldElem)\n\nReturn the square root of the element a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\nsqrt(a::Generic.PuiseuxSeriesElem{T}; check::Bool=true) where T <: RingElement\n\nReturn the square root of the given Puiseux series a. By default the function will throw an exception if the input is not square. If check=false this test is omitted.\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\nc = 7^2 + 2*7^3 + O(R, 7^4)\n\nd = sqrt(a)\nf = sqrt(b)\nf = sqrt(c)\ng = sqrt(R(121))","category":"page"},{"location":"Nemo/padic/#Special-functions","page":"Padics","title":"Special functions","text":"","category":"section"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Base.exp(::padic)","category":"page"},{"location":"Nemo/padic/#exp-Tuple{padic}","page":"Padics","title":"exp","text":"exp(a::AbsSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::RelSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.LaurentSeriesElem)\n\nReturn the exponential of the power series a.\n\n\n\nexp(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the exponential of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"log(::padic)","category":"page"},{"location":"Nemo/padic/#log-Tuple{padic}","page":"Padics","title":"log","text":"log(a::SeriesElem{T}) where T <: FieldElement\n\nReturn the logarithm of the power series a.\n\n\n\nlog(a::Generic.PuiseuxSeriesElem{T}) where T <: RingElement\n\nReturn the logarithm of the given Puiseux series a.\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"teichmuller(::padic)","category":"page"},{"location":"Nemo/padic/#teichmuller-Tuple{padic}","page":"Padics","title":"teichmuller","text":"teichmuller(a::padic)\n\nReturn the Teichmuller lift of the p-adic value a. We require the valuation of a to be nonnegative. The precision of the output will be the same as the precision of the input. For convenience, if a is congruent to zero modulo p we return zero. If the input is not valid an exception is thrown.\n\n\n\n","category":"method"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"Examples","category":"page"},{"location":"Nemo/padic/","page":"Padics","title":"Padics","text":"R = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 5*7 + 3*7^2 + O(R, 7^3)\nc = 3*7 + 2*7^2 + O(R, 7^5)\n\nc = exp(c)\nd = log(a)\nc = exp(R(0))\nd = log(R(1))\nf = teichmuller(b)","category":"page"},{"location":"AbstractAlgebra/map_introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"AbstractAlgebra/map_introduction/","page":"Introduction","title":"Introduction","text":"Maps in AbstractAlgebra model maps on sets f  D to C for some domain D and codomain C, which have no real limitations except that elements of the codomain and domain be represented by element objects in the system.","category":"page"},{"location":"AbstractAlgebra/map_introduction/","page":"Introduction","title":"Introduction","text":"Maps f  D to C in AbstractAlgebra are modeled by Julia objects that are able to be called on a single element d in D of the domain to yield an element f(d) in C of the codomain. We say that the map is being applied.","category":"page"},{"location":"AbstractAlgebra/map_introduction/","page":"Introduction","title":"Introduction","text":"Maps can be constructed from Julia functions, or they can be represented by some other kind of data, e.g. a matrix, or built up from other maps.","category":"page"},{"location":"AbstractAlgebra/map_introduction/","page":"Introduction","title":"Introduction","text":"Maps in AbstractAlgebra have a domain and codomain, can be applied, composed with other maps. Various special kinds of map provide more functionality.","category":"page"},{"location":"AbstractAlgebra/map_introduction/","page":"Introduction","title":"Introduction","text":"For details please refer to the Map Interface documentation.","category":"page"},{"location":"AbstractAlgebra/map_introduction/","page":"Introduction","title":"Introduction","text":"For example, there are functional maps which wrap a Julia function, cached maps which cache values so they do not have to be recomputed each time they are applied to the same inputs and various kinds of maps with inverses, e.g. maps with sections, retractions and full inverses.","category":"page"},{"location":"AbstractAlgebra/map_introduction/","page":"Introduction","title":"Introduction","text":"The map system uses a complex four parameter Map type, however various helper functions are provided to make it easier to work with.","category":"page"},{"location":"Hecke/misc/conjugacy/#Conjugacy-of-integral-matrices","page":"Conjugacy of integral matrices","title":"Conjugacy of integral matrices","text":"","category":"section"},{"location":"Hecke/misc/conjugacy/","page":"Conjugacy of integral matrices","title":"Conjugacy of integral matrices","text":"isGLZ_conjugate(::fmpz_mat, ::fmpz_mat)","category":"page"},{"location":"Hecke/misc/conjugacy/#isGLZ_conjugate-Tuple{fmpz_mat, fmpz_mat}","page":"Conjugacy of integral matrices","title":"isGLZ_conjugate","text":"isGLZ_conjugate(A::MatElem, B::MatElem) -> Bool, MatElem\n\nGiven two integral or rational matrices, determine whether there exists an invertible integral matrix T with TA = BT. If true, the second argument is such a matrix T. Otherwise, the second argument is unspecified.\n\njulia> A = matrix(ZZ, 4, 4, [ 0, 1,  0, 0,\n                             -4, 0,  0, 0,\n                              0, 0,  0, 1,\n                              0, 0, -4, 0]);\n\njulia> B = matrix(ZZ, 4, 4,  [ 0, 1,  4,  0,\n                              -4, 0,  0, -4,\n                               0, 0,  0,  1,\n                               0, 0, -4,  0]);\n\njulia> fl, T = isGLZ_conjugate(A, B);\n\njulia> isone(abs(det(T))) && T * A == B * T\ntrue\n\n\n\n","category":"method"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"using Oscar","category":"page"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"Pages = [\"matgroup.md\"]","category":"page"},{"location":"Groups/matgroup/#Matrix-groups","page":"Matrix groups","title":"Matrix groups","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"MatrixGroup{RE<:RingElem, T<:MatElem{RE}}\nMatrixGroupElem{RE<:RingElem, T<:MatElem{RE}}\nbase_ring(G::MatrixGroup)\ndegree(G::MatrixGroup)\ncentralizer(G::MatrixGroup{T}, x::MatrixGroupElem{T}) where T <: FinFieldElem","category":"page"},{"location":"Groups/matgroup/#MatrixGroup","page":"Matrix groups","title":"MatrixGroup","text":"MatrixGroup{RE<:RingElem, T<:MatElem{RE}} <: GAPGroup\n\nType of groups G of n x n matrices over the ring R, where n = degree(G) and R = base_ring(G).\n\nAt the moment, only rings of type FqNmodFiniteField are supported.\n\n\n\n\n\n","category":"type"},{"location":"Groups/matgroup/#MatrixGroupElem","page":"Matrix groups","title":"MatrixGroupElem","text":"MatrixGroupElem{RE<:RingElem, T<:MatElem{RE}} <: AbstractMatrixGroupElem\n\nElements of a group of type MatrixGroup{RE<:RingElem, T<:MatElem{RE}}\n\n\n\n\n\n","category":"type"},{"location":"Groups/matgroup/#base_ring-Tuple{MatrixGroup}","page":"Matrix groups","title":"base_ring","text":"base_ring(G::MatrixGroup)\n\nReturn the base ring of the matrix group G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#degree-Tuple{MatrixGroup}","page":"Matrix groups","title":"degree","text":"degree(G::MatrixGroup)\n\nReturn the degree of the matrix group G, i.e. the number of rows of its matrices.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#centralizer-Union{Tuple{T}, Tuple{MatrixGroup{T, T1} where T1<:MatElem{T}, MatrixGroupElem{T, T1} where T1<:MatElem{T}}} where T<:FinFieldElem","page":"Matrix groups","title":"centralizer","text":"centralizer(G::MatrixGroup{T}, x::MatrixGroupElem{T})\n\nReturn (C,f), where C is the centralizer of x in C and f is the embedding of C into G. If G = GL(n,F) or SL(n,F), then f = nothing. In this case, to get the embedding homomorphism of C into G, use\n\nissubgroup(G,C)[2]\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Elements-of-matrix-groups","page":"Matrix groups","title":"Elements of matrix groups","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"matrix(x::MatrixGroupElem)\nbase_ring(x::MatrixGroupElem)\nnrows(x::MatrixGroupElem)\ndet(x::MatrixGroupElem)\ntrace(x::MatrixGroupElem)\nmultiplicative_jordan_decomposition(x::MatrixGroupElem)\nissemisimple(x::MatrixGroupElem{T}) where T <: FinFieldElem\nisunipotent(x::MatrixGroupElem{T}) where T <: FinFieldElem","category":"page"},{"location":"Groups/matgroup/#matrix-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"matrix","text":"matrix(x::MatrixGroupElem)\n\nReturn the underlying AbstractAlgebra matrix of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#base_ring-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"base_ring","text":"base_ring(x::MatrixGroupElem)\n\nReturn the base ring of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#nrows-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"nrows","text":"nrows(x::MatrixGroupElem)\n\nReturn the number of rows of the given matrix.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#det-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"det","text":"det(x::MatrixGroupElem)\n\nReturn the determinant of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#trace-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"trace","text":"trace(x::MatrixGroupElem)\ntr(x::MatrixGroupElem)\n\nReturn the trace of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#multiplicative_jordan_decomposition-Tuple{MatrixGroupElem}","page":"Matrix groups","title":"multiplicative_jordan_decomposition","text":"multiplicative_jordan_decomposition(M::MatrixGroupElem)\n\nReturn S and U in the group G = parent(M) such that S is semisimple, U is unipotent and  M = SU = US.\n\nwarning: WARNING:\nthis is NOT, in general, the same output returned when M has type MatElem.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#issemisimple-Union{Tuple{MatrixGroupElem{T, T1} where T1<:MatElem{T}}, Tuple{T}} where T<:FinFieldElem","page":"Matrix groups","title":"issemisimple","text":"issemisimple(x::MatrixGroupElem{T}) where T <: FinFieldElem\n\nReturn whether x is semisimple, i.e. has order coprime with the characteristic of its base ring.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#isunipotent-Union{Tuple{MatrixGroupElem{T, T1} where T1<:MatElem{T}}, Tuple{T}} where T<:FinFieldElem","page":"Matrix groups","title":"isunipotent","text":"isunipotent(x::MatrixGroupElem{T}) where T <: FinFieldElem\n\nReturn whether x is unipotent, i.e. its order is a power of the characteristic of its base ring.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Sesquilinear-forms","page":"Matrix groups","title":"Sesquilinear forms","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"SesquilinearForm{T<:RingElem}\nisalternating_form(f::SesquilinearForm)\nishermitian_form(f::SesquilinearForm)\nisquadratic_form(f::SesquilinearForm)\nissymmetric_form(f::SesquilinearForm)\nalternating_form(B::MatElem{T}) where T <: FieldElem\nsymmetric_form(B::MatElem{T}) where T <: FieldElem\nhermitian_form(B::MatElem{T}) where T <: FieldElem\nquadratic_form(B::MatElem{T}) where T <: FieldElem\nquadratic_form(f::MPolyElem{T}) where T <: FieldElem\ncorresponding_bilinear_form(B::SesquilinearForm)\ncorresponding_quadratic_form(B::SesquilinearForm)\ngram_matrix(f::SesquilinearForm)\ndefining_polynomial(f::SesquilinearForm)\nradical(f::SesquilinearForm{T}) where T\nwitt_index(f::SesquilinearForm{T}) where T\nisdegenerate(f::SesquilinearForm{T}) where T\nissingular(f::SesquilinearForm{T}) where T\niscongruent(f::SesquilinearForm{T}, g::SesquilinearForm{T}) where T <: RingElem","category":"page"},{"location":"Groups/matgroup/#SesquilinearForm","page":"Matrix groups","title":"SesquilinearForm","text":"SesquilinearForm{T<:RingElem}\n\nType of groups G of n x n matrices over the ring R, where n = degree(G) and R = base_ring(G). At the moment, only rings of type FqNmodFiniteField are supported.\n\n\n\n\n\n","category":"type"},{"location":"Groups/matgroup/#isalternating_form-Tuple{SesquilinearForm}","page":"Matrix groups","title":"isalternating_form","text":"isalternating_form(f::SesquilinearForm)\n\nReturn whether the form f is an alternating form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#ishermitian_form-Tuple{SesquilinearForm}","page":"Matrix groups","title":"ishermitian_form","text":"ishermitian_form(f::SesquilinearForm)\n\nReturn whether the form f is a hermitian form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#isquadratic_form-Tuple{SesquilinearForm}","page":"Matrix groups","title":"isquadratic_form","text":"isquadratic_form(f::SesquilinearForm)\n\nReturn whether the form f is a quadratic form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#issymmetric_form-Tuple{SesquilinearForm}","page":"Matrix groups","title":"issymmetric_form","text":"issymmetric_form(f::SesquilinearForm)\n\nReturn whether the form f is a symmetric form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#alternating_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"alternating_form","text":"alternating_form(B::MatElem{T})\n\nReturn the alternating form with Gram matrix B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#symmetric_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"symmetric_form","text":"symmetric_form(B::MatElem{T})\n\nReturn the symmetric form with Gram matrix B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#hermitian_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"hermitian_form","text":"hermitian_form(B::MatElem{T})\n\nReturn the hermitian form with Gram matrix B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#quadratic_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"quadratic_form","text":"quadratic_form(B::MatElem{T})\n\nReturn the quadratic form with Gram matrix B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#quadratic_form-Union{Tuple{MPolyElem{T}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"quadratic_form","text":"quadratic_form(f::MPolyElem{T}; check=true)\n\nReturn the quadratic form described by the polynomial f. Here, f must be a homogeneous polynomial of degree 2. If check is set as false, it does not check whether the polynomial is homogeneous of degree 2. To define quadratic forms of dimension 1, f can also have type PolyElem{T}.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#corresponding_bilinear_form-Tuple{SesquilinearForm}","page":"Matrix groups","title":"corresponding_bilinear_form","text":"corresponding_bilinear_form(Q::SesquilinearForm)\n\nGiven a quadratic form Q, return the bilinear form B defined by B(u,v) = Q(u+v)-Q(u)-Q(v).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#corresponding_quadratic_form-Tuple{SesquilinearForm}","page":"Matrix groups","title":"corresponding_quadratic_form","text":"corresponding_quadratic_form(Q::SesquilinearForm)\n\nGiven a symmetric form f, returns the quadratic form Q defined by Q(v) = f(v,v)/2. It is defined only in odd characteristic.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#gram_matrix-Tuple{SesquilinearForm}","page":"Matrix groups","title":"gram_matrix","text":"gram_matrix(B::SesquilinearForm)\n\nReturn the Gram matrix of a sesquilinear or quadratic form B.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#defining_polynomial-Tuple{SesquilinearForm}","page":"Matrix groups","title":"defining_polynomial","text":"defining_polynomial(f::SesquilinearForm)\n\nReturn the polynomial that defines the quadratic form f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#radical-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"radical","text":" radical(A::AbsAlgAss) -> AbsAlgAssIdl\n\nReturns the Jacobson-Radical of A.\n\n\n\nradical(f::SesquilinearForm{T})\n\nReturn the radical of the sesquilinear form f, i.e. the subspace of all v such that f(u,v)=0 for all u. The radical of a quadratic form Q is the set of vectors v such that Q(v)=0  and v lies in the radical of the corresponding bilinear form.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#witt_index-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"witt_index","text":"witt_index(f::SesquilinearForm{T})\n\nReturn the Witt index of the form induced by f on V/Rad(f). The Witt Index is the dimension of a maximal totally isotropic (singular for quadratic forms) subspace.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#isdegenerate-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"isdegenerate","text":"isdegenerate(f::SesquilinearForm{T})\n\nReturn whether f is degenerate, i.e. f has nonzero radical. A quadratic form is degenerate if the corresponding bilinear form is.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#issingular-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"issingular","text":"issingular(Q::SesquilinearForm{T})\n\nFor a quadratic form Q, return whether Q is singular, i.e. Q has nonzero radical.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#iscongruent-Union{Tuple{T}, Tuple{SesquilinearForm{T}, SesquilinearForm{T}}} where T<:RingElem","page":"Matrix groups","title":"iscongruent","text":"iscongruent(f::SesquilinearForm{T}, g::SesquilinearForm{T}) where T <: RingElem\n\nIf f and g are sesquilinear forms, return (true, C) if there exists a matrix C such that f^C = g, or equivalently, CBC* = A, where A and B are the Gram matrices of f and g respectively, and C* is the transpose-conjugate matrix of C. If such C does not exist, then return (false, nothing).\n\nIf f and g are quadratic forms, return (true, C) if there exists a matrix C such that f^A = ag for some scalar a. If such C does not exist, then return (false, nothing).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Invariant-forms","page":"Matrix groups","title":"Invariant forms","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"invariant_bilinear_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_sesquilinear_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_quadratic_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_symmetric_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_alternating_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_hermitian_forms(G::MatrixGroup{S,T}) where {S,T}\ninvariant_bilinear_form(G::MatrixGroup)\ninvariant_sesquilinear_form(G::MatrixGroup)\ninvariant_quadratic_form(G::MatrixGroup)\npreserved_quadratic_forms(G::MatrixGroup{S,T}) where {S,T}\npreserved_sesquilinear_forms(G::MatrixGroup{S,T}) where {S,T}\nisometry_group(f::SesquilinearForm{T}) where T\northogonal_sign(G::MatrixGroup)","category":"page"},{"location":"Groups/matgroup/#invariant_bilinear_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_bilinear_forms","text":"invariant_bilinear_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of bilinear forms preserved by the group G.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_sesquilinear_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_sesquilinear_forms","text":"invariant_sesquilinear_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of sesquilinear non-bilinear forms preserved by the group G. An exception is thrown if base_ring(G) is not a finite field with even degree over its prime subfield.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_quadratic_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_quadratic_forms","text":"invariant_quadratic_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of quadratic forms preserved by the group G.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_symmetric_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_symmetric_forms","text":"invariant_symmetric_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of symmetric forms preserved by the group G.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\nwarning: Note:\nWork properly only in odd characteristic. In even characteristic, only alternating forms are found.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_alternating_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_alternating_forms","text":"invariant_alternating_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of alternating forms preserved by the group G.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_hermitian_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"invariant_hermitian_forms","text":"invariant_hermitian_forms(G::MatrixGroup)\n\nReturn a generating set for the vector spaces of hermitian forms preserved by the group G. An exception is thrown if base_ring(G) is not a finite field with even degree over its prime subfield.\n\nwarning: Note:\nAt the moment, elements of the generating set are returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_bilinear_form-Tuple{MatrixGroup}","page":"Matrix groups","title":"invariant_bilinear_form","text":"invariant_bilinear_form(G::MatrixGroup)\n\nReturn an invariant bilinear form for the group G. An exception is thrown if the module induced by the action of G is not absolutely irreducible.\n\nwarning: Note:\nAt the moment, the output is returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_sesquilinear_form-Tuple{MatrixGroup}","page":"Matrix groups","title":"invariant_sesquilinear_form","text":"invariant_sesquilinear_form(G::MatrixGroup)\n\nReturn an invariant sesquilinear (non bilinear) form for the group G. An exception is thrown if the module induced by the action of G is not absolutely irreducible or if the group is defined over a finite field of odd degree over the prime field.\n\nwarning: Note:\nAt the moment, the output is returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#invariant_quadratic_form-Tuple{MatrixGroup}","page":"Matrix groups","title":"invariant_quadratic_form","text":"invariant_quadratic_form(G::MatrixGroup)\n\nReturn an invariant quadratic form for the group G. An exception is thrown if the module induced by the action of G is not absolutely irreducible.\n\nwarning: Note:\nAt the moment, the output is returned of type mat_elem_type(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#preserved_quadratic_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"preserved_quadratic_forms","text":"preserved_quadratic_forms(G::MatrixGroup)\n\nUses random methods to find all of the quadratic forms preserved by G up to a scalar (i.e. such that G is a group of similarities for the forms).  Since the procedure relies on a pseudo-random generator,  the user may need to execute the operation more than once to find all invariant quadratic forms.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#preserved_sesquilinear_forms-Union{Tuple{MatrixGroup{S, T}}, Tuple{T}, Tuple{S}} where {S, T}","page":"Matrix groups","title":"preserved_sesquilinear_forms","text":"preserved_sesquilinear_forms(G::MatrixGroup)\n\nUses random methods to find all of the sesquilinear forms preserved by G up to a scalar (i.e. such that G is a group of similarities for the forms). Since the procedure relies on a pseudo-random generator, the user may need to execute the operation more than once to find all invariant sesquilinear forms.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#isometry_group-Union{Tuple{SesquilinearForm{T}}, Tuple{T}} where T","page":"Matrix groups","title":"isometry_group","text":"isometry_group(f::SesquilinearForm{T})\n\nReturn the group of isometries for the sesquilinear form f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#orthogonal_sign-Tuple{MatrixGroup}","page":"Matrix groups","title":"orthogonal_sign","text":"orthogonal_sign(G::MatrixGroup)\n\nFor absolutely irreducible G of degree n and such that base_ring(G) is a finite field, return\n\nnothing if G does not preserve a nonzero quadratic form,\n0 if n is odd and G preserves a nonzero quadratic form,\n1 if n is even and G preserves a nonzero quadratic form of + type,\n-1 if n is even and G preserves a nonzero quadratic form of - type.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Utilities-for-matrices-(replace-by-available-functions,-or-document-elsewhere?)","page":"Matrix groups","title":"Utilities for matrices (replace by available functions, or document elsewhere?)","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"pol_elementary_divisors(A::MatElem{T}) where T\ngeneralized_jordan_block(f::T, n::Int) where T<:PolyElem\ngeneralized_jordan_form(A::MatElem{T}; with_pol=false) where T\nmatrix(A::Vector{AbstractAlgebra.Generic.FreeModuleElem{T}}) where T<: FieldElem\nupper_triangular_matrix(L)\nlower_triangular_matrix(L)\nconjugate_transpose(x::MatElem{T}) where T <: FinFieldElem\ncomplement(V::AbstractAlgebra.Generic.FreeModule{T}, W::AbstractAlgebra.Generic.Submodule{T}) where T <: FieldElem\npermutation_matrix(F::Ring, Q::AbstractVector{<:IntegerUnion})\nisskewsymmetric_matrix(B::MatElem{T}) where T <: RingElem\nishermitian_matrix(B::MatElem{T}) where T <: FinFieldElem","category":"page"},{"location":"Groups/matgroup/#pol_elementary_divisors-Union{Tuple{MatElem{T}}, Tuple{T}} where T","page":"Matrix groups","title":"pol_elementary_divisors","text":"pol_elementary_divisors(x::MatElem)\npol_elementary_divisors(x::MatrixGroupElem)\n\nReturn a list of pairs (f_i,m_i), for irreducible polynomials f_i and positive integers m_i, where the f_i^m_i are the elementary divisors of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#generalized_jordan_block-Union{Tuple{T}, Tuple{T, Int64}} where T<:PolyElem","page":"Matrix groups","title":"generalized_jordan_block","text":"generalized_jordan_block(f::T, n::Int) where T<:PolyElem\n\nReturn the Jordan block of dimension n corresponding to the polynomial f.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#generalized_jordan_form-Union{Tuple{MatElem{T}}, Tuple{T}} where T","page":"Matrix groups","title":"generalized_jordan_form","text":"generalized_jordan_form(A::MatElem{T}; with_pol::Bool=false) where T\n\nReturn (J,Z), where Z^-1*J*Z = A and J is a diagonal join of Jordan blocks (corresponding to irreducible polynomials).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#matrix-Union{Tuple{Array{AbstractAlgebra.Generic.FreeModuleElem{T}, 1}}, Tuple{T}} where T<:FieldElem","page":"Matrix groups","title":"matrix","text":"matrix(A::Vector{AbstractAlgebra.Generic.FreeModuleElem{T}})\n\nReturn the matrix whose rows are the vectors in A. All vectors in A must have the same length and the same base ring.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#upper_triangular_matrix-Tuple{Any}","page":"Matrix groups","title":"upper_triangular_matrix","text":"upper_triangular_matrix(L)\n\nReturn the upper triangular matrix whose entries on and above the diagonal are the elements of L.\n\nAn exception is thrown whenever the length of L is not equal to n(n+1)2, for some integer n.\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#lower_triangular_matrix-Tuple{Any}","page":"Matrix groups","title":"lower_triangular_matrix","text":"lower_triangular_matrix(L)\n\nReturn the upper triangular matrix whose entries on and below the diagonal are the elements of L.\n\nAn exception is thrown whenever the length of L is not equal to n(n+1)2, for some integer n.\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#conjugate_transpose-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FinFieldElem","page":"Matrix groups","title":"conjugate_transpose","text":"conjugate_transpose(x::MatElem{T}) where T <: FinFieldElem\n\nIf the base ring of x is GF(q^2), return the matrix transpose( map ( y -> y^q, x) ).  An exception is thrown if the base ring does not have even degree.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#complement-Union{Tuple{T}, Tuple{AbstractAlgebra.Generic.FreeModule{T}, AbstractAlgebra.Generic.Submodule{T}}} where T<:FieldElem","page":"Matrix groups","title":"complement","text":"complement(V::AbstractAlgebra.Generic.FreeModule{T}, W::AbstractAlgebra.Generic.Submodule{T})\n\nReturn a complement for W in V, i.e. a subspace U of V such that V is direct sum of U and W.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#permutation_matrix-Tuple{AbstractAlgebra.Ring, AbstractVector{var\"#s271\"} where var\"#s271\"<:Union{Integer, fmpz}}","page":"Matrix groups","title":"permutation_matrix","text":"permutation_matrix(F::Ring, Q::AbstractVector{T}) where T <: Int\npermutation_matrix(F::Ring, p::PermGroupElem)\n\nReturn the permutation matrix over the ring R corresponding to the sequence Q or to the permutation p. If Q is a sequence, then Q must contain exactly once every integer from 1 to some n.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#isskewsymmetric_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:RingElem","page":"Matrix groups","title":"isskewsymmetric_matrix","text":"isskewsymmetric_matrix(B::MatElem{T}) where T <: Ring\n\nReturn whether the matrix B is skew-symmetric, i.e. B = -transpose(B) and B has zeros on the diagonal. Return false if B is not a square matrix.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#ishermitian_matrix-Union{Tuple{MatElem{T}}, Tuple{T}} where T<:FinFieldElem","page":"Matrix groups","title":"ishermitian_matrix","text":"ishermitian_matrix(B::MatElem{T}) where T <: FinFieldElem\n\nReturn whether the matrix B is hermitian, i.e. B = conjugate_transpose(B). Return false if B is not a square matrix, or the field has not even degree.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#Classical-groups","page":"Matrix groups","title":"Classical groups","text":"","category":"section"},{"location":"Groups/matgroup/","page":"Matrix groups","title":"Matrix groups","text":"general_linear_group(n::Int, F::Ring)\nspecial_linear_group(n::Int, F::Ring)\nsymplectic_group(n::Int, F::Ring)\northogonal_group(e::Int, n::Int, F::Ring)\nspecial_orthogonal_group(e::Int, n::Int, F::Ring)\nomega_group(e::Int, n::Int, F::Ring)\nunitary_group(n::Int, q::Int)\nspecial_unitary_group(n::Int, q::Int)\nmatrix_group(V::AbstractVector{T}) where T<:Union{MatElem,MatrixGroupElem}","category":"page"},{"location":"Groups/matgroup/#general_linear_group-Tuple{Int64, AbstractAlgebra.Ring}","page":"Matrix groups","title":"general_linear_group","text":"general_linear_group(n::Int, q::Int)\ngeneral_linear_group(n::Int, F::FqNmodFiniteField)\nGL = general_linear_group\n\nReturn the general linear group of dimension n either over the field F or the field GF(q).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#special_linear_group-Tuple{Int64, AbstractAlgebra.Ring}","page":"Matrix groups","title":"special_linear_group","text":"special_linear_group(n::Int, q::Int)\nspecial_linear_group(n::Int, F::FqNmodFiniteField)\nSL = special_linear_group\n\nReturn the special linear group of dimension n either over the field F or the field GF(q).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#symplectic_group-Tuple{Int64, AbstractAlgebra.Ring}","page":"Matrix groups","title":"symplectic_group","text":"symplectic_group(n::Int, q::Int)\nsymplectic_group(n::Int, F::FqNmodFiniteField)\nSp = symplectic_group\n\nReturn the symplectic group of dimension n either over the field F or the field GF(q). The dimension n must be even.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#orthogonal_group-Tuple{Int64, Int64, AbstractAlgebra.Ring}","page":"Matrix groups","title":"orthogonal_group","text":"orthogonal_group(e::Int, n::Int, F::Ring)\northogonal_group(e::Int, n::Int, q::Int)\nGO = orthogonal_group\n\nReturn the orthogonal group of dimension n either over the field F or the field GF(q) of type e, where e in {+1,-1} for n even and e=0 for n odd. If n is odd, e can be omitted.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#special_orthogonal_group-Tuple{Int64, Int64, AbstractAlgebra.Ring}","page":"Matrix groups","title":"special_orthogonal_group","text":"special_orthogonal_group(e::Int, n::Int, F::Ring)\nspecial_orthogonal_group(e::Int, n::Int, q::Int)\nSO = special_orthogonal_group\n\nReturn the special orthogonal group of dimension n either over the field F or the field GF(q) of type e, where e in {+1,-1} for n even and e=0 for n odd. If n is odd, e can be omitted.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#omega_group-Tuple{Int64, Int64, AbstractAlgebra.Ring}","page":"Matrix groups","title":"omega_group","text":"omega_group(e::Int, n::Int, F::Ring)\nomega_group(e::Int, n::Int, q::Int)\n\nReturn the Omega group of dimension n over the field GF(q) of type e, where e in {+1,-1} for n even and e=0 for n odd. If n is odd, e can be omitted.\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#unitary_group-Tuple{Int64, Int64}","page":"Matrix groups","title":"unitary_group","text":"unitary_group(n::Int, q::Int)\nGU = unitary_group\n\nReturn the unitary group of dimension n over the field GF(q^2).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#special_unitary_group-Tuple{Int64, Int64}","page":"Matrix groups","title":"special_unitary_group","text":"special_unitary_group(n::Int, q::Int)\nSU = special_unitary_group\n\nReturn the special unitary group of dimension n over the field GF(q^2).\n\n\n\n\n\n","category":"method"},{"location":"Groups/matgroup/#matrix_group-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Union{MatElem, MatrixGroupElem}","page":"Matrix groups","title":"matrix_group","text":"matrix_group(V::T...) where T<:MatrixGroup\nmatrix_group(V::AbstractVector{T}) where T<:MatrixGroup\n\nReturn the matrix group generated by elements in the vector V.\n\n\n\n\n\n","category":"method"},{"location":"Nemo/rational/","page":"Rationals","title":"Rationals","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/rational/#Rationals","page":"Rationals","title":"Rationals","text":"","category":"section"},{"location":"Nemo/rational/","page":"Rationals","title":"Rationals","text":"Nemo provides much functionality for the rational numbers. See the section on Fraction Fields where all the basic functionality is documented, along with the extra functionality only available for the rational numbers themselves.","category":"page"},{"location":"Hecke/number_fields/internal/","page":"Internals","title":"Internals","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/number_fields/internal/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"Hecke/number_fields/internal/#Types-of-number-fields","page":"Internals","title":"Types of number fields","text":"","category":"section"},{"location":"Hecke/number_fields/internal/","page":"Internals","title":"Internals","text":"Number fields, in Hecke, come in several different types:","category":"page"},{"location":"Hecke/number_fields/internal/","page":"Internals","title":"Internals","text":"AnticNumberField: a finite simple extension of the rational numbers mathbfQ\nNfAbsNS: a finite extension of mathbfQ given by several polynomials. We will refer to this as a non-simple field - even though mathematically we can find a primitive elements.\nNfRel: a finite simple extension of a number field. This is actually parametried by the (element) type of the coefficient field. The complete type of an extension of an absolute field (AnticNumberField) is NfRel{nf_elem}. The next extension thus will be NfRel{NfRelElem{nf_elem}}.\nNfRelNS: extensions of number fields given by several polynomials.  This too will be refered to as a non-simple field.","category":"page"},{"location":"Hecke/number_fields/internal/","page":"Internals","title":"Internals","text":"The simple types AnticNumberField and NfRel are also calle simple fields in the rest of this document, NfRel and NfRelNS are referred to as relative extensions while AnticNumberField and NfAbsNS are called absolute.","category":"page"},{"location":"Hecke/number_fields/internal/","page":"Internals","title":"Internals","text":"Internally, simple fields are essentially just (univariate) polynomial quotients in a dense representation, while non-simple fields are multivariate quotient rings, thus have a sparse presentation. In general, simple fields allow much faster arithmetic, while the non-simple fields give easy access to large degree fields.","category":"page"},{"location":"Hecke/number_fields/internal/#Absolute-simple-fields","page":"Internals","title":"Absolute simple fields","text":"","category":"section"},{"location":"Hecke/number_fields/internal/","page":"Internals","title":"Internals","text":"The most basic number field type is that of AnticNumberField. Internally this is essentially represented as a unvariate quotient with the arithmetic provided by the C-library antic with the binding provided by Nemo.","category":"page"},{"location":"Hecke/function_fields/elements/#Elements","page":"-","title":"Elements","text":"","category":"section"},{"location":"Hecke/function_fields/elements/","page":"-","title":"-","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/function_fields/elements/","page":"-","title":"-","text":"For details on element arithmetic in rational function fields and extensions, refer to the AbstractAlgebra documentation which can be found at https://nemocas.github.io/AbstractAlgebra.jl/stable/function_field/.","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/residue_interface/#Residue-Ring-Interface","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"","category":"section"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Residue rings (currently a quotient ring modulo a principal ideal) are supported in AbstractAlgebra.jl, at least for Euclidean base rings. There is also partial support for residue rings of polynomial rings where the modulus has invertible leading coefficient.","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"In addition to the standard Ring interface, some additional functions are required to be present for residue rings.","category":"page"},{"location":"AbstractAlgebra/residue_interface/#Types-and-parents","page":"Residue Ring Interface","title":"Types and parents","text":"","category":"section"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"AbstractAlgebra provides four abstract types for residue rings and their elements:","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"ResRing{T} is the abstract type for residue ring parent types\nResField{T} is the abstract type for residue rings known to be fields\nResElem{T} is the abstract type for types of elements of residue rings (residues)\nResFieldElem{T} is the abstract type for types of elements of residue fields","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"We have that ResRing{T} <: AbstractAlgebra.Ring and  ResElem{T} <: AbstractAlgebra.RingElem.","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Note that these abstract types are parameterised. The type T should usually be the type of elements of the base ring of the residue ring/field.","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"If the parent object for a residue ring has type MyResRing and residues in that ring have type MyRes then one would have:","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"MyResRing <: ResRing{BigInt}\nMyRes <: ResElem{BigInt}","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Residue rings should be made unique on the system by caching parent objects (unless an optional cache parameter is set to false). Residue rings should at least be distinguished based on their base ring and modulus (the principal ideal one is taking a quotient of the base ring by).","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"See src/generic/GenericTypes.jl for an example of how to implement such a cache (which usually makes use of a dictionary).","category":"page"},{"location":"AbstractAlgebra/residue_interface/#Required-functionality-for-residue-rings","page":"Residue Ring Interface","title":"Required functionality for residue rings","text":"","category":"section"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"In addition to the required functionality for the Ring interface the Residue Ring interface has the following required functions.","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"We suppose that R is a fictitious base ring, m is an element of that ring, and that S is the residue ring (quotient ring) R(m) with parent object S of type MyResRing{T}. We also assume the residues r pmodm in the residue ring have type MyRes{T}, where T is the type of elements of the base ring.","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElem.","category":"page"},{"location":"AbstractAlgebra/residue_interface/#Data-type-and-parent-object-methods","page":"Residue Ring Interface","title":"Data type and parent object methods","text":"","category":"section"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"modulus(S::MyResRing{T}) where T <: AbstractAlgebra.RingElem","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Return the modulus of the given residue ring, i.e. if the residue ring S was specified to be R(m), return m.","category":"page"},{"location":"AbstractAlgebra/residue_interface/#Basic-manipulation-of-rings-and-elements","page":"Residue Ring Interface","title":"Basic manipulation of rings and elements","text":"","category":"section"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"data(f::MyRes{T}) where T <: RingElem\nlift(f::MyRes{T}) where T <: RingElem","category":"page"},{"location":"AbstractAlgebra/residue_interface/","page":"Residue Ring Interface","title":"Residue Ring Interface","text":"Given a residue r pmodm, represented as such, return r. In the special case where machine integers are used to represent the residue, data will return the machine integer, whereas lift will return a multiprecision integer. Otherwise lift falls back to data by default.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/integer/#Integers","page":"Integers","title":"Integers","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"The default integer type in Nemo is provided by Flint. The associated ring of integers is represented by the constant parent object called FlintZZ.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"For convenience we define","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"ZZ = FlintZZ","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"so that integers can be constructed using ZZ instead of FlintZZ. Note that this is the name of a specific parent object, not the name of its type.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"The types of the integer ring parent objects and elements of the associated rings of integers are given in the following table according to the library provding them.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Library Element type Parent type\nFlint fmpz FlintIntegerRing","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"All integer element types belong directly to the abstract type RingElem and all the integer ring parent object types belong to the abstract type Ring.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"A lot of code will want to accept both fmpz integers and Julia integers, that is, subtypes of Base.Integer. Thus for convenience we define","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"IntegerUnion = Union{Integer,fmpz}","category":"page"},{"location":"Nemo/integer/#Integer-functionality","page":"Integers","title":"Integer functionality","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Nemo integers provide all of the ring and Euclidean ring functionality of AbstractAlgebra.jl.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/ring","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/euclidean_interface","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Below, we describe the functionality that is specific to the Nemo/Flint integer ring.","category":"page"},{"location":"Nemo/integer/#Constructors","page":"Integers","title":"Constructors","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"ZZ(n::Integer)","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Coerce a Julia integer value into the integer ring.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"ZZ(n::String)","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Parse the given string as an integer.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"ZZ(n::Float64)\nZZ(n::Float32)\nZZ(n::Float16)\nZZ(n::BigFloat)","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Coerce the given floating point number into the integer ring, assuming that it can be exactly represented as an integer.","category":"page"},{"location":"Nemo/integer/#Basic-manipulation","page":"Integers","title":"Basic manipulation","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"sign(::fmpz)","category":"page"},{"location":"Nemo/integer/#sign-Tuple{fmpz}","page":"Integers","title":"sign","text":"sign(a::fmpz)\n\nReturn the sign of a, i.e. +1, 0 or -1.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"size(::fmpz)","category":"page"},{"location":"Nemo/integer/#size-Tuple{fmpz}","page":"Integers","title":"size","text":"size(a::fmpz)\n\nReturn the number of limbs required to store the absolute value of a.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"fits(::Type{UInt}, ::fmpz)\nfits(::Type{Int}, ::fmpz)","category":"page"},{"location":"Nemo/integer/#fits-Tuple{Type{UInt64}, fmpz}","page":"Integers","title":"fits","text":"fits(::Type{UInt}, a::fmpz)\n\nReturn true if a fits into a UInt, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#fits-Tuple{Type{Int64}, fmpz}","page":"Integers","title":"fits","text":"fits(::Type{Int}, a::fmpz)\n\nReturn true if a fits into an Int, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"denominator(::fmpz)","category":"page"},{"location":"Nemo/integer/#denominator-Tuple{fmpz}","page":"Integers","title":"denominator","text":"denominator(a::fmpz)\n\nReturn the denominator of a thought of as a rational. Always returns 1.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"numerator(::fmpz)","category":"page"},{"location":"Nemo/integer/#numerator-Tuple{fmpz}","page":"Integers","title":"numerator","text":"numerator(a::fmpz)\n\nReturn the numerator of a thought of as a rational. Always returns a.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = ZZ(12)\n\nisunit(a)\nsign(a)\ns = size(a)\nfits(Int, a)\nn = numerator(a)\nd = denominator(a)","category":"page"},{"location":"Nemo/integer/#Euclidean-division","page":"Integers","title":"Euclidean division","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Nemo also provides a large number of Euclidean division operations. Recall that for a dividend a and divisor b, we can write a = bq + r with 0 leq r  b. We call q the quotient and r the remainder.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"We distinguish three cases. If q is rounded towards zero, r will have the same sign as a. If q is rounded towards plus infinity, r will have the opposite sign to b. Finally, if q is rounded towards minus infinity, r will have the same sign as b.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"In the following table we list the division functions and their rounding behaviour. We also give the return value of the function, with q representing return of the quotient and r representing return of the remainder.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Function Return Rounding of the quotient\nmod r towards minus infinity\nrem r towards zero\ndiv q towards minus infinity\ndivrem(a::fmpz, b::fmpz) q, r towards minus infinity\ntdivrem(a::fmpz, b::fmpz) q, r towards zero\nfdivrem(a::fmpz, b::fmpz) q, r towards minus infinity\ncdivrem(a::fmpz, b::fmpz) q, r towards plus infinity\nntdivrem(a::fmpz, b::fmpz) q, r nearest integer, ties toward zero\nnfdivrem(a::fmpz, b::fmpz) q, r nearest integer, ties toward minus infinity\nncdivrem(a::fmpz, b::fmpz) q, r nearest integer, ties toward plus infinity","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"N.B: the internal definition of Nemo.div and Nemo.divrem are the same as fdiv and fdivrem. The definitions in the table are of Base.div and Base.divrem which agree with Julia's definitions of div and divrem.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Nemo also offers the following ad hoc division operators. The notation and description is as for the other Euclidean division functions.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Function Return Rounding\nmod(a::fmpz, b::Int) r towards minus infinity\nrem(a::fmpz, b::Int) r towards zero\ndiv(a::fmpz, b::Int) q towards zero\ntdiv(a::fmpz, b::Int) q towards zero\nfdiv(a::fmpz, b::Int) q towards minus infinity\ncdiv(a::fmpz, b::Int) q towards plus infinity","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"N.B: the internal definition of Nemo.div is the same as fdiv. The definition in the table is Base.div which agrees with Julia's definition of div.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"The following functions are also available, for the case where one is dividing by a power of 2. In other words, for Euclidean division of the form a = b2^d + r. These are useful for bit twiddling.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Function Return Rounding\ntdivpow2(a::fmpz, d::Int) q towards zero\nfdivpow2(a::fmpz, d::Int) q towards minus infinity\nfmodpow2(a::fmpz, d::Int) r towards minus infinity\ncdivpow2(a::fmpz, d::Int) q towards plus infinity","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\nb = fmpz(5)\n\nq, r = divrem(a, b)\nc = cdiv(a, b)\nd = fdiv(a, b)\nf = tdivpow2(a, 2)\ng = fmodpow2(a, 3)","category":"page"},{"location":"Nemo/integer/#Comparison","page":"Integers","title":"Comparison","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Instead of isless we implement a function cmp(a, b) which returns a positive value if a  b, zero if a == b and a negative value if a  b. We then implement all the other operators, including == in terms of cmp.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"For convenience we also implement a cmpabs(a, b) function which returns a positive value if a  b, zero if a == b and a negative value if a  b. This can be slightly faster than a call to cmp or one of the comparison operators when comparing nonnegative values for example.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Here is a list of the comparison functions implemented, with the understanding that cmp provides all of the comparison operators listed above.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Function\ncmp(a::fmpz, b::fmpz)\ncmpabs(a::fmpz, b::fmpz)","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"We also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Function\ncmp(a::fmpz, b::Int)\ncmp(a::Int, b::fmpz)\ncmp(a::fmpz, b::UInt)\ncmp(a::UInt, b::fmpz)","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = ZZ(12)\nb = ZZ(3)\n\na < b\na != b\na > 4\n5 <= b\ncmpabs(a, b)","category":"page"},{"location":"Nemo/integer/#Shifting","page":"Integers","title":"Shifting","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"<<(::fmpz, ::Int)","category":"page"},{"location":"Nemo/integer/#<<-Tuple{fmpz, Int64}","page":"Integers","title":"<<","text":"<<(x::fmpz, c::Int)\n\nReturn 2^cx where c geq 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":">>(::fmpz, ::Int)","category":"page"},{"location":"Nemo/integer/#>>-Tuple{fmpz, Int64}","page":"Integers","title":">>","text":">>(x::fmpz, c::Int)\n\nReturn x2^c, discarding any remainder, where c geq 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\n\na << 3\na >> 5","category":"page"},{"location":"Nemo/integer/#Modular-arithmetic","page":"Integers","title":"Modular arithmetic","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"sqrtmod(::fmpz, ::fmpz)","category":"page"},{"location":"Nemo/integer/#sqrtmod-Tuple{fmpz, fmpz}","page":"Integers","title":"sqrtmod","text":"sqrtmod(x::fmpz, m::fmpz)\n\nReturn a square root of x (mod m) if one exists. The remainder will be in the range 0 m). We require that m is prime, otherwise the algorithm may not terminate.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"crt(::fmpz, ::fmpz, ::fmpz, m::fmpz, ::Bool)\ncrt(::fmpz, ::fmpz, ::Int, ::Int, ::Bool)","category":"page"},{"location":"Nemo/integer/#crt-Tuple{fmpz, fmpz, fmpz, fmpz, Bool}","page":"Integers","title":"crt","text":"crt(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, signed=false)\n\nReturn r such that r equiv r_1 (mod m_1) and r equiv r_2 (mod m_2). If signed = true, r will be in the range -m_1m_22  r leq m_1m_22. If signed = false the value will be in the range 0 leq r  m_1m_2.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#crt-Tuple{fmpz, fmpz, Int64, Int64, Bool}","page":"Integers","title":"crt","text":"crt(r1::fmpz, m1::fmpz, r2::Int, m2::Int, signed=false)\n\nReturn r such that r equiv r_1 (mod m_1) and r equiv r_2 (mod m_2). If signed = true, r will be in the range -m_1m_22  r leq m_1m_22. If signed = false the value will be in the range 0 leq r  m_1m_2.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"c = sqrtmod(ZZ(12), ZZ(13))\nd = crt(ZZ(5), ZZ(13), ZZ(7), ZZ(37), true)","category":"page"},{"location":"Nemo/integer/#Integer-logarithm","page":"Integers","title":"Integer logarithm","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"flog(::fmpz, ::fmpz)\nflog(::fmpz, ::Int)","category":"page"},{"location":"Nemo/integer/#flog-Tuple{fmpz, fmpz}","page":"Integers","title":"flog","text":"flog(x::fmpz, c::fmpz)\n\nReturn the floor of the logarithm of x to base c.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#flog-Tuple{fmpz, Int64}","page":"Integers","title":"flog","text":"flog(x::fmpz, c::Int)\n\nReturn the floor of the logarithm of x to base c.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"clog(::fmpz, ::fmpz)\nclog(::fmpz, ::Int)","category":"page"},{"location":"Nemo/integer/#clog-Tuple{fmpz, fmpz}","page":"Integers","title":"clog","text":"clog(x::fmpz, c::fmpz)\n\nReturn the ceiling of the logarithm of x to base c.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#clog-Tuple{fmpz, Int64}","page":"Integers","title":"clog","text":"clog(x::fmpz, c::Int)\n\nReturn the ceiling of the logarithm of x to base c.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\nb = fmpz(2)\n\nc = flog(a, b)\nd = clog(a, 3)","category":"page"},{"location":"Nemo/integer/#Integer-roots","page":"Integers","title":"Integer roots","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"isqrt(::fmpz)","category":"page"},{"location":"Nemo/integer/#isqrt-Tuple{fmpz}","page":"Integers","title":"isqrt","text":"isqrt(x::fmpz)\n\nReturn the floor of the square root of x.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"isqrtrem(::fmpz)","category":"page"},{"location":"Nemo/integer/#isqrtrem-Tuple{fmpz}","page":"Integers","title":"isqrtrem","text":"isqrtrem(x::fmpz)\n\nReturn a tuple s r consisting of the floor s of the square root of x and the remainder r, i.e. such that x = s^2 + r. We require x geq 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"root(::fmpz, ::Int)","category":"page"},{"location":"Nemo/integer/#root-Tuple{fmpz, Int64}","page":"Integers","title":"root","text":"root(x::fmpz, n::Int; check::Bool=true)\n\nReturn the n-the root of x. We require n  0 and that x geq 0 if n is even. By default the function tests whether the input was a perfect n-th power and if not raises an exception. If check=false this check is omitted.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"iroot(::fmpz, ::Int)","category":"page"},{"location":"Nemo/integer/#iroot-Tuple{fmpz, Int64}","page":"Integers","title":"iroot","text":"iroot(x::fmpz, n::Int)\n\nReturn the integer truncation of the n-the root of x (round towards zero). We require n  0 and that x geq 0 if n is even.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = ZZ(13)\nb = ZZ(27)\n\nc = isqrt(a)\ns, r = isqrtrem(a)\nd = iroot(a, 3)\nk = root(b, 3; check=true)","category":"page"},{"location":"Nemo/integer/#Number-theoretic-functionality","page":"Integers","title":"Number theoretic functionality","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"divisible(::fmpz, ::Int)\ndivisible(::fmpz, ::fmpz)","category":"page"},{"location":"Nemo/integer/#divisible-Tuple{fmpz, Int64}","page":"Integers","title":"divisible","text":"divisible(x::fmpz, y::Int)\n\nReturn true if x is divisible by y, otherwise return false. We require x neq 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#divisible-Tuple{fmpz, fmpz}","page":"Integers","title":"divisible","text":"divisible(x::fmpz, y::fmpz)\n\nReturn true if x is divisible by y, otherwise return false. We require x neq 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"issquare(::fmpz)","category":"page"},{"location":"Nemo/integer/#issquare-Tuple{fmpz}","page":"Integers","title":"issquare","text":"issquare(f::PolyElem{T}) where T <: RingElement\n\nReturn true if f is a perfect square.\n\n\n\nissquare(a::FracElem{T}) where T <: RingElem\n\nReturn true if a is a square.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"isprime(::fmpz)","category":"page"},{"location":"Nemo/integer/#isprime-Tuple{fmpz}","page":"Integers","title":"isprime","text":"isprime(x::fmpz)\n\nReturn true if x is a prime number, otherwise return false.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"isprobable_prime(::fmpz)","category":"page"},{"location":"Nemo/integer/#isprobable_prime-Tuple{fmpz}","page":"Integers","title":"isprobable_prime","text":"isprobable_prime(x::fmpz)\n\nReturn true if x is very probably a prime number, otherwise return false. No counterexamples are known to this test, but it is conjectured that infinitely many exist.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"factor(::fmpz)","category":"page"},{"location":"Nemo/integer/#factor-Tuple{fmpz}","page":"Integers","title":"factor","text":"factor(a::fmpz)\nfactor(a::UInt)\nfactor(a::Int)\n\nReturn a factorisation of a using a Fac struct (see the documentation on factorisation in Nemo).\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"divisor_lenstra(::fmpz, ::fmpz, ::fmpz)","category":"page"},{"location":"Nemo/integer/#divisor_lenstra-Tuple{fmpz, fmpz, fmpz}","page":"Integers","title":"divisor_lenstra","text":"divisor_lenstra(n::fmpz, r::fmpz, m::fmpz)\n\nIf n has a factor which lies in the residue class r (mod m) for 0  r  m  n, this function returns such a factor. Otherwise it returns 0. This is only efficient if m is at least the cube root of n. We require gcd(r m) = 1 and this condition is not checked.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"factorial(::fmpz)","category":"page"},{"location":"Nemo/integer/#factorial-Tuple{fmpz}","page":"Integers","title":"factorial","text":"factorial(x::fmpz)\n\nReturn the factorial of x, i.e. x = 123ldots x. We require x geq 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"rising_factorial(::fmpz, ::fmpz)\nrising_factorial(::fmpz, ::Int)\nrising_factorial(::Int, ::Int)","category":"page"},{"location":"Nemo/integer/#rising_factorial-Tuple{fmpz, fmpz}","page":"Integers","title":"rising_factorial","text":"rising_factorial(x::fmpz, n::fmpz)\n\nReturn the rising factorial of x, i.e. x(x + 1)(x + 2)cdots (x + n - 1). If n  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/#rising_factorial-Tuple{fmpz, Int64}","page":"Integers","title":"rising_factorial","text":"rising_factorial(x::fmpz, n::Int)\n\nReturn the rising factorial of x, i.e. x(x + 1)(x + 2)ldots (x + n - 1). If n  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/#rising_factorial-Tuple{Int64, Int64}","page":"Integers","title":"rising_factorial","text":"rising_factorial(x::Int, n::Int)\n\nReturn the rising factorial of x, i.e. x(x + 1)(x + 2)ldots (x + n - 1). If n  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"primorial(::fmpz)\nprimorial(::Int)","category":"page"},{"location":"Nemo/integer/#primorial-Tuple{fmpz}","page":"Integers","title":"primorial","text":"primorial(x::fmpz)\n\nReturn the primorial of x, i.e. the product of all primes less than or equal to x. If x  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/#primorial-Tuple{Int64}","page":"Integers","title":"primorial","text":"primorial(x::Int)\n\nReturn the primorial of x, i.e. the product of all primes less than or equal to x. If x  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"fibonacci(::Int)\nfibonacci(::fmpz)","category":"page"},{"location":"Nemo/integer/#fibonacci-Tuple{Int64}","page":"Integers","title":"fibonacci","text":"fibonacci(x::Int)\n\nReturn the x-th Fibonacci number F_x. We define F_1 = 1, F_2 = 1 and F_i + 1 = F_i + F_i - 1 for all integers i.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#fibonacci-Tuple{fmpz}","page":"Integers","title":"fibonacci","text":"fibonacci(x::fmpz)\n\nReturn the x-th Fibonacci number F_x. We define F_1 = 1, F_2 = 1 and F_i + 1 = F_i + F_i - 1 for all integers i.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"bell(::fmpz)\nbell(::Int)","category":"page"},{"location":"Nemo/integer/#bell-Tuple{fmpz}","page":"Integers","title":"bell","text":"bell(x::fmpz)\n\nReturn the Bell number B_x.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#bell-Tuple{Int64}","page":"Integers","title":"bell","text":"bell(x::Int)\n\nReturn the Bell number B_x.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"binomial(::fmpz, ::fmpz)\nbinomial(::UInt, ::UInt, ::FlintIntegerRing)","category":"page"},{"location":"Nemo/integer/#binomial-Tuple{fmpz, fmpz}","page":"Integers","title":"binomial","text":"binomial(n::fmpz, k::fmpz)\n\nReturn the binomial coefficient fracn (n-1) cdots (n-k+1)k. If k  0 we return 0, and the identity binomial(n, k) == binomial(n - 1, k - 1) + binomial(n - 1, k) always holds for integers n and k.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#binomial-Tuple{UInt64, UInt64, FlintIntegerRing}","page":"Integers","title":"binomial","text":"binomial(n::UInt, k::UInt, ::FlintIntegerRing)\n\nReturn the binomial coefficient fracn(n - k)k as an fmpz.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"moebius_mu(::Int)\nmoebius_mu(::fmpz)","category":"page"},{"location":"Nemo/integer/#moebius_mu-Tuple{Int64}","page":"Integers","title":"moebius_mu","text":"moebius_mu(x::Int)\n\nReturn the Moebius mu function of x as an Int. The value returned is either -1, 0 or 1. If x leq 0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/#moebius_mu-Tuple{fmpz}","page":"Integers","title":"moebius_mu","text":"moebius_mu(x::fmpz)\n\nReturn the Moebius mu function of x as an Int. The value returned is either -1, 0 or 1. If x leq 0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"jacobi_symbol(::Int, ::Int)\njacobi_symbol(::fmpz, ::fmpz)\nkronecker_symbol(::Int, ::Int)","category":"page"},{"location":"Nemo/integer/#jacobi_symbol-Tuple{Int64, Int64}","page":"Integers","title":"jacobi_symbol","text":"jacobi_symbol(x::Int, y::Int)\n\nReturn the value of the Jacobi symbol left(fracxyright). The modulus y must be odd and positive, otherwise a DomainError is thrown.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#jacobi_symbol-Tuple{fmpz, fmpz}","page":"Integers","title":"jacobi_symbol","text":"jacobi_symbol(x::fmpz, y::fmpz)\n\nReturn the value of the Jacobi symbol left(fracxyright). The modulus y must be odd and positive, otherwise a DomainError is thrown.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#kronecker_symbol-Tuple{Int64, Int64}","page":"Integers","title":"kronecker_symbol","text":"kronecker_symbol(x::fmpz, y::fmpz)\nkronecker_symbol(x::Int, y::Int)\n\nReturn the value of the Kronecker symbol left(fracxyright). The definition is as per Henri Cohen's book, \"A Course in Computational Algebraic Number Theory\", Definition 1.4.8.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"divisor_sigma(::Int, ::Int)\ndivisor_sigma(::fmpz, ::Int)\ndivisor_sigma(::fmpz, ::fmpz)","category":"page"},{"location":"Nemo/integer/#divisor_sigma-Tuple{Int64, Int64}","page":"Integers","title":"divisor_sigma","text":"divisor_sigma(x::Int, y::Int)\n\nReturn the value of the sigma function, i.e. sum_0  d  x d^y. If x leq 0 or y  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/#divisor_sigma-Tuple{fmpz, Int64}","page":"Integers","title":"divisor_sigma","text":"divisor_sigma(x::fmpz, y::Int)\n\nReturn the value of the sigma function, i.e. sum_0  d  x d^y. If x leq 0 or y  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/#divisor_sigma-Tuple{fmpz, fmpz}","page":"Integers","title":"divisor_sigma","text":"divisor_sigma(x::fmpz, y::fmpz)\n\nReturn the value of the sigma function, i.e. sum_0  d  x d^y. If x leq 0 or y  0 we throw a DomainError().\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"euler_phi(::Int)\neuler_phi(::fmpz)","category":"page"},{"location":"Nemo/integer/#euler_phi-Tuple{Int64}","page":"Integers","title":"euler_phi","text":"euler_phi(x::Int)\n\nReturn the value of the Euler phi function at x, i.e. the number of positive integers up to x (inclusive) that are coprime with x. An exception is raised if x leq 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#euler_phi-Tuple{fmpz}","page":"Integers","title":"euler_phi","text":"euler_phi(x::fmpz)\n\nReturn the value of the Euler phi function at x, i.e. the number of positive integers up to x (inclusive) that are coprime with x. An exception is raised if x leq 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"number_of_partitions(::Int)\nnumber_of_partitions(::fmpz) ","category":"page"},{"location":"Nemo/integer/#number_of_partitions-Tuple{Int64}","page":"Integers","title":"number_of_partitions","text":"number_of_partitions(x::Int)\n\nReturn the number of partitions of x. This function is not available on Windows 64.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#number_of_partitions-Tuple{fmpz}","page":"Integers","title":"number_of_partitions","text":"number_of_partitions(x::fmpz)\n\nReturn the number of partitions of x. This function is not available on Windows 64.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"isprime(ZZ(13))\nn = factorial(ZZ(100))\ns = divisor_sigma(ZZ(128), 10)\na = euler_phi(ZZ(12480))\np = number_of_partitions(ZZ(1000))\nf = factor(ZZ(12))","category":"page"},{"location":"Nemo/integer/#Digits-and-bases","page":"Integers","title":"Digits and bases","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"bin(::fmpz)","category":"page"},{"location":"Nemo/integer/#bin-Tuple{fmpz}","page":"Integers","title":"bin","text":"bin(n::fmpz)\n\nReturn n as a binary string.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"oct(::fmpz)","category":"page"},{"location":"Nemo/integer/#oct-Tuple{fmpz}","page":"Integers","title":"oct","text":"oct(n::fmpz)\n\nReturn n as a octal string.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"dec(::fmpz)","category":"page"},{"location":"Nemo/integer/#dec-Tuple{fmpz}","page":"Integers","title":"dec","text":"dec(n::fmpz)\n\nReturn n as a decimal string.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"hex(::fmpz)","category":"page"},{"location":"Nemo/integer/#hex-Tuple{fmpz}","page":"Integers","title":"hex","text":"hex(n::fmpz) = base(n, 16)\n\nReturn n as a hexadecimal string.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"base(::fmpz, ::Integer)","category":"page"},{"location":"Nemo/integer/#base-Tuple{fmpz, Integer}","page":"Integers","title":"base","text":"base(n::fmpz, b::Integer)\n\nReturn n as a string in base b. We require 2 leq b leq 62.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"ndigits(::fmpz, ::Integer)","category":"page"},{"location":"Nemo/integer/#ndigits-Tuple{fmpz, Integer}","page":"Integers","title":"ndigits","text":"ndigits(x::fmpz, b::Integer)\n\nReturn the number of digits of x in the base b (default is b = 10).\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"nbits(::fmpz)","category":"page"},{"location":"Nemo/integer/#nbits-Tuple{fmpz}","page":"Integers","title":"nbits","text":"nbits(x::fmpz)\n\nReturn the number of binary bits of x. We return zero if x = 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\n\ns1 = bin(a)\ns2 = base(a, 13)\nn1 = nbits(a)\nn2 = ndigits(a, 3)","category":"page"},{"location":"Nemo/integer/#Bit-twiddling","page":"Integers","title":"Bit twiddling","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"popcount(::fmpz)","category":"page"},{"location":"Nemo/integer/#popcount-Tuple{fmpz}","page":"Integers","title":"popcount","text":"popcount(x::fmpz)\n\nReturn the number of ones in the binary representation of x.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"prevpow2(::fmpz)","category":"page"},{"location":"Nemo/integer/#prevpow2-Tuple{fmpz}","page":"Integers","title":"prevpow2","text":"prevpow2(x::fmpz)\n\nReturn the previous power of 2 up to including x.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"nextpow2(::fmpz)","category":"page"},{"location":"Nemo/integer/#nextpow2-Tuple{fmpz}","page":"Integers","title":"nextpow2","text":"nextpow2(x::fmpz)\n\nReturn the next power of 2 that is at least x.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"trailing_zeros(::fmpz)","category":"page"},{"location":"Nemo/integer/#trailing_zeros-Tuple{fmpz}","page":"Integers","title":"trailing_zeros","text":"trailing_zeros(x::fmpz)\n\nReturn the number of trailing zeros in the binary representation of x.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"clrbit!(::fmpz, ::Int)\nsetbit!(::fmpz, ::Int)\ncombit!(::fmpz, ::Int)\ntstbit(::fmpz, ::Int)","category":"page"},{"location":"Nemo/integer/#clrbit!-Tuple{fmpz, Int64}","page":"Integers","title":"clrbit!","text":"clrbit!(x::fmpz, c::Int)\n\nClear bit c of x, where the least significant bit is the 0-th bit. Note that this function modifies its input in-place.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#setbit!-Tuple{fmpz, Int64}","page":"Integers","title":"setbit!","text":"setbit!(x::fmpz, c::Int)\n\nSet bit c of x, where the least significant bit is the 0-th bit. Note that this function modifies its input in-place.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#combit!-Tuple{fmpz, Int64}","page":"Integers","title":"combit!","text":"combit!(x::fmpz, c::Int)\n\nComplement bit c of x, where the least significant bit is the 0-th bit. Note that this function modifies its input in-place.\n\n\n\n","category":"method"},{"location":"Nemo/integer/#tstbit-Tuple{fmpz, Int64}","page":"Integers","title":"tstbit","text":"tstbit(x::fmpz, c::Int)\n\nReturn bit i of x (numbered from 0) as true for 1 or false for 0.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = fmpz(12)\n\np = popcount(a)\nb = nextpow2(a)\ncombit!(a, 2)","category":"page"},{"location":"Nemo/integer/#Random-generation","page":"Integers","title":"Random generation","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"rand_bits(::FlintIntegerRing, ::Int)","category":"page"},{"location":"Nemo/integer/#rand_bits-Tuple{FlintIntegerRing, Int64}","page":"Integers","title":"rand_bits","text":"rand_bits(::FlintIntegerRing, b::Int)\n\nReturn a random signed integer whose absolute value has b bits.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"rand_bits_prime(::FlintIntegerRing, ::Int, ::Bool)","category":"page"},{"location":"Nemo/integer/#rand_bits_prime-Tuple{FlintIntegerRing, Int64, Bool}","page":"Integers","title":"rand_bits_prime","text":"rand_bits_prime(::FlintIntegerRing, n::Int, proved::Bool=true)\n\nReturn a random prime number with the given number of bits. If only a probable prime is required, one can pass proved=false.\n\n\n\n","category":"method"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = rand_bits(ZZ, 23)\nb = rand_bits_prime(ZZ, 7)","category":"page"},{"location":"Nemo/integer/#Complex-Integers","page":"Integers","title":"Complex Integers","text":"","category":"section"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"The Gaussian integer type in Nemo is provided by a pair of Flint integers. The associated ring of integers is represented by the constant parent object called FlintZZi or ZZi, and the fraction field is called FlintQQi or QQi.","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"Examples","category":"page"},{"location":"Nemo/integer/","page":"Integers","title":"Integers","text":"a = ZZ(5)*im\nb = ZZi(3, 4)\n\nisunit(a)\nfactor(a)\na//b\nabs2(a//b)","category":"page"},{"location":"Hecke/quad_forms/lattices/#Quadratic-and-hermitian-lattices","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/quad_forms/lattices/#Creation-of-lattices","page":"Quadratic and hermitian lattices","title":"Creation of lattices","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"quadratic_lattice(::Field, ::MatElem; gram = nothing)\nquadratic_lattice(::Field, ::PMat; gram = nothing)\nhermitian_lattice(::NumField, ::MatElem; gram = nothing)\nhermitian_lattice(::NumField, ::PMat; gram = nothing)","category":"page"},{"location":"Hecke/quad_forms/lattices/#quadratic_lattice-Tuple{AbstractAlgebra.Field, MatElem}","page":"Quadratic and hermitian lattices","title":"quadratic_lattice","text":"quadratic_lattice(K::Field, basis::MatElem ; gram = nothing, \n\t\t\t                 check::Bool = true) -> QuadLat\n\nGiven a matrix basis and a field K, return the quadratic lattice spanned  by the rows of basis inside the quadratic space over K with Gram matrix gram.\n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over K of size the number of columns of basis.\n\nBy default, basis is checked to be of full rank. This test can be disabled by setting check to false.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#quadratic_lattice-Tuple{AbstractAlgebra.Field, Hecke.PMat}","page":"Quadratic and hermitian lattices","title":"quadratic_lattice","text":"quadratic_lattice(K::Field, B::PMat ; gram = nothing, \n\t\t\t          check:::Bool = true) -> QuadLat\n\nGiven a pseudo-matrix B with entries in a field K return the quadratic lattice spanned by the pseudo-matrix B inside the quadratic space over K with  Gram matrix gram. \n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over K of size the number of columns of B.\n\nBy default, B is checked to be of full rank. This test can be disabled by setting check to false.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#hermitian_lattice-Tuple{NumField, MatElem}","page":"Quadratic and hermitian lattices","title":"hermitian_lattice","text":"hermitian_lattice(E::NumField, basis::MatElem ; gram = nothing, \n\t\t\t                    check::Bool = true) -> HermLat\n\nGiven a matrix basis and a number field E of degree 2, return the hermitian lattice spanned by the rows of basis inside the hermitian space over E with Gram matrix gram.\n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over E of size the number of columns of basis.\n\nBy default, basis is checked to be of full rank. This test can be disabled by setting  check to false.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#hermitian_lattice-Tuple{NumField, Hecke.PMat}","page":"Quadratic and hermitian lattices","title":"hermitian_lattice","text":"hermitian_lattice(E::NumField, B::PMat ; gram = nothing, \n\t\t\t             check::Bool = true) -> HermLat\n\nGiven a pseudo-matrix B with entries in a number field E of degree 2,  return the hermitian lattice spanned by the pseudo-matrix B inside the hermitian  space over E with Gram matrix gram.\n\nIf gram is not supplied, the Gram matrix of the ambient space will be the identity matrix over E of size the number of columns of B.\n\nBy default, B is checked to be of full rank. This test can be disabled by setting  check to false.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Basic-invariants","page":"Quadratic and hermitian lattices","title":"Basic invariants","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"ambient_space(L::AbsLat)\nrational_span(::AbsLat)\nfixed_field(L::AbsLat)\ninvolution(::AbsLat)\nrank(L::AbsLat)\ndegree(L::AbsLat)\ngenerators(L::AbsLat; minimal::Bool = false)\ndiscriminant(L::AbsLat)\npseudo_matrix(L::AbsLat)\ncoefficient_ideals(L::AbsLat)\nabsolute_basis(L::AbsLat)\nabsolute_basis_matrix(L::AbsLat)","category":"page"},{"location":"Hecke/quad_forms/lattices/#ambient_space-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"ambient_space","text":"ambient_space(L::AbsLat) -> AbsSpace\n\nReturn the ambient space of the lattice L. If the ambient space is not known, an error is raised.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#rational_span-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"rational_span","text":"rational_span(L::AbsLat) -> AbsSpace\n\nReturn the rational span of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#fixed_field-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"fixed_field","text":"fixed_field(L::AbsLat) -> Field\n\nReturns the fixed field of the involution of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#involution-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"involution","text":"involution(L::AbsLat) -> Map\n\nReturn the involution of the rational span of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#rank-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"rank","text":"rank(L::AbsLat) -> Int\n\nReturn the rank of the underlying module of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#degree-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"degree","text":"degree(L::AbsLat) -> Int\n\nReturn the dimension of the ambient space of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#generators-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"generators","text":"generators(L::AbsLat; minimal = false) -> Vector{Vector}\n\nReturn a set of generators of the lattice L over the base ring of L.\n\nIf minimal == true, the number of generators is minimal. Note that computing minimal generators is expensive.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#discriminant-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"discriminant","text":"discriminant(L::AbsLat) -> NfOrdFracIdl\n\nReturn the discriminant of the lattice L, that is, the generalized index ideal L^  L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#pseudo_matrix-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"pseudo_matrix","text":"pseudo_matrix(L::AbsLat) -> PMat\n\nReturn a basis pseudo-matrix of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#coefficient_ideals-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"coefficient_ideals","text":"coefficient_ideals(L::AbsLat) -> Vector{NfOrdIdl}\n\nReturn the coefficient ideals of a pseudo-basis of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#absolute_basis-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"absolute_basis","text":"absolute_basis(L::AbsLat) -> Vector\n\nReturn a mathbfZ-basis of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#absolute_basis_matrix-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"absolute_basis_matrix","text":"absolute_basis_matrix(L::AbsLat) -> MatElem\n\nReturn a mathbfZ-basis matrix of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Rational-invariants","page":"Quadratic and hermitian lattices","title":"Rational invariants","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"hasse_invariant(L::QuadLat, p)\nwitt_invariant(L::QuadLat, p::NfAbsOrdIdl)\nisrationally_isometric(::AbsLat, ::AbsLat, ::NfAbsOrdIdl)\nisrationally_isometric(L::AbsLat, M::AbsLat)","category":"page"},{"location":"Hecke/quad_forms/lattices/#hasse_invariant-Tuple{QuadLat, Any}","page":"Quadratic and hermitian lattices","title":"hasse_invariant","text":"hasse_invariant(L::AbsLat, p::Union{InfPlc, NfOrdIdl}) -> Int\n\nReturn the Hasse invariant of the rational span of the lattice L at the place p.  The lattice must be quadratic.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#witt_invariant-Tuple{QuadLat, NfAbsOrdIdl}","page":"Quadratic and hermitian lattices","title":"witt_invariant","text":"witt_invariant(L::AbsLat, p::Union{InfPlc, NfOrdIdl}) -> Int\n\nReturn the Witt invariant of the rational span of the lattice L at the place p.  The lattice must be quadratic.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#isrationally_isometric-Tuple{Hecke.AbsLat, Hecke.AbsLat, NfAbsOrdIdl}","page":"Quadratic and hermitian lattices","title":"isrationally_isometric","text":"isrationally_isometric(L::AbsLat, M::AbsLat, p::Union{InfPlc, NfOrdIdl})\n                                                                     -> Bool\n\nReturn whether the rational spans of the lattices L and M are isometric over  the completion at the place p.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#isrationally_isometric-Tuple{Hecke.AbsLat, Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"isrationally_isometric","text":"isrationally_isometric(L::AbsLat, M::AbsLat) -> Bool\n\nReturn whether the rational spans of the lattices L and M are isometric.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Definiteness","page":"Quadratic and hermitian lattices","title":"Definiteness","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"ispositive_definite(L::AbsLat)\nisnegative_definite(L::AbsLat)\nisdefinite(L::AbsLat)\ncan_scale_totally_positive(L::AbsLat)","category":"page"},{"location":"Hecke/quad_forms/lattices/#ispositive_definite-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"ispositive_definite","text":"ispositive_definite(L::AbsLat) -> Bool\n\nReturn whether the rational span of the lattice L is positive definite.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#isnegative_definite-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"isnegative_definite","text":"isnegative_definite(L::AbsLat) -> Bool\n\nReturn whether the rational span of the lattice L is negative definite.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#isdefinite-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"isdefinite","text":"isdefinite(L::AbsLat) -> Bool\n\nReturn whether the rational span of the lattice L is definite.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#can_scale_totally_positive-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"can_scale_totally_positive","text":"can_scale_totally_positive(L::AbsLat) -> Bool, NumFieldElem\n\nReturn whether there is a totally positive rescaled lattice of the lattice L.  If so, the second returned value is an element a such that L^a is totally positive.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Module-operations","page":"Quadratic and hermitian lattices","title":"Module operations","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"Base.:(*)(::NumFieldElem, ::AbsLat)\nBase.:(*)(::NfOrdIdl, ::AbsLat)\nBase.:(*)(::NfOrdFracIdl, ::AbsLat)\nrescale(::AbsLat, ::NumFieldElem)\ndual(::AbsLat)","category":"page"},{"location":"Hecke/quad_forms/lattices/#*-Tuple{NumFieldElem, Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"*","text":"*(a::NumFieldElem, L::AbsLat) -> AbsLat\n\nReturn the lattice aL inside the ambient space of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#*-Tuple{NfOrdIdl, Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"*","text":"*(a::NfRelOrdIdl, L::AbsLat) -> AbsLat\n\nReturn the lattice aL inside the ambient space of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#*-Tuple{Hecke.NfAbsOrdFracIdl{AnticNumberField, nf_elem}, Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"*","text":"*(a::NfOrdFracIdl, L::AbsLat) -> AbsLat\n\nReturn the lattice aL inside the ambient space of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#rescale-Tuple{Hecke.AbsLat, NumFieldElem}","page":"Quadratic and hermitian lattices","title":"rescale","text":"rescale(L::AbsLat, a::NumFieldElem) -> AbsLat\n\nReturn the rescaled lattice L^a. Note that this has a different ambient space than the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#dual-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"dual","text":"dual(L::AbsLat) -> AbsLat\n\nReturn the dual lattice of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Invariants","page":"Quadratic and hermitian lattices","title":"Invariants","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"norm(::AbsLat)\nscale(L::AbsLat)\nisintegral(L::AbsLat)\nvolume(L::AbsLat)\nismodular(L::AbsLat)","category":"page"},{"location":"Hecke/quad_forms/lattices/#norm-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"norm","text":"norm(L::AbsLat) -> NfOrdFracIdl\n\nReturn the norm of the lattice L. This is a fractional ideal of the fixed field  of L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#scale-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"scale","text":"scale(L::AbsLat) -> NfOrdFracIdl\n\nReturn the scale of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#isintegral-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"isintegral","text":"isintegral(L::AbsLat) -> Bool\n\nReturn whether the lattice L is integral.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#volume-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"volume","text":"volume(L::AbsLat) -> NfOrdFracIdl\n\nReturn the volume of the lattice L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#ismodular-Tuple{Hecke.AbsLat}","page":"Quadratic and hermitian lattices","title":"ismodular","text":"ismodular(L::AbsLat) -> Bool, NfOrdFracIdl\n\nReturn whether the lattice L is modular. In this case, the second returned value  is a fractional ideal mathfrak a of the base algebra of L such that  mathfrak a L^ = L, where L^ is the dual of 'L'.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Local-properties","page":"Quadratic and hermitian lattices","title":"Local properties","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"local_basis_matrix(L::AbsLat, p; type::Symbol = :any)\njordan_decomposition(L::AbsLat, p::NfOrdIdl)\nislocally_isometric(::AbsLat, ::AbsLat, ::NfOrdIdl)","category":"page"},{"location":"Hecke/quad_forms/lattices/#local_basis_matrix-Tuple{Hecke.AbsLat, Any}","page":"Quadratic and hermitian lattices","title":"local_basis_matrix","text":"local_basis_matrix(L::AbsLat, p::NfOrdIdl; type = :any) -> MatElem\n\nGiven a prime ideal p and a lattice L, return a basis matrix of a lattice  M such that M_p = L_p. Note that if p is an ideal in the base ring of L, the completions are taken at the minimum of p (which is an ideal in the base ring of the order of p).\n\nIf type == :submodule, the lattice L will be a sublattice of M.\nIf type == :supermodule, the lattice L will be a superlattice of M.\nIf type == :any, there may not be any containment relation between M and L.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#jordan_decomposition-Tuple{Hecke.AbsLat, NfOrdIdl}","page":"Quadratic and hermitian lattices","title":"jordan_decomposition","text":"jordan_decomposition(L::AbsLat, p::NfOrdIdl)\n                            -> Vector{MatElem}, Vector{MatElem}, Vector{Int}\n\nReturn a Jordan decomposition of the completion of the lattice L at a prime  ideal p.\n\nThe returned value consists of three lists (M_i)_i, (G_i)_i and (s_i)_i of the same length r. The completions of the row spans of the matrices M_i yield a Jordan decomposition of L_p into modular sublattices L_i with Gram matrices G_i and scale of p-adic valuation s_i.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#islocally_isometric-Tuple{Hecke.AbsLat, Hecke.AbsLat, NfOrdIdl}","page":"Quadratic and hermitian lattices","title":"islocally_isometric","text":"islocally_isometric(L::AbsLat, M::AbsLat, p::NfOrdIdl) -> Bool\n\nReturn whether the completions of the lattices L and M at the prime ideal p are isometric.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Genera","page":"Quadratic and hermitian lattices","title":"Genera","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/#Creation-of-genera-from-lattices","page":"Quadratic and hermitian lattices","title":"Creation of genera from lattices","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"genus(L::HermLat, p)\ngenus(L::HermLat)","category":"page"},{"location":"Hecke/quad_forms/lattices/#genus-Tuple{HermLat, Any}","page":"Quadratic and hermitian lattices","title":"genus","text":"genus(L::HermLat, p::NfOrdIdl) -> LocalGenusHerm\n\nReturn the local genus symbol g for hermitian lattices over EK of the completion  of the hermitian lattice L at the prime ideal p of O_K.\n\nSee [Kir16, Definition 8.3.1].\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#genus-Tuple{HermLat}","page":"Quadratic and hermitian lattices","title":"genus","text":"genus(L::HermLat) -> GenusHerm\n\nReturn the global genus symbol G of the hermitian lattice L. G satisfies:\n\nits local genus symbols correspond to those of the completions of L at the bad  prime ideals of L, i.e. the prime ideals dividing either the scale of L, or the  volume of L, or the discriminant of O_E, and also the dyadic prime ideals of O_K;\nsignatures are those of the Gram matrix of the rational span of L. They are given  at the real infinite places of K which splits into complex places of E.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Properties-of-genera","page":"Quadratic and hermitian lattices","title":"Properties of genera","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"rank(G::LocalGenusHerm)\nrank(G::LocalGenusHerm, i::Int)\nranks(G::LocalGenusHerm)\ndet(G::LocalGenusHerm)\ndet_representative(G::LocalGenusHerm)\ngram_matrix(G::LocalGenusHerm)\nprimes(G::GenusHerm)","category":"page"},{"location":"Hecke/quad_forms/lattices/#rank-Tuple{Hecke.LocalGenusHerm}","page":"Quadratic and hermitian lattices","title":"rank","text":"rank(g::LocalGenusHerm) -> Int\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of O_K, return the rank of any hermitian lattice whose mathfrak p-adic completion has local genus symbol g.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#rank-Tuple{Hecke.LocalGenusHerm, Int64}","page":"Quadratic and hermitian lattices","title":"rank","text":"rank(g::LocalGenusHerm, i::Int) -> Int\n\nGiven a local genus symbol g for hermitian lattices, return the rank of the ith Jordan block of g.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#ranks-Tuple{Hecke.LocalGenusHerm}","page":"Quadratic and hermitian lattices","title":"ranks","text":"ranks(g::LocalGenusHerm) -> Vector{Int}\n\nGiven a local genus symbol g for hermitian lattices, return the ranks of the Jordan blocks of g.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#det-Tuple{Hecke.LocalGenusHerm}","page":"Quadratic and hermitian lattices","title":"det","text":"det(g::LocalGenusHerm) -> Int\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of O_K, return the determinant of a hermitian lattice whose mathfrak p-adic completion has local genus symbol g. \n\nThe returned value is 1 or -1 depending on whether the determinant is a local norm in K.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#det_representative-Tuple{Hecke.LocalGenusHerm}","page":"Quadratic and hermitian lattices","title":"det_representative","text":"det_representative(g::LocalGenusHerm) -> NumFieldElem\n\nGiven a local genus symbol g for hermitian lattices over EK, return a  representative of the norm class of the determinant of g in K^times.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#gram_matrix-Tuple{Hecke.LocalGenusHerm}","page":"Quadratic and hermitian lattices","title":"gram_matrix","text":"gram_matrix(g::LocalGenusHerm) -> MatElem\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal mathfrak p of O_K, return a Gram matrix M of g, with coefficients in E. M is such that any hermitian lattice over EK with Gram matrix M satisfies  that the local genus symbol of its completion at mathfrak p is g.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#primes-Tuple{Hecke.GenusHerm}","page":"Quadratic and hermitian lattices","title":"primes","text":"primes(G::GenusHerm) -> Vector{NfOrdIdl}\n\nGiven a global genus symbol G for hermitian lattices over EK, return the list of prime ideals of O_K at which G has a local genus symbol.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Check-if-lattice-is-contained-in-genus","page":"Quadratic and hermitian lattices","title":"Check if lattice is contained in genus","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"Base.in(L::HermLat, G::LocalGenusHerm)\nBase.in(L::HermLat, G::GenusHerm)","category":"page"},{"location":"Hecke/quad_forms/lattices/#in-Tuple{HermLat, Hecke.LocalGenusHerm}","page":"Quadratic and hermitian lattices","title":"in","text":"in(L::HermLat, g::LocalGenusHerm) -> Bool\n\nReturn whether g and the local genus symbol of the completion of the hermitian lattice L at prime(g) agree. Note that L being in g requires both L and  g to be defined over the same extension EK.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/#in-Tuple{HermLat, Hecke.GenusHerm}","page":"Quadratic and hermitian lattices","title":"in","text":"in(L::HermLat, G::GenusHerm) -> Bool\n\nReturn whether G and the global genus symbol of the hermitian lattice L agree.\n\n\n\n","category":"method"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"","category":"page"},{"location":"Hecke/quad_forms/lattices/#Creating-representatives","page":"Quadratic and hermitian lattices","title":"Creating representatives","text":"","category":"section"},{"location":"Hecke/quad_forms/lattices/","page":"Quadratic and hermitian lattices","title":"Quadratic and hermitian lattices","text":"representative(G::LocalGenusHerm)","category":"page"},{"location":"Hecke/quad_forms/lattices/#representative-Tuple{Hecke.LocalGenusHerm}","page":"Quadratic and hermitian lattices","title":"representative","text":"representative(g::LocalGenusHerm) -> HermLat\n\nGiven a local genus symbol g for hermitian lattices over EK at a prime ideal  mathfrak p of O_K, return a hermitian lattice over EK whose completion at  mathfrak p admits g as local genus symbol.\n\n\n\n","category":"method"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"CurrentModule = Nemo","category":"page"},{"location":"Nemo/series/#Power-series-and-Laurent-series","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Nemo allows the creation of capped relative and absolute power series over any computable ring R. Capped relative power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_k-1x^k-1 + O(x^k) where j geq 0, a_j in R and the relative precision k - j is at most equal to some specified precision n. On the other hand capped absolute power series are power series of the form a_jx^j + a_j+1x^j+1 + cdots + a_n-1x^n-1 + O(x^n) where j geq 0, a_j in R and the precision n is fixed.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"There are two different kinds of implementation: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of power series over numerous specific rings, usually provided by C/C++ libraries.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The following table shows each of the relative power series types available in Nemo, the base ring R, and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl `Generic.RelSeries{T} Generic.RelSeriesRing{T}\nmathbbZ Flint fmpz_rel_series FmpzRelSeriesRing\nmathbbZnmathbbZ (small n) Flint nmod_rel_series NmodRelSeriesRing\nmathbbZnmathbbZ (large n) Flint fmpz_mod_rel_series FmpzModRelSeriesRing\nmathbbQ Flint fmpq_rel_series FmpqRelSeriesRing\nmathbbF_p (small n) Flint gfp_rel_series GFPRelSeriesRing\nmathbbF_p (large n) Flint gfp_fmpz_rel_series GFPFmpzRelSeriesRing\nmathbbF_p^n (small p) Flint fq_nmod_rel_series FqNmodRelSeriesRing\nmathbbF_p^n (large p) Flint fq_rel_series FqRelSeriesRing","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"All relative power series elements belong to the abstract type RelSeriesElem and all of the relative power series ring types belong to the abstract type RelSeriesRing.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The maximum relative precision, the string representation of the variable and the base ring R of a generic power series are stored in its parent object. ","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Here is the corresponding table for the absolute power series types.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.AbsSeries{T} Generic.AbsSeriesRing{T}\nmathbbZ Flint fmpz_abs_series FmpzAbsSeriesRing\nmathbbZnmathbbZ (small n) Flint nmod_abs_series NmodAbsSeriesRing\nmathbbZnmathbbZ (large n) Flint fmpz_mod_abs_series FmpzModAbsSeriesRing\nmathbbQ Flint fmpq_abs_series FmpqAbsSeriesRing\nmathbbF_p (small n) Flint gfp_abs_series GFPAbsSeriesRing\nmathbbF_p (large n) Flint gfp_fmpz_abs_series GFPFmpzAbsSeriesRing\nmathbbF_p^n (small n) Flint fq_nmod_abs_series FqNmodAbsSeriesRing\nmathbbF_p^n (large n) Flint fq_abs_series FqAbsSeriesRing","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"All absolute power series elements belong to the abstract type AbsSeriesElem and all of the absolute power series ring types belong to the abstract type AbsSeriesRing.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The absolute precision, the string representation of the variable and the base ring R of a generic power series are stored in its parent object. ","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"All power series element types belong to the abstract type SeriesElem and all of the power series ring types belong to the abstract type SeriesRing. This enables one to write generic functions that can accept any Nemo power series type.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"AbstractAlgebra.jl also provides Nemo with a generic implementation of Laurent series over a given ring R. For completeness, we list it here.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Base ring Library Element type Parent type\nGeneric ring R AbstractAlgebra.jl Generic.LaurentSeriesRingElem{T} Generic.LaurentSeriesRing{T}\nGeneric field K AbstractAlgebra.jl Generic.LaurentSeriesFieldElem{T} ","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Generic.LaurentSeriesField{T}","category":"page"},{"location":"Nemo/series/#Capped-relative-power-series","page":"Power series and Laurent series","title":"Capped relative power series","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Capped relative power series have their maximum relative precision capped at some value prec_max. This means that if the leading term of a nonzero power series element is c_ax^a and the precision is b then the power series is of the form  c_ax^a + c_a+1x^a+1 + ldots + O(x^a + b).","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The zero power series is simply taken to be 0 + O(x^b).","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series f and g we have that divexact(f*g), g) == f.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"However, capped relative power series are not additively stable, i.e. we do not always have (f + g) - g = f.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"In the capped relative model we say that two power series are equal if they agree up to the minimum absolute precision of the two power series. Thus, for example, x^5 + O(x^10) == 0 + O(x^5), since the minimum absolute precision is 5.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"During computations, it is possible for power series to lose relative precision due to cancellation. For example if f = x^3 + x^5 + O(x^8) and g = x^3 + x^6 + O(x^8) then f - g = x^5 - x^6 + O(x^8) which now has relative precision 3 instead of relative precision 5.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Amongst other things, this means that equality is not transitive. For example x^6 + O(x^11) == 0 + O(x^5) and x^7 + O(x^12) == 0 + O(x^5) but x^6 + O(x^11) neq x^7 + O(x^12).","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the isequal function.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"For example, if f = x^2 + O(x^7) and g = x^2 + O(x^8) and h = 0 + O(x^2) then f == g, f == h and g == h, but isequal(f, g), isequal(f, h) and isequal(g, h) would all return false. However, if k = x^2 + O(x^7) then isequal(f, k) would return true.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in y over the power series ring in x over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of (0 + O(x^10))y + (1 + O(x^10))?","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"If one takes it to be (0 + O(x^10)) then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Simply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!","category":"page"},{"location":"Nemo/series/#Capped-absolute-power-series","page":"Power series and Laurent series","title":"Capped absolute power series","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"An absolute power series ring over a ring R with precision p behaves  very much like the quotient Rx(x^p) of the polynomial ring over R.","category":"page"},{"location":"Nemo/series/#Power-series-functionality","page":"Power series and Laurent series","title":"Power series functionality","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Power series rings in Nemo provide all the functionality described for power series in AbstractAlgebra:","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"https://nemocas.github.io/AbstractAlgebra.jl/stable/series","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"In addition, generic power series and Laurent series are provided by AbstractAlgebra.","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"We list below only the functionality that is Nemo specific for power series rings.","category":"page"},{"location":"Nemo/series/#Special-functions","page":"Power series and Laurent series","title":"Special functions","text":"","category":"section"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"Examples","category":"page"},{"location":"Nemo/series/","page":"Power series and Laurent series","title":"Power series and Laurent series","text":"S, x = PowerSeriesRing(R, 30, \"x\")\nT, z = PowerSeriesRing(QQ, 30, \"z\")\n\na = 1 + z + 3z^2 + O(z^5)\nb = z + 2z^2 + 5z^3 + O(z^5)\n\nd = divexact(x, exp(x + O(x^40)) - 1)\nf = exp(b)\ng = log(a)\nh = sqrt(a)\nk = sin(b)\nm = atanh(b)","category":"page"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"CurrentModule = Hecke\nDocTestSetup = quote\n    using Hecke\n  end","category":"page"},{"location":"Hecke/number_fields/elements/#Element-operations","page":"Element operations","title":"Element operations","text":"","category":"section"},{"location":"Hecke/number_fields/elements/#Creation","page":"Element operations","title":"Creation","text":"","category":"section"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"gen(::SimpleNumField)\ngens(::NonSimpleNumField)","category":"page"},{"location":"Hecke/number_fields/elements/#gen-Tuple{SimpleNumField}","page":"Element operations","title":"gen","text":"gen(L::SimpleNumField) -> NumFieldElem\n\nGiven a simple number field L = Kx(x) over K, this functions returns the class of x, which is the canonical primitive element of L over K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#gens-Tuple{NonSimpleNumField}","page":"Element operations","title":"gens","text":"gens(L::NonSimpleNumField) -> Vector{NumFieldElem}\n\nGiven a non-simple number field L = Kx_1dotscx_n(f_1dotscf_n) over K, this functions returns the list bar x_1dotscbar x_n.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"Elements can also be created by specifying the coordinates with respect to the basis of the number field:","category":"page"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"    (L::NumberField)(c::Vector{NumFieldElem}) -> NumFieldElem","category":"page"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"Given a number field LK of degree d and a vector c length d, this constructs the element a with coordinates(a) == c.","category":"page"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"julia> Qx, x = QQ[\"x\"];\n\njulia> K, a = NumberField(x^2 - 2, \"a\");\n\njulia> K([1, 2])\n2*a + 1\n\njulia> L, b = radical_extension(3, a, \"b\")\n(Relative number field over with defining polynomial x^3 - a\n over Number field over Rational Field with defining polynomial x^2 - 2, b)\n\njulia> L([a, 1, 1//2])\n1//2*b^2 + b + a","category":"page"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"quadratic_defect(a::NumFieldElem, p)\nhilbert_symbol(a::nf_elem, b::nf_elem, p::Union{NfAbsOrdIdl, NfRelOrdIdl})\nrepresentation_matrix(::NumFieldElem)\nbasis_matrix(::Vector{nf_elem})\ncoefficients(::SimpleNumFieldElem)\ncoordinates(::NumFieldElem)\nabsolute_coordinates(::NumFieldElem)\ncoeff(::SimpleNumFieldElem, ::Int)\nvaluation(::NumFieldElem, ::Any)\ntorsion_unit_order(::nf_elem, ::Int)\ntr(::NumFieldElem)\nabsolute_tr(::NumFieldElem)\nalgebraic_split(::nf_elem)","category":"page"},{"location":"Hecke/number_fields/elements/#quadratic_defect-Tuple{NumFieldElem, Any}","page":"Element operations","title":"quadratic_defect","text":"quadratic_defect(a::Union{NumFieldElem,Rational,fmpq}, p) -> Union{Inf, PosInf}\n\nReturns the valuation of the quadratic defect of the element a at p, which can either be prime object or an infinite place of the parent of a.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#hilbert_symbol-Tuple{nf_elem, nf_elem, Union{NfAbsOrdIdl, Hecke.NfRelOrdIdl}}","page":"Element operations","title":"hilbert_symbol","text":"hilbert_symbol(a::NumFieldElem, b::NumFieldElem, p::NfOrdIdl) -> Int\n\nReturns the local Hilbert symbol (ab)_p.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#representation_matrix-Tuple{NumFieldElem}","page":"Element operations","title":"representation_matrix","text":"representation_matrix(a::NumFieldElem) -> MatElem\n\nReturns the representation matrix of a, that is, the matrix representing multiplication with a with respect to the canonical basis of the parent of a.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#basis_matrix-Tuple{Vector{nf_elem}}","page":"Element operations","title":"basis_matrix","text":"basis_matrix(v::Vector{NumFieldElem}) -> Mat\n\nGiven a vector v of n elements of a number field K of degree d, this function returns an n x d matrix with entries in the base field of K, where row i contains the coefficients of vi with respect of the canonical basis of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#coefficients-Tuple{SimpleNumFieldElem}","page":"Element operations","title":"coefficients","text":"coefficients(a::SimpleNumFieldElem, i::Int) -> Vector{FieldElem}\n\nGiven a number field element a of a simple number field extension L/K, this function returns the coefficients of a, when expanded in the canonical power basis of L.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#coordinates-Tuple{NumFieldElem}","page":"Element operations","title":"coordinates","text":"coordinates(x::NumFieldElem{T}) -> Vector{T}\n\nGiven an element x in a number field K, this function returns the coordinates of x with respect to the basis of K (the output of the 'basis' function).\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#absolute_coordinates-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_coordinates","text":"absolute_coordinates(x::NumFieldElem{T}) -> Vector{T}\n\nGiven an element x in a number field K, this function returns the coordinates of x with respect to the basis of K over the rationals (the output of the 'absolute_basis' function).\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#coeff-Tuple{SimpleNumFieldElem, Int64}","page":"Element operations","title":"coeff","text":"coeff(a::SimpleNumFieldElem, i::Int) -> FieldElem\n\nGiven a number field element a of a simple number field extension L/K, this function returns the i-th coefficient of a, when expanded in the canonical power basis of L. The result is an element of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#valuation-Tuple{NumFieldElem, Any}","page":"Element operations","title":"valuation","text":"valuation(a::NumFieldElem, p::NfOrdIdl) -> fmpz\n\nComputes the mathfrak p-adic valuation of a, that is, the largest i such that a is contained in mathfrak p^i.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#torsion_unit_order-Tuple{nf_elem, Int64}","page":"Element operations","title":"torsion_unit_order","text":"torsion_unit_order(x::nf_elem, n::Int)\n\nGiven a torsion unit x together with a multiple n of its order, compute the order of x, that is, the smallest k in mathbb Z_geq 1 such that x^k = 1.\n\nIt is not checked whether x is a torsion unit.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#tr-Tuple{NumFieldElem}","page":"Element operations","title":"tr","text":"tr(a::NumFieldElem) -> NumFieldElem\n\nReturns the trace of an element a of a number field extension LK. This will be an element of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#absolute_tr-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_tr","text":"absolute_tr(a::NumFieldElem) -> fmpq\n\nGiven a number field element a, returns the absolute trace of a.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#algebraic_split-Tuple{nf_elem}","page":"Element operations","title":"algebraic_split","text":"algebraic_split(a::nf_elem) -> nf_elem, nf_elem\n\nWrites the input as a quotient of two \"small\" algebraic integers.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#Conjugates","page":"Element operations","title":"Conjugates","text":"","category":"section"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"conjugates(::NumFieldElem, ::AcbField)\nconjugates(::NumFieldElem)\nconjugates_log(::nf_elem, ::Int)\nconjugates_real(::nf_elem)\nconjugates_complex(::nf_elem)\nevaluate(::nf_elem, ::InfPlc)\nconjugates_arb_log_normalise(::nf_elem)\nminkowski_map(::nf_elem)\nisnegative(::nf_elem, ::InfPlc)","category":"page"},{"location":"Hecke/number_fields/elements/#conjugates-Tuple{NumFieldElem, AcbField}","page":"Element operations","title":"conjugates","text":"conjugates(x::nf_elem, C::AcbField) -> Vector{acb}\n\nCompute the conjugates of x as elements of type acb. Recall that we order the complex conjugates sigma_r+1(x)sigma_r+2s(x) such that sigma_i(x) = overlinesigma_i + s(x) for r + 1 leq i leq r + s.\n\nLet p be the precision of C, then every entry y of the vector returned satisfies radius(real(y)) < 2^-p and radius(imag(y)) < 2^-p respectively.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#conjugates-Tuple{NumFieldElem}","page":"Element operations","title":"conjugates","text":"conjugates(x::nf_elem, abs_tol::Int) -> Vector{acb}\n\nCompute the conjugates of x as elements of type acb. Recall that we order the complex conjugates sigma_r+1(x)sigma_r+2s(x) such that sigma_i(x) = overlinesigma_i + s(x) for r + 1 leq i leq r + s.\n\nEvery entry y of the vector returned satisfies radius(real(y)) < 2^-abs_tol and radius(imag(y)) < 2^-abs_tol respectively.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#conjugates_log-Tuple{nf_elem, Int64}","page":"Element operations","title":"conjugates_log","text":"conjugates_arb_log(x::nf_elem, abs_tol::Int) -> Vector{arb}\n\nReturns the elements (log(lvert sigma_1(x) rvert)dotsclog(lvertsigma_r(x) rvert) dotsc2log(lvert sigma_r+1(x) rvert)dotsc 2log(lvert sigma_r+s(x)rvert)) as elements of type arb with radius less then 2^-abs_tol.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#conjugates_real-Tuple{nf_elem}","page":"Element operations","title":"conjugates_real","text":"conjugates_arb_real(x::nf_elem, abs_tol::Int) -> Vector{arb}\n\nCompute the real conjugates of x as elements of type arb.\n\nEvery entry y of the array returned satisfies radius(y) < 2^-abs_tol.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#conjugates_complex-Tuple{nf_elem}","page":"Element operations","title":"conjugates_complex","text":"conjugates_complex(x::nf_elem, abs_tol::Int) -> Vector{acb}\n\nCompute the complex conjugates of x as elements of type acb. Recall that we order the complex conjugates sigma_r+1(x)sigma_r+2s(x) such that sigma_i(x) = overlinesigma_i + s(x) for r + 1 leq i leq r + s.\n\nEvery entry y of the array returned satisfies radius(real(y)) < 2^-abs_tol and radius(imag(y)) < 2^-abs_tol.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#evaluate-Tuple{nf_elem, InfPlc}","page":"Element operations","title":"evaluate","text":"evaluate(a::nf_elem, P::InfPlc, p::Int = 20)\n\nThe evaluation of a at the place P, i.e. a real or complex value. p specifies the precision to be returned.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#conjugates_arb_log_normalise-Tuple{nf_elem}","page":"Element operations","title":"conjugates_arb_log_normalise","text":"conjugates_arb_log_normalise(x::nf_elem, p::Int = 10)\nconjugates_arb_log_normalise(x::FacElem{nf_elem, AnticNumberField}, p::Int = 10)\n\nThe \"normalised\" logarithms, i.e. the array c_ilog x^(i) - 1nlogN(x), so the (weighted) sum adds up to zero.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#minkowski_map-Tuple{nf_elem}","page":"Element operations","title":"minkowski_map","text":"minkowski_map(a::nf_elem, abs_tol::Int) -> Vector{arb}\n\nReturns the image of a under the Minkowski embedding. Every entry of the array returned is of type arb with radius less then 2^(-abs_tol).\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#isnegative-Tuple{nf_elem, InfPlc}","page":"Element operations","title":"isnegative","text":"isnegative(a::nf_elem, P::InfPlc)          -> Bool\nisnegative(a::FacElem{nf_elem}, P::InfPlc) -> Bool\n\nReturns whether the element a is negative at the embedding corresponding to P. The place P must be real.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#Predicates","page":"Element operations","title":"Predicates","text":"","category":"section"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"isintegral(::NumFieldElem)\nistorsion_unit(::nf_elem)\nislocal_norm(::NumField, ::NumFieldElem, ::Any)\nisnorm_divisible(::nf_elem, ::fmpz)\nisnorm(::AnticNumberField, ::fmpz)","category":"page"},{"location":"Hecke/number_fields/elements/#isintegral-Tuple{NumFieldElem}","page":"Element operations","title":"isintegral","text":"isintegral(a::NumFieldElem) -> Bool\n\nReturns whether a is integral, that is, whether the minimal polynomial of a has integral coefficients.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#istorsion_unit-Tuple{nf_elem}","page":"Element operations","title":"istorsion_unit","text":"istorsion_unit(x::nf_elem, checkisunit::Bool = false) -> Bool\n\nReturns whether x is a torsion unit, that is, whether there exists n such that x^n = 1.\n\nIf checkisunit is true, it is first checked whether x is a unit of the maximal order of the number field x is lying in.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#islocal_norm-Tuple{NumField, NumFieldElem, Any}","page":"Element operations","title":"islocal_norm","text":"islocal_norm(L::NumField, a::NumFieldElem, P)\n\nGiven a number field LK, an element a in K and a prime ideal P of K, returns whether a is a local norm at P.\n\nThe number field LK must be a simple extension of degree 2.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#isnorm_divisible-Tuple{nf_elem, fmpz}","page":"Element operations","title":"isnorm_divisible","text":"isnorm_divisible(a::nf_elem, n::fmpz) -> Bool\n\nChecks if the norm of a is divisible by n, assuming that the norm of a is an integer.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#isnorm-Tuple{AnticNumberField, fmpz}","page":"Element operations","title":"isnorm","text":"isnorm(K::AnticNumberField, a::fmpz; extra::Vector{fmpz}) -> Bool, nf_elem\n\nFor a fmpz a, try to find T in K s.th. N(T) = a holds. If successful, return true and T, otherwise false and some element. In \\testtt{extra} one can pass in additional prime numbers that are allowed to occur in the solution. This will then be supplemented. The element will be returned in factored form.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#Invariants","page":"Element operations","title":"Invariants","text":"","category":"section"},{"location":"Hecke/number_fields/elements/","page":"Element operations","title":"Element operations","text":"norm(::NumFieldElem)\nabsolute_norm(::NumFieldElem)\nminpoly(::NumFieldElem)\nabsolute_minpoly(::NumFieldElem)\ncharpoly(::NumFieldElem)\nabsolute_charpoly(::NumFieldElem)\nnorm(::NumFieldElem, ::NumField)","category":"page"},{"location":"Hecke/number_fields/elements/#norm-Tuple{NumFieldElem}","page":"Element operations","title":"norm","text":"norm(a::NumFieldElem) -> NumFieldElem\n\nReturns the norm of an element a of a number field extension LK. This will be an element of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#absolute_norm-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_norm","text":"absolute_norm(a::NumFieldElem) -> fmpq\n\nGiven a number field element a, returns the absolute norm of a.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#minpoly-Tuple{NumFieldElem}","page":"Element operations","title":"minpoly","text":"minpoly(a::NumFieldElem) -> PolyElem\n\nGiven a number field element a of a number field K, this function returns the minimal polynomial of a over the base field of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#absolute_minpoly-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_minpoly","text":"absolute_minpoly(a::NumFieldElem) -> PolyElem\n\nGiven a number field element a of a number field K, this function returns the minimal polynomial of a over the rationals mathbfQ.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#charpoly-Tuple{NumFieldElem}","page":"Element operations","title":"charpoly","text":"charpoly(a::NumFieldElem) -> PolyElem\n\nGiven a number field element a of a number field K, this function returns the characteristic polynomial of a over the base field of K.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#absolute_charpoly-Tuple{NumFieldElem}","page":"Element operations","title":"absolute_charpoly","text":"absolute_charpoly(a::NumFieldElem) -> PolyElem\n\nGiven a number field element a of a number field K, this function returns the characteristic polynomial of a over the rationals mathbfQ.\n\n\n\n","category":"method"},{"location":"Hecke/number_fields/elements/#norm-Tuple{NumFieldElem, NumField}","page":"Element operations","title":"norm","text":"norm(a::NumFieldElem, k::NumField) -> NumFieldElem\n\nReturns the norm of an element a of a number field L with respect to a subfield k of L. This will be an element of k.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Sparse-linear-algebra","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"CurrentModule = Hecke","category":"page"},{"location":"Hecke/sparse/intro/#Introduction","page":"Sparse linear algebra","title":"Introduction","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"This chapter deals with sparse linear algebra over commutative rings and fields.","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Sparse linear algebra, that is, linear algebra with sparse matrices, plays an important role in various algorithms in algebraic number theory. For example, it is one of the key ingredients in the computation of class groups and discrete logarithms using index calculus methods.","category":"page"},{"location":"Hecke/sparse/intro/#Sparse-rows","page":"Sparse linear algebra","title":"Sparse rows","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Building blocks for sparse matrices are sparse rows, which are modelled by objects of type \\texttt{SRow}. More precisely, the type is of parametrized form objects of type SRow. More precisely, the type is of parametrized form SRow{T}, where T is the element type of the base ring R. For example, SRow{fmpz} is the type for sparse rows over the integers.","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"It is important to note that sparse rows do not have a fixed number of columns, that is, they represent elements of  (x_i)_i in R^mathbbN mid x_i = 0 text for almost all i. In particular any two sparse rows over the same base ring can be added.","category":"page"},{"location":"Hecke/sparse/intro/#Creation","page":"Sparse linear algebra","title":"Creation","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparse_row(::FlintIntegerRing, ::Vector{Tuple{Int, fmpz}})\nsparse_row(::FlintIntegerRing, ::Vector{Tuple{Int, Int}})\nsparse_row(::FlintIntegerRing, ::Vector{Int}, ::Vector{fmpz})","category":"page"},{"location":"Hecke/sparse/intro/#sparse_row-Tuple{FlintIntegerRing, Vector{Tuple{Int64, fmpz}}}","page":"Sparse linear algebra","title":"sparse_row","text":"sparse_row(R::Ring, J::Vector{Tuple{Int, T}}) -> SRow{T}\n\nConstructs the sparse row (a_i)_i with a_i_j = x_j, where J = (i_j x_j)_j. The elements x_i must belong to the ring R.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#sparse_row-Tuple{FlintIntegerRing, Vector{Tuple{Int64, Int64}}}","page":"Sparse linear algebra","title":"sparse_row","text":"sparse_row(R::Ring, J::Vector{Tuple{Int, T}}) -> SRow{T}\n\nConstructs the sparse row (a_i)_i with a_i_j = x_j, where J = (i_j x_j)_j. The elements x_i must belong to the ring R.\n\n\n\nsparse_row(R::Ring, J::Vector{Tuple{Int, Int}}) -> SRow\n\nConstructs the sparse row (a_i)_i over R with a_i_j = x_j, where J = (i_j x_j)_j.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#sparse_row-Tuple{FlintIntegerRing, Vector{Int64}, Vector{fmpz}}","page":"Sparse linear algebra","title":"sparse_row","text":"sparse_row(R::Ring, J::Vector{Int}, V::Vector{T}) -> SRow{T}\n\nConstructs the sparse row (a_i)_i over R with a_i_j = x_j, where J = (i_j)_j and V = (x_j)_j.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Basic-operations","page":"Sparse linear algebra","title":"Basic operations","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Rows support the usual operations:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"+, -, ==\nmultiplication by scalars\ndiv, divexact","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"getindex(::SRow{fmpz}, ::Int)\nadd_scaled_row(::SRow{fmpz}, ::SRow{fmpz}, ::fmpz)\nadd_scaled_row(::SRow{T}, ::SRow{T}, ::T) where {T}\ntransform_row(::SRow{T}, ::SRow{T}, ::T, ::T, ::T, ::T) where {T}\nlength(::SRow)","category":"page"},{"location":"Hecke/sparse/intro/#getindex-Tuple{SRow{fmpz}, Int64}","page":"Sparse linear algebra","title":"getindex","text":"getindex(A::SRow, j::Int) -> RingElem\n\nGiven a sparse row (a_i)_i and an index j return a_j.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#add_scaled_row-Tuple{SRow{fmpz}, SRow{fmpz}, fmpz}","page":"Sparse linear algebra","title":"add_scaled_row","text":"add_scaled_row(A::SRow{T}, B::SRow{T}, c::T) -> SRow{T}\n\nReturns the row c A + B.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#add_scaled_row-Union{Tuple{T}, Tuple{SRow{T}, SRow{T}, T}} where T","page":"Sparse linear algebra","title":"add_scaled_row","text":"add_scaled_row(A::SRow{T}, B::SRow{T}, c::T) -> SRow{T}\n\nReturns the row c A + B.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#transform_row-Union{Tuple{T}, Tuple{SRow{T}, SRow{T}, T, T, T, T}} where T","page":"Sparse linear algebra","title":"transform_row","text":"transform_row(A::SRow{T}, B::SRow{T}, i::Int, j::Int, a::T, b::T, c::T, d::T)\n\nReturns the tuple (aA + bB cA + dB).\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#length-Tuple{SRow}","page":"Sparse linear algebra","title":"length","text":"length(A::SRow)\n\nReturns the number of nonzero entries of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Change-of-base-ring","page":"Sparse linear algebra","title":"Change of base ring","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"change_base_ring(::FlintIntegerRing, ::SRow{fmpz})","category":"page"},{"location":"Hecke/sparse/intro/#change_base_ring-Tuple{FlintIntegerRing, SRow{fmpz}}","page":"Sparse linear algebra","title":"change_base_ring","text":"change_base_ring(R::Ring, A::SRow) -> SRow\n\nCreate a new sparse row by coercing all elements into the ring R.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Maximum,-minimum-and-2-norm","page":"Sparse linear algebra","title":"Maximum, minimum and 2-norm","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"maximum(::SRow)\nmaximum(::SRow{fmpz})\nminimum(::SRow{fmpz})\nminimum(::SRow)\nnorm2(::SRow{fmpz})","category":"page"},{"location":"Hecke/sparse/intro/#maximum-Tuple{SRow}","page":"Sparse linear algebra","title":"maximum","text":"maximum(A::SRow{T}) -> T\n\nReturns the largest entry of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#maximum-Tuple{SRow{fmpz}}","page":"Sparse linear algebra","title":"maximum","text":"maximum(A::SRow{T}) -> T\n\nReturns the largest entry of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#minimum-Tuple{SRow{fmpz}}","page":"Sparse linear algebra","title":"minimum","text":"  minimum(A::NfRelOrdIdl) -> NfOrdIdl\n  minimum(A::NfRelOrdIdl) -> NfRelOrdIdl\n\nReturns the ideal A cap O where O is the maximal order of the coefficient ideals of A.\n\n\n\nminimum(A::SRow{T}) -> T\n\nReturns the smallest entry of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#minimum-Tuple{SRow}","page":"Sparse linear algebra","title":"minimum","text":"minimum(A::SRow{T}) -> T\n\nReturns the smallest entry of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#norm2-Tuple{SRow{fmpz}}","page":"Sparse linear algebra","title":"norm2","text":"norm2(A::SRow{T} -> T\n\nReturns A cdot A^t.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Functionality-for-integral-sparse-rows","page":"Sparse linear algebra","title":"Functionality for integral sparse rows","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"lift(::SRow{nmod})\nmod!(::SRow{fmpz}, ::fmpz)\nmod_sym!(::SRow{fmpz}, ::fmpz)\nmod_sym!(::SRow{fmpz}, ::Integer)\nmaximum(::typeof(abs), ::SRow{fmpz})","category":"page"},{"location":"Hecke/sparse/intro/#lift-Tuple{SRow{nmod}}","page":"Sparse linear algebra","title":"lift","text":"lift(A::SRow{nmod}) -> SRow{fmpz}\n\nReturn the sparse row obtained by lifting all entries in A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#mod!-Tuple{SRow{fmpz}, fmpz}","page":"Sparse linear algebra","title":"mod!","text":"mod!(A::SRow{fmpz}, n::fmpz) -> SRow{fmpz}\n\nInplace reduction of all entries of A modulo n to the positive residue system.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#mod_sym!-Tuple{SRow{fmpz}, fmpz}","page":"Sparse linear algebra","title":"mod_sym!","text":"mod_sym!(A::SRow{fmpz}, n::fmpz) -> SRow{fmpz}\n\nInplace reduction of all entries of A modulo n to the symmetric residue system.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#mod_sym!-Tuple{SRow{fmpz}, Integer}","page":"Sparse linear algebra","title":"mod_sym!","text":"mod_sym!(A::SRow{fmpz}, n::Integer) -> SRow{fmpz}\n\nInplace reduction of all entries of A modulo n to the symmetric residue system.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#maximum-Tuple{typeof(abs), SRow{fmpz}}","page":"Sparse linear algebra","title":"maximum","text":"maximum(abs, A::SRow{fmpz}) -> fmpz\n\nReturns the largest, in absolute value, entry of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Sparse-matrices","page":"Sparse linear algebra","title":"Sparse matrices","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Let R be a commutative ring. Sparse matrices with base ring R are modelled by objects of type SMat. More precisely, the type is of parametrized form SRow{T}, where T is the element type of the base ring. For example, SMat{fmpz} is the type for sparse matrices over the integers.","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"In constrast to sparse rows, sparse matrices have a fixed number of rows and columns, that is, they represent elements of the matrices space mathrmMat_ntimes m(R). Internally, sparse matrices are implemented as an array of sparse rows. As a consequence, unlike their dense counterparts, sparse matrices have a mutable number of rows and it is very performant to add additional rows.","category":"page"},{"location":"Hecke/sparse/intro/#Construction","page":"Sparse linear algebra","title":"Construction","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparse_matrix(::Ring)","category":"page"},{"location":"Hecke/sparse/intro/#sparse_matrix-Tuple{AbstractAlgebra.Ring}","page":"Sparse linear algebra","title":"sparse_matrix","text":"sparse_matrix(R::Ring) -> SMat\n\nReturn an empty sparse matrix with base ring R.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Sparse matrices can also be created from dense matrices as well as from julia arrays:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparse_matrix(::MatElem; keepzrows)\nsparse_matrix(::Matrix{T}) where {T}\nsparse_matrix(::Ring, ::Matrix{T}) where {T}","category":"page"},{"location":"Hecke/sparse/intro/#sparse_matrix-Tuple{MatElem}","page":"Sparse linear algebra","title":"sparse_matrix","text":"sparse_matrix(A::MatElem; keepzrows::Bool = true)\n\nConstructs the sparse matrix corresponding to the dense matrix A. If keepzrows is false, then the constructor will drop any zero row of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#sparse_matrix-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Sparse linear algebra","title":"sparse_matrix","text":"sparse_matrix(R::Ring, A::Matrix{T}) -> SMat\n\nConstructs the sparse matrix over R corresponding to A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#sparse_matrix-Union{Tuple{T}, Tuple{AbstractAlgebra.Ring, Matrix{T}}} where T","page":"Sparse linear algebra","title":"sparse_matrix","text":"sparse_matrix(R::Ring, A::Matrix{T}) -> SMat\n\nConstructs the sparse matrix over R corresponding to A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"The normal way however, is to add rows:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"push!(::SMat{T}, ::SRow{T}) where {T}","category":"page"},{"location":"Hecke/sparse/intro/#push!-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}}} where T","page":"Sparse linear algebra","title":"push!","text":"push!(A::SMat{T}, B::SRow{T}) where T\n\nAppends the sparse row B to A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Sparse matrices can also be concatenated to form larger ones:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"vcat!(::SMat{T}, ::SMat{T}) where {T}\nvcat(::SMat{T}, ::SMat{T}) where {T}\nhcat!(::SMat{T}, ::SMat{T}) where {T}\nhcat(::SMat{T}, ::SMat{T}) where {T}","category":"page"},{"location":"Hecke/sparse/intro/#vcat!-Union{Tuple{T}, Tuple{SMat{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"vcat!","text":"vcat!(A::SMat, B::SMat) -> SMat\n\nVertically joins A and B inplace, that is, the rows of B are appended to A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#vcat-Union{Tuple{T}, Tuple{SMat{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"vcat","text":"vcat(A::SMat, B::SMat) -> SMat\n\nVertically joins A and B.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#hcat!-Union{Tuple{T}, Tuple{SMat{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"hcat!","text":"hcat!(A::SMat, B::SMat) -> SMat\n\nHorizontally concatenates A and B, inplace, changing A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#hcat-Union{Tuple{T}, Tuple{SMat{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"hcat","text":"hcat(A::SMat, B::SMat) -> SMat\n\nHorizontally concatenates A and B.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"(Normal julia cat is also supported)","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"There are special constructors:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"identity_matrix(::Type{SMat}, ::Ring, ::Int)\nzero_matrix(::Type{SMat}, ::Ring, ::Int)\nzero_matrix(::Type{SMat}, ::Ring, ::Int, ::Int)","category":"page"},{"location":"Hecke/sparse/intro/#identity_matrix-Tuple{Type{SMat}, AbstractAlgebra.Ring, Int64}","page":"Sparse linear algebra","title":"identity_matrix","text":"identity_matrix(::Type{SMat}, R::Ring, n::Int)\n\nReturn a sparse n times n identity matrix over R.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#zero_matrix-Tuple{Type{SMat}, AbstractAlgebra.Ring, Int64}","page":"Sparse linear algebra","title":"zero_matrix","text":"zero_matrix(::Type{SMat}, R::Ring, n::Int)\n\nReturn a sparse n times n zero matrix over R.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#zero_matrix-Tuple{Type{SMat}, AbstractAlgebra.Ring, Int64, Int64}","page":"Sparse linear algebra","title":"zero_matrix","text":"zero_matrix(::Type{SMat}, R::Ring, n::Int, m::Int)\n\nReturn a sparse n times m zero matrix over R.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Slices:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sub(::SMat{T}, ::UnitRange, ::UnitRange) where {T}","category":"page"},{"location":"Hecke/sparse/intro/#sub-Union{Tuple{T}, Tuple{SMat{T}, UnitRange, UnitRange}} where T","page":"Sparse linear algebra","title":"sub","text":"sub(A::SMat, r::UnitRange, c::UnitRange) -> SMat\n\nReturn the submatrix of A, where the rows correspond to r and the columns correspond to c.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Transpose:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"transpose(A::SMat)","category":"page"},{"location":"Hecke/sparse/intro/#transpose-Tuple{SMat}","page":"Sparse linear algebra","title":"transpose","text":"transpose(A::SMat) -> SMat\n\nReturns the transpose of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Elementary-Properties","page":"Sparse linear algebra","title":"Elementary Properties","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparsity(::SMat)\ndensity(::SMat)\nnnz(::SMat)\nnrows(::SMat)\nncols(::SMat)\nisone(::SMat)\niszero(::SMat)\nisupper_triangular(::SMat)\nmaximum(::SMat)\nminimum(::SMat)\nmaximum(::typeof(abs), ::SMat{fmpz})\nelementary_divisors(::SMat{fmpz})\nHecke.solve_dixon_sf(::SMat{fmpz}, ::SRow{fmpz})\nHecke.hadamard_bound2(::SMat)\nHecke.echelon_with_transform(::SMat{nmod})\nHecke.reduce_full(::SMat{fmpz}, ::SRow{fmpz})\nhnf!(::SMat{fmpz})\nhnf(::SMat{fmpz})\nsnf(::SMat{fmpz})\nhnf_extend!(::SMat{fmpz}, ::SMat{fmpz})\nisdiagonal(::SMat)\ndet(::SMat{fmpz})\ndet_mc(::SMat{fmpz})\nvalence_mc(::SMat)\nsaturate(::SMat{fmpz})\nHecke.hnf_kannan_bachem(::SMat{fmpz})\ndiagonal_form(::SMat{fmpz})","category":"page"},{"location":"Hecke/sparse/intro/#sparsity-Tuple{SMat}","page":"Sparse linear algebra","title":"sparsity","text":"sparsity(A::SMat) -> Float64\n\nReturn the sparsity of A, that is, the number of zero-valued elements divided by the number of all elements.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#density-Tuple{SMat}","page":"Sparse linear algebra","title":"density","text":"density(A::SMat) -> Float64\n\nReturn the density of A, that is, the number of nonzero-valued elements divided by the number of all elements.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#nnz-Tuple{SMat}","page":"Sparse linear algebra","title":"nnz","text":"nnz(A::SMat) -> Int\n\nReturn the number of non-zero entries of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#nrows-Tuple{SMat}","page":"Sparse linear algebra","title":"nrows","text":"nrows(A::SMat) -> Int\n\nReturn the number of rows of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#ncols-Tuple{SMat}","page":"Sparse linear algebra","title":"ncols","text":"ncols(A::SMat) -> Int\n\nReturn the number of columns of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#isone-Tuple{SMat}","page":"Sparse linear algebra","title":"isone","text":"isone(A::SMat)\n\nTests if A is an identity matrix.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#iszero-Tuple{SMat}","page":"Sparse linear algebra","title":"iszero","text":"iszero(A::SMat)\n\nTests if A is a zero matrix.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#isupper_triangular-Tuple{SMat}","page":"Sparse linear algebra","title":"isupper_triangular","text":"isupper_triangular(A::SMat)\n\nReturns true if and only if A is upper (right) triangular.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#maximum-Tuple{SMat}","page":"Sparse linear algebra","title":"maximum","text":"maximum(A::SMat{T}) -> T\n\nFinds the largest entry of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#minimum-Tuple{SMat}","page":"Sparse linear algebra","title":"minimum","text":"minimum(A::SMat{T}) -> T\n\nFinds the smallest entry of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#maximum-Tuple{typeof(abs), SMat{fmpz}}","page":"Sparse linear algebra","title":"maximum","text":"maximum(abs, A::SMat{fmpz}) -> fmpz\n\nFinds the largest, in absolute value, entry of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#elementary_divisors-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"elementary_divisors","text":"elementary_divisors(A::SMat{fmpz}) -> Vector{fmpz}\n\nThe elementary divisors of A, i.e. the diagonal elements of the Smith normal form of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#solve_dixon_sf-Tuple{SMat{fmpz}, SRow{fmpz}}","page":"Sparse linear algebra","title":"solve_dixon_sf","text":"solve_dixon_sf(A::SMat{fmpz}, b::SRow{fmpz}, is_int::Bool = false) -> SRow{fmpz}, fmpz\nsolve_dixon_sf(A::SMat{fmpz}, B::SMat{fmpz}, is_int::Bool = false) -> SMat{fmpz}, fmpz\n\nFor a sparse square matrix A of full rank and a sparse matrix (row), find a sparse matrix (row) x and an integer d s.th. x A = bd holds. The algorithm is a Dixon-based linear p-adic lifting method. If \\code{is_int} is given, then d is assumed to be 1. In this case rational reconstruction is avoided.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#hadamard_bound2-Tuple{SMat}","page":"Sparse linear algebra","title":"hadamard_bound2","text":"hadamard_bound2(A::SMat{T}) -> T\n\nThe square of the product of the norms of the rows of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#echelon_with_transform-Tuple{SMat{nmod}}","page":"Sparse linear algebra","title":"echelon_with_transform","text":"echelon_with_transform(A::SMat{nmod}) -> SMat, SMat\n\nFind a unimodular matrix T and an upper-triangular E s.th. TA = E holds.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#reduce_full-Tuple{SMat{fmpz}, SRow{fmpz}}","page":"Sparse linear algebra","title":"reduce_full","text":"reduce_full(A::SMat{fmpz}, g::SRow{fmpz},\n                      trafo = Val{false}) -> SRow{fmpz}, Vector{Int}\n\nReduces g modulo A and assumes that A is upper triangular.\n\nThe second return value is the array of pivot elements of A that changed.\n\nIf trafo is set to Val{true}, then additionally an array of transformations is returned.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#hnf!-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"hnf!","text":"hnf!(A::SMat{fmpz})\n\nInplace transform of A into upper right Hermite normal form.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#hnf-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"hnf","text":"hnf(A::SMat{fmpz}) -> SMat{fmpz}\n\nReturn the upper right Hermite normal form of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#snf-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"snf","text":"snf(A::SMat{fmpz})\n\nThe Smith normal form (snf) of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#hnf_extend!-Tuple{SMat{fmpz}, SMat{fmpz}}","page":"Sparse linear algebra","title":"hnf_extend!","text":"hnf_extend!(A::SMat{fmpz}, b::SMat{fmpz}, offset::Int = 0) -> SMat{fmpz}\n\nGiven a matrix A in HNF, extend this to get the HNF of the concatenation with b.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#isdiagonal-Tuple{SMat}","page":"Sparse linear algebra","title":"isdiagonal","text":"isdiagonal(A::SMat) -> Bool\n\nTrue iff only the i-th entry in the i-th row is non-zero.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#det-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"det","text":"det(A::SMat{fmpz})\n\nThe determinant of A using a modular algorithm. Uses the dense (nmod_mat) determinant on A for various primes p.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#det_mc-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"det_mc","text":"det_mc(A::SMat{fmpz})\n\nComputes the determinant of A using a LasVegas style algorithm, i.e. the result is not proven to be correct. Uses the dense (nmod_mat) determinant on A for various primes p.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#valence_mc-Tuple{SMat}","page":"Sparse linear algebra","title":"valence_mc","text":"valence_mc{T}(A::SMat{T}; extra_prime = 2, trans = Vector{SMatSLP_add_row{T}}()) -> T\n\nUses a Monte-Carlo algorithm to compute the valence of A. The valence is the valence of the minimal polynomial f of transpose(A)*A, thus the last non-zero coefficient, typically f(0).\n\nThe valence is computed modulo various primes until the computation stabilises for extra_prime many.\n\ntrans, if given, is  a SLP (straight-line-program) in GL(n, Z). Then the valence of trans * A  is computed instead.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#saturate-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"saturate","text":"saturate(A::SMat{fmpz}) -> SMat{fmpz}\n\nComputes the saturation of A, that is, a basis for mathbfQotimes M meet mathbfZ^n, where M is the row span of A and n the number of rows of A.\n\nEquivalently, return TA for an invertible rational matrix T, such that TA is integral and the elementary divisors of TA are all trivial.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#hnf_kannan_bachem-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"hnf_kannan_bachem","text":"hnf_kannan_bachem(A::SMat{fmpz}) -> SMat{fmpz}\n\nCompute the Hermite normal form of A using the Kannan-Bachem algorithm.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#diagonal_form-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"diagonal_form","text":"diagonal_form(A::SMat{fmpz}) -> SMat{fmpz}\n\nA matrix D that is diagonal and obtained via unimodular row and column operations. Like a snf without the divisibility condition.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Manipulation/-Access","page":"Sparse linear algebra","title":"Manipulation/ Access","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"getindex(::SMat{T}, ::Int, ::Int) where {T}\ngetindex(::SMat{T}, ::Int) where {T}\nsetindex!(::SMat{T}, ::SRow{T}, ::Int) where {T}\nswap_rows!(::SMat, ::Int, I::Int)\nswap_cols!(::SMat, ::Int, I::Int)\nscale_row!(::SMat{T}, ::Int, ::T) where {T}\nadd_scaled_col!(::SMat{T}, ::Int, ::Int, ::T) where {T}\nadd_scaled_row!(::SMat{T}, ::Int, ::Int, ::T) where {T}\ntransform_row!(::SMat{T}, ::Int, ::Int, ::T, ::T, ::T, ::T) where {T}\ndiagonal(::SMat)\nreverse_rows!(::SMat)\nmod_sym!(::SMat{fmpz}, ::fmpz)\nfind_row_starting_with(::SMat, ::Int)\nreduce(::SMat{fmpz}, ::SRow{fmpz}, ::fmpz)\nreduce(::SMat{fmpz}, ::SRow{fmpz})\nreduce(::SMat{T}, ::SRow{T}) where {T <: FieldElement}\nrand_row(::SMat{T}) where {T}","category":"page"},{"location":"Hecke/sparse/intro/#getindex-Union{Tuple{T}, Tuple{SMat{T}, Int64, Int64}} where T","page":"Sparse linear algebra","title":"getindex","text":"getindex(A::SMat, i::Int, j::Int)\n\nGiven a sparse matrix A = (a_ij)_i j, return the entry a_ij.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#getindex-Union{Tuple{T}, Tuple{SMat{T}, Int64}} where T","page":"Sparse linear algebra","title":"getindex","text":"getindex(A::SMat, i::Int) -> SRow\n\nGiven a sparse matrix A and an index i, return the i-th row of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#setindex!-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}, Int64}} where T","page":"Sparse linear algebra","title":"setindex!","text":"setindex!(A::SMat, b::SRow, i::Int)\n\nGiven a sparse matrix A, a sparse row b and an index i, set the i-th row of A equal to b.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#swap_rows!-Tuple{SMat, Int64, Int64}","page":"Sparse linear algebra","title":"swap_rows!","text":"swap_rows!(A::SMat{T}, i::Int, j::Int)\n\nSwap the i-th and j-th row of A inplace.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#swap_cols!-Tuple{SMat, Int64, Int64}","page":"Sparse linear algebra","title":"swap_cols!","text":"swap_cols!(A::SMat, i::Int, j::Int)\n\nSwap the i-th and j-th column of A inplace.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#scale_row!-Union{Tuple{T}, Tuple{SMat{T}, Int64, T}} where T","page":"Sparse linear algebra","title":"scale_row!","text":"scale_row!(A::SMat{T}, i::Int, c::T)\n\nMultiply the i-th row of A by c inplace.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#add_scaled_col!-Union{Tuple{T}, Tuple{SMat{T}, Int64, Int64, T}} where T","page":"Sparse linear algebra","title":"add_scaled_col!","text":"add_scaled_col!(A::SMat{T}, i::Int, j::Int, c::T)\n\nAdd c times the i-th column to the j-th column of A inplace, that is, A_j rightarrow A_j + c cdot A_i, where (A_i)_i denote the columns of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#add_scaled_row!-Union{Tuple{T}, Tuple{SMat{T}, Int64, Int64, T}} where T","page":"Sparse linear algebra","title":"add_scaled_row!","text":"add_scaled_row!(A::SMat{T}, i::Int, j::Int, c::T)\n\nAdd c times the i-th row to the j-th row of A inplace, that is, A_j rightarrow A_j + c cdot A_i, where (A_i)_i denote the rows of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#transform_row!-Union{Tuple{T}, Tuple{SMat{T}, Int64, Int64, T, T, T, T}} where T","page":"Sparse linear algebra","title":"transform_row!","text":"transform_row!(A::SMat{T}, i::Int, j::Int, a::T, b::T, c::T, d::T)\n\nApplies the transformation (A_i A_j) rightarrow (aA_i + bA_j cA_i + dA_j) to A, where (A_i)_i are the rows of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#diagonal-Tuple{SMat}","page":"Sparse linear algebra","title":"diagonal","text":"diagonal(A::SMat) -> fmpz[]\n\nThe diagonal elements of A in an array.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#reverse_rows!-Tuple{SMat}","page":"Sparse linear algebra","title":"reverse_rows!","text":"reverse_rows!(A::SMat)\n\nInplace inversion of the rows of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#mod_sym!-Tuple{SMat{fmpz}, fmpz}","page":"Sparse linear algebra","title":"mod_sym!","text":"mod_sym!(A::SMat{fmpz}, n::fmpz)\n\nInplace reduction of all entries of A modulo n to the symmetric residue system.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#find_row_starting_with-Tuple{SMat, Int64}","page":"Sparse linear algebra","title":"find_row_starting_with","text":"find_row_starting_with(A::SMat, p::Int) -> Int\n\nTries to find the index i such that A_ip neq 0 and A_i p-j = 0 for all j  1. It is assumed that A is upper triangular. If such an index does not exist, find the smallest index larger.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#reduce-Tuple{SMat{fmpz}, SRow{fmpz}, fmpz}","page":"Sparse linear algebra","title":"reduce","text":"reduce(A::SMat{fmpz}, g::SRow{fmpz}, m::fmpz) -> SRow{fmpz}\n\nGiven an upper triangular matrix A over the integers, a sparse row g and an integer m, this function reduces g modulo A and returns g modulo m with respect to the symmetric residue system.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#reduce-Tuple{SMat{fmpz}, SRow{fmpz}}","page":"Sparse linear algebra","title":"reduce","text":"reduce(A::SMat{fmpz}, g::SRow{fmpz}) -> SRow{fmpz}\n\nGiven an upper triangular matrix A over a field and a sparse row g, this function reduces g modulo A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#reduce-Union{Tuple{T}, Tuple{SMat{T}, SRow{T}}} where T<:FieldElement","page":"Sparse linear algebra","title":"reduce","text":"reduce(A::SMat{T}, g::SRow{T}) -> SRow{T}\n\nGiven an upper triangular matrix A over a field and a sparse row g, this function reduces g modulo A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#rand_row-Union{Tuple{SMat{T}}, Tuple{T}} where T","page":"Sparse linear algebra","title":"rand_row","text":"rand_row(A::SMat) -> SRow\n\nReturn a random row of the sparse matrix A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Changing of the ring:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"map_entries(f, ::SMat)\nchange_base_ring(::Ring, ::SMat)","category":"page"},{"location":"Hecke/sparse/intro/#map_entries-Tuple{Any, SMat}","page":"Sparse linear algebra","title":"map_entries","text":"map_entries(f, A::SMat) -> SMat\n\nGiven a sparse matrix A and a callable object f, this function will construct a new sparse matrix by applying f to all elements of A.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#change_base_ring-Tuple{AbstractAlgebra.Ring, SMat}","page":"Sparse linear algebra","title":"change_base_ring","text":"change_base_ring(R::Ring, A::SMat)\n\nCreate a new sparse matrix by coercing all elements into the ring R.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Arithmetic","page":"Sparse linear algebra","title":"Arithmetic","text":"","category":"section"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Matrices support the usual operatation as well","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"+, -, ==, *\ndiv, divexact by scalars\nmultiplication by scalars","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Various products:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Hecke.mul(::SMat{T}, ::AbstractVector{T}) where {T}\nHecke.mul(::SMat{T}, ::AbstractMatrix{T})  where {T}\nHecke.mul(::SMat{T}, ::MatElem{T}) where {T}\nHecke.mul(::SRow{T}, ::SMat{T}) where {T}","category":"page"},{"location":"Hecke/sparse/intro/#mul-Union{Tuple{T}, Tuple{SMat{T}, AbstractVector{T}}} where T","page":"Sparse linear algebra","title":"mul","text":"mul(A::SMat{T}, b::AbstractVector{T}) -> Vector{T}\n\nReturn the product A cdot b as a dense vector.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#mul-Union{Tuple{T}, Tuple{SMat{T}, AbstractMatrix{T}}} where T","page":"Sparse linear algebra","title":"mul","text":"mul(A::SMat{T}, b::AbstractMatrix{T}) -> Matrix{T}\n\nReturn the product A cdot b as a dense array.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#mul-Union{Tuple{T}, Tuple{SMat{T}, MatElem{T}}} where T","page":"Sparse linear algebra","title":"mul","text":"mul(A::SMat{T}, b::MatElem{T}) -> MatElem\n\nReturn the product A cdot b as a dense matrix.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#mul-Union{Tuple{T}, Tuple{SRow{T}, SMat{T}}} where T","page":"Sparse linear algebra","title":"mul","text":"mul(A::SRow, B::SMat) -> SRow\n\nReturn the product Acdot B as a sparse row.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"Other:","category":"page"},{"location":"Hecke/sparse/intro/","page":"Sparse linear algebra","title":"Sparse linear algebra","text":"sparse(::SMat)\nfmpz_mat(::SMat{fmpz})\nfmpz_mat(::SMat{T}) where {T <: Integer}\nArray(::SMat{T}) where {T}","category":"page"},{"location":"Hecke/sparse/intro/#sparse-Tuple{SMat}","page":"Sparse linear algebra","title":"sparse","text":"sparse(A::SMat) -> SparseMatrixCSC\n\nThe same matrix, but as a sparse matrix of julia type SparseMatrixCSC.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#fmpz_mat-Tuple{SMat{fmpz}}","page":"Sparse linear algebra","title":"fmpz_mat","text":"fmpz_mat(A::SMat{fmpz})\n\nThe same matrix A, but as an fmpz_mat.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#fmpz_mat-Union{Tuple{SMat{T}}, Tuple{T}} where T<:Integer","page":"Sparse linear algebra","title":"fmpz_mat","text":"fmpz_mat(A::SMat{T}) where {T <: Integer}\n\nThe same matrix A, but as an fmpz_mat. Requires a conversion from the base ring of A to mathbb ZZ.\n\n\n\n","category":"method"},{"location":"Hecke/sparse/intro/#Array-Union{Tuple{SMat{T}}, Tuple{T}} where T","page":"Sparse linear algebra","title":"Array","text":"Array(A::SMat{T}) -> Matrix{T}\n\nThe same matrix, but as a two-dimensional julia array.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Module-Homomorphisms","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Abstract Algebra provides homomorphisms of finitely presented modules.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Generic-module-homomorphism-types","page":"Module Homomorphisms","title":"Generic module homomorphism types","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"AbstractAlgebra defines two module homomorphism types, namely Generic.ModuleHomomorphism and Generic.ModuleIsomorphism. Functionality for these is implemented in src/generic/ModuleHomomorphism.jl.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Abstract-types","page":"Module Homomorphisms","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"The Generic.ModuleHomomorphism and Generic.ModuleIsomorphism types inherit from Map(FPModuleHomomorphism).","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Generic-functionality","page":"Module Homomorphisms","title":"Generic functionality","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"The following generic functionality is provided for module homomorphisms.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Constructors","page":"Module Homomorphisms","title":"Constructors","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Homomorphisms of AbstractAlgebra modules, f  R^s to R^t, can be represented by stimes t matrices over R.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"ModuleHomomorphism(M1::FPModule{T}, M2::FPModule{T}, m::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#ModuleHomomorphism-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}, MatElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"ModuleHomomorphism","text":"ModuleHomomorphism(M1::FPModule{T},\n                      M2::FPModule{T}, m::MatElem{T}) where T <: RingElement\n\nCreate the homomorphism f  M_1 to M_2 represented by the matrix m.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"ModuleIsomorphism(M1::FPModule{T}, M2::FPModule{T}, m::MatElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#ModuleIsomorphism-Union{Tuple{T}, Tuple{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}, MatElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"ModuleIsomorphism","text":"ModuleIsomorphism(M1::FPModule{T}, M2::FPModule{T}, M::MatElem{T},\n                                     minv::MatElem{T}) where T <: RingElement\n\nCreate the isomorphism f  M_1 to M_2 represented by the matrix M. The inverse morphism is automatically computed.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"julia> M = FreeModule(ZZ, 2)\nFree module of rank 2 over Integers\n\njulia> f = ModuleHomomorphism(M, M, matrix(ZZ, 2, 2, [1, 2, 3, 4]))\nModule homomorphism with\nDomain: Free module of rank 2 over Integers\nCodomain: Free module of rank 2 over Integers\n\njulia> m = M([ZZ(1), ZZ(2)])\n(1, 2)\n\njulia> f(m)\n(7, 10)\n","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"They can also be created by giving images (in the codomain) of the generators of the domain:","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"ModuleHomomorphism(M1::FPModule{T}, M2::FPModule{T}, v::Vector{<:FPModuleElem{T}}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Kernels","page":"Module Homomorphisms","title":"Kernels","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"kernel(f::Map(FPModuleHomomorphism))","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#kernel-Tuple{Map{D, C, var\"#s459\", T} where {D, C, T, var\"#s459\"<:AbstractAlgebra.FPModuleHomomorphism}}","page":"Module Homomorphisms","title":"kernel","text":"kernel(f::ModuleHomomorphism{T}) where T <: RingElement\n\nReturn a pair K, g consisting of the kernel object K of the given module homomorphism f (as a submodule of its domain) and the canonical injection from the kernel into the domain of f\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Examples","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"julia> M = FreeModule(ZZ, 3)\nFree module of rank 3 over Integers\n\njulia> m = M([ZZ(1), ZZ(2), ZZ(3)])\n(1, 2, 3)\n\njulia> S, f = sub(M, [m])\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 3 over Integers)\n\njulia> Q, g = quo(M, S)\n(Quotient module over Integers with 2 generators and no relations\n, Module homomorphism with\nDomain: Free module of rank 3 over Integers\nCodomain: Quotient module over Integers with 2 generators and no relations\n)\n\njulia> kernel(g)\n(Submodule over Integers with 1 generator and no relations\n, Module homomorphism with\nDomain: Submodule over Integers with 1 generator and no relations\n\nCodomain: Free module of rank 3 over Integers)\n","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Images","page":"Module Homomorphisms","title":"Images","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"image(::Map(FPModuleHomomorphism))","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#image-Tuple{Map{D, C, var\"#s459\", T} where {D, C, T, var\"#s459\"<:AbstractAlgebra.FPModuleHomomorphism}}","page":"Module Homomorphisms","title":"image","text":"image(f::Map(FPModuleHomomorphism))\n\nReturn a pair I, g consisting of the image object I of the given module homomorphism f (as a submodule of its codomain) and the canonical injection from the image into the codomain of f\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"M = FreeModule(ZZ, 3)\n\nm = M([ZZ(1), ZZ(2), ZZ(3)])\n\nS, f = sub(M, [m])\nQ, g = quo(M, S)\nK, k = kernel(g)\n\nimage(compose(k, g))","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Preimages","page":"Module Homomorphisms","title":"Preimages","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"preimage(::Map(FPModuleHomomorphism), ::FPModuleElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#preimage-Union{Tuple{T}, Tuple{Map{D, C, var\"#s459\", T} where {D, C, T, var\"#s459\"<:AbstractAlgebra.FPModuleHomomorphism}, AbstractAlgebra.FPModuleElem{T}}} where T<:RingElement","page":"Module Homomorphisms","title":"preimage","text":"preimage(f::Map(FPModuleHomomorphism),\n      v::FPModuleElem{T}) where T <: RingElement\n\nReturn a preimage of v under the homomorphism f, i.e. an element of the domain of f that maps to v under f. Note that this has no special mathematical properties. It is an element of the set theoretical preimage of the map f as a map of sets, if one exists. The preimage is neither unique nor chosen in a canonical way in general. When no such element exists, an exception is raised.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"M = FreeModule(ZZ, 3)\n\nm = M([ZZ(1), ZZ(2), ZZ(3)])\n\nS, f = sub(M, [m])\nQ, g = quo(M, S)\n\nm = rand(M, -10:10)\nn = g(m)\n\np = preimage(g, n)","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#Inverses","page":"Module Homomorphisms","title":"Inverses","text":"","category":"section"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Module isomorphisms can be cheaply inverted.","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"Base.inv(::Map(Generic.ModuleIsomorphism))","category":"page"},{"location":"AbstractAlgebra/module_homomorphism/#inv-Tuple{Map{AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModule{T}, AbstractAlgebra.FPModuleHomomorphism, AbstractAlgebra.Generic.ModuleIsomorphism} where T<:RingElement}","page":"Module Homomorphisms","title":"inv","text":"Base.inv(f::Map(ModuleIsomorphism))\n\nReturn the inverse map of the given module isomorphism. This is computed cheaply.\n\n\n\n","category":"method"},{"location":"AbstractAlgebra/module_homomorphism/","page":"Module Homomorphisms","title":"Module Homomorphisms","text":"M = FreeModule(ZZ, 2)\nN = matrix(ZZ, 2, 2, BigInt[1, 0, 0, 1])\nf = ModuleIsomorphism(M, M, N)\n\ng = inv(f)","category":"page"},{"location":"AbstractAlgebra/constructors/#Constructing-mathematical-objects-in-AbstractAlgebra.jl","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/constructors/#Constructing-objects-in-Julia","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing objects in Julia","text":"","category":"section"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"In Julia, one constructs objects of a given type by calling a type constructor. This is simply a function with the same name as the type itself. For example, to construct a BigInt object from an Int in Julia, we simply call the BigInt constructor:","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"n = BigInt(123)","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"Note that a number literal too big to fit in an Int or Int128 automatically creates a BigInt:","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"julia> typeof(12345678765456787654567890987654567898765678909876567890)\nBigInt","category":"page"},{"location":"AbstractAlgebra/constructors/#How-we-construct-objects-in-AbstractAlgebra.jl","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"How we construct objects in AbstractAlgebra.jl","text":"","category":"section"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"As we explain in Elements and parents, Julia types don't contain enough information to properly model groups, rings, fields, etc. Instead of using types to construct objects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"Consider the following simple example, to create a multiprecision integer:","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"n = ZZ(12345678765456787654567890987654567898765678909876567890)","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"Here ZZ is not a Julia type, but a callable object. However, for most purposes one can think of such a parent object as though it were a type.","category":"page"},{"location":"AbstractAlgebra/constructors/#Constructing-parent-objects","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing parent objects","text":"","category":"section"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"For more complicated groups, rings, fields, etc., one first needs to construct the parent object before one can use it to construct element objects.","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"AbstractAlgebra.jl provides a set of functions for constructing such parent objects. For example, to create a parent object for univariate polynomials over the integers, we use the PolynomialRing parent object constructor.","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"R, x = PolynomialRing(ZZ, \"x\")\nf = x^3 + 3x + 1\ng = R(12)","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"In this example, R is the parent object and we use it to convert the Int value 12 to an element of the polynomial ring mathbbZx.","category":"page"},{"location":"AbstractAlgebra/constructors/#List-of-parent-object-constructors","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"List of parent object constructors","text":"","category":"section"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"For convenience, we provide a list of all the parent object constructors in AbstractAlgebra.jl and explain what mathematical domains they represent.","category":"page"},{"location":"AbstractAlgebra/constructors/","page":"Constructing mathematical objects in AbstractAlgebra.jl","title":"Constructing mathematical objects in AbstractAlgebra.jl","text":"Mathematics AbstractAlgebra.jl constructor\nR = mathbbZ R = ZZ\nR = mathbbQ R = QQ\nR = mathbbF_p R = GF(p)\nR = mathbbZnmathbbZ R = ResidueRing(ZZ, n)\nS = Rx S, x = PolynomialRing(R, \"x\")\nS = Rx y S, (x, y) = PolynomialRing(R, [\"x\", \"y\"])\nS = Rx (to precision n) S, x = PowerSeriesRing(R, n, \"x\")\nS = R((x)) (to precision n) S, x = LaurentSeriesRing(R, n, \"x\")\nS = K((x)) (to precision n) S, x = LaurentSeriesField(K, n, \"x\")\nS = mathrmFrac_R S = FractionField(R)\nS = R(f) S = ResidueRing(R, f)\nS = R(f) (with (f) maximal) S = ResidueField(R, f)\nS = mathrmMat_mtimes n(R) S = MatrixSpace(R, m, n)\nS = mathbbQx(f) S, a = NumberField(f, \"a\")","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"using Oscar","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Pages = [\"group_characters.md\"]","category":"page"},{"location":"Groups/group_characters/#Group-characters","page":"Group characters","title":"Group characters","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Let G be a finite group, and let rho G rightarrow GL(n R) be a group homomorphism, for some ring R. We call chi G rightarrow R, defined by chi(g) = Trace(rho(g)), the character afforded by rho.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Since chi is constant on conjugacy classes of G, it can be represented by an array l of values such that the value on the i-th conjugacy class of G (see conjugacy_classes) is stored at li. Note that this makes sense only if we assume that the ordering of conjugacy classes of G is fixed once the classes have been computed.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"We deal only with the cases that either R can be embedded into some number field, or that R is a finite field.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"In the former case, the eigenvalues of the matrix rho(g), for g in G, are k-th roots of unity, where k is the order of g, thus all values of chi can be represented by elements in the abelian closure of the field of rational numbers, see abelian_closure. The characters obtained this way are called ordinary characters.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"In the latter case, the list of traces of rho(g) (the so-called Frobenius character of rho) is often not so interesting; instead, one considers the Brauer character of rho, which is defined on (conjugacy classes of) elements g whose order is coprime to the characteristic of R (the so-called p-regular elements resp. classes), by first lifting the eigenvalues of rho(g) to complex roots of unity and then summing up these roots; this way, one gets again a list of values in the abelian closure of the field of rationals.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"The pointwise sum and product of two characters are again characters, they are afforded by the direct sum and the tensor product of the underlying representations. A character that is not the sum of two characters is called absolutely irreducible.","category":"page"},{"location":"Groups/group_characters/#Character-tables","page":"Group characters","title":"Character tables","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Putting the values of the absolutely irreducible ordinary characters of a group G into an array such that the rows correspond to the characters and the columns correspond to the conjugacy classes yields the ordinary character table of G, which is in fact a square matrix. Analogously, the absolutely irreducible Brauer characters of G, for a given characteristic p, yield a square matrix, the p-modular Brauer character table.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Ordinary character tables can be computed with character_table from a given group. The computation of p-modular Brauer tables is currently restricted to the case of p-solvable groups.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Character tables contain a lot of information about their groups, many questions about a finite group can be answered by computations only with its characters. Thus it makes sense to deal also with character tables without an explicit labeling of the columns of the table by conjugacy classes of a group. For example, the character tables shown in Atlas of Finite Groups J. H. Conway, R. T. Curtis, S. P. Norton, R. A. Parker, R. A. Wilson (1985) and from the Atlas of Brauer Characters C. Jansen, K. Lux, R. Parker, R. Wilson (1995) are available in Oscar. Such character tables can be fetched with character_table from the database, via their names.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"In Oscar, a character table t is identified with the array of absolutely irreducible characters of G, in the sense that t[i] yields the i-th irreducible character of G, and t[i, j] is the value of this character on the j-th conjugacy class of G (or the j-th conjugacy class of p-regular elements in the case of Brauer tables).","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Ordinary and p-modular Brauer tables in Oscar are distinguished by the field characteristic; its value is 0 for ordinary tables and p otherwise.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"GAPGroupCharacterTable\ncharacter_table\nBase.mod(tbl::GAPGroupCharacterTable, p::Int)\nall_character_table_names","category":"page"},{"location":"Groups/group_characters/#GAPGroupCharacterTable","page":"Group characters","title":"GAPGroupCharacterTable","text":"GAPGroupCharacterTable <: GroupCharacterTable\n\nThis is the type of (ordinary or Brauer) character tables that can delegate tasks to an underlying character table object in the GAP system (field GAPTable).\n\nAn object of type GAPGroup can (but need not) be stored in the field GAPGroup.\n\nThe value of the field characteristic determines whether the table is an ordinary one (value 0) or a p-modular one (value p).\n\nObjects of type GAPGroupCharacterTable support get_attribute, for example in order to store the already computed p-modular tables in an ordinary table, and to store the corresponding ordinary table in a p-modular table.\n\n\n\n\n\n","category":"type"},{"location":"Groups/group_characters/#character_table","page":"Group characters","title":"character_table","text":"character_table(G::GAPGroup, p::Int = 0)\n\nReturn the ordinary (if p == 0) or p-modular character table of the finite group G. If the p-modular character table of G cannot be computed by GAP then nothing is returned.\n\nExamples\n\njulia> Oscar.with_unicode() do\n         show(character_table(symmetric_group(3)))\n       end;\nSym( [ 1 .. 3 ] )\n\n 2  1  1  .\n 3  1  .  1\n           \n   1a 2a 3a\n2P 1a 1a 3a\n3P 1a 2a 1a\n           \nχ₁  1 -1  1\nχ₂  2  . -1\nχ₃  1  1  1\n\njulia> Oscar.with_unicode() do\n         show(character_table(symmetric_group(3), 2))\n       end;\nSym( [ 1 .. 3 ] ) mod 2\n\n 2  1  .\n 3  1  1\n        \n   1a 3a\n2P 1a 3a\n3P 1a 1a\n        \nχ₁  1  1\nχ₂  2 -1\n\n\n\n\n\n\ncharacter_table(id::String, p::Int = 0)\n\nReturn the ordinary (if p == 0) or p-modular character table for which id is an admissible name in GAP's library of character tables. If no such table is available then nothing is returned.\n\nExamples\n\njulia> println(character_table(\"A5\"))\ncharacter_table(\"A5\")\n\njulia> println(character_table(\"A5\", 2))\ncharacter_table(\"A5mod2\")\n\njulia> println(character_table(\"J5\"))\nnothing\n\n\n\n\n\n\ncharacter_table(series::Symbol, parameter::Any)\n\nReturn the ordinary character table of the group described by the series series and the parameter parameter.\n\nExamples\n\njulia> println(character_table(:Symmetric, 5))\ncharacter_table(\"Sym(5)\")\n\njulia> println(character_table(:WeylB, 3))\ncharacter_table(\"W(B3)\")\n\n\nCurrently the following series are supported.\n\nSeries Parameter\n:Cyclic pos. integer\n:Dihedral even pos. integer\n:Symmetric pos. integer\n:Alternating integer > 1\n:WeylB pos. integer\n:WeylD integer > 1\n:DoubleCoverSymmetric pos. integer\n:DoubleCoverAlternating pos. integer\n:GL2 prime power\n:SL2odd odd prime power\n:SL2even even prime power\n:PSL2odd odd prime power q s. t. (q-1)/2 is odd\n:PSL2even odd prime power q s. t. (q-1)/2 is even\n:Suzuki odd power of 2\n:GU3 prime power\n:SU3 prime power\nSymbol(\"P:Q\") array [p, q] with prime p and q dividing p-1\n:ExtraspecialPlusOdd odd power of odd prime\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#mod-Tuple{Oscar.GAPGroupCharacterTable, Int64}","page":"Group characters","title":"mod","text":"mod(tbl::GAPGroupCharacterTable, p::Int)\n\nReturn the p-modular character table of tbl, or nothing if this table cannot be computed.\n\nAn exception is thrown if tbl is not an ordinary character table.\n\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#all_character_table_names","page":"Group characters","title":"all_character_table_names","text":"all_character_table_names(L...; ordered_by = nothing)\n\nReturn an array of strings that contains all those names of character tables in the character table library that satisfy the conditions in the array L.\n\nExamples\n\njulia> spor_names = all_character_table_names(is_sporadic_simple => true,\n         is_duplicate_table => false);\n\njulia> println(spor_names[1:5])\n[\"B\", \"Co1\", \"Co2\", \"Co3\", \"F3+\"]\n\njulia> spor_names = all_character_table_names(is_sporadic_simple,\n         !is_duplicate_table; ordered_by = order);\n\njulia> println(spor_names[1:5])\n[\"M11\", \"M12\", \"J1\", \"M22\", \"J2\"]\n\njulia> length(all_character_table_names(number_conjugacy_classes => 1))\n1\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#Attributes-of-group-characters","page":"Group characters","title":"Attributes of group characters","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"character_field\nconj(chi::GAPGroupClassFunction)\nNemo.degree(chi::GAPGroupClassFunction)\nindicator\nisirreducible(chi::GAPGroupClassFunction)\nschur_index","category":"page"},{"location":"Groups/group_characters/#character_field","page":"Group characters","title":"character_field","text":"character_field(chi::GAPGroupClassFunction)\n\nReturn the pair (F, phi) where F is a number field that is generated by the character values of chi, and phi is the embedding of F into abelian_closure(QQ).\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#conj-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"conj","text":"conj(chi::GAPGroupClassFunction)\n\nReturn the class function whose values are the complex conjugates of the values of chi.\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#degree-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"degree","text":"degree(::Type{T} = fmpq, chi::GAPGroupClassFunction)\n       where T <: Union{IntegerUnion, fmpz, mpq, QabElem}\n\nReturn chi[1], as an instance of T.\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#indicator","page":"Group characters","title":"indicator","text":"indicator(chi::GAPGroupClassFunction, n::Int = 2)\n\nReturn the n-th Frobenius-Schur indicator of chi, that is, the value (_g  G chi(g^n))G, where G is the group of chi.\n\nIf chi is irreducible then indicator(chi) is 0 if chi is not real-valued, 1 if chi is afforded by a real representation of G, and -1 if chi is real-valued but not afforded by a real representation of G.\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#isirreducible-Tuple{Oscar.GAPGroupClassFunction}","page":"Group characters","title":"isirreducible","text":"isirreducible(chi::GAPGroupClassFunction)\n\nReturn true if chi is an irreducible character, and alse otherwise.\n\nA character is irreducible if it cannot be written as the sum of two characters. For ordinary characters this can be checked using the scalar product of class functions (see scalar_product. For Brauer characters there is no generic method for checking irreducibility.\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#schur_index","page":"Group characters","title":"schur_index","text":"schur_index(chi::GAPGroupClassFunction)\n\nReturn either the minimal integer m such that the character m * chi is afforded by a representation over the character field of chi, or nothing.\n\nThe latter happens if character theoretic criteria do not suffice for computing m.\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#Attributes-of-character-tables","page":"Group characters","title":"Attributes of character tables","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"character_parameters\nclass_parameters\ndecomposition_matrix\nidentifier\ninduced_cyclic(tbl::GAPGroupCharacterTable)\nis_duplicate_table\nmaxes\nnames_of_fusion_sources\norders_centralizers\norders_class_representatives\ntrivial_character(tbl::GAPGroupCharacterTable)","category":"page"},{"location":"Groups/group_characters/#character_parameters","page":"Group characters","title":"character_parameters","text":"character_parameters(tbl::GAPGroupCharacterTable)\n\nReturn a vector of character parameters for the rows of tbl if such parameters are stored, and nothing otherwise.\n\nExamples\n\njulia> character_parameters(character_table(\"S5\"))\n7-element Vector{Vector{Int64}}:\n [5]\n [1, 1, 1, 1, 1]\n [3, 1, 1]\n [4, 1]\n [2, 1, 1, 1]\n [3, 2]\n [2, 2, 1]\n\njulia> character_parameters(character_table(\"M11\"))\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#class_parameters","page":"Group characters","title":"class_parameters","text":"class_parameters(tbl::GAPGroupCharacterTable)\n\nReturn a vector of class parameters for the columns of tbl if such parameters are stored, and nothing otherwise.\n\nExamples\n\njulia> class_parameters(character_table(\"S5\"))\n7-element Vector{Vector{Int64}}:\n [1, 1, 1, 1, 1]\n [2, 2, 1]\n [3, 1, 1]\n [5]\n [2, 1, 1, 1]\n [4, 1]\n [3, 2]\n\njulia> class_parameters(character_table(\"M11\"))\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#decomposition_matrix","page":"Group characters","title":"decomposition_matrix","text":"decomposition_matrix(modtbl::GAPGroupCharacterTable)\n\nReturn the decomposition matrix (of type fmpz_mat) of the Brauer character table modtbl. The rows and columns are indexed by the irreducible characters of the ordinary character table of modtbl and the irreducible characters of modtbl, respectively,\n\nExamples\n\njulia> t = character_table(\"A5\"); t2 = mod(t, 2);\n\njulia> decomposition_matrix(t2)\n[1   0   0   0]\n[1   0   1   0]\n[1   1   0   0]\n[0   0   0   1]\n[1   1   1   0]\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#identifier","page":"Group characters","title":"identifier","text":"identifier(tbl::GAPGroupCharacterTable)\n\nReturn a string that identifies tbl. It is used mainly for library tables.\n\nExamples\n\njulia> identifier(character_table(\"A5\"))\n\"A5\"\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#induced_cyclic-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"induced_cyclic","text":"induced_cyclic(tbl::GAPGroupCharacterTable)\n\nReturn the array of permutation characters of tbl that are induced from cyclic subgroups.\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#is_duplicate_table","page":"Group characters","title":"is_duplicate_table","text":"is_duplicate_table(tbl::GAPGroupCharacterTable)\n\nReturn whether tbl is a table from the character table library that was constructed from another library character table by permuting rows and columns.\n\nOne application of this function is to restrict the search with all_character_table_names to only one library character table for each class of permutation equivalent tables.\n\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#maxes","page":"Group characters","title":"maxes","text":"maxes(tbl::GAPGroupCharacterTable)\n\nReturn either nothing (if the value is not known) or an array of identifiers of the ordinary character tables of all maximal subgroups of tbl. There is no default method to compute this value from tbl.\n\nIf the maxes value of tbl is stored then it lists exactly one representative for each conjugacy class of maximal subgroups of the group of tbl, and the character tables of these maximal subgroups are available in the character table library, and compatible class fusions to tbl are stored on these tables.\n\nExamples\n\njulia> println(maxes(character_table(\"M11\")))\n[\"A6.2_3\", \"L2(11)\", \"3^2:Q8.2\", \"A5.2\", \"2.S4\"]\n\njulia> maxes(character_table(\"M\")) == nothing  # not (yet) known\ntrue\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#names_of_fusion_sources","page":"Group characters","title":"names_of_fusion_sources","text":"names_of_fusion_sources(tbl::GAPGroupCharacterTable)\n\nReturn the array of strings that are identifiers of those character tables which store a class fusion to tbl.\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#orders_centralizers","page":"Group characters","title":"orders_centralizers","text":"orders_centralizers(tbl::GAPGroupCharacterTable)\n\nReturn the array of the orders of centralizers of conjugacy class representatives for tbl in the group of tbl, ordered according to the columns of tbl.\n\nExamples\n\njulia> println(orders_centralizers(character_table(\"A5\")))\nfmpz[60, 4, 3, 5, 5]\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#orders_class_representatives","page":"Group characters","title":"orders_class_representatives","text":"orders_class_representatives(tbl::GAPGroupCharacterTable)\n\nReturn the array of the orders of conjugacy class representatives for tbl, ordered according to the columns of tbl.\n\nExamples\n\njulia> println(orders_class_representatives(character_table(\"A5\")))\n[1, 2, 3, 5, 5]\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#trivial_character-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"trivial_character","text":"trivial_character(tbl::GAPGroupCharacterTable)\n\nReturn the character of tbl that has the value QabElem(1) in each position.\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#Construct-group-characters-from-groups","page":"Group characters","title":"Construct group characters from groups","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"natural_character(G::PermGroup)\nnatural_character(G::Union{MatrixGroup{fmpq}, MatrixGroup{nf_elem}})\ntrivial_character(G::GAPGroup)","category":"page"},{"location":"Groups/group_characters/#natural_character-Tuple{PermGroup}","page":"Group characters","title":"natural_character","text":"natural_character(G::PermGroup)\n\nReturn the permutation character of degree degree(G) that maps each element of G to the number of its fixed points.\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#natural_character-Tuple{Union{MatrixGroup{fmpq, T} where T<:MatElem{fmpq}, MatrixGroup{nf_elem, T} where T<:MatElem{nf_elem}}}","page":"Group characters","title":"natural_character","text":"natural_character(G::Union{MatrixGroup{fmpq}, MatrixGroup{nf_elem}})\n\nReturn the character that maps each element of G to its trace. We assume that the entries of the elements of G are either of type fmpq or contained in a cyclotomic field.\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#trivial_character-Tuple{Oscar.GAPGroup}","page":"Group characters","title":"trivial_character","text":"trivial_character(G::GAPGroup)\n\nReturn the character of (the ordinary character table of) G that has the value QabElem(1) in each position.\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#Operations-for-group-characters","page":"Group characters","title":"Operations for group characters","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"length and iteration:","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"The length of a class function is the number of conjugacy classes of its group, iteration is defined w.r.t. the ordering of conjugacy classes.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"arithmetic operations:","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"chi == psi: two class functions are equal if and only if they belong to the same character table and have the same values,\nchi + psi and chi - psi are the pointwise sum and difference, respectively, of the two class functions chi, psi,\nn*chi is the pointwise n-fold sum of chi, for an integer n,\nchi*psi is the pointwise (tensor) product of chi and psi,\nzero(chi) is the class function that is zero on all classes,\none(chi) is the trivial character of the character table of chi,\nchi^n is the n-th tensor power of chi, for positive integers n,\nchi(g) is the value of chi at the element g of the group of chi,\nchi^g is the conjugate character of chi under the action of a group element g that normalizes the group G of chi; we have chi^g(x) == chi(g*x*g^-1) for all x in G,\nchi^galaut is the Galois conjugate character of chi under the pointwise action of the field automorphism galaut (If galaut was created as QabAutomorphism(k) then the action raises each root of unity to its k-th power; this action defines a field automorphism of the n-th cyclotomic field whenever n and k are coprime.)\nchi^tbl is the character of the character table tbl that is induced from chi, where the group of chi is a subgroup of the group of tbl.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"scalar_product\ninduced_class_function","category":"page"},{"location":"Groups/group_characters/#scalar_product","page":"Group characters","title":"scalar_product","text":"scalar_product(::Type{T} = fmpq, chi::GAPGroupClassFunction, psi::GAPGroupClassFunction)\n               where T <: Union{IntegerUnion, fmpz, fmpq, QabElem}\n\nReturn sum_g in G chi(g) conj(psi)(g) / G, where G is the group of both chi and psi.\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#induced_class_function","page":"Group characters","title":"induced_class_function","text":"induced_class_function(chi::GAPGroupClassFunction, tbl::GAPGroupCharacterTable[, fusion::Vector{Int}])\n\nReturn the class function of tbl that is induced from chi, which is a class function of a subgroup of the group of tbl. The default for the class fusion fus is given either by the fusion of the conjugacy classes of the two character tables (if groups are stored in the tables) or by the class fusion given by known_class_fusion for the two tables.\n\nExamples\n\njulia> s = character_table(\"A5\");  t = character_table(\"A6\");\n\njulia> maps = possible_class_fusions(s, t);  length(maps)\n4\n\njulia> chi = trivial_character(s);\n\njulia> ind = [induced_class_function(chi, t, x) for x in maps];  length(ind)\n4\njulia> length(Set(ind))\n2\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#Operations-for-character-tables","page":"Group characters","title":"Operations for character tables","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"class_multiplication_coefficient\nknown_class_fusion\norder(tbl::GAPGroupCharacterTable)\npossible_class_fusions","category":"page"},{"location":"Groups/group_characters/#class_multiplication_coefficient","page":"Group characters","title":"class_multiplication_coefficient","text":"class_multiplication_coefficient(::Type{T} = fmpz, tbl::GAPGroupCharacterTable, i::Int, j::Int, k::Int) where T <: IntegerUnion\n\nReturn the class multiplication coefficient of the classes i, j, and k of the group G with ordinary character table tbl, as an instance of T.\n\nThe class multiplication coefficient c_ijk of the classes i j k equals the  number of pairs (x y) of elements x y in G such that x lies in class i, y lies in class j, and their product xy is a fixed element of class k.\n\nIn the center of the group algebra of G, these numbers are found as coefficients of the decomposition of the product of two class sums K_i and K_j into class sums:\n\nK_i K_j = sum_k c_ijk K_k\n\nGiven the character table of a finite group G, whose classes are C_1 ldots C_r with representatives g_i in C_i, the class multiplication coefficient c_ijk can be computed with the following formula:\n\n    c_ijk = C_i C_j  G\n              sum_chi in Irr(G) chi(g_i) chi(g_j) chi(g_k^-1)\n               chi(1)\n\nOn the other hand the knowledge of the class multiplication coefficients admits the computation of the irreducible characters of G.\n\nExamples\n\njulia> class_multiplication_coefficient(character_table(\"A5\"), 2, 3, 4)\n5\n\njulia> class_multiplication_coefficient(character_table(\"A5\"), 2, 4, 4)\n0\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#known_class_fusion","page":"Group characters","title":"known_class_fusion","text":"known_class_fusion(tbl1::GAPGroupCharacterTable, tbl2::GAPGroupCharacterTable)\n\nReturn (flag, fus) where flag == true if a class fusion to tbl2 is stored on tbl1, and flag == false otherwise.\n\nIn the former case, fus is the vector of integers, of length number_conjugacy_classes(tbl1), such that the i-th conjugacy class of tbl1 corresponds to the fus[i]-th conjugacy class of tbl2, in the following sense.\n\nIf the group of tbl1 is a subgroup of the group of tbl2 then the i-th conjugacy class of tbl1 is contained in the fus[i]-th conjugacy class of tbl2. If the group of tbl2 is a factor group of the group of tbl1 then the image of the i-th conjugacy class tbl1 under the relevant epimorphism is the fus[i]-th conjugacy class of tbl2.\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#order-Tuple{Oscar.GAPGroupCharacterTable}","page":"Group characters","title":"order","text":"order(::Type{T} = fmpz, tbl::GAPGroupCharacterTable) where T <: IntegerUnion\n\nReturn the order of the group for which tbl is the character table.\n\nExamples\n\njulia> order(character_table(symmetric_group(4)))\n24\n\n\n\n\n","category":"method"},{"location":"Groups/group_characters/#possible_class_fusions","page":"Group characters","title":"possible_class_fusions","text":"possible_class_fusions(subtbl::GAPGroupCharacterTable, tbl::GAPGroupCharacterTable)\n\nReturn the array of possible class fusions from subtbl to tbl. Each entry is an array of positive integers, where the value at position i is the position of the conjugacy class in tbl that contains the i-th class of subtbl.\n\nExamples\n\njulia> possible_class_fusions(character_table(\"A5\"), character_table(\"A6\"))\n4-element Vector{Vector{Int64}}:\n [1, 2, 3, 6, 7]\n [1, 2, 3, 7, 6]\n [1, 2, 4, 6, 7]\n [1, 2, 4, 7, 6]\n\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#Character-tables-and-normal-subgroups","page":"Group characters","title":"Character tables and normal subgroups","text":"","category":"section"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"Normal subgroups of a group G are unions of conjugacy classes of elements of G. Thus one can often turn questions about a normal subgroup N of G into questions about the array of those positions in the list of conjugacy classes of G that contain the elements of N.","category":"page"},{"location":"Groups/group_characters/","page":"Group characters","title":"Group characters","text":"class_positions_of_kernel\nclass_positions_of_pcore","category":"page"},{"location":"Groups/group_characters/#class_positions_of_kernel","page":"Group characters","title":"class_positions_of_kernel","text":"class_positions_of_kernel(chi::GAPGroupClassFunction)\n\nReturn the array of those integers i such that chi[i] == chi[1] holds.\n\n\n\n","category":"function"},{"location":"Groups/group_characters/#class_positions_of_pcore","page":"Group characters","title":"class_positions_of_pcore","text":"class_positions_of_pcore(tbl::GAPGroupCharacterTable, p::IntegerUnion)\n\nReturn the array of integers i such that the i-th conjugacy class of tbl is contained in the p-core of the group of tbl, see pcore.\n\nExamples\n\njulia> println(Oscar.class_positions_of_pcore(character_table(\"2.A5\"), 2))\n[1, 2]\n\n\n\n\n","category":"function"},{"location":"Hecke/misc/Map/#Map-from-julia-functions","page":"Map from julia functions","title":"Map from julia functions","text":"","category":"section"},{"location":"Hecke/misc/Map/","page":"Map from julia functions","title":"Map from julia functions","text":"For the situation where it is desirable to create a Map given arbitrary callable julia objects (like anonymous functions), the type MapFromFunc is provided.","category":"page"},{"location":"Hecke/misc/Map/","page":"Map from julia functions","title":"Map from julia functions","text":"MapFromFunc","category":"page"},{"location":"Hecke/misc/Map/#MapFromFunc","page":"Map from julia functions","title":"MapFromFunc","text":"MapFromFunc(f, [g], D, C)\n\nCreates the map D -> C, x -> f(x) given the callable object f. If g is provided, it is assumed to satisfy f(g(x)) = x and will be used as the preimage function.\n\nExample\n\njulia> F = GF(2);\n\njulia> f = MapFromFunc(x -> F(numerator(x)) * inv(F(denominator(x))), QQ, F)\nMap from\nRational Field to Galois field with characteristic 2 defined by a julia-function\n\njulia> f(QQ(1//3))\n1\n\njulia> f = MapFromFunc(x -> F(numerator(x)) * inv(F(denominator(x))), y -> QQ(lift(y)),  QQ, F)\nMap from\nRational Field to Galois field with characteristic 2 defined by a julia-function with inverse\n\njulia> preimage(f, F(1))\n1\n\n\n\n\n\n","category":"type"},{"location":"Hecke/misc/Map/","page":"Map from julia functions","title":"Map from julia functions","text":"note: Note\nWhen applying an object f of type  MapFromFunc to an element x, it will be checked whether the parent of x coincides with the domain and whether the parent of f(x) coincides with the codomain of f. Similar for the optional preimage function.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"CurrentModule = AbstractAlgebra\nDocTestSetup = quote\n    using AbstractAlgebra\nend","category":"page"},{"location":"AbstractAlgebra/module_interface/#Module-Interface","page":"Module Interface","title":"Module Interface","text":"","category":"section"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"note: Note\nThe module infrastructure in AbstractAlgebra should be considered experimental at this stage. This means that the interface may change in the future.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"AbstractAlgebra allows the construction of finitely presented modules (i.e. with finitely many generators and relations), starting from free modules. The generic code provided by AbstractAlgebra will only work for modules over euclidean domains, however there is nothing preventing a library from implementing more general modules using the same interface.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"All finitely presented module types in AbstractAlgebra follow the following interface which is a loose interface of functions, without much generic infrastructure built on top.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Free modules can be built over both commutative and noncommutative rings. Other types of module are restricted to fields and euclidean rings.","category":"page"},{"location":"AbstractAlgebra/module_interface/#Abstract-types","page":"Module Interface","title":"Abstract types","text":"","category":"section"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"AbstractAlgebra provides two abstract types for finitely presented modules and their elements:","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"FPModule{T} is the abstract type for finitely presented module parent","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"types","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"FPModuleElem{T} is the abstract type for finitely presented module","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"element types","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Note that the abstract types are parameterised. The type T should usually be the type of elements of the ring the module is over.","category":"page"},{"location":"AbstractAlgebra/module_interface/#Required-functionality-for-modules","page":"Module Interface","title":"Required functionality for modules","text":"","category":"section"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"We suppose that R is a fictitious base ring and that S is a module over R with parent object S of type MyModule{T}. We also assume the elements in the module have type MyModuleElem{T}, where T is the type of elements of the ring the module is over.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Of course, in practice these types may not be parameterised, but we use parameterised types here to make the interface clearer.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Note that the type T must (transitively) belong to the abstract type RingElement or NCRingElem.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"We describe the functionality below for modules over commutative rings, i.e. with element type belonging to RingElement, however similar constructors should be available for element types belonging to NCRingElem instead, for free modules over a noncommutative ring.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Although not part of the module interface, implementations of modules that wish to follow our interface should use the same function names for submodules, quotient modules, direct sums and module homomorphisms if they wish to remain compatible with our module generics in the future.","category":"page"},{"location":"AbstractAlgebra/module_interface/#Basic-manipulation","page":"Module Interface","title":"Basic manipulation","text":"","category":"section"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"iszero(m::MyModuleElem{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Return true if the given module element is zero.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"ngens(M::MyModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Return the number of generators of the module M in its current representation.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"gen(M::MyModule{T}, i::Int) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Return the i-th generator (indexed from 1) of the module M.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"gens(M::MyModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Return a Julia array of the generators of the module M.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"rels(M::MyModule{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Return a Julia vector of all the relations between the generators of M. Each relation is given as an AbstractAlgebra row matrix.","category":"page"},{"location":"AbstractAlgebra/module_interface/#Element-constructors","page":"Module Interface","title":"Element constructors","text":"","category":"section"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"We can construct elements of a module M by specifying linear combinations of the generators of M. This is done by passing a vector of ring elements.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"(M::Module{T})(v::Vector{T}) where T <: RingElement","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Construct the element of the module M corrsponding to sum_i givi where gi are the generators of the module M. The resulting element will lie in the module M.","category":"page"},{"location":"AbstractAlgebra/module_interface/#Coercions","page":"Module Interface","title":"Coercions","text":"","category":"section"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Given a module M and an element n of a module N, it is possible to coerce n into M using the notation M(n) in certain circumstances.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"In particular the element n will be automatically coerced along any canonical injection of a submodule map and along any canonical projection of a quotient map. There must be a path from N to M along such maps.","category":"page"},{"location":"AbstractAlgebra/module_interface/#Arithmetic-operators","page":"Module Interface","title":"Arithmetic operators","text":"","category":"section"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"Elements of a module can be added, subtracted or multiplied by an element of the ring the module is defined over and compared for equality.","category":"page"},{"location":"AbstractAlgebra/module_interface/","page":"Module Interface","title":"Module Interface","text":"In the case of a noncommutative ring, both left and right scalar multiplication are defined.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"using Oscar","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"Let mathbbF be an ordered field; the default is that mathbbF=mathbbQ is the field of rational numbers and other fields are not yet supported everywhere in the implementation.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"A set P subseteq mathbbF^n is called a (convex) polyhedron if it can be written as the intersection of finitely many closed affine halfspaces in mathbbF^n.  That is, there exists a matrix A and a vector b such that P = P(Ab) =  x in mathbbF^n mid Ax leq b Writing P as above is called an H-representation of P.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"When a polyhedron P subset mathbbF^n is bounded, it is called a polytope and the fundamental theorem of polytopes states that it may be written as the convex hull of finitely many points. That is P = textrmconv(p_1ldotsp_N) p_i in mathbbF^n Writing P in this way is called a V-representation. Polytopes are necessarily compact, i.e., they form convex bodies.","category":"page"},{"location":"PolyhedralGeometry/Polyhedra/intro/","page":"Introduction","title":"Introduction","text":"Each polytope has a unique V-representation which is minimal with respect to inclusion (or cardinality). Conversely, a polyhedron which is full-dimensional, has a unique minimal H-representation. If the polyhedron is not full-dimensional, then there is no canonical choice of an H-representation.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"CurrentModule = Oscar\nDocTestSetup = quote\n  using Oscar\nend","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"using Oscar","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"Pages = [\"basics.md\"]","category":"page"},{"location":"Groups/basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"Groups/basics/#elements_of_groups","page":"Basics","title":"Elements of groups","text":"","category":"section"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"Given a group G, it is always possible to have access to some particular elements.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"GAPGroup\nBasicGAPGroupElem{T<:GAPGroup}\nelem_type(::Type{T}) where T <: GAPGroup\none(x::GAPGroup)\none(x::GAPGroupElem)\nisfiniteorder(x::GAPGroupElem)\ngens(::GAPGroup)\nhas_gens(::GAPGroup)\nngens(G::GAPGroup)\ngen(::GAPGroup, i::Int)\nBase.rand(G::GAPGroup)\nrand_pseudo(G::GAPGroup)","category":"page"},{"location":"Groups/basics/#GAPGroup","page":"Basics","title":"GAPGroup","text":"GAPGroup <: AbstractAlgebra.Group\n\nEach object of the abstract type GAPGroup stores a group object from the GAP system, and thus can delegate questions about this object to GAP.\n\nFor expert usage, you can extract the underlying GAP object via GapObj, i.e., if G is a GAPGroup, then GapObj(G) is the GapObj underlying G.\n\nConcrete subtypes of GAPGroup are PermGroup, FPGroup, PcGroup, and MatrixGroup.\n\n\n\n","category":"type"},{"location":"Groups/basics/#BasicGAPGroupElem","page":"Basics","title":"BasicGAPGroupElem","text":"BasicGAPGroupElem{T<:GAPGroup} <: GAPGroupElem{T}\n\nThe type BasicGAPGroupElem gathers all types of group elements described only by an underlying GAP object.\n\nIf x is an element of the group G of type T, then the type of x is BasicGAPGroupElem{T}.\n\n\n\n","category":"type"},{"location":"Groups/basics/#elem_type-Union{Tuple{Type{T}}, Tuple{T}} where T<:Oscar.GAPGroup","page":"Basics","title":"elem_type","text":"elem_type(::Type{T}) where T <: GAPGroup\nelem_type(::T) where T <: GAPGroup\n\nelem_type maps (the type of) a group to the type of its elements. For now, a group of type T has elements of type BasicGAPGroupElem{T}. So we provide it mostly for consistency with other parts of OSCAR. In the future, a more elaborate setup for group element types might also be needed.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#one-Tuple{Oscar.GAPGroup}","page":"Basics","title":"one","text":"one(G::GAPGroup) -> elem_type(G)\n\nReturn the identity of the group G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#one-Tuple{GAPGroupElem}","page":"Basics","title":"one","text":"one(x::GAPGroupElem{T}) -> GAPGroupElem{T}\n\nReturn the identity of the parent group of x.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#isfiniteorder-Tuple{GAPGroupElem}","page":"Basics","title":"isfiniteorder","text":"isfiniteorder(g::GAPGroupElem) -> Bool\n\nReturn true if g has finite order, and false otherwise.\n\nExamples\n\njulia> isfiniteorder(gen(symmetric_group(5), 1))\ntrue\n\njulia> isfiniteorder(gen(free_group(2), 1))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#gens-Tuple{Oscar.GAPGroup}","page":"Basics","title":"gens","text":"gens(G::Group)\n\nReturn a vector of generators of the group G. To get the i-th generator, use G[i] or gen(G,i) (see gen) instead of gens(G)[i], as that is more efficient.\n\nExamples\n\njulia> g = symmetric_group(5);  gens(g)\n2-element Vector{PermGroupElem}:\n (1,2,3,4,5)\n (1,2)\n\njulia> g[2]\n(1,2)\n\n\nnote: Note\nThe output of gens(G) is not, in general, the minimal list of generators for G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#has_gens-Tuple{Oscar.GAPGroup}","page":"Basics","title":"has_gens","text":"has_gens(G::Group)\n\nReturn whether generators for the group G are known.\n\nExamples\n\njulia> F = free_group(2)\n<free group on the generators [ f1, f2 ]>\n\njulia> has_gens(F)\ntrue\n\njulia> H = derived_subgroup(F)[1]\nGroup(<free, no generators known>)\n\njulia> has_gens(H)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#ngens-Tuple{Oscar.GAPGroup}","page":"Basics","title":"ngens","text":"ngens(G::GAPGroup) -> Int\n\nReturn the length of the vector gens(G).\n\nwarning: WARNING:\nthis is NOT, in general, the minimum number of generators for G.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#gen-Tuple{Oscar.GAPGroup, Int64}","page":"Basics","title":"gen","text":"gen(G::GAPGroup, i::Int)\n\nReturn the i-th element of the vector gens(G). This is equivalent to G[i], and returns gens(G)[i] but may be more efficient than the latter.\n\nAn exception is thrown if i is larger than the length of gens(G).\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#rand-Tuple{Oscar.GAPGroup}","page":"Basics","title":"rand","text":"rand(rng::Random.AbstractRNG = Random.GLOBAL_RNG, G::Group)\n\nReturn a random element of G, using the random number generator rng.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#rand_pseudo-Tuple{Oscar.GAPGroup}","page":"Basics","title":"rand_pseudo","text":"rand_pseudo(G::Group)\n\nReturn a pseudo random element of G.  This works faster than rand, but the returned elements are not necessarily uniformly distributed.\n\nIt is sometimes necessary to work with finite groups that we cannot effectively enumerate, e.g. matrix groups over finite fields. We may not even know the size of these groups. Yet many algorithms need to sample elements from the group \"as randomly as possible\", whatever that means; but also they need this fast.\n\nThe function rand_pseudo returns elements that are cheap to compute and somehow random, but makes no guarantees about their distribution.\n\nFor finitely presented groups, it returns random words of bounded length.\n\nFor finite permutation and matrix groups, it uses a variant of the product replacement algorithm. For most inputs, the resulting stream of elements relatively quickly converges to a uniform distribution.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"It is also possible to obtain the generators of G by typing","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"f1,f2,f3 = gens(G)","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"This is equivalent to","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"f1=G[1]; f2=G[2]; f3=G[3];","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"For a group G that has been created as a subgroup of another group, generated by a list L of elements, gens(G) is equal to L.","category":"page"},{"location":"Groups/basics/#Operations-on-group-elements","page":"Basics","title":"Operations on group elements","text":"","category":"section"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"Oscar supports the following operations and functions on group elements.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"*, multiplication between two elements in a group.\ninv(x) and x^-1, the inverse of x.\nx/y, the element x y^-1.\nx^n, the n-th power of x; if n == 0, the identity of the group is returned; if n < 0, the -n-th power of the inverse of x is returned.\nisone(x) returns whether x is the identity of the group.\nconj(x,y) and x^y, the conjugate of x by y, i.e., the element y^-1 x y.\ncomm(x,y), the commutator of x and y, i.e., the element x^-1 y^-1 x y.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"note: Note\nIn Oscar, the expression x^y^z is equivalent to x^(y^z). In other words, conjugations are evaluated from the right to the left.","category":"page"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"comm(x::GAPGroupElem, y::GAPGroupElem)","category":"page"},{"location":"Groups/basics/#comm-Tuple{GAPGroupElem, GAPGroupElem}","page":"Basics","title":"comm","text":"comm(x::GAPGroupElem, y::GAPGroupElem)\n\nReturn the commutator of x and y, which is defined as x^-1*y^-1*x*y, and usually denoted as [x,y] in the literature.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#Properties-of-groups","page":"Basics","title":"Properties of groups","text":"","category":"section"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"Base.isfinite(G::GAPGroup)\nisabelian(G::GAPGroup)\nispgroup\nisnilpotent\nissupersolvable\nissolvable\nisperfect\nissimple(G::GAPGroup)\nisalmostsimple\nis_quasisimple\nis_sporadic_simple\nisfinitelygenerated","category":"page"},{"location":"Groups/basics/#isfinite-Tuple{Oscar.GAPGroup}","page":"Basics","title":"isfinite","text":"isfinite(G::GAPGroup) -> Bool\n\nReturn true if G is finite, and false otherwise.\n\nExamples\n\njulia> isfinite(symmetric_group(5))\ntrue\n\njulia> isfinite(free_group(2))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#isabelian-Tuple{Oscar.GAPGroup}","page":"Basics","title":"isabelian","text":"isabelian(G::Group)\n\nReturn true if G is abelian (commutative), that is, x*y = y*x holds for all elements x y in G.\n\n\n\n","category":"method"},{"location":"Groups/basics/#ispgroup","page":"Basics","title":"ispgroup","text":"ispgroup(G)\n\nReturn (true, nothing) if G is the trivial group, (true, p) if the order of every element in G is a power of a prime p, and (false, nothing) otherwise.\n\nFor finite groups G, the first return value is true if and only if the order of G is a prime power.\n\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#isnilpotent","page":"Basics","title":"isnilpotent","text":"isnilpotent(G::GAPGroup)\n\nReturn whether G is nilpotent, i.e., whether the lower central series of G reaches the trivial subgroup in a finite number of steps.\n\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#issupersolvable","page":"Basics","title":"issupersolvable","text":"issupersolvable(G::GAPGroup)\n\nReturn whether G is supersolvable, i.e., G is finite and has a normal series with cyclic factors.\n\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#issolvable","page":"Basics","title":"issolvable","text":"issolvable(G::GAPGroup)\n\nReturn whether G is solvable, i.e., whether derived_series(G) reaches the trivial subgroup in a finite number of steps.\n\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#isperfect","page":"Basics","title":"isperfect","text":"isperfect(G::GAPGroup)\n\nReturn whether G is a perfect group, i.e., equal to its derived subgroup.\n\nExamples\n\njulia> isperfect(special_linear_group(2, 5))\ntrue\n\njulia> isperfect(symmetric_group(5))\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#issimple-Tuple{Oscar.GAPGroup}","page":"Basics","title":"issimple","text":"issimple(G::GAPGroup)\n\nReturn whether G is a simple group, i.e., G is not trivial and has no non-trivial normal subgroups.\n\nExamples\n\njulia> issimple(alternating_group(5))\ntrue\n\njulia> issimple(symmetric_group(5))\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#isalmostsimple","page":"Basics","title":"isalmostsimple","text":"isalmostsimple(G::GAPGroup)\n\nReturn whether G is an almost simple group, i.e., G is isomorphic to a group H with the property S leq H leq Aut(S), for some non-abelian simple group S.\n\nExamples\n\njulia> isalmostsimple(symmetric_group(5))\ntrue\n\njulia> isalmostsimple(special_linear_group(2, 5))\nfalse\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#is_quasisimple","page":"Basics","title":"is_quasisimple","text":"is_quasisimple(G::GAPGroup)\n\nReturn whether G is a quasisimple group, i.e., G is perfect such that the factor group modulo its centre is a non-abelian simple group.\n\nExamples\n\njulia> is_quasisimple(special_linear_group(2, 5))\ntrue\n\njulia> is_quasisimple(symmetric_group(5))\nfalse\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#is_sporadic_simple","page":"Basics","title":"is_sporadic_simple","text":"is_sporadic_simple(G::GAPGroup)\n\nReturn whether G is a sporadic simple group.\n\nExamples\n\njulia> is_sporadic_simple(mathieu_group(11))\ntrue\n\njulia> is_sporadic_simple(mathieu_group(10))\nfalse\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#isfinitelygenerated","page":"Basics","title":"isfinitelygenerated","text":"isfinitelygenerated(G)\n\nReturn whether G is a finitely generated group.\n\nExamples\n\njulia> F = free_group(2)\n<free group on the generators [ f1, f2 ]>\n\njulia> isfinitelygenerated(F)\ntrue\n\njulia> H = derived_subgroup(F)[1]\nGroup(<free, no generators known>)\n\njulia> isfinitelygenerated(H)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"Groups/basics/#Attributes-of-groups","page":"Basics","title":"Attributes of groups","text":"","category":"section"},{"location":"Groups/basics/","page":"Basics","title":"Basics","text":"order(::Type{T}, x::Union{GAPGroupElem, GAPGroup}) where T <: IntegerUnion\nexponent(x::GAPGroup)\ndescribe(x::GAPGroup)\nnilpotency_class(G::GAPGroup)","category":"page"},{"location":"Groups/basics/#order-Union{Tuple{T}, Tuple{Type{T}, Union{Oscar.GAPGroup, GAPGroupElem}}} where T<:Union{Integer, fmpz}","page":"Basics","title":"order","text":"order(::Type{T} = fmpz, x::Union{GAPGroupElem, GAPGroup}) where T <: IntegerUnion\n\nReturn the order of x, as an instance of T.\n\nFor a group element x in the group G, the order of x is the smallest positive integer n such that x^n is the identity of G. For a group x, the order of x is the number of elements in x.\n\nAn exception is thrown if the order of x is infinite, use isfinite in order to check for finiteness.\n\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#exponent-Tuple{Oscar.GAPGroup}","page":"Basics","title":"exponent","text":"exponent(::Type{T} = fmpz, G::GAPGroup) where T <: IntegerUnion\n\nReturn the exponent of G, as an instance of T, i.e., the smallest positive integer e such that g^e is the identity of G for every g in G.\n\n\n\n","category":"method"},{"location":"Groups/basics/#describe-Tuple{Oscar.GAPGroup}","page":"Basics","title":"describe","text":"describe(G::GAPGroup)\n\nReturn a string that describes some aspects of the structure of G.\n\nFor finite groups, the function works well if G is an abelian group or a finite simple group or a group in one of the following series: symmetric, dihedral, quasidihedral, generalized quaternion, general linear, special linear.\n\nFor other finite groups, the function tries to decompose G as a direct product or a semidirect product, and if this is not possible as a non-splitting extension of a normal subgroup N with the factor group GN, where N is the center or the derived subgroup or the Frattini subgroup of G.\n\nFor infinite groups, if the group is known to be finitely generated and abelian or free, a reasonable description is printed.\n\nFor general infinite groups, or groups for which finiteness is not (yet) known, not much if anything can be done. In particular we avoid potentially expensive checks such as computing the size of the group or whether it is abelian. While we do attempt a few limited fast checks for finiteness and commutativity, these will not detect all finite or commutative groups.\n\nThus calling describe again on the same group after additional information about it becomes known to Oscar may yield different outputs.\n\nnote: Note\nfor finitely presented groups, even deciding if the group is trivial is impossible in general; the same holds for most other properties, like whether the group is finite, abelian, etc.,\nthere is in general no \"nice\" decomposition of G,\nthere may be several decompositions of G,\nnonisomorphic groups may yield the same describe result,\nisomorphic groups may yield different describe results,\nthe computations can take a long time (for example in the case of large p-groups), and the results are still often not very helpful.\n\nThe following notation is used in the returned string.\n\nDescription Syntax\ntrivial group 1\nfinite cyclic group C<size>\ninfinite cyclic group Z\nalternating group A<degree>\nsymmetric group S<degree>\ndihedral group D<size>\nquaternion group Q<size>\nquasidihedral group QD<size>\nprojective special linear group PSL(<n>,<q>)\nspecial linear group SL(<n>,<q>)\ngeneral linear group GL(<n>,<q>)\nproj. special unitary group PSU(<n>,<q>)\northogonal group, type B O(2<n>+1,<q>)\northogonal group, type D O+(2<n>,<q>)\northogonal group, type 2D O-(2<n>,<q>)\nproj. special symplectic group PSp(2<n>,<q>)\nSuzuki group (type 2B) Sz(<q>)\nRee group (type 2F or 2G) Ree(<q>)\nLie group of exceptional type E(6,<q>), E(7,<q>), E(8,<q>), 2E(6,<q>), F(4,<q>), G(2,<q>)\nSteinberg triality group 3D(4,<q>)\nsporadic simple group M11, M12, M22, M23, M24, J1, J2, J3, J4, Co1, Co2, Co3, Fi22, Fi23, Fi24', Suz, HS, McL, He, HN, Th, B, M, ON, Ly, Ru\nTits group 2F(4,2)'\nthe indicated group from the library of perfect groups PerfectGroup(<size>,<id>)\ndirect product A x B\nsemidirect product N : H\nnon-split extension Z(G) . G/Z(G) = G' . G/G', Phi(G) . G/Phi(G)\n\nExamples\n\njulia> g = symmetric_group(6);\n\njulia> describe(g)\n\"S6\"\n\njulia> describe(sylow_subgroup(g,2)[1])\n\"C2 x D8\"\n\njulia> describe(sylow_subgroup(g, 3)[1])\n\"C3 x C3\"\n\njulia> describe(free_group(3))\n\"a free group of rank 3\"\n\n\n\n\n","category":"method"},{"location":"Groups/basics/#nilpotency_class-Tuple{Oscar.GAPGroup}","page":"Basics","title":"nilpotency_class","text":"nilpotency_class(G::GAPGroup) -> Int\n\nReturn the nilpotency class of G, i.e., the smallest integer n such that G has a central series of length n.\n\nAn exception is thrown if G is not nilpotent.\n\n\n\n","category":"method"}]
}
