<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Localizations of commutative rings Â· Oscar.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to Oscar</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Quadratic and hermitian spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/serialization/">Saving and loading</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/visualization/">Visualization</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../free_modules/">Free Modules Over Multivariate Rings</a></li><li><a class="tocitem" href="../modules/">Modules Over Multivariate Rings</a></li><li><a class="tocitem" href="../affine_algebras/">Affine Algebras</a></li><li><a class="tocitem" href="../binomial_ideals/">Binomial Primary Decomposition</a></li><li class="is-active"><a class="tocitem" href>Localizations of commutative rings</a><ul class="internal"><li><a class="tocitem" href="#The-localization-interface"><span>The localization interface</span></a></li><li><a class="tocitem" href="#Localizations-of-multivariate-polynomial-rings"><span>Localizations of multivariate polynomial rings</span></a></li><li><a class="tocitem" href="#Localizations-of-affine-algebras"><span>Localizations of affine algebras</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/para_rational_curves/">Rational Parametrizations of Rational Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12-3" type="checkbox"/><label class="tocitem" for="menuitem-12-3"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../ToricVarieties/AlgebraicCycles/">Algebraic Cycles</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12-4" type="checkbox"/><label class="tocitem" for="menuitem-12-4"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/AffineSchemes/">General schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12-5" type="checkbox"/><label class="tocitem" for="menuitem-12-5"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Curves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-17" type="checkbox"/><label class="tocitem" for="menuitem-17"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><input class="collapse-toggle" id="menuitem-17-5" type="checkbox"/><label class="tocitem" for="menuitem-17-5"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Commutative Algebra</a></li><li class="is-active"><a href>Localizations of commutative rings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Localizations of commutative rings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/Oscar.jl/blob/master/docs/src/CommutativeAlgebra/localizations.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Localizations-of-commutative-rings"><a class="docs-heading-anchor" href="#Localizations-of-commutative-rings">Localizations of commutative rings</a><a id="Localizations-of-commutative-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Localizations-of-commutative-rings" title="Permalink"></a></h1><p>Suppose <span>$R$</span> is a commutative ring with unit and <span>$S \subset R$</span> is a <em>multiplicatively  closed set</em> containing <span>$1 \in R$</span>. Then we can form the <em>localization</em> of <span>$R$</span> at <span>$S$</span></p><p class="math-container">\[    R[S^{-1}] = \left\{ \frac{p}{q} : p,q \in R, \, q \in S \right\},\]</p><p>with its standard arithmetic for fractions. See, for instance, [Eis95] for an account on localizations.</p><p>Oscar provides a general framework for such localizations, originally intended to be used  with multivariate polynomial rings <span>$R$</span> over some base field <span>$\mathbb k$</span>, but also  applicable to more general commutative rings.</p><p>In the case of polynomials, the localization framework provides the structure for  certain algorithms using standard bases. Note that, in general, localizations of  polynomial algebras are not finitely generated  as algebras over <span>$\mathbb k$</span>; for instance when localizing at some maximal  ideal <span>$\mathfrak m \subset R$</span>. However, many ideal- and module-theoretic questions in the localization  <span>$R[S^{-1}]$</span>, such as e.g. the ideal membership, can be transformed to questions on  ideals and modules over the base ring <span>$R$</span> and then solved using Groebner- or standard-basis  techniques. This makes it important to regard localizations <span>$R[S^{-1}]$</span> as rings with  a history of creation from the original pair <span>$S \subset R$</span>. </p><h2 id="The-localization-interface"><a class="docs-heading-anchor" href="#The-localization-interface">The localization interface</a><a id="The-localization-interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-localization-interface" title="Permalink"></a></h2><h3 id="Localized-rings"><a class="docs-heading-anchor" href="#Localized-rings">Localized rings</a><a id="Localized-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Localized-rings" title="Permalink"></a></h3><p>The interface that needs to be implemented for any concrete  instance of localized rings is the following.  Multiplicatively closed sets are derived from the abstract type</p><article class="docstring"><header><a class="docstring-binding" id="AbsMultSet" href="#AbsMultSet"><code>AbsMultSet</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsMultSet{RingType, RingElemType}</code></pre><p>Abstract type for a multiplicatively closed set in a commutative (Noetherian) ring  R of type <code>RingType</code> with elements of type <code>RingElemType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L26-L31">source</a></section></article><p>The basic functionality that has to be implemented for any concrete type derived from  this is to be able to check containment of elements via</p><article class="docstring"><header><a class="docstring-binding" id="in-Union{Tuple{RingElemType}, Tuple{RingType}, Tuple{RingElemType, AbsMultSet{RingType, RingElemType}}} where {RingType, RingElemType}" href="#in-Union{Tuple{RingElemType}, Tuple{RingType}, Tuple{RingElemType, AbsMultSet{RingType, RingElemType}}} where {RingType, RingElemType}"><code>in</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in(f::RingElemType, S::AbsMultSet{RingType, RingElemType}) where {RingType, RingElemType}</code></pre><p>Return <code>true</code> if <code>f</code> belongs to <code>S</code>; <code>false</code> otherwise.</p><p><strong>Note:</strong> If this routine is not implemented, the function call will default to the  execution of an error message. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L45-L52">source</a></section></article><p>This is supposed to be an extension of the methods of the function <code>Base.in</code>.</p><p>A localized ring should then be derived from </p><article class="docstring"><header><a class="docstring-binding" id="AbsLocalizedRing" href="#AbsLocalizedRing"><code>AbsLocalizedRing</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsLocalizedRing{RingType, RingElemType, MultSetType}</code></pre><p>The localization R[Sâ»Â¹] of a ring R of type <code>RingType</code> with elements of type <code>RingElemType</code> at a  multiplicatively closed set S of type <code>MultSetType</code>. </p><p>In general, the arithmetic of such a localized ring R[Sâ»Â¹] should be implemented using fractions  of elements in the original ring R. The methods provided for the multiplicatively closed set S  can be used to check whether a given denominator is admissible for the specific localization. </p><p>Depending on the actual type of R and S, further functionality can then be provided using  different Groebner-basis driven backends. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L70-L82">source</a></section></article><p>The basic way to construct localized rings is to first  specify a multiplicative set <code>S</code> and then call </p><article class="docstring"><header><a class="docstring-binding" id="Localization-Tuple{AbsMultSet}" href="#Localization-Tuple{AbsMultSet}"><code>Localization</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Localization(S::AbsMultSet)</code></pre><p>Return the localization of the <code>ambient_ring</code> of <code>S</code> at <code>S</code> itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L105-L109">source</a></section></article><p>This method must be implemented with a dispatch depending on  the concrete type of <code>S</code>.</p><p>For any concrete instance of type <code>AbsLocalizedRing</code> the following methods must be implemented:</p><article class="docstring"><header><a class="docstring-binding" id="base_ring-Tuple{AbsLocalizedRing}" href="#base_ring-Tuple{AbsLocalizedRing}"><code>base_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_ring(W::AbsLocalizedRing)</code></pre><p>Return the base ring R for a localized ring of the form W = R[Sâ»Â¹].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="inverted_set-Tuple{AbsLocalizedRing}" href="#inverted_set-Tuple{AbsLocalizedRing}"><code>inverted_set</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverted_set(W::AbsLocalizedRing)</code></pre><p>Return the set S of at which has been localized for a localized ring W = R[Sâ»Â¹].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L95-L99">source</a></section></article><p>Also, conversion of fractions to elements of localized rings must be implemented in the form  <code>(W::AbsLocalizedRing{RingType, RingElemType, MultSetType})(a::RingElemType) where {RingType, RingElemType, MultSetType}</code>, taking <span>$a$</span> to the element <span>$\frac{a}{1}$</span>. For more general fractions one needs <code>(W::AbsLocalizedRing{RingType, RingElemType, MultSetType})(a::RingElemType, b::RingElemType) where {RingType, RingElemType, MultSetType}</code>, mapping a pair <span>$(a, b)$</span> to the fraction <span>$\frac{a}{b}$</span>.</p><p>The <em>elements</em> of localized rings must be derived from </p><article class="docstring"><header><a class="docstring-binding" id="AbsLocalizedRingElem" href="#AbsLocalizedRingElem"><code>AbsLocalizedRingElem</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsLocalizedRingElem{RingType, RingElemType, MultSetType}</code></pre><p>The abstract type of an element of the localization R[Sâ»Â¹] of a commutative ring  R of type <code>RingType</code> with elements of type <code>RingElemType</code> at a multiplicatively  closed set S of type <code>MultSetType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L151-L157">source</a></section></article><p>For any concrete instance <code>F</code> of <code>AbsLocalizedRingElem</code> there must be the following  methods:</p><article class="docstring"><header><a class="docstring-binding" id="numerator-Tuple{AbsLocalizedRingElem}" href="#numerator-Tuple{AbsLocalizedRingElem}"><code>numerator</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numerator(f::AbsLocalizedRingElem)</code></pre><p>Return the numerator of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="denominator-Tuple{AbsLocalizedRingElem}" href="#denominator-Tuple{AbsLocalizedRingElem}"><code>denominator</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">denominator(f::AbsLocalizedRingElem)</code></pre><p>Return the denominator of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="parent-Tuple{AbsLocalizedRingElem}" href="#parent-Tuple{AbsLocalizedRingElem}"><code>parent</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parent(f::AbsLocalizedRingElem)</code></pre><p>Return the parent ring R[Sâ»Â¹] of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L183-L187">source</a></section></article><p>A default version of the arithmetic is implemented on the generic level using the above  functionality and the arithmetic for the original ring.  Depending on the actual concrete instance, one might wish to provide more fine-tuned methods,  starting e.g. by implementing </p><article class="docstring"><header><a class="docstring-binding" id="reduce_fraction-Tuple{AbsLocalizedRingElem}" href="#reduce_fraction-Tuple{AbsLocalizedRingElem}"><code>reduce_fraction</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_fraction(a::AbsLocalizedRingElem)</code></pre><p>Reduce the fraction a = p/q. <strong>Warning</strong>: The catchall-implementation does nothing!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L201-L205">source</a></section></article><p>Note that this is called after <em>every</em> arithmetic operation (addition, multiplication,...),  so the computations carried out here should be computationally cheap.</p><p>Two toy examples for implementations of this interface for localizations  of the integers <span>$\mathbb Z$</span> and rings of the form <span>$\mathbb Z/n\mathbb Z$</span>  can be found in the test files  <code>test/Rings/integer-localizations.jl</code> and <code>test/Rings/nmod-localizations.jl</code>.</p><p><strong>Note:</strong> Any concrete type for localized rings is also required to implement  the general <a href="../../AbstractAlgebra/ring_interface/#Ring-Interface">Ring Interface</a> of Oscar! This has not been done to a full extent  for the previous two examples, but for <code>MPolyLocalizedRing</code>; see below.</p><h3 id="Homomorphisms-for-localized-rings"><a class="docs-heading-anchor" href="#Homomorphisms-for-localized-rings">Homomorphisms for localized rings</a><a id="Homomorphisms-for-localized-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Homomorphisms-for-localized-rings" title="Permalink"></a></h3><p>Homomorphisms from localized rings to arbitrary algebras are of type </p><article class="docstring"><header><a class="docstring-binding" id="AbsLocalizedRingHom" href="#AbsLocalizedRingHom"><code>AbsLocalizedRingHom</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsLocalizedRingHom{
    DomainType&lt;:AbsLocalizedRing,
    CodomainType&lt;:Ring,
    RestrictedMapType
  } &lt;: Map{
    DomainType,
    CodomainType,
    SetMap,
    AbsLocalizedRingHom
  }</code></pre><p>Homomorphism <span>$Ï : R[Uâ»Â¹] â S$</span> from the localization <span>$R[Uâ»Â¹]$</span> of type  <span>$DomainType$</span> to an arbitrary ring <code>S</code> of type <code>CodomainType</code>. Such a  homomorphism is completely determined by its &#39;restriction&#39;  <span>$Ï&#39; : R â R[Uâ»Â¹] â S$</span> to the <code>base_ring</code> <span>$R$</span> before localization and  the type parameter <code>RestrictedMapType</code> is reserved for that map. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L444-L461">source</a></section></article><p>Note that, in order to be well-defined, we must have  that <span>$\phi&#39;(u) \in S$</span> must be a unit for every element <span>$u \in U$</span>. </p><p>The getters associated to this type which need to be implemented are </p><article class="docstring"><header><a class="docstring-binding" id="domain-Tuple{AbsLocalizedRingHom}" href="#domain-Tuple{AbsLocalizedRingHom}"><code>domain</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">domain(f::AbsLocalizedRingHom)</code></pre><p>Return the domain of definition of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L476-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="codomain-Tuple{AbsLocalizedRingHom}" href="#codomain-Tuple{AbsLocalizedRingHom}"><code>codomain</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">codomain(f::AbsLocalizedRingHom)</code></pre><p>Return the codomain of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L485-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="restricted_map-Tuple{AbsLocalizedRingHom}" href="#restricted_map-Tuple{AbsLocalizedRingHom}"><code>restricted_map</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restricted_map(f::AbsLocalizedRingHom)</code></pre><p>For a ring homomorphism <span>$Ï : R[Uâ»Â¹] â S$</span> return the underlying  restriction <span>$Ï&#39; : R â S$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L494-L499">source</a></section></article><p>Any concrete instance <code>f</code> of <code>AbsLocalizedRingHom</code> can then be applied to elements  <code>a</code> of <code>domain(f)</code> by calling <code>f(a)</code>. </p><h3 id="Ideals-in-localized-rings"><a class="docs-heading-anchor" href="#Ideals-in-localized-rings">Ideals in localized rings</a><a id="Ideals-in-localized-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Ideals-in-localized-rings" title="Permalink"></a></h3><p>One of the main reasons to implement localizations in the first place  is that this process preserves the property of a ring to be Noetherian;  which is crucial for computer algebra. In this regard, we have </p><article class="docstring"><header><a class="docstring-binding" id="AbsLocalizedIdeal" href="#AbsLocalizedIdeal"><code>AbsLocalizedIdeal</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsLocalizedIdeal{RingType, RingElemType, MultSetType}</code></pre><p>Abstract type for finitely generated ideals <span>$I â R[Sâ»Â¹]$</span> in localized rings. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/localization_interface.jl#L354-L358">source</a></section></article><p>The required getter methods are</p><article class="docstring"><header><a class="docstring-binding" id="gens-Tuple{AbsLocalizedIdeal}" href="#gens-Tuple{AbsLocalizedIdeal}"><code>gens</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gens(A::AbsAlgAss, return_full_basis::Typel{Val{T}} = Val{false};
     thorough_search::Bool = false) where T
  -&gt; Vector{AbsAlgAssElem}</code></pre><p>Returns a subset of <code>basis(A)</code>, which generates <span>$A$</span> as an algebra over <code>base_ring(A)</code>. If <code>return_full_basis</code> is set to <code>Val{true}</code>, the function also returns a <code>Vector{AbsAlgAssElem}</code> containing a full basis consisting of monomials in the generators and a <code>Vector{Vector{Tuple{Int, Int}}}</code> containing the information on how these monomials are built. E. g.: If the function returns <code>g</code>, <code>full_basis</code> and <code>v</code>, then we have <code>full_basis[i] = prod( g[j]^k for (j, k) in v[i] )</code>. If <code>thorough_search</code> is <code>true</code>, the number of returned generators is possibly smaller. This will in general increase the runtime. It is not guaranteed that the number of generators is minimal in any case.</p></div></section><section><div><pre><code class="nohighlight hljs">gens(A::AlgGrp, return_full_basis::Type{Val{T}} = Val{false})
  -&gt; Vector{AlgGrpElem}</code></pre><p>Returns a subset of <code>basis(A)</code>, which generates <span>$A$</span> as an algebra over <code>base_ring(A)</code>. If <code>return_full_basis</code> is set to <code>Val{true}</code>, the function also returns a <code>Vector{AbsAlgAssElem}</code> containing a full basis consisting of monomials in the generators and a <code>Vector{Vector{Tuple{Int, Int}}}</code> containing the information on how these monomials are built. E. g.: If the function returns <code>g</code>, <code>full_basis</code> and <code>v</code>, then we have <code>full_basis[i] = prod( g[j]^k for (j, k) in v[i] )</code>.</p></div></section><section><div><pre><code class="nohighlight hljs">gens(M::SubQuo{T}) where T</code></pre><p>Return the generators of <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Modules/UngradedModules.jl#L2130">source</a></section><section><div><pre><code class="nohighlight hljs">gens(I::sideal)</code></pre><p>Return the generators in the internal representation of the ideal <span>$I$</span> as an array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="base_ring-Tuple{AbsLocalizedIdeal}" href="#base_ring-Tuple{AbsLocalizedIdeal}"><code>base_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_ring(M::PMat)</code></pre><p>The <code>PMat</code> <span>$M$</span> defines an <span>$R$</span>-module for some maximal order <span>$R$</span>. This function returns the <span>$R$</span> that was used to defined <span>$M$</span>.</p></div></section><section><div><pre><code class="nohighlight hljs">base_ring(I::MPolyIdeal)</code></pre><p>Return the ambient ring of <code>I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate Polynomial Ring in x, y over Rational Field, fmpq_mpoly[x, y])

julia&gt; I = ideal(R, [x, y])^2
ideal(x^2, x*y, y^2)

julia&gt; base_ring(I)
Multivariate Polynomial Ring in x, y over Rational Field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-ideals.jl#L1009">source</a></section></article><p>The constructors to be implemented are</p><pre><code class="nohighlight hljs">   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, f::AbsLocalizedRingElem{RingType, RingElemType, MultSetType}) where {RingType, RingElemType, MultSetType}
   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, f::RingElemType) where {RingType, RingElemType, MultSetType}
   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, v::Vector{AbsLocalizedRingElem{RingType, RingElemType, MultSetType}}) where {RingType, RingElemType, MultSetType}
   ideal(W::AbsLocalizedRing{RingType, RingElemType, MultSetType}, v::Vector{RingElemType}) where {RingType, RingElemType, MultSetType}</code></pre><p>for a single and a list of generators from both the <code>base_ring</code> of <code>W</code> and from <code>W</code> itself.</p><p>The minimal functionality which should be implemented for ideals is the test  for ideal membership</p><pre><code class="nohighlight hljs">Base.in(
    f::AbsLocalizedRingElem{RingType, RingElemType, MultSetType}, 
    I::AbsLocalizedIdeal{RingType, RingElemType, MultSetType}
  ) where {RingType, RingElemType, MultSetType}</code></pre><p>and again the same for elements <code>f</code> of type <code>RingElemType</code>.</p><p>Basic operations on ideals which are already implemented on the generic level are </p><pre><code class="nohighlight hljs">Base.:*(I::T, J::T) where {T&lt;:AbsLocalizedIdeal}
Base.:+(I::T, J::T) where {T&lt;:AbsLocalizedIdeal}</code></pre><p>Everything else, such as e.g. intersections of ideals, has to be implemented for the specific  types by the user.</p><h2 id="Localizations-of-multivariate-polynomial-rings"><a class="docs-heading-anchor" href="#Localizations-of-multivariate-polynomial-rings">Localizations of multivariate polynomial rings</a><a id="Localizations-of-multivariate-polynomial-rings-1"></a><a class="docs-heading-anchor-permalink" href="#Localizations-of-multivariate-polynomial-rings" title="Permalink"></a></h2><p>Various primitive types of multiplicative sets are available, such as </p><article class="docstring"><header><a class="docstring-binding" id="MPolyComplementOfPrimeIdeal" href="#MPolyComplementOfPrimeIdeal"><code>MPolyComplementOfPrimeIdeal</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPolyComplementOfPrimeIdeal{
    BaseRingType, 
    BaseRingElemType,
    RingType,
    RingElemType
  } &lt;: AbsMPolyMultSet{
    BaseRingType, 
    BaseRingElemType,
    RingType,
    RingElemType
  }</code></pre><p>The complement of a prime ideal <span>$P â ð[xâ,â¦,xâ]$</span> in a multivariate polynomial ring  with elements of type <code>RingElemType</code> over a base ring <span>$ð$</span> of type <code>BaseRingType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L147-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPolyComplementOfKPointIdeal" href="#MPolyComplementOfKPointIdeal"><code>MPolyComplementOfKPointIdeal</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPolyComplementOfKPointIdeal{
    BaseRingType,
    BaseRingElemType, 
    RingType,
    RingElemType
  } &lt;: AbsMPolyMultSet{
    BaseRingType,
    BaseRingElemType, 
    RingType, 
    RingElemType
  }</code></pre><p>Complement of a maximal ideal <span>$ðª = â¨xâ-aâ,â¦,xâ-aââ©â ð[xâ,â¦xâ]$</span> with <span>$aáµ¢â ð$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L225-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPolyPowersOfElement" href="#MPolyPowersOfElement"><code>MPolyPowersOfElement</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPolyPowersOfElement{
    BaseRingType,
    BaseRingElemType, 
    RingType,
    RingElemType
  } &lt;: AbsMPolyMultSet{
    BaseRingType,
    BaseRingElemType, 
    RingType, 
    RingElemType
  }</code></pre><p>The set <code>S = { aáµ : k â ââ }</code> for some <span>$a â R$</span> with <span>$R$</span> of type <code>BaseRingType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L42-L56">source</a></section></article><p>Moreover, such types can be combined to products: </p><p><strong>Definition (Products of multiplicative sets):</strong> Let <span>$T$</span> and <span>$U$</span> be multiplicative sets in a commutative ring <span>$R$</span>. The product  of <span>$T$</span> and <span>$U$</span> is defined as </p><p class="math-container">\[  T\cdot U = \left\{ f\cdot g : f \in T \textnormal{ and }g \in U \right\}.\]</p><p>A product of multiplicative sets <span>$U = U_1 \cdot \dots \cdot U_r$</span> is called <em>interreduced</em>  if neither one of the factors <span>$U_i$</span> is contained in one of the others <span>$U_j, j \neq i$</span>.</p><p>Note that any product of multiplicative sets may be replaced by  an interreduced one. However, such an interreduced multiplicative set is  not unique as the following example shows:</p><p><strong>Example (interreduction of products of multiplicative sets):</strong> An interreduced factorization of a product of multiplicative sets may  not be unique: Consider the ring <span>$\mathbb Z[x]$</span> and the multiplicative sets </p><p class="math-container">\[  T  = \left\{(5x)^k : k \in \mathbb N_0\right\}, \quad
  T&#39; = \left\{ x^k : k \in \mathbb N_0\right\},\quad
  S  = \left\{ c_0 \cdot x^0 : c_0 \notin 7 \mathbb Z\right\}.\]</p><p>Then <span>$T\cdot S = \left\{ aâx^k : a \notin 7\mathbb Z, k \in \mathbb N_0 \right\} = T&#39;\cdot S$</span>.</p><p><strong>Upshot:</strong> Whenever a product is taken, some interreduced form of the  entire product is returned. Besides the obvious simplification in  case all factors are contained in a single one, it is difficult to  determine which interreduction is the best one.  Localizations of multivariate polynomial rings are of type </p><p>The type for storing general products is </p><article class="docstring"><header><a class="docstring-binding" id="MPolyProductOfMultSets" href="#MPolyProductOfMultSets"><code>MPolyProductOfMultSets</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPolyProductOfMultSets{
    BaseRingType,
    BaseRingElemType, 
    RingType,
    RingElemType
  } &lt;: AbsMPolyMultSet{
    BaseRingType,
    BaseRingElemType, 
    RingType, 
    RingElemType
  }</code></pre><p>A finite product <code>TâU = { aâb : a â T, bâ U}</code> of arbitrary other  multiplicative sets in a multivariate polynomial ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L298-L313">source</a></section></article><p>and products can be taken using the usual arithmetic</p><article class="docstring"><header><a class="docstring-binding" id="product-Tuple{Oscar.AbsMPolyMultSet, Oscar.AbsMPolyMultSet}" href="#product-Tuple{Oscar.AbsMPolyMultSet, Oscar.AbsMPolyMultSet}"><code>product</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">product(T::AbsMPolyMultSet, U::AbsMPolyMultSet)</code></pre><p>Return the product of the multiplicative sets <code>T</code> and <code>U</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L621-L625">source</a></section></article><p><strong>Note:</strong> The methods of this function naturally attempt  to return a primitive type of multiplicative sets whenever possible.  Hence, they are not type-stable. </p><p>Localizations of polynomial rings are of type</p><article class="docstring"><header><a class="docstring-binding" id="MPolyLocalizedRing" href="#MPolyLocalizedRing"><code>MPolyLocalizedRing</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPolyLocalizedRing{
    BaseRingType,
    BaseRingElemType,
    RingType,
    RingElemType,
    MultSetType
  } &lt;: AbsLocalizedRing{
    RingType,
    RingType,
    MultSetType
  }</code></pre><p>The localization of a multivariate polynomial ring <span>$R = ð[xâ,â¦,xâ]$</span> over a  base field <span>$ð$</span> of type <code>BaseRingType</code> and with elements of type <code>RingElemType</code>  at a multiplicative set <span>$S â R$</span> of type <code>MultSetType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L788-L804">source</a></section></article><p>with elements of type</p><article class="docstring"><header><a class="docstring-binding" id="MPolyLocalizedRingElem" href="#MPolyLocalizedRingElem"><code>MPolyLocalizedRingElem</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPolyLocalizedRingElem{
    BaseRingType, 
    BaseRingElemType,
    RingType,
    RingElemType, 
    MultSetType
  } &lt;: AbsLocalizedRingElem{
    RingType,
    RingElemType, 
    MultSetType
  }</code></pre><p>Elements of localizations of polynomial rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L897-L911">source</a></section></article><p>Ideals in localized polynomial rings are of type </p><article class="docstring"><header><a class="docstring-binding" id="MPolyLocalizedIdeal" href="#MPolyLocalizedIdeal"><code>MPolyLocalizedIdeal</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPolyLocalizedIdeal{BRT, BRET, RT, RET, MST} &lt;: AbsLocalizedIdeal{RT, RET, MST}</code></pre><p>Ideals in localizations of polynomial rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L1402-L1406">source</a></section></article><p>Recall (see e.g. [Eis95]) that  if <span>$\mathbb k$</span> is a Noetherian ring, any localization <span>$W = R[U^{-1}]$</span> of a  multivariate polynomial ring <span>$R = \mathbb k[x_1,\dots,x_n]$</span> is again Noetherian and  any ideal <span>$I \subset W$</span> is of the form <span>$I = I&#39;\cdot W$</span> for some ideal <span>$I&#39; \subset R$</span>.  This correspondence is not 1:1 but for any ideal <span>$I \subset W$</span> we always  have that </p><p class="math-container">\[  J = \left\{ x\in R : \exists u \in U : u\cdot x \in I \right\}\]</p><p>is the unique element which is maximal among all ideals <span>$I&#39;$</span> in <span>$R$</span> for  which <span>$I = I&#39;\cdot W$</span>. We call this the <em>saturated ideal</em> of the localization  and it can be obtained using </p><article class="docstring"><header><a class="docstring-binding" id="saturated_ideal-Tuple{MPolyLocalizedIdeal}" href="#saturated_ideal-Tuple{MPolyLocalizedIdeal}"><code>saturated_ideal</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saturated_ideal(I::MPolyLocalizedIdeal)</code></pre><p>For an ideal <span>$I â R[Sâ»Â¹]$</span> in a localized polynomial ring this returns  the unique ideal <span>$J â R$</span> which is maximal among all those ideals  <span>$I&#39; â R$</span> for which <span>$I&#39; â Sâ»Â¹ = I$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L1441-L1447">source</a></section></article><p>Groebner bases for the saturated ideal can be used to bring the numerators  of any fraction <span>$\frac{a}{b} \in R[S^{-1}]$</span> into normal form and check for  ideal membership and/or equality of elements modulo ideals in <span>$R[S^{-1}]$</span>. But for some cases, e.g. when using local orderings for localizations at  <span>$\mathbb k$</span>-points, it is desirable, to have the groebner- and standard  basis functionality available directly in the localized ring.   To this end we have </p><article class="docstring"><header><a class="docstring-binding" id="LocalizedBiPolyArray" href="#LocalizedBiPolyArray"><code>LocalizedBiPolyArray</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalizedBiPolyArray{BRT, BRET, RT, RET, MST}</code></pre><p>Main workhorse for binding of ideals in localizations <span>$R[Sâ»Â¹]$</span> of  multivariate polynomial rings <span>$R = ð[xâ,â¦,xâ]$</span> to Singular.  To a set of elements <span>$fâ/gâ,â¦, fáµ£/gáµ£ â R[Sâ»Â¹]$</span> this associates  the numerators <span>$Ï(fâ),â¦,Ï(fáµ£)$</span> as polynomials in <code>Singular</code>,  possibly after applying a shift <span>$Ï : xáµ¢ â¦ xáµ¢- aáµ¢$</span> with constants  <span>$aáµ¢â ð$</span> depending on the type <code>MST</code> of the multiplicative set.</p><p><strong>Note:</strong> The optional coordinate shift is to make local orderings  available for localizations at arbitrary <span>$ð$</span>-points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L1151-L1163">source</a></section></article><p>which has a monomial ordering and a <code>Singular</code> ring associated to it. </p><p><strong>Note:</strong> Transfering an element <span>$\frac{a}{b} \in R[S^{-1}]$</span> of a localized  ring to the <code>Singular</code>-side drops all denominators and only  the numerators appear as polynomials in <code>Singular</code>!  Hence, a <code>LocalizedBiPolyArray</code> is not really a 1:1-correspondence  of elements and in particular, the <code>Oscar</code> fractions can not be recovered  from the <code>Singular</code> side. </p><p>This is also the type returned by any Groebner- or standard basis  computation. We make the following convention: </p><p><strong>Definition:</strong> Let <span>$\mathbb k[x_1,\dots,x_n][S^{-1}]$</span> be  a localized polynomial ring with <span>$R = \mathbb k[x_1,\dots,x_n]$</span>.  A monomial ordering <span>$\geq$</span> is <em>compatible</em> with the localization, if  every unit in the localization <span>$R_{\geq}$</span> is also a unit in <span>$R[S^{-1}]$</span>. </p><p>For an ideal <span>$I \subset R[S^{-1}]$</span> and a compatible monomial ordering <span>$\geq$</span>  we say that a set of elements <span>$\frac{g_1}{1},\dots,\frac{g_r}{1} \in R[S^{-1}]$</span> is a  groebner/standard basis for <span>$I$</span> if the elements <span>$g_1,\dots,g_r$</span> are  a standard basis for the saturated ideal <span>$J$</span> of <span>$I$</span> in <span>$R$</span>. </p><p><strong>Note:</strong> When localizing at <span>$\mathbb k$</span>-points <span>$a = (a_1,\dots,a_n) \in \mathbb k^n$</span> outside the origin, the transfer of polynomials from the <code>Oscar</code> to the  <code>Singular</code> side in <code>LocalizedBiPolyArray</code> shifts the coordinates such that  <span>$a$</span> becomes zero. A monomial ordering is always considered after application  of such shifts. </p><p>Groebner and standard bases of ideals can be computed for explicit  orderings using </p><pre><code class="nohighlight hljs">    groebner_basis(I::MPolyLocalizedIdeal, ord::Symbol)</code></pre><p>Note that depending on the type parameters of <code>I</code>, this method  is dispatched differently, which will also lead to different  interpretations of the ordering. For instance, for multiplicative  sets of type <code>MPolyComplementOfKPointIdeal</code>, a shift of variables  taking the geometric point to the origin is applied to all polynomials  when passing to the singular side. </p><p>If the second argument is omitted, a default ordering  will be chosen, depending on the type of the multiplicative set. </p><p><strong>Remark:</strong> Why bother introducing Groebner and standard basis for  localized ideals in the first place and not only work with the  saturated ideal? The main reason is that for localizations at  <span>$\mathbb k$</span>-points, the computation of the saturated ideal is  quite expensive: It involves a primary decomposition using a  global ordering and discarding components outside the point  at which has been localized. Using local orderings, on the other hand,  we can decide ideal membership or equality of elements without  computing the saturated ideal explicitly.</p><p>The following method might be of practical interest: </p><article class="docstring"><header><a class="docstring-binding" id="as_affine_algebra-Union{Tuple{MPolyLocalizedRing{BRT, BRET, RT, RET, MPolyPowersOfElement{BRT, BRET, RT, RET}}}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}} where {BRT, BRET, RT, RET}" href="#as_affine_algebra-Union{Tuple{MPolyLocalizedRing{BRT, BRET, RT, RET, MPolyPowersOfElement{BRT, BRET, RT, RET}}}, Tuple{RET}, Tuple{RT}, Tuple{BRET}, Tuple{BRT}} where {BRT, BRET, RT, RET}"><code>as_affine_algebra</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">as_affine_algebra(
  L::MPolyLocalizedRing{BRT, BRET, RT, RET, 
  MPolyPowersOfElement{BRT, BRET, RT, RET}}; 
  inverse_name::String=&quot;Î¸&quot;
) where {BRT, BRET, RT, RET}</code></pre><p>For a localized polynomial ring <span>$L = ð[xâ,â¦,xâ][fâ»Â¹]$</span> this returns a  quintuple <span>$(A, I, d, Ï, Î¸)$</span> consisting of </p><ul><li>an <code>AffineAlgebra</code> <span>$A = ð[xâ,â¦,xâ,Î¸]/â¨1 - Î¸âdâ©$</span> isomorphic to <span>$L$</span></li><li>the ideal <span>$â¨1 - Î¸âdâ©$</span></li><li>an element <span>$d â ð[xâ,â¦,xâ]$</span> at which has been localized</li><li>the natural inclusion <span>$Ï : ð[xâ,â¦,xâ] âª A$</span></li><li>the localization variable <span>$Î¸$</span> corresponding to <span>$dâ»Â¹$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpoly-localizations.jl#L1940-L1955">source</a></section></article><h2 id="Localizations-of-affine-algebras"><a class="docs-heading-anchor" href="#Localizations-of-affine-algebras">Localizations of affine algebras</a><a id="Localizations-of-affine-algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Localizations-of-affine-algebras" title="Permalink"></a></h2><p>Let <span>$R = ð[xâ,â¦,xâ]$</span> be a polynomial ring, <span>$I â R$</span> some ideal  and <span>$P = R/I$</span> its quotient. Then <span>$P$</span> is naturally an <span>$R$</span>-module  and localization of <span>$P$</span> as a ring coincides with localization  as an <span>$R$</span>-module in the sense that for every multiplicative  set <span>$T â R$</span> there is a commutative diagram </p><p class="math-container">\[\begin{matrix}
        R   &amp; â &amp; P = R/I\\
        â &amp; &amp;       â \\
  W = R[Tâ»Â¹] &amp; â &amp; P[Tâ»Â¹].
\end{matrix}\]</p><p>Observe that, moreover, for every multiplicative set  <span>$T&#39; â P$</span> the preimage <span>$T$</span> of <span>$T&#39;$</span> in <span>$R$</span> is also a multiplicative set. </p><p>We may therefore treat localizations of polynomial algebras  as localizations of modules over free polynomial rings: and apply the following </p><p><strong>Convention:</strong> For localizations of affine algebras  <span>$L = (ð[xâ,â¦,xâ]/I)[Sâ»Â¹]$</span> </p><ul><li>ideals in <span>$L$</span> are given by ideals in <span>$W = ð[xâ,â¦,xâ][Sâ»Â¹]$</span> containing <span>$I\cdot S^{-1}$</span>.</li><li>the available multiplicative sets for <span>$L$</span> are exclusively those for <span>$ð[xâ,â¦,xâ]$</span>.</li></ul><p>Note that this leads to the following differences compared to the  standard usage of the localization interface:</p><ul><li>The <code>base_ring</code> returns neither <span>$P$</span>, nor <span>$W$</span>, but <span>$R$</span>.</li><li>The <code>BaseRingType</code> is the type of <span>$R$</span> and similar for  the other ring-based type parameters.</li></ul><p>This is to make the data structure most accessible for  the computational backends.</p><ul><li>The type returned by <code>numerator</code> and <code>denominator</code>  on an element of type <code>MPolyQuoLocalizedRingElem</code> is  not <code>RingElemType</code>, but the type of <span>$P$</span>. </li></ul><p>This is to comply with the purely mathematical viewpoint where elements of localized rings are fractions of  residue classes rather than residue classes of fractions. </p><p>Localizations of affine algebras are realized by </p><article class="docstring"><header><a class="docstring-binding" id="MPolyQuoLocalizedRing" href="#MPolyQuoLocalizedRing"><code>MPolyQuoLocalizedRing</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPolyQuoLocalizedRing{
    BaseRingType,
    BaseRingElemType,
    RingType,
    RingElemType,
    MultSetType &lt;: AbsMultSet{RingType, RingElemType}
  } &lt;: AbsLocalizedRing{
    RingType,
    RingElemType,
    MultSetType
  }</code></pre><p>Localization <span>$L = (ð[xâ,â¦,xâ]/I)[Sâ»Â¹]$</span> of a quotient <span>$ð[xâ,â¦,xâ]/I$</span> of a polynomial ring <span>$P = ð[xâ,â¦,xâ]$</span> of type <code>RingType</code> over a base ring <span>$ð$</span> of type <code>BaseRingType</code> at a multiplicative set <span>$S â P$</span> of type <code>MultSetType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpolyquo-localizations.jl#L58-L75">source</a></section></article><p>which have the additional methods </p><article class="docstring"><header><a class="docstring-binding" id="quotient_ring-Tuple{MPolyQuoLocalizedRing}" href="#quotient_ring-Tuple{MPolyQuoLocalizedRing}"><code>quotient_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quotient_ring(L::MPolyQuoLocalizedRing)</code></pre><p>For <span>$L = (ð[xâ,â¦,xâ]/I)[Sâ»Â¹]$</span> this returns <span>$ð[xâ,â¦,xâ]/I$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpolyquo-localizations.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="localized_ring-Tuple{MPolyQuoLocalizedRing}" href="#localized_ring-Tuple{MPolyQuoLocalizedRing}"><code>localized_ring</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localized_ring(L::MPolyQuoLocalizedRing)</code></pre><p>For <span>$L = (ð[xâ,â¦,xâ]/I)[Sâ»Â¹]$</span> this returns <span>$ð[xâ,â¦,xâ][Sâ»Â¹]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpolyquo-localizations.jl#L172-L176">source</a></section></article><p>returning the other two computationally important rings in its construction.</p><p>Elements of such rings are of the form </p><article class="docstring"><header><a class="docstring-binding" id="MPolyQuoLocalizedRingElem" href="#MPolyQuoLocalizedRingElem"><code>MPolyQuoLocalizedRingElem</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPolyQuoLocalizedRingElem{
  BaseRingType, 
  BaseRingElemType,
  RingType,
  RingElemType, 
  MultSetType
} &lt;: AbsLocalizedRingElem{
  RingType,
  RingElemType, 
  MultSetType
}</code></pre><p>Elements <span>$a//b$</span> of localizations <span>$L = (ð[xâ,â¦,xâ]/I)[Sâ»Â¹]$</span> of type  <code>MPolyQuoLocalizedRing{BaseRingType, BaseRingElemType, RingType, RingElemType, MultSetType}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpolyquo-localizations.jl#L285-L300">source</a></section></article><p>In contrast to ordinary elements of a localized ring, they  have the additional methods </p><article class="docstring"><header><a class="docstring-binding" id="lifted_numerator-Tuple{MPolyQuoLocalizedRingElem}" href="#lifted_numerator-Tuple{MPolyQuoLocalizedRingElem}"><code>lifted_numerator</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lifted_numerator(a::MPolyQuoLocalizedRingElem)</code></pre><p>For <span>$A//B â (ð[xâ,â¦,xâ]/I)[Sâ»Â¹]$</span> this returns a representative  <span>$a â ð[xâ,â¦,xâ]$</span> of the numerator. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpolyquo-localizations.jl#L358-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="lifted_denominator-Tuple{MPolyQuoLocalizedRingElem}" href="#lifted_denominator-Tuple{MPolyQuoLocalizedRingElem}"><code>lifted_denominator</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lifted_denominator(a::MPolyQuoLocalizedRingElem)</code></pre><p>For <span>$A//B â (ð[xâ,â¦,xâ]/I)[Sâ»Â¹]$</span> this returns a representative  <span>$b â  ð[xâ,â¦,xâ]$</span> of the denominator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpolyquo-localizations.jl#L366-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="fraction-Tuple{MPolyQuoLocalizedRingElem}" href="#fraction-Tuple{MPolyQuoLocalizedRingElem}"><code>fraction</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fraction(a::MPolyQuoLocalizedRingElem)</code></pre><p>For <span>$A//B â (ð[xâ,â¦,xâ]/I)[Sâ»Â¹]$</span> this returns a representative  <span>$a//b â Quot(ð[xâ,â¦,xâ])$</span> of the fraction. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/Oscar.jl/blob/408f5ac2d5ea4b79bd9d95e42121ddf4a0ed3992/src/Rings/mpolyquo-localizations.jl#L374-L379">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../binomial_ideals/">Â« Binomial Primary Decomposition</a><a class="docs-footer-nextpage" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Wednesday 4 May 2022 10:18">Wednesday 4 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
